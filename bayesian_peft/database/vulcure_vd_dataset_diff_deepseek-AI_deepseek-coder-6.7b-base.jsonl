{"code": "static int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate; \n\tunsigned long flags;\n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\n}", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {\n  DCHECK_EQ(t.args_size(), 3);\n  const auto& cont = t.args(0);\n  const auto& tmpl = t.args(1);\n  const auto& t_var = t.args(2);\n  StringPiece var_name = t_var.s();\n  if (!attrs.contains(var_name)) {\n    return Status(\n        error::INVALID_ARGUMENT,\n        absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));\n  }\n  const AttrValue* attr = attrs.at(var_name);\n  FullTypeDef result;\n  result.set_type_id(cont.type_id());\n  const auto attr_type = attr->value_case();\n  if (attr_type == AttrValue::kType) {\n    FullTypeDef* target = result.add_args();\n    *target = tmpl;\n    TF_RETURN_WITH_CONTEXT_IF_ERROR(\n        SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,\n        \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());\n  } else if (attr_type == AttrValue::kList) {\n    const auto& attr_list = attr->list();\n    int tsize = attr_list.type_size();\n    if (tsize == 0) {\n      return Status(error::UNIMPLEMENTED,\n                    absl::StrCat(\"unsupported list attribute type\\n\",\n                                 attr_list.DebugString(), \"\\nkey=\", var_name));\n    }\n    AttrValue replacement;\n    attrs[var_name] = &replacement;\n    for (int i = 0; i < tsize; i++) {\n      replacement.set_type(attr_list.type(i));\n      FullTypeDef* target = result.add_args();\n      *target = tmpl;\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),\n                                      \"while substituting '\", var_name,\n                                      \"' from\\n\", attr->DebugString(), \"\\n[\", i,\n                                      \"] into\\n\", target->DebugString());\n    }\n    attrs[var_name] = attr;\n  } else {\n    return Status(error::UNIMPLEMENTED,\n                  absl::StrCat(\"unsupported attribute type\\n\",\n                               attr->DebugString(), \"\\nfor name \", var_name));\n  }\n  t = result;\n  return OkStatus();\n}", "target": 1}
{"code": "gss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}", "target": 0}
{"code": "static void ok_jpg_idct_16x16(const int16_t *input, uint8_t *output) {\n    int temp[8 * 16];\n    ok_jpg_idct_1d_col_16(input, temp);\n    ok_jpg_idct_1d_row_16(16, temp, output);\n}", "target": 0}
{"code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tif((cc0%rowsize)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n                     \"%s\", \"(cc0%rowsize)!=0\");\n        _TIFFfree( working_copy );\n        return 0;\n    }\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n        _TIFFfree( working_copy );\n        return result_code;\n}", "target": 0}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void draw_fill_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *fill_color;\n  fill_color=NewPixelWand();\n  PixelSetRedQuantum(fill_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(fill_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(fill_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(fill_color,OpaqueAlpha);\n  DrawSetFillColor(WmfDrawingWand,fill_color);\n  fill_color=DestroyPixelWand(fill_color);\n}", "target": 0}
{"code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\tif ((int)id < 0)\n\t\treturn;\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}", "target": 1}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "void stl_le_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stl_le(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next;\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\tif (vma->part) {\n\t\tstruct nvkm_vma *prev = node(vma, prev);\n\t\tif (!prev->memory) {\n\t\t\tprev->size += vma->size;\n\t\t\trb_erase(&vma->tree, &vmm->root);\n\t\t\tlist_del(&vma->head);\n\t\t\tkfree(vma);\n\t\t\tvma = prev;\n\t\t}\n\t}\n\tnext = node(vma, next);\n\tif (next && next->part) {\n\t\tif (!next->memory) {\n\t\t\tvma->size += next->size;\n\t\t\trb_erase(&next->tree, &vmm->root);\n\t\t\tlist_del(&next->head);\n\t\t\tkfree(next);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static u32 psi_group_change(struct psi_group *group, int cpu,\n\t\t\t    unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\tenum psi_states s;\n\tu32 state_mask = 0;\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\twrite_seqcount_begin(&groupc->seq);\n\trecord_times(groupc, cpu, false);\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\tgroupc->state_mask = state_mask;\n\twrite_seqcount_end(&groupc->seq);\n\treturn state_mask;\n}", "target": 0}
{"code": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tuncharge_slab_page(page, order, s);\n\t__free_pages(page, order);\n}", "target": 0}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 0}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "isdn_net_force_dial(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tif (!p)\n\t\treturn -ENODEV;\n\treturn (isdn_net_force_dial_lp(p->local));\n}", "target": 0}
{"code": "static int __net_init sctp_ctrlsock_init(struct net *net)\n{\n\tint status;\n\tstatus = sctp_ctl_sock_init(net);\n\tif (status)\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\treturn status;\n}", "target": 0}
{"code": "void linsertCommand(client *c) {\n    int where;\n    robj *subject;\n    listTypeIterator *iter;\n    listTypeEntry entry;\n    int inserted = 0;\n    if (strcasecmp(c->argv[2]->ptr,\"after\") == 0) {\n        where = LIST_TAIL;\n    } else if (strcasecmp(c->argv[2]->ptr,\"before\") == 0) {\n        where = LIST_HEAD;\n    } else {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,subject,OBJ_LIST)) return;\n    iter = listTypeInitIterator(subject,0,LIST_TAIL);\n    while (listTypeNext(iter,&entry)) {\n        if (listTypeEqual(&entry,c->argv[3])) {\n            listTypeInsert(&entry,c->argv[4],where);\n            inserted = 1;\n            break;\n        }\n    }\n    listTypeReleaseIterator(iter);\n    if (inserted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"linsert\",\n                            c->argv[1],c->db->id);\n        server.dirty++;\n    } else {\n        addReplyLongLong(c,-1);\n        return;\n    }\n    addReplyLongLong(c,listTypeLength(subject));\n}", "target": 0}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::create(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  if (capacity <= kDefaultCombinedBufSize) {\n    return createCombined(capacity);\n  }\n  if (canNallocx()) {\n    auto mallocSize = goodMallocSize(capacity);\n    size_t minSize = ((capacity + 7) & ~7) + sizeof(SharedInfo);\n    if (mallocSize < minSize) {\n      auto* buf = checkedMalloc(mallocSize);\n      return takeOwnership(SIZED_FREE, buf, mallocSize, 0, 0);\n    }\n  }\n  return createSeparate(capacity);\n}", "target": 0}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "crm_parse_remote_buffer(char **msg_buf)\n{\n    char *buf = NULL;\n    char *start = NULL;\n    char *end = NULL;\n    xmlNode *xml = NULL;\n    if (*msg_buf == NULL) {\n        return NULL;\n    }\n    buf = *msg_buf;\n    *msg_buf = NULL;\n    start = buf;\n    end = strstr(start, REMOTE_MSG_TERMINATOR);\n    while (!xml && end) {\n        end[0] = '\\0';\n        end += strlen(REMOTE_MSG_TERMINATOR);\n        xml = string2xml(start);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", start);\n        }\n        start = end;\n        end = strstr(start, REMOTE_MSG_TERMINATOR);\n    }\n    if (xml && start) {\n        *msg_buf = strdup(start);\n        free(buf);\n    } else if (!xml) {\n        *msg_buf = buf;\n    }\n    return xml;\n}", "target": 0}
{"code": "bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_writable();\n}", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t  __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "got_headers (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerPrivate *priv = SOUP_SERVER_GET_PRIVATE (server);\n\tSoupURI *uri;\n\tSoupDate *date;\n\tchar *date_string;\n\tSoupAuthDomain *domain;\n\tGSList *iter;\n\tgboolean rejected = FALSE;\n\tchar *auth_user;\n\tif (!priv->raw_paths) {\n\t\tchar *decoded_path;\n\t\turi = soup_message_get_uri (req);\n\t\tdecoded_path = soup_uri_decode (uri->path);\n\t\tif (strstr (decoded_path, \"/../\") ||\n\t\t    g_str_has_suffix (decoded_path, \"/..\")) {\n\t\t\tg_free (decoded_path);\n\t\t\tsoup_message_set_status (req, SOUP_STATUS_BAD_REQUEST);\n\t\t\treturn;\n\t\t}\n\t\tsoup_uri_set_path (uri, decoded_path);\n\t\tg_free (decoded_path);\n\t}\n\tdate = soup_date_new_from_now (0);\n\tdate_string = soup_date_to_string (date, SOUP_DATE_HTTP);\n\tsoup_message_headers_replace (req->response_headers, \"Date\",\n\t\t\t\t      date_string);\n\tg_free (date_string);\n\tsoup_date_free (date);\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req)) {\n\t\t\tauth_user = soup_auth_domain_accepts (domain, req);\n\t\t\tif (auth_user) {\n\t\t\t\tclient->auth_domain = g_object_ref (domain);\n\t\t\t\tclient->auth_user = auth_user;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trejected = TRUE;\n\t\t}\n\t}\n\tif (!rejected)\n\t\treturn;\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req))\n\t\t\tsoup_auth_domain_challenge (domain, req);\n\t}\n}", "target": 0}
{"code": "dump_dest_constraints(const char *context,\n    const struct dest_constraint *dcs, size_t ndcs)\n{\n#ifdef DEBUG_CONSTRAINTS\n\tsize_t i;\n\tdebug_f(\"%s: %zu constraints\", context, ndcs);\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdebug_f(\"constraint %zu / %zu: from: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].from);\n\t\tdebug_f(\"constraint %zu / %zu: to: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].to);\n\t}\n\tdebug_f(\"done for %s\", context);\n#endif \n}", "target": 0}
{"code": "int mnt_optstr_get_uid(const char *optstr, const char *name, uid_t *uid)\n{\n\tchar *value = NULL;\n\tsize_t valsz = 0;\n\tchar buf[sizeof(stringify_value(UINT64_MAX))];\n\tint rc;\n\tuint64_t num;\n\tassert(optstr);\n\tassert(name);\n\tassert(uid);\n\trc = mnt_optstr_get_option(optstr, name, &value, &valsz);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (valsz > sizeof(buf) - 1) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\tmem2strcpy(buf, value, valsz, sizeof(buf));\n\trc = ul_strtou64(buf, &num, 10);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (num > ULONG_MAX || (uid_t) num != num) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\t*uid = (uid_t) num;\n\treturn 0;\nfail:\n\tDBG(UTILS, ul_debug(\"failed to convert '%s'= to number [rc=%d]\", name, rc));\n\treturn rc;\n}", "target": 0}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 1}
{"code": "int VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables) {\n  HuffmanTablesSegment* const root = &huffman_tables->root;\n  huffman_tables->curr_segment = root;\n  root->start = (HuffmanCode*)WebPSafeMalloc(size, sizeof(*root->start));\n  if (root->start == NULL) return 0;\n  root->curr_table = root->start;\n  root->next = NULL;\n  root->size = size;\n  return 1;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}", "target": 0}
{"code": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}", "target": 1}
{"code": "NOEXPORT char *pgsql_server(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {\n    uint8_t buffer[8], ssl_ok[1]={'S'};\n    static const uint8_t gss_request[8]={0, 0, 0, 8, 0x04, 0xd2, 0x16, 0x30};\n    static const uint8_t gss_response[62]=\n        {'E', 0, 0, 0, 61, 'S', 'E', 'R', 'R', 'O', 'R', 0, 'C', 'X', 'X', '0',\n        '0', '0', 0, 'M', 'S', 'S', 'L', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',\n        ' ', 'b', 'u', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't',\n        'e', 'd', ' ', 'b', 'y', ' ', 'c', 'l', 'i', 'e', 'n', 't', 0, 0};\n    (void)opt; \n    if(phase!=PROTOCOL_EARLY)\n        return NULL;\n    s_log(LOG_DEBUG, \"Started server-side psql protcol negotiation\");\n    memset(buffer, 0, sizeof buffer);\n    s_read(c, c->local_rfd.fd, buffer, sizeof buffer);\n    if(!safe_memcmp(buffer, gss_request, sizeof gss_request)) {\n        s_log(LOG_INFO, \"GSSAPI encryption requested, rejecting gracefully\");\n        s_write(c, c->local_wfd.fd, gss_response, sizeof gss_response);\n        throw_exception(c, 2); \n    }\n    if(safe_memcmp(buffer, ssl_request, sizeof ssl_request)) {\n        s_log(LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\");\n        throw_exception(c, 1);\n    }\n    s_log(LOG_DEBUG, \"SSLRequest received\");\n    s_write(c, c->local_wfd.fd, ssl_ok, sizeof ssl_ok);\n    return NULL;\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestDefaultHeaderLocation) {\n  auto headers = TestRequestHeaderMapImpl{{\"Authorization\", \"Bearer jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token\");\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer1\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer2\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer3\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer4\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"unknown_issuer\"));\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.has(Http::CustomHeaders::get().Authorization));\n}", "target": 0}
{"code": "xmlCopyEnumeration(xmlEnumerationPtr cur) {\n    xmlEnumerationPtr ret;\n    if (cur == NULL) return(NULL);\n    ret = xmlCreateEnumeration((xmlChar *) cur->name);\n    if (ret == NULL) return(NULL);\n    if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\n    else ret->next = NULL;\n    return(ret);\n}", "target": 0}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\tepi->nwait = -1;\n\t}\n}", "target": 0}
{"code": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}", "target": 1}
{"code": "setup_wait_limits(struct infra_cache* infra, struct config_file* cfg)\n{\n\taddr_tree_init(&infra->wait_limits_netblock);\n\taddr_tree_init(&infra->wait_limits_cookie_netblock);\n\tif(!infra_wait_limit_netblock_insert(infra, cfg))\n\t\treturn 0;\n\taddr_tree_init_parents(&infra->wait_limits_netblock);\n\taddr_tree_init_parents(&infra->wait_limits_cookie_netblock);\n\treturn 1;\n}", "target": 0}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n\tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}", "target": 1}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "void main_cleanup() {\n#ifdef USE_OS_THREADS\n    CLI *c;\n    unsigned i, threads;\n    THREAD_ID *thread_list;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);\n    threads=0;\n    for(c=thread_head; c; c=c->thread_next) \n        threads++;\n    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));\n    i=0;\n    for(c=thread_head; c; c=c->thread_next) { \n        thread_list[i++]=c->thread_id;\n        s_log(LOG_DEBUG, \"Terminating a thread for [%s]\", c->opt->servname);\n    }\n    if(cron_thread_id) { \n        thread_list[threads++]=cron_thread_id;\n        s_log(LOG_DEBUG, \"Terminating the cron thread\");\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);\n    if(threads) {\n        s_log(LOG_NOTICE, \"Terminating %u service thread(s)\", threads);\n        writesocket(terminate_pipe[1], \"\", 1);\n        for(i=0; i<threads; ++i) { \n#ifdef USE_PTHREAD\n            if(pthread_join(thread_list[i], NULL))\n                s_log(LOG_ERR, \"pthread_join() failed\");\n#endif\n#ifdef USE_WIN32\n            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)\n                ioerror(\"WaitForSingleObject\");\n            if(!CloseHandle(thread_list[i]))\n                ioerror(\"CloseHandle\");\n#endif\n        }\n        s_log(LOG_NOTICE, \"Service threads terminated\");\n    }\n    str_free(thread_list);\n#endif \n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}", "target": 1}
{"code": "smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n{\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n#ifdef\tCONFIG_USB_OTG\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}", "target": 1}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\treturn prog;\n}", "target": 1}
{"code": "static inline void CleanupPDFInfo(PDFInfo *pdf_info)\n{\n  if (pdf_info->profile != (StringInfo *) NULL)\n    pdf_info->profile=DestroyStringInfo(pdf_info->profile);\n}", "target": 0}
{"code": "bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  } else {\n    bool dtype_error = false;\n    CASES_WITH_DEFAULT(proto.dtype(), break, dtype_error = true,\n                       dtype_error = true);\n    if (dtype_error) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}", "target": 0}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}", "target": 0}
{"code": "static int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = private;\n\tif (!io_end)\n\t\treturn 0;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n\t\t  io_end, io_end->inode->i_ino, iocb, offset, size);\n\tif (size <= 0) {\n\t\text4_clear_io_unwritten_flag(io_end);\n\t\tsize = 0;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n\treturn 0;\n}", "target": 0}
{"code": "char *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void dnxhd_setup_threads_slices(DNXHDEncContext *ctx)\n{\n    int mb_y, mb_x;\n    int offset = 0;\n    for (mb_y = 0; mb_y < ctx->m.mb_height; mb_y++) {\n        int thread_size;\n        ctx->slice_offs[mb_y] = offset;\n        ctx->slice_size[mb_y] = 0;\n        for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {\n            unsigned mb = mb_y * ctx->m.mb_width + mb_x;\n            ctx->slice_size[mb_y] += ctx->mb_bits[mb];\n        }\n        ctx->slice_size[mb_y] = (ctx->slice_size[mb_y]+31)&~31;\n        ctx->slice_size[mb_y] >>= 3;\n        thread_size = ctx->slice_size[mb_y];\n        offset += thread_size;\n    }\n}", "target": 0}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\treturn 0;\n}", "target": 0}
{"code": "smtp_get_interface(uschar *istring, int host_af, address_item *addr,\n  uschar **interface, uschar *msg)\n{\nconst uschar * expint;\nuschar *iface;\nint sep = 0;\nif (!istring) return TRUE;\nif (!(expint = expand_string(istring)))\n  {\n  if (f.expand_string_forcedfail) return TRUE;\n  addr->transport_return = PANIC;\n  addr->message = string_sprintf(\"failed to expand \\\"interface\\\" \"\n      \"option for %s: %s\", msg, expand_string_message);\n  return FALSE;\n  }\nwhile (isspace(*expint)) expint++;\nif (*expint == 0) return TRUE;\nwhile ((iface = string_nextinlist(&expint, &sep, big_buffer,\n          big_buffer_size)))\n  {\n  if (string_is_ip_address(iface, NULL) == 0)\n    {\n    addr->transport_return = PANIC;\n    addr->message = string_sprintf(\"\\\"%s\\\" is not a valid IP \"\n      \"address for the \\\"interface\\\" option for %s\",\n      iface, msg);\n    return FALSE;\n    }\n  if (((Ustrchr(iface, ':') == NULL)? AF_INET:AF_INET6) == host_af)\n    break;\n  }\nif (iface) *interface = string_copy(iface);\nreturn TRUE;\n}", "target": 0}
{"code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n  TF_LITE_ENSURE(context, axis >= 0);\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "static void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}", "target": 1}
{"code": "void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pitch = data->data.value - 0x2000;\n    if (mdi->channel[ch].pitch < 0) {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8192;\n    } else {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8191;\n    }\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->sample_inc = get_inc(mdi, note_data);\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "void sort_directory(struct dir *dir)\n{\n\tstruct dir_ent *cur, *l1, *l2, *next;\n\tint len1, len2, stride = 1;\n\tif(dir->dir_count < 2)\n\t\treturn;\n\tdo {\n\t\tl2 = dir->dirs; \n\t\tcur = NULL; \n\t\twhile(l2) {\n\t\t\tl1 = l2;\n\t\t\tfor(len1 = 0; l2 && len1 < stride; len1 ++, l2 = l2->next);\n\t\t\tlen2 = stride;\n\t\t\twhile(len1 && l2 && len2) {\n\t\t\t\tif(strcmp(l1->name, l2->name) <= 0) {\n\t\t\t\t\tnext = l1;\n\t\t\t\t\tl1 = l1->next;\n\t\t\t\t\tlen1 --;\n\t\t\t\t} else {\n\t\t\t\t\tnext = l2;\n\t\t\t\t\tl2 = l2->next;\n\t\t\t\t\tlen2 --;\n\t\t\t\t}\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = next;\n\t\t\t\t\tcur = next;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = next;\n\t\t\t}\n\t\t\tfor(; len1; len1 --, l1 = l1->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l1;\n\t\t\t\t\tcur = l1;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l1;\n\t\t\t}\n\t\t\tfor(; l2 && len2; len2 --, l2 = l2->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l2;\n\t\t\t\t\tcur = l2;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l2;\n\t\t\t}\n\t\t}\n\t\tcur->next = NULL;\n\t\tstride = stride << 1;\n\t} while(stride < dir->dir_count);\n}", "target": 0}
{"code": "static int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             int64_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}", "target": 0}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "static inline int domain_pfn_mapping(struct dmar_domain *domain, unsigned long iov_pfn,\n\t\t\t\t     unsigned long phys_pfn, unsigned long nr_pages,\n\t\t\t\t     int prot)\n{\n\treturn domain_mapping(domain, iov_pfn, NULL, phys_pfn, nr_pages, prot);\n}", "target": 0}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "agoo_ws_create_req(agooCon c, long mlen) {\n    uint8_t\top = 0x0F & *c->buf;\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\tagoo_log_cat(&agoo_error_cat, \"Out of memory attempting to allocate request.\");\n\treturn true;\n    }\n    if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {\n\treturn true;\n    }\n    memset(c->req, 0, sizeof(struct _agooReq));\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->mlen = mlen;\n    c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = c->up;\n    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n    c->req->res = NULL;\n    if (c->up->on_msg) {\n\tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);\n    }\n    return false;\n}", "target": 0}
{"code": "static int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tfor (;;) {\n\t\tvcpu->arch.at_instruction_boundary = false;\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(vcpu);\n\t\t}\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tkvm_clear_request(KVM_REQ_UNBLOCK, vcpu);\n\t\tif (kvm_xen_has_pending_events(vcpu))\n\t\t\tkvm_xen_inject_pending_events(vcpu);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\t\tif (__xfer_to_guest_mode_work_pending()) {\n\t\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\t\tr = xfer_to_guest_mode_handle_work(vcpu);\n\t\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\treturn r;\n}", "target": 0}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void TestDecodeGif(Env* env, DecodeGifTestCase testcase) {\n  string gif;\n  ReadFileToStringOrDie(env, testcase.filepath, &gif);\n  std::unique_ptr<uint8[]> imgdata;\n  int nframes, w, h, c;\n  string error_string;\n  imgdata.reset(gif::Decode(\n      gif.data(), gif.size(),\n      [&](int frame_cnt, int width, int height, int channels) -> uint8* {\n        nframes = frame_cnt;\n        w = width;\n        h = height;\n        c = channels;\n        return new uint8[frame_cnt * height * width * channels];\n      },\n      &error_string));\n  ASSERT_NE(imgdata, nullptr);\n  ASSERT_EQ(nframes, testcase.num_frames);\n  ASSERT_EQ(w, testcase.width);\n  ASSERT_EQ(h, testcase.height);\n  ASSERT_EQ(c, testcase.channels);\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}", "target": 1}
{"code": "LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}", "target": 1}
{"code": "CSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "void send( char* str ) {\n    fprintf(outfile, \"%s\",str);\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  TF_LITE_ENSURE(context, !params->table_name.empty());\n  TF_LITE_ENSURE(context, (params->key_dtype == kTfLiteInt64 &&\n                           params->value_dtype == kTfLiteString) ||\n                              (params->key_dtype == kTfLiteString &&\n                               params->value_dtype == kTfLiteInt64));\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor->type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, resource_handle_tensor, outputSize);\n}", "target": 1}
{"code": "kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n    return 0;\n}", "target": 1}
{"code": "void zend_shared_alloc_register_xlat_entry(const void *old, const void *new)\n{\n\tzend_hash_index_update_ptr(&xlat_table, (zend_ulong)old, (void*)new);\n}", "target": 0}
{"code": "static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)\n{\n\tu64 runtime, runtime_expires;\n\tint throttled;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tgoto out_deactivate;\n\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\tcfs_b->nr_periods += overrun;\n\tif (cfs_b->idle && !throttled)\n\t\tgoto out_deactivate;\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\tif (!throttled) {\n\t\tcfs_b->idle = 1;\n\t\treturn 0;\n\t}\n\tcfs_b->nr_throttled += overrun;\n\truntime_expires = cfs_b->runtime_expires;\n\twhile (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {\n\t\truntime = cfs_b->runtime;\n\t\tcfs_b->distribute_running = 1;\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\truntime = distribute_cfs_runtime(cfs_b, runtime,\n\t\t\t\t\t\t runtime_expires);\n\t\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\t\tcfs_b->distribute_running = 0;\n\t\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\t}\n\tcfs_b->idle = 0;\n\treturn 0;\nout_deactivate:\n\treturn 1;\n}", "target": 1}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; \n\tconst char *mntsrc = src;\n\tif (!rootfs)\n\t\trootfs = \"\";\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\treturn destfd;\n\t}\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinit_rwsem(&ei->i_mmap_sem);\n\tinode_init_once(&ei->vfs_inode);\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static int create_mr(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                     union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_create_mr *cmd = &req->create_mr;\n    struct pvrdma_cmd_create_mr_resp *resp = &rsp->create_mr_resp;\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n    void *host_virt = NULL;\n    int rc = 0;\n    memset(resp, 0, sizeof(*resp));\n    if (!(cmd->flags & PVRDMA_MR_FLAG_DMA)) {\n        host_virt = pvrdma_map_to_pdir(pci_dev, cmd->pdir_dma, cmd->nchunks,\n                                       cmd->length);\n        if (!host_virt) {\n            rdma_error_report(\"Failed to map to pdir\");\n            return -EINVAL;\n        }\n    }\n    rc = rdma_rm_alloc_mr(&dev->rdma_dev_res, cmd->pd_handle, cmd->start,\n                          cmd->length, host_virt, cmd->access_flags,\n                          &resp->mr_handle, &resp->lkey, &resp->rkey);\n    if (rc && host_virt) {\n        munmap(host_virt, cmd->length);\n    }\n    return rc;\n}", "target": 0}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 1}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}", "target": 0}
{"code": "void * calloc(size_t n, size_t lb)\n{\n    if ((lb | n) > GC_SQRT_SIZE_MAX \n        && lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 0}
{"code": "static int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}", "target": 0}
{"code": "NCR_ModifyMaxdelay(NCR_Instance inst, double new_max_delay)\n{\n  inst->max_delay = new_max_delay;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new max delay %f\",\n      UTI_IPToString(&inst->remote_addr.ip_addr), new_max_delay);\n}", "target": 0}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tfl6_free_socklist(sk);\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}", "target": 1}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void HttpMultiBufHeaderThreadDataFree(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = data;\n    for (size_t i = 0; i < td->cap; i++) {\n        SCFree(td->items[i].buffer);\n    }\n    SCFree(td->items);\n    SCFree(td);\n}", "target": 0}
{"code": "static void adpt_sparc_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ULTRASPARC;\n}", "target": 1}
{"code": "_asn1_set_default_tag (asn1_node node)\n{\n  asn1_node p;\n  if ((node == NULL) || (type_field (node->type) != ASN1_ETYPE_DEFINITIONS))\n    return ASN1_ELEMENT_NOT_FOUND;\n  p = node;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_TAG) &&\n\t  !(p->type & CONST_EXPLICIT) && !(p->type & CONST_IMPLICIT))\n\t{\n\t  if (node->type & CONST_EXPLICIT)\n\t    p->type |= CONST_EXPLICIT;\n\t  else\n\t    p->type |= CONST_IMPLICIT;\n\t}\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_get_up (p);\n\t      if (p == node)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  return ASN1_SUCCESS;\n}", "target": 0}
{"code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "ProcAllocColor(ClientPtr client)\n{\n    ColormapPtr pmap;\n    int rc;\n    REQUEST(xAllocColorReq);\n    REQUEST_SIZE_MATCH(xAllocColorReq);\n    rc = dixLookupResourceByType((void **) &pmap, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        xAllocColorReply acr = {\n            .type = X_Reply,\n            .sequenceNumber = client->sequence,\n            .length = 0,\n            .red = stuff->red,\n            .green = stuff->green,\n            .blue = stuff->blue,\n            .pixel = 0\n        };\n        if ((rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,\n                             &acr.pixel, client->index)))\n            return rc;\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pmap->pScreen->myNum)\n#endif\n            WriteReplyToClient(client, sizeof(xAllocColorReply), &acr);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": "SecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n    const SSL_METHOD* method;\n    OpenSSL_add_all_algorithms();\n    SSL_load_error_strings();\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n    }\n}", "target": 0}
{"code": "static void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "cib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n    buf = calloc(1, chunk_size);\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "cib_remote_command_dispatch(gpointer user_data)\n{\n    int disconnected = 0;\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n    free(private->command.recv_buf);\n    private->command.recv_buf = NULL;\n    crm_err(\"received late reply for remote cib connection, discarding\");\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "agoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\tstruct sockaddr_storage\taddr;\n\tsocklen_t\t\tlen = sizeof(addr);\n\tgetpeername(sock, (struct sockaddr*)&addr, &len);\n\tif (addr.ss_family == AF_INET) {\n\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;\n\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));\n\t} else {\n\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;\n\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));\n\t}\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}", "target": 0}
{"code": "mm_memvalid(struct mm_master *mm, void *address, size_t size)\n{\n\tvoid *end = (char *)address + size;\n\tif (address < mm->address)\n\t\tfatal(\"mm_memvalid: address too small: %p\", address);\n\tif (end < address)\n\t\tfatal(\"mm_memvalid: end < address: %p < %p\", end, address);\n\tif (end > MM_ADDRESS_END(mm))\n\t\tfatal(\"mm_memvalid: address too large: %p\", address);\n}", "target": 1}
{"code": "\t\tstatic auto HasProxy(Local<Object> object) -> bool {\n\t\t\tif (object->IsProxy()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tauto proto = object->GetPrototype();\n\t\t\t\tif (proto->IsNullOrUndefined()) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn HasProxy(proto.As<Object>());\n\t\t\t\t}\n\t\t\t}\n\t\t}", "target": 0}
{"code": "  virtual bool ms_verify_authorizer(Connection *con,\n\t\t\t\t    int peer_type,\n\t\t\t\t    int protocol,\n\t\t\t\t    ceph::bufferlist& authorizer,\n\t\t\t\t    ceph::bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid,\n\t\t\t\t    CryptoKey& session_key) { return false; }", "target": 1}
{"code": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n\t\tsock_put(sk);\n\t}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* filter_backprop = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(0, filter.shape(), &filter_backprop));\n    if (filter.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropFilter<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        filter_backprop->tensor<T, 3>());\n  }", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(\n        context, grad_in.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    LaunchMaxPoolingGradGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "int module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n  set_integer(1, module_object, \"struct_array[1].i\");\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n  set_integer(256, module_object, \"integer_array[%i]\", 256);\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n  return ERROR_SUCCESS;\n}", "target": 0}
{"code": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\tsk_setup_caps(sk, &rt->dst);\n\tnew_saddr = rt->rt_src;\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->thread_keyring)\n\t\treturn 0;\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}", "target": 0}
{"code": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\treturn err;\n}", "target": 1}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n        if (len == 0) {\n            return -1;\n        }\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "static struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 5;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\tif (netif_carrier_ok(dev)) {\n\t\trtnl_lock();\n\t\tnetif_carrier_off(dev); \n\t\tif (netif_running(dev))\n\t\t\txenvif_down(vif);\n\t\trtnl_unlock();\n\t\txenvif_put(vif);\n\t}\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\tdel_timer_sync(&vif->credit_timeout);\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\tunregister_netdev(vif->dev);\n\txen_netbk_unmap_frontend_rings(vif);\n\tfree_netdev(vif->dev);\n}", "target": 1}
{"code": "static int php_curl_option_str(php_curl *ch, zend_long option, const char *str, const int len, zend_bool make_copy)\n{\n\tCURLcode error = CURLE_OK;\n\tif (strlen(str) != len) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Curl option contains invalid characters (\\\\0)\");\n\t\treturn FAILURE;\n\t}\n#if LIBCURL_VERSION_NUM >= 0x071100\n\tif (make_copy) {\n#endif\n\t\tchar *copystr;\n\t\tcopystr = estrndup(str, len);\n\t\terror = curl_easy_setopt(ch->cp, option, copystr);\n\t\tzend_llist_add_element(&ch->to_free->str, &copystr);\n#if LIBCURL_VERSION_NUM >= 0x071100\n\t} else {\n\t\terror = curl_easy_setopt(ch->cp, option, str);\n\t}\n#endif\n\tSAVE_CURL_ERROR(ch, error)\n\treturn error == CURLE_OK ? SUCCESS : FAILURE;\n}", "target": 0}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tif (nft_set_is_anonymous(set))\n\t\t\tnft_deactivate_next(ctx->net, set);\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}", "target": 0}
{"code": "dcinit()\n{\n\tstrsize = 1; \n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}", "target": 0}
{"code": "int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n  if (flags & IMAP_CMD_SINGLE)\n  {\n    if (adata->nextcmd != adata->lastcmd)\n      imap_exec(adata, NULL, IMAP_CMD_POLL);\n  }\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n      break;\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n  return IMAP_EXEC_SUCCESS;\n}", "target": 0}
{"code": "static inline u32 dma_high(dma_addr_t addr)\n{\n\treturn upper_32_bits(addr);\n}", "target": 1}
{"code": "bool dir_is_in_dump_location(const char *dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0)\n    {\n        log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);\n        return false;\n    }\n    const char *base_name = dir_name + len;\n    while (*base_name && *base_name == '/')\n        ++base_name;\n    if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))\n    {\n        log_debug(\"Invalid dump directory name: '%s'\", base_name);\n        return false;\n    }\n    struct stat sb;\n    if (lstat(dir_name, &sb) < 0)\n    {\n        VERB2 perror_msg(\"stat('%s')\", dir_name);\n        return errno== ENOENT;\n    }\n    return S_ISDIR(sb.st_mode);\n}", "target": 0}
{"code": "static inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}", "target": 0}
{"code": "static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type==3) { \n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { \n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "int zmq::stream_engine_t::decode_and_push (msg_t *msg_)\n{\n    zmq_assert (mechanism != NULL);\n    if (mechanism->decode (msg_) == -1)\n        return -1;\n    if (metadata)\n        msg_->set_metadata (metadata);\n    if (session->push_msg (msg_) == -1) {\n        if (errno == EAGAIN)\n            process_msg = &stream_engine_t::push_one_then_decode_and_push;\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "decode_definite_long_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL, *chunk = NULL, *string = NULL;\n    Py_ssize_t left = length;\n    Py_ssize_t consumed;\n    Py_ssize_t buffer_size = 0;  \n    Py_ssize_t buffer_length = 0;  \n    char *buffer = NULL;\n    while (left) {\n        Py_ssize_t chunk_length = 65536 - buffer_size;\n        if (left < chunk_length)\n            chunk_length = left;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        left -= chunk_length;\n        if (!chunk)\n            goto error;\n        char *bytes_buffer = PyBytes_AsString(chunk);\n        if (!bytes_buffer)\n            goto error;\n        char *source_buffer;\n        if (buffer) {\n            if (buffer_length + chunk_length > buffer_size) {\n                buffer_size = buffer_length + chunk_length;\n                char *new_buffer = PyMem_Realloc(buffer, buffer_size);\n                if (!new_buffer)\n                    goto error;\n                buffer = new_buffer;\n            }\n            memcpy(buffer + buffer_length, bytes_buffer, chunk_length);\n            buffer_length += chunk_length;\n            source_buffer = buffer;\n            chunk_length = buffer_length;\n        } else {\n            source_buffer = bytes_buffer;\n        }\n        string = PyUnicode_DecodeUTF8Stateful(source_buffer, chunk_length, NULL, &consumed);\n        if (!string)\n            goto error;\n        if (ret) {\n            PyObject *joined = PyUnicode_Concat(ret, string);\n            if (!joined)\n                goto error;\n            Py_DECREF(string);\n            string = NULL;\n            ret = joined;\n        } else {\n            ret = string;\n        }\n        Py_ssize_t unconsumed = chunk_length - consumed;\n        if (consumed != chunk_length) {\n            if (buffer) {\n                memmove(buffer, buffer + consumed, unconsumed);\n            } else {\n                buffer = PyMem_Malloc(unconsumed);\n                if (!buffer)\n                    goto error;\n                memcpy(buffer, bytes_buffer + consumed, unconsumed);\n            }\n            buffer_length = unconsumed;\n        }\n    }\n    if (ret && string_namespace_add(self, ret, length) == -1)\n        goto error;\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    Py_XDECREF(chunk);\n    Py_XDECREF(string);\n    if (buffer)\n        PyMem_Free(buffer);\n    return NULL;\n}", "target": 0}
{"code": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\toidc_debug(r, \"enter\");\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}", "target": 1}
{"code": "fr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\treturn capabilities;\n}", "target": 1}
{"code": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len _U_,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_KE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" key len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_KE)));\n\treturn NULL;\n}", "target": 0}
{"code": "nfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\t__be32 status;\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}", "target": 0}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "mesh_state_cleanup(struct mesh_state* mstate)\n{\n\tstruct mesh_area* mesh;\n\tint i;\n\tif(!mstate)\n\t\treturn;\n\tmesh = mstate->s.env->mesh;\n\tif(mstate->s.serve_expired_data && mstate->s.serve_expired_data->timer) {\n\t\tcomm_timer_delete(mstate->s.serve_expired_data->timer);\n\t\tmstate->s.serve_expired_data->timer = NULL;\n\t}\n\tif(!mstate->replies_sent) {\n\t\tstruct mesh_reply* rep = mstate->reply_list;\n\t\tstruct mesh_cb* cb;\n\t\tmstate->reply_list = NULL;\n\t\tfor(; rep; rep=rep->next) {\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&rep->query_reply, mesh->env->cfg);\n\t\t\tcomm_point_drop_reply(&rep->query_reply);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t\twhile((cb = mstate->cb_list)!=NULL) {\n\t\t\tmstate->cb_list = cb->next;\n\t\t\tfptr_ok(fptr_whitelist_mesh_cb(cb->cb));\n\t\t\t(*cb->cb)(cb->cb_arg, LDNS_RCODE_SERVFAIL, NULL,\n\t\t\t\tsec_status_unchecked, NULL, 0);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t}\n\tfor(i=0; i<mesh->mods.num; i++) {\n\t\tfptr_ok(fptr_whitelist_mod_clear(mesh->mods.mod[i]->clear));\n\t\t(*mesh->mods.mod[i]->clear)(&mstate->s, i);\n\t\tmstate->s.minfo[i] = NULL;\n\t\tmstate->s.ext_state[i] = module_finished;\n\t}\n\talloc_reg_release(mstate->s.env->alloc, mstate->s.region);\n}", "target": 0}
{"code": "compute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}", "target": 0}
{"code": "static TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void csi_K(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short *start = (unsigned short *)vc->vc_pos;\n\tint offset;\n\tswitch (vpar) {\n\t\tcase 0:\t\n\t\t\toffset = 0;\n\t\t\tcount = vc->vc_cols - vc->vc_x;\n\t\t\tbreak;\n\t\tcase 1:\t\n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_x + 1;\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_cols;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tvc_uniscr_clear_line(vc, vc->vc_x + offset, count);\n\tscr_memsetw(start + offset, vc->vc_video_erase_char, 2 * count);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long)(start + offset), count);\n}", "target": 0}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "theme_adium_match_with_format (const gchar **str,\n\t\t\t       const gchar *match,\n\t\t\t       gchar **format)\n{\n\tconst gchar *cur = *str;\n\tconst gchar *end;\n\tif (!theme_adium_match (&cur, match)) {\n\t\treturn FALSE;\n\t}\n\tcur++;\n\tend = strstr (cur, \"}%\");\n\tif (!end) {\n\t\treturn FALSE;\n\t}\n\t*format = g_strndup (cur , end - cur);\n\t*str = end + 1;\n\treturn TRUE;\n}", "target": 0}
{"code": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}", "target": 0}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n    if (!cblk->length)\n        return 0;\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "inline void aligned_free(void* ptr) {\n  folly::detail::aligned_free(ptr);\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}", "target": 1}
{"code": "pci_bus_configured(int bus)\n{\n\tassert(bus >= 0 && bus < MAXBUSES);\n\treturn (pci_businfo[bus] != NULL);\n}", "target": 1}
{"code": "GF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (fieldSize == 32) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\tsas_probe_sata(port);\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}", "target": 1}
{"code": "int use_env()\n{\n    int indent;\n    size_t flags = 0;\n    json_t *json;\n    json_error_t error;\n    #ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n    _setmode(_fileno(stderr), _O_BINARY);\n    #endif\n    indent = getenv_int(\"JSON_INDENT\");\n    if(indent < 0 || indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", indent);\n        return 2;\n    }\n    if(indent > 0)\n        flags |= JSON_INDENT(indent);\n    if(getenv_int(\"JSON_COMPACT\") > 0)\n        flags |= JSON_COMPACT;\n    if(getenv_int(\"JSON_ENSURE_ASCII\"))\n        flags |= JSON_ENSURE_ASCII;\n    if(getenv_int(\"JSON_PRESERVE_ORDER\"))\n        flags |= JSON_PRESERVE_ORDER;\n    if(getenv_int(\"JSON_SORT_KEYS\"))\n         flags |= JSON_SORT_KEYS;\n    if(getenv_int(\"STRIP\")) {\n        size_t size = 0, used = 0;\n        char *buffer = NULL;\n        while(1) {\n            size_t count;\n            size = (size == 0 ? 128 : size * 2);\n            buffer = realloc(buffer, size);\n            if(!buffer) {\n                fprintf(stderr, \"Unable to allocate %d bytes\\n\", (int)size);\n                return 1;\n            }\n            count = fread(buffer + used, 1, size - used, stdin);\n            if(count < size - used) {\n                buffer[used + count] = '\\0';\n                break;\n            }\n            used += count;\n        }\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(stdin, 0, &error);\n    if(!json) {\n        fprintf(stderr, \"%d %d %d\\n%s\\n\",\n            error.line, error.column,\n            error.position, error.text);\n        return 1;\n    }\n    json_dumpf(json, stdout, flags);\n    json_decref(json);\n    return 0;\n}", "target": 1}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "int lstat_cache_aware_rmdir(const char *path)\n{\n\tint ret = rmdir(path);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n    luaL_checkstack(L, 3, \"in function mp_encode_lua_table_as_map\");\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); \n        len++;\n    }\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pushvalue(L,-2); \n        mp_encode_lua_type(L,buf,level+1); \n        mp_encode_lua_type(L,buf,level+1); \n    }\n}", "target": 0}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "static int whiteheat_probe(struct usb_serial *serial,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tsize_t num_bulk_in = 0;\n\tsize_t num_bulk_out = 0;\n\tsize_t min_num_bulk;\n\tunsigned int i;\n\tiface_desc = serial->interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint))\n\t\t\t++num_bulk_in;\n\t\tif (usb_endpoint_is_bulk_out(endpoint))\n\t\t\t++num_bulk_out;\n\t}\n\tmin_num_bulk = COMMAND_PORT + 1;\n\tif (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n    if (BN_is_zero(a))\n        return 0;\n    for (i = a->top - 1; i >= 0; i--) {\n        if (!a->d[i])\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j >= 0; j--) {\n            if (a->d[i] & mask) {\n                if (k < max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask >>= 1;\n        }\n    }\n    if (k < max) {\n        p[k] = -1;\n        k++;\n    }\n    return k;\n}", "target": 1}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "    int32_t audio_io_osx::shutdown_audio_unit() {\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_play_ = NULL;\n        }\n        return 0;\n    }", "target": 0}
{"code": "static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block)\n{\n    if (! p_code_block->data) {\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE);\n        if (! p_code_block->data) {\n            return OPJ_FALSE;\n        }\n        p_code_block->data_max_size = OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE;\n        p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,\n                             sizeof(opj_tcd_seg_t));\n        if (! p_code_block->segs) {\n            return OPJ_FALSE;\n        }\n        p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n    } else {\n        OPJ_BYTE* l_data = p_code_block->data;\n        OPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n        opj_tcd_seg_t * l_segs = p_code_block->segs;\n        OPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n        memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n        p_code_block->data = l_data;\n        p_code_block->data_max_size = l_data_max_size;\n        p_code_block->segs = l_segs;\n        p_code_block->m_current_max_segs = l_current_max_segs;\n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static void perf_event_task_event(struct perf_task_event *task_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_task_ctx(&cpuctx->ctx, task_event);\n\t\tctx = task_event->task_ctx;\n\t\tif (!ctx) {\n\t\t\tctxn = pmu->task_ctx_nr;\n\t\t\tif (ctxn < 0)\n\t\t\t\tgoto next;\n\t\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\t\tif (ctx)\n\t\t\t\tperf_event_task_ctx(ctx, task_event);\n\t\t}\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\tif (task_event->task_ctx)\n\t\tperf_event_task_ctx(task_event->task_ctx, task_event);\n\trcu_read_unlock();\n}", "target": 0}
{"code": "int js_isuserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\treturn !strcmp(tag, v->u.object->u.user.tag);\n\treturn 0;\n}", "target": 0}
{"code": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "snmp_ber_decode_timeticks(snmp_packet_t *snmp_packet, uint32_t *timeticks)\n{\n  return snmp_ber_decode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\tif (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}", "target": 0}
{"code": "static void mark_curve(fixed sx, fixed sy, fixed c1x, fixed c1y, fixed c2x, fixed c2y, fixed ex, fixed ey, fixed base_y, fixed height, int *table, int *index, int depth)\n{\n    fixed ax = (sx + c1x)>>1;\n    fixed ay = (sy + c1y)>>1;\n    fixed bx = (c1x + c2x)>>1;\n    fixed by = (c1y + c2y)>>1;\n    fixed cx = (c2x + ex)>>1;\n    fixed cy = (c2y + ey)>>1;\n    fixed dx = (ax + bx)>>1;\n    fixed dy = (ay + by)>>1;\n    fixed fx = (bx + cx)>>1;\n    fixed fy = (by + cy)>>1;\n    fixed gx = (dx + fx)>>1;\n    fixed gy = (dy + fy)>>1;\n    assert(depth >= 0);\n    if (depth == 0)\n        mark_line(sx, sy, ex, ey, base_y, height, table, index);\n    else {\n        depth--;\n        mark_curve(sx, sy, ax, ay, dx, dy, gx, gy, base_y, height, table, index, depth);\n        mark_curve(gx, gy, fx, fy, cx, cy, ex, ey, base_y, height, table, index, depth);\n    }\n}", "target": 0}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}", "target": 1}
{"code": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_fs_locations(client, dir, name, fs_locations, page),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}", "target": 0}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "void InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}", "target": 1}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "int check_name(char *name, int size)\n{\n\tchar *start = name;\n\tif(name[0] == '.') {\n\t\tif(name[1] == '.')\n\t\t\tname++;\n\t\tif(name[1] == '/' || name[1] == '\\0')\n\t\t\treturn FALSE;\n\t}\n\twhile(name[0] != '/' && name[0] != '\\0')\n\t\tname ++;\n\tif(name[0] == '/')\n\t\treturn FALSE;\n\tif((name - start) != size)\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\tif(selector!=1) {\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\tif(selector==0) { \n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\tif(selector==0 || selector==1) {\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}", "target": 0}
{"code": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}", "target": 1}
{"code": "STATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }", "target": 0}
{"code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\tgf_filter_pck_send(pck);\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\treturn GF_OK;\n}", "target": 0}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "static inline neu_msg_t *neu_msg_new(neu_reqresp_type_e t, void *ctx,\n                                     void *data)\n{\n    size_t data_size = neu_reqresp_size(t);\n    size_t body_size = 0;\n    switch (t) {\n    case NEU_REQ_CHECK_SCHEMA:\n        body_size = neu_reqresp_size(NEU_RESP_CHECK_SCHEMA);\n        break;\n    case NEU_REQ_GET_PLUGIN:\n        body_size = neu_reqresp_size(NEU_RESP_GET_PLUGIN);\n        break;\n    case NEU_REQ_UPDATE_GROUP:\n    case NEU_REQ_UPDATE_DRIVER_GROUP:\n        body_size = neu_reqresp_size(NEU_RESP_UPDATE_DRIVER_GROUP);\n        break;\n    case NEU_REQ_UPDATE_NODE:\n    case NEU_REQ_NODE_RENAME:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_RENAME);\n        break;\n    case NEU_REQ_DEL_NODE:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_UNINIT);\n        break;\n    case NEU_REQ_GET_NODE_SETTING:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODE_SETTING);\n        break;\n    case NEU_REQ_GET_NODES_STATE:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODES_STATE);\n        break;\n    default:\n        body_size = data_size;\n    }\n    size_t     total = sizeof(neu_msg_t) + body_size;\n    neu_msg_t *msg   = calloc(1, total);\n    if (msg) {\n        msg->head.type = t;\n        msg->head.len  = total;\n        msg->head.ctx  = ctx;\n        if (data) {\n            memcpy(msg->body, data, data_size);\n        }\n    }\n    return msg;\n}", "target": 0}
{"code": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "static uint jsi_SizeOfArray(Jsi_Interp *interp, Jsi_Obj *obj) {\n    if (!obj || !obj->arr)\n        return 0;\n    return obj->arrCnt;\n}", "target": 0}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "void read_pcm_samples_internal(thread_context* tctx, int x0, int y0, int log2CbSize,\n                               int cIdx, bitreader& br)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  int nPcmBits;\n  int bitDepth;\n  int w = 1<<log2CbSize;\n  int h = 1<<log2CbSize;\n  if (cIdx>0) {\n    w /= sps.SubWidthC;\n    h /= sps.SubHeightC;\n    x0 /= sps.SubWidthC;\n    y0 /= sps.SubHeightC;\n    nPcmBits = sps.pcm_sample_bit_depth_chroma;\n    bitDepth = sps.BitDepth_C;\n  }\n  else {\n    nPcmBits = sps.pcm_sample_bit_depth_luma;\n    bitDepth = sps.BitDepth_Y;\n  }\n  pixel_t* ptr;\n  int stride;\n  ptr    = tctx->img->get_image_plane_at_pos_NEW<pixel_t>(cIdx,x0,y0);\n  stride = tctx->img->get_image_stride(cIdx);\n  int shift = bitDepth - nPcmBits;\n  if (shift < 0) {\n    shift=0;\n  }\n  for (int y=0;y<h;y++)\n    for (int x=0;x<w;x++)\n      {\n        int value = get_bits(&br, nPcmBits);\n        ptr[y*stride+x] = value << shift;\n      }\n}", "target": 0}
{"code": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "bool current_chrooted(void)\n{\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\tget_fs_root(current->fs, &fs_root);\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\treturn chrooted;\n}", "target": 0}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\txml_parser *parser = (xml_parser *)rsrc->ptr;\n\tif (parser->parser) {\n\t\tXML_ParserFree(parser->parser);\n\t}\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\tefree(parser);\n}", "target": 0}
{"code": "static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "KCleanup::operator= ( const KCleanup &src )\n{\n    copy( src );\n    return *this;\n}", "target": 0}
{"code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *length); \n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; \n\t\treturn TRUE;\n\t}\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type); \n\t*type &= 0x0F;                \n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); \n\telse\n\t\t*channel_id = 0; \n\treturn TRUE;\n}", "target": 1}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n    if (poll_set->used == poll_set->max_used) {\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n    free_slot->fd = fd;\n    ++poll_set->used;\n    return free_slot;\n}", "target": 1}
{"code": "void js_rot(js_State *J, int n)\n{\n\tint i;\n\tjs_Value tmp = STACK[TOP-1];\n\tfor (i = 1; i < n; ++i)\n\t\tSTACK[TOP-i] = STACK[TOP-i-1];\n\tSTACK[TOP-i] = tmp;\n}", "target": 0}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "gerb_fopen(char const * filename)\n{\n    gerb_file_t *fd;\n    struct stat statinfo;\n    dprintf(\"---> Entering gerb_fopen, filename = %s\\n\", filename);\n    fd = g_new(gerb_file_t, 1);\n    if (fd == NULL) {\n\treturn NULL;\n    }\n    dprintf(\"     Doing fopen\\n\");\n    fd->fd = g_fopen(filename, \"rb\");\n    if (fd->fd == NULL) {\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Doing fstat\\n\");\n    fd->ptr = 0;\n    fd->fileno = fileno(fd->fd);\n    if (fstat(fd->fileno, &statinfo) < 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Checking S_ISREG\\n\");\n    if (!S_ISREG(statinfo.st_mode)) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EISDIR;\n\treturn NULL;\n    }\n    dprintf(\"     Checking statinfo.st_size\\n\");\n    if ((int)statinfo.st_size == 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EIO; \n\treturn NULL;\n    }\n#ifdef HAVE_SYS_MMAN_H\n    dprintf(\"     Doing mmap\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = (char *)mmap(0, statinfo.st_size, PROT_READ, MAP_PRIVATE, \n\t\t\t    fd->fileno, 0);\n    if(fd->data == MAP_FAILED) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\tfd = NULL;\n    }\n#else\n    dprintf(\"     Doing calloc\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = calloc(1, statinfo.st_size + 1);\n    if (fd->data == NULL) {\n        fclose(fd->fd);\n        g_free(fd);\n        return NULL;\n    }\n    if (fread((void*)fd->data, 1, statinfo.st_size, fd->fd) != statinfo.st_size) {\n        fclose(fd->fd);\n\tg_free(fd->data);\n        g_free(fd);\n\treturn NULL;\n    }\n    rewind (fd->fd);\n#endif\n    dprintf(\"     Setting filename\\n\");\n    fd->filename = g_strdup(filename);\n    dprintf(\"<--- Leaving gerb_fopen\\n\");\n    return fd;\n} ", "target": 0}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static void cfg_resp_handler(int err, const struct http_msg *msg,\n\t\t\t     struct mbuf *mb, struct json_object *jobj,\n\t\t\t     void *arg)\n{\n\tchar *json_str = NULL;\n\tstruct zapi_ice_server *servers;\n\tsize_t nservers = 0;\n\tsize_t i;\n\tre_printf(\"config ready! err=%d\\n\");\n\tif (err == ECONNABORTED)\n\t\tgoto out;\n\tif (!err && jobj) {\n\t\terr = jzon_encode(&json_str, jobj);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tre_printf(\"CONFIG: %s\\n\", json_str);\n\tconfig_update(g_config, err, json_str, str_len(json_str));\n\tmem_deref(json_str);\n\tservers = config_get_iceservers(g_config, &nservers);\n\tre_printf(\"Probing: %d servers\\n\", nservers);\n\tfor (i = 0; i < nservers; ++i) {\n\t\tstruct zapi_ice_server *turn = &servers[i];\n\t\tstruct stun_uri uri;\n\t\terr = stun_uri_decode(&uri, turn->url);\n\t\tif (err)\n\t\t\terr = turn_dns_lookup(turn, &uri);\n\t\telse {\n\t\t\tstart_netprobe(&uri.addr, uri.proto, uri.secure,\n\t\t\t\t       turn->username, turn->credential);\n\t\t}\n\t}\n out:\n\tif (err)\n\t\terror(\"config request failed: %m\\n\", err);\n}", "target": 0}
{"code": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}", "target": 1}
{"code": "void isdn_ppp_receive(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb)\n{\n\tstruct ippp_struct *is;\n\tint slot;\n\tint proto;\n\tBUG_ON(net_dev->local->master); \n\tslot = lp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR \"isdn_ppp_receive: lp->ppp_slot(%d)\\n\",\n\t\t       lp->ppp_slot);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tis = ippp_table[slot];\n\tif (is->debug & 0x4) {\n\t\tprintk(KERN_DEBUG \"ippp_receive: is:%08lx lp:%08lx slot:%d unit:%d len:%d\\n\",\n\t\t       (long)is, (long)lp, lp->ppp_slot, is->unit, (int)skb->len);\n\t\tisdn_ppp_frame_log(\"receive\", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\n\t}\n\tif (isdn_ppp_skip_ac(is, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = isdn_ppp_strip_proto(skb);\n\tif (proto < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n#ifdef CONFIG_ISDN_MPP\n\tif (is->compflags & SC_LINK_DECOMP_ON) {\n\t\tskb = isdn_ppp_decompress(skb, is, NULL, &proto);\n\t\tif (!skb) \n\t\t\treturn;\n\t}\n\tif (!(is->mpppcfg & SC_REJ_MP_PROT)) { \n\t\tif (proto == PPP_MP) {\n\t\t\tisdn_ppp_mp_receive(net_dev, lp, skb);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\tisdn_ppp_push_higher(net_dev, lp, skb, proto);\n}", "target": 0}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, 255, output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>().cwiseMax(min_as_quantized).template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "static unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    !range_in_vma(svma, sbase, s_end))\n\t\treturn 0;\n\treturn saddr;\n}", "target": 0}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tret = key->type->instantiate(key, prep);\n\t\tif (ret == 0) {\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret;\n}", "target": 1}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "find_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\t} else if (oidc_is_discovery_response(r, c)) {\n\t\treturn oidc_handle_discovery_response(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\t\treturn oidc_handle_logout(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\t\treturn oidc_handle_jwks(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\t\treturn oidc_handle_session_management(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\t\treturn oidc_handle_request_uri(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n}", "target": 1}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 0}
{"code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n\t\t\tsockfd_put(csock);\n\t\t\treturn err;\n\t\t}\n\t\tca.name[sizeof(ca.name)-1] = 0;\n\t\terr = hidp_connection_add(&ca, csock, isock);\n\t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\t\treturn err;\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn hidp_connection_del(&cd);\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}", "target": 1}
{"code": "static void packet_flush_mclist(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml;\n\tif (!po->mclist)\n\t\treturn;\n\trtnl_lock();\n\twhile ((ml = po->mclist) != NULL) {\n\t\tstruct net_device *dev;\n\t\tpo->mclist = ml->next;\n\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\tif (dev != NULL)\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\tkfree(ml);\n\t}\n\trtnl_unlock();\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "AP_DECLARE(int) ap_update_vhost_from_headers_ex(request_rec *r, int require_match)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    int rc = HTTP_OK;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (!require_match && r->status != HTTP_OK)\n        return HTTP_OK;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            rc = update_server_from_aliases(r);\n        else\n            check_serverpath(r);\n    }\n    else if (require_match && r->hostname) { \n        rc = update_server_from_aliases(r);\n    }\n    return rc;\n}", "target": 0}
{"code": "void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tif (iface) {\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\tdev->mtu = local->mtu;\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n}", "target": 0}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context,\n                          const TfLiteEvalTensor* params,\n                          const TfLiteEvalTensor* indices,\n                          TfLiteEvalTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n      break;\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static int nft_inner_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_inner *priv = nft_expr_priv(expr);\n\tu32 flags, hdrsize, type, num;\n\tstruct nft_expr_info expr_info;\n\tint err;\n\tif (!tb[NFTA_INNER_FLAGS] ||\n\t    !tb[NFTA_INNER_NUM] ||\n\t    !tb[NFTA_INNER_HDRSIZE] ||\n\t    !tb[NFTA_INNER_TYPE] ||\n\t    !tb[NFTA_INNER_EXPR])\n\t\treturn -EINVAL;\n\tflags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));\n\tif (flags & ~NFT_INNER_MASK)\n\t\treturn -EOPNOTSUPP;\n\tnum = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));\n\tif (num != 0)\n\t\treturn -EOPNOTSUPP;\n\thdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));\n\ttype = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));\n\tif (type > U8_MAX)\n\t\treturn -EINVAL;\n\tif (flags & NFT_INNER_HDRSIZE) {\n\t\tif (hdrsize == 0 || hdrsize > 64)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->flags = flags;\n\tpriv->hdrsize = hdrsize;\n\tpriv->type = type;\n\terr = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);\n\tif (err < 0)\n\t\treturn err;\n\tpriv->expr.ops = expr_info.ops;\n\tif (!strcmp(expr_info.ops->type->name, \"payload\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_PAYLOAD;\n\telse if (!strcmp(expr_info.ops->type->name, \"meta\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_META;\n\telse\n\t\treturn -EINVAL;\n\terr = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,\n\t\t\t\t  (const struct nlattr * const*)expr_info.tb);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "xfs_lock_inodes(\n\tstruct xfs_inode\t**ips,\n\tint\t\t\tinodes,\n\tuint\t\t\tlock_mode)\n{\n\tint\t\t\tattempts = 0, i, j, try_lock;\n\tstruct xfs_log_item\t*lp;\n\tASSERT(ips && inodes >= 2 && inodes <= 5);\n\tASSERT(lock_mode & (XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL |\n\t\t\t    XFS_ILOCK_EXCL));\n\tASSERT(!(lock_mode & (XFS_IOLOCK_SHARED | XFS_MMAPLOCK_SHARED |\n\t\t\t      XFS_ILOCK_SHARED)));\n\tASSERT(!(lock_mode & XFS_MMAPLOCK_EXCL) ||\n\t\tinodes <= XFS_MMAPLOCK_MAX_SUBCLASS + 1);\n\tASSERT(!(lock_mode & XFS_ILOCK_EXCL) ||\n\t\tinodes <= XFS_ILOCK_MAX_SUBCLASS + 1);\n\tif (lock_mode & XFS_IOLOCK_EXCL) {\n\t\tASSERT(!(lock_mode & (XFS_MMAPLOCK_EXCL | XFS_ILOCK_EXCL)));\n\t} else if (lock_mode & XFS_MMAPLOCK_EXCL)\n\t\tASSERT(!(lock_mode & XFS_ILOCK_EXCL));\n\ttry_lock = 0;\n\ti = 0;\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\t\tif (i && (ips[i] == ips[i - 1]))\t\n\t\t\tcontinue;\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = &ips[j]->i_itemp->ili_item;\n\t\t\t\tif (lp && test_bit(XFS_LI_IN_AIL, &lp->li_flags))\n\t\t\t\t\ttry_lock++;\n\t\t\t}\n\t\t}\n\t\tif (!try_lock) {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(i != 0);\n\t\tif (xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i)))\n\t\t\tcontinue;\n\t\tattempts++;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tif (j != (i - 1) && ips[j] == ips[j + 1])\n\t\t\t\tcontinue;\n\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t}\n\t\tif ((attempts % 5) == 0) {\n\t\t\tdelay(1); \n\t\t}\n\t\ti = 0;\n\t\ttry_lock = 0;\n\t\tgoto again;\n\t}\n}", "target": 0}
{"code": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "static unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tstruct mnt_namespace *ns = p->m.private;\n\tunsigned res = 0;\n\tpoll_wait(file, &ns->poll, wait);\n\tspin_lock(&vfsmount_lock);\n\tif (p->event != ns->event) {\n\t\tp->event = ns->event;\n\t\tres = POLLERR;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\treturn res;\n}", "target": 0}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "int writeToFile(PlatformFileHandle handle, const char* data, int length)\n{\n    if (!isHandleValid(handle))\n        return -1;\n    DWORD bytesWritten;\n    bool success = WriteFile(handle, data, length, &bytesWritten, 0);\n    if (!success)\n        return -1;\n    return static_cast<int>(bytesWritten);\n}", "target": 0}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)\n{\n    int plenbytes;\n    char buf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128\")];\n    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&\n        is_ipv4_mapped_address(&prefix[1])) {\n        struct in_addr addr;\n        u_int plen;\n        plen = prefix[0]-96;\n        if (32 < plen)\n            return -1;\n        max_length -= 1;\n        memset(&addr, 0, sizeof(addr));\n        plenbytes = (plen + 7) / 8;\n        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)\n            return -3;\n        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);\n        if (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, sizeof(buf), \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n        plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;\n    } else {\n        plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));\n        if (plenbytes < 0)\n            return plenbytes;\n    }\n    ND_PRINT((ndo, \"%s\", buf));\n    return plenbytes;\n}", "target": 0}
{"code": "juniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n        ND_TCHECK(*gh);\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "soup_server_new (const char *optname1, ...)\n{\n\tSoupServer *server;\n\tva_list ap;\n\tva_start (ap, optname1);\n\tserver = (SoupServer *)g_object_new_valist (SOUP_TYPE_SERVER,\n\t\t\t\t\t\t    optname1, ap);\n\tva_end (ap);\n\treturn server;\n}", "target": 0}
{"code": "  Status FillCollectiveParams(CollectiveParams* col_params,\n                              CollectiveType collective_type,\n                              const Tensor& group_size, const Tensor& group_key,\n                              const Tensor& instance_key) {\n    if (group_size.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_size, got \",\n                              group_size.shape().DebugString());\n    }\n    if (group_key.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key.shape().DebugString());\n    }\n    if (instance_key.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input instance_key, got \",\n          instance_key.shape().DebugString());\n    }\n    col_params->name = name_;\n    col_params->group.device_type = device_type_;\n    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);\n    if (col_params->group.group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \",\n          col_params->group.group_size);\n    }\n    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);\n    col_params->instance.type = collective_type;\n    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);\n    col_params->instance.data_type = data_type_;\n    col_params->instance.impl_details.communication_hint = communication_hint_;\n    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;\n    return Status::OK();\n  }", "target": 1}
{"code": "static inline bool siphash_key_is_zero(const siphash_key_t *key)\n{\n\treturn !(key->key[0] | key->key[1]);\n}", "target": 0}
{"code": "static const char *sip_endpoint_identifier_type2str(enum ast_sip_endpoint_identifier_type method)\n{\n\tconst char *str = \"<unknown>\";\n\tswitch (method) {\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME:\n\t\tstr = \"username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME:\n\t\tstr = \"auth_username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_IP:\n\t\tstr = \"ip\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER:\n\t\tstr = \"header\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI:\n\t\tstr = \"request_uri\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT:\n\t\tstr = \"transport\";\n\t\tbreak;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "cib_remote_callback_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    int disconnected = 0;\n    crm_info(\"Message on callback channel\");\n    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    while (msg) {\n        const char *type = crm_element_value(msg, F_TYPE);\n        crm_trace(\"Activating %s callbacks...\", type);\n        if (safe_str_eq(type, T_CIB)) {\n            cib_native_callback(cib, msg, 0, 0);\n        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n        } else {\n            crm_err(\"Unknown message type: %s\", type);\n        }\n        free_xml(msg);\n        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    }\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,\n                                                              UncompressedComponents *const colldata) {\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;\n    BlockBasedImagePerChannel<false> image_data;\n    for (int i = 0; i < colldata->get_num_components(); ++i) {\n        component_size_in_blocks[i] = colldata->component_size_in_blocks(i);\n        image_data[i] = &colldata->full_component_write((BlockType)i);\n    }\n    Sirikata::Array1d<uint32_t,\n                      (size_t)ColorChannel::NumBlockTypes> max_coded_heights\n        = colldata->get_max_coded_heights();\n    dev_assert(luma_splits_.size() == 2); \n    always_assert(luma_splits_.size() >= 2);\n    int min_y = luma_splits_[0];\n    int max_y = luma_splits_[1];\n    while(true) {\n        RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);\n        if (cur_row.done) {\n            break;\n        }\n        if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) {\n            break;\n        }\n        if (cur_row.skip) {\n            continue;\n        }\n        if (cur_row.luma_y < min_y) {\n            continue;\n        }\n        decode_rowf(image_data,\n                   component_size_in_blocks,\n                   cur_row.component,\n                   cur_row.curr_y);\n        if (thread_id == 0) {\n            colldata->worker_update_cmp_progress((BlockType)cur_row.component,\n                                                 image_data[cur_row.component]->block_width() );\n        }\n        return CODING_PARTIAL;\n    }\n    return CODING_DONE;\n}", "target": 0}
{"code": "static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    if (ossock->ossl_ssl) {\n\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n    }\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n    ssl_close_sockets(ssock);\n    ERR_clear_error();\n}", "target": 0}
{"code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "target": 0}
{"code": "static void bson_append32_as_int( bson *b, int data ) {\n    bson_little_endian32( b->cur, &data );\n    b->cur += 4;\n}", "target": 0}
{"code": "static void spl_array_it_get_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC) \n{\n\tspl_array_it       *iterator = (spl_array_it *)iter;\n\tspl_array_object   *object   = iterator->object;\n\tHashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);\n\tif (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {\n\t\tzend_user_it_get_current_key(iter, key TSRMLS_CC);\n\t} else {\n\t\tif (spl_array_object_verify_pos_ex(object, aht, \"ArrayIterator::current(): \" TSRMLS_CC) == FAILURE) {\n\t\t\tZVAL_NULL(key);\n\t\t} else {\n\t\t\tzend_hash_get_current_key_zval_ex(aht, key, &object->pos);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\tspin_lock_irqsave(&m->lock, flags);\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n\tspin_unlock_irqrestore(&m->lock, flags);\n\tif (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n}", "target": 0}
{"code": "    size_t FileIo::write(BasicIo& src)\n    {\n        assert(p_->fp_ != 0);\n        if (static_cast<BasicIo*>(this) == &src) return 0;\n        if (!src.isopen()) return 0;\n        if (p_->switchMode(Impl::opWrite) != 0) return 0;\n        byte buf[4096];\n        size_t readCount = 0;\n        size_t writeTotal = 0;\n        while ((readCount = src.read(buf, sizeof(buf)))) {\n            const size_t writeCount = static_cast<long>(std::fwrite(buf, 1, static_cast<size_t>(readCount), p_->fp_));\n            writeTotal += writeCount;\n            if (writeCount != readCount) {\n                src.seek(writeCount-readCount, BasicIo::cur);\n                break;\n            }\n        }\n        return writeTotal;\n    }", "target": 0}
{"code": "static void dump_completed_IO(struct inode * inode)\n{\n#ifdef\tEXT4_DEBUG\n\tstruct list_head *cur, *before, *after;\n\text4_io_end_t *io, *io0, *io1;\n\tunsigned long flags;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n\t\treturn;\n\t}\n\text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n\t\tcur = &io->list;\n\t\tbefore = cur->prev;\n\t\tio0 = container_of(before, ext4_io_end_t, list);\n\t\tafter = cur->next;\n\t\tio1 = container_of(after, ext4_io_end_t, list);\n\t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n\t\t\t    io, inode->i_ino, io0, io1);\n\t}\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n#endif\n}", "target": 0}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == 1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 1}
{"code": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n    return njs_promise(&capability->promise);\n}", "target": 1}
{"code": "mailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n\t\t NULL);\n  clist_free(info->st_info_list);\n  free(info);\n}", "target": 1}
{"code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}", "target": 1}
{"code": "int bridge__remap_topic_in(struct mosquitto *context, char **topic)\n{\n\tstruct mosquitto__bridge_topic *cur_topic;\n\tchar *topic_temp;\n\tint i;\n\tsize_t len;\n\tint rc;\n\tbool match;\n\tif(context->bridge && context->bridge->topics && context->bridge->topic_remapping){\n\t\tfor(i=0; i<context->bridge->topic_count; i++){\n\t\t\tcur_topic = &context->bridge->topics[i];\n\t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_in)\n\t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n\t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->remote_topic, *topic, &match);\n\t\t\t\tif(rc){\n\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t*topic = NULL;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tif(match){\n\t\t\t\t\tif(cur_topic->remote_prefix){\n\t\t\t\t\t\tif(!strncmp(cur_topic->remote_prefix, *topic, strlen(cur_topic->remote_prefix))){\n\t\t\t\t\t\t\ttopic_temp = mosquitto__strdup((*topic)+strlen(cur_topic->remote_prefix));\n\t\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->local_prefix){\n\t\t\t\t\t\tlen = strlen(*topic) + strlen(cur_topic->local_prefix)+1;\n\t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->local_prefix, *topic);\n\t\t\t\t\t\ttopic_temp[len] = '\\0';\n\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\tpath->closed = (!isopen);\n\tpath->dummy = 0;\n\tPG_RETURN_PATH_P(path);\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "uipbuf_add_ext_hdr(int16_t len)\n{\n  if(len + uip_len <= UIP_LINK_MTU && len + uip_len >= 0 && len + uip_ext_len >= 0) {\n    uip_ext_len += len;\n    uip_len += len;\n    return true;\n  } else {\n    return false;\n  }\n}", "target": 0}
{"code": "  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }", "target": 1}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "\t\tAccessorRunner(ReferenceHandle& target, Local<Value> key_handle) :\n\t\tcontext{target.context},\n\t\ttarget{target.reference},\n\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)} {\n\t\t\ttarget.CheckDisposed();\n\t\t\tif (!key || (!key_handle->IsName() && !key_handle->IsUint32())) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t} else if (target.type_of != decltype(target.type_of)::Object) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not an object\");\n\t\t\t}\n\t\t}", "target": 0}
{"code": "max3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\tint rcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tint epnum = usb_endpoint_num(&urb->ep->desc);\n\t\tusb_settoggle(urb->dev, epnum, 0, rcvtog);\n\t\tusb_settoggle(urb->dev, epnum, 1, sndtog);\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "void sev_es_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ES_ENABLE;\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tsvm->vmcb->control.vmsa_pa = __pa(svm->vmsa);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tsvm_set_intercept(svm, TRAP_EFER_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR0_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR4_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR8_WRITE);\n\tclr_exception_intercept(svm, GP_VECTOR);\n\tsvm_clr_intercept(svm, INTERCEPT_XSETBV);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_EFER, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_CR_PAT, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "static inline int page_is_allowed(unsigned long pfn)\n{\n\treturn devmem_is_allowed(pfn);\n}", "target": 0}
{"code": "void WasmBinaryWriter::writeFunctionSignatures() {\n  if (importInfo->getNumDefinedFunctions() == 0) {\n    return;\n  }\n  BYN_TRACE(\"== writeFunctionSignatures\\n\");\n  auto start = startSection(BinaryConsts::Section::Function);\n  o << U32LEB(importInfo->getNumDefinedFunctions());\n  ModuleUtils::iterDefinedFunctions(*wasm, [&](Function* func) {\n    BYN_TRACE(\"write one\\n\");\n    o << U32LEB(getTypeIndex(func->type));\n  });\n  finishSection(start);\n}", "target": 0}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(nonce, bl);\n  }", "target": 1}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,\n    uint32_t append)\n{\n    uint32_t     free_before, free_after;\n    uint64_t     size;\n    njs_value_t  *start, *old;\n    njs_assert(array->object.fast_array);\n    free_before = array->start - array->data;\n    free_after = array->size - array->length - free_before;\n    if (njs_fast_path(free_before >= prepend && free_after >= append)) {\n        return NJS_OK;\n    }\n    size = (uint64_t) prepend + array->length + append;\n    if (size < 16) {\n        size *= 2;\n    } else {\n        size += size / 2;\n    }\n    if (njs_slow_path(size > (UINT32_MAX / sizeof(njs_value_t)))) {\n        goto memory_error;\n    }\n    start = njs_mp_align(vm->mem_pool, sizeof(njs_value_t),\n                         size * sizeof(njs_value_t));\n    if (njs_slow_path(start == NULL)) {\n        goto memory_error;\n    }\n    array->size = size;\n    old = array->data;\n    array->data = start;\n    start += prepend;\n    if (array->length != 0) {\n        memcpy(start, array->start, array->length * sizeof(njs_value_t));\n    }\n    array->start = start;\n    njs_mp_free(vm->mem_pool, old);\n    return NJS_OK;\nmemory_error:\n    njs_memory_error(vm);\n    return NJS_ERROR;\n}", "target": 0}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(\n          ctx, input_min_ <= input_max_,\n          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }", "target": 1}
{"code": "archive_read_format_cpio_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tssize_t bytes_read;\n\tstruct cpio *cpio;\n\tcpio = (struct cpio *)(a->format->data);\n\tif (cpio->entry_bytes_unconsumed) {\n\t\t__archive_read_consume(a, cpio->entry_bytes_unconsumed);\n\t\tcpio->entry_bytes_unconsumed = 0;\n\t}\n\tif (cpio->entry_bytes_remaining > 0) {\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (bytes_read <= 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (bytes_read > cpio->entry_bytes_remaining)\n\t\t\tbytes_read = (ssize_t)cpio->entry_bytes_remaining;\n\t\t*size = bytes_read;\n\t\tcpio->entry_bytes_unconsumed = bytes_read;\n\t\t*offset = cpio->entry_offset;\n\t\tcpio->entry_offset += bytes_read;\n\t\tcpio->entry_bytes_remaining -= bytes_read;\n\t\treturn (ARCHIVE_OK);\n\t} else {\n\t\tif (cpio->entry_padding !=\n\t\t\t__archive_read_consume(a, cpio->entry_padding)) {\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tcpio->entry_padding = 0;\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = cpio->entry_offset;\n\t\treturn (ARCHIVE_EOF);\n\t}\n}", "target": 0}
{"code": "void WasmBinaryBuilder::readDylink0(size_t payloadLen) {\n  BYN_TRACE(\"== readDylink0\\n\");\n  auto sectionPos = pos;\n  uint32_t lastType = 0;\n  wasm.dylinkSection = make_unique<DylinkSection>();\n  while (pos < sectionPos + payloadLen) {\n    auto oldPos = pos;\n    auto dylinkType = getU32LEB();\n    if (lastType && dylinkType <= lastType) {\n      std::cerr << \"warning: out-of-order dylink.0 subsection: \" << dylinkType\n                << std::endl;\n    }\n    lastType = dylinkType;\n    auto subsectionSize = getU32LEB();\n    auto subsectionPos = pos;\n    if (dylinkType == BinaryConsts::UserSections::Subsection::DylinkMemInfo) {\n      wasm.dylinkSection->memorySize = getU32LEB();\n      wasm.dylinkSection->memoryAlignment = getU32LEB();\n      wasm.dylinkSection->tableSize = getU32LEB();\n      wasm.dylinkSection->tableAlignment = getU32LEB();\n    } else if (dylinkType ==\n               BinaryConsts::UserSections::Subsection::DylinkNeeded) {\n      size_t numNeededDynlibs = getU32LEB();\n      for (size_t i = 0; i < numNeededDynlibs; ++i) {\n        wasm.dylinkSection->neededDynlibs.push_back(getInlineString());\n      }\n    } else {\n      pos = oldPos;\n      size_t remaining = (sectionPos + payloadLen) - pos;\n      auto tail = getByteView(remaining);\n      wasm.dylinkSection->tail = {tail.first, tail.second};\n      break;\n    }\n    if (pos != subsectionPos + subsectionSize) {\n      throwError(\"bad dylink.0 subsection position change\");\n    }\n  }\n}", "target": 0}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int i)\n{\n\tint j, glyph;\n\tunsigned short *t = translations[i];\n\tunsigned char *q;\n\tif (!p) return;\n\tq = p->inverse_translations[i];\n\tif (!q) {\n\t\tq = p->inverse_translations[i] = kmalloc(MAX_GLYPH, GFP_KERNEL);\n\t\tif (!q) return;\n\t}\n\tmemset(q, 0, MAX_GLYPH);\n\tfor (j = 0; j < E_TABSZ; j++) {\n\t\tglyph = conv_uni_to_pc(conp, t[j]);\n\t\tif (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {\n\t\t  \tq[glyph] = j;\n\t\t}\n\t}\n}", "target": 0}
{"code": "int crypto_scrypt(const uint8_t* password, size_t pwlen, const uint8_t* salt,\n                  size_t saltlen, uint64_t N, uint32_t r, uint32_t p,\n                  uint8_t* buf, size_t buflen) {\n  return crypto_pwhash_scryptsalsa208sha256_ll(password, pwlen, salt, saltlen,\n                                               N, r, p, buf, buflen);\n}", "target": 0}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n{\n    return bn2binpad(a, to, -1);\n}", "target": 0}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "bool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}", "target": 0}
{"code": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "jp2_box_t *jp2_box_create0()\n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}", "target": 0}
{"code": "void conn_close_all(void) {\n    int i;\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i] && conns[i]->state != conn_closed) {\n            conn_close(conns[i]);\n        }\n    }\n}", "target": 0}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "int smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\twork->response_sz = sz;\n\treturn 0;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static enum sctp_ierror sctp_process_unk_param(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\tif (NULL == *errp)\n\t\t\t*errp = sctp_make_op_error_fixed(asoc, chunk);\n\t\tif (*errp) {\n\t\t\tif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length))))\n\t\t\t\tsctp_addto_chunk_fixed(*errp,\n\t\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length)),\n\t\t\t\t\t\tparam.v);\n\t\t} else {\n\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,\n                                    uint64_t off, NvmeRequest *req)\n{\n    uint32_t nslist[1024];\n    uint32_t trans_len;\n    int i = 0;\n    uint32_t nsid;\n    if (off >= sizeof(nslist)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(nslist));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    memset(nslist, 0x0, sizeof(nslist));\n    trans_len = MIN(sizeof(nslist) - off, buf_len);\n    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=\n            NVME_CHANGED_NSID_SIZE) {\n        if (i == ARRAY_SIZE(nslist)) {\n            memset(nslist, 0x0, sizeof(nslist));\n            nslist[0] = 0xffffffff;\n            break;\n        }\n        nslist[i++] = nsid;\n        clear_bit(nsid, n->changed_nsids);\n    }\n    if (nslist[0] == 0xffffffff) {\n        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);\n    }\n    if (!rae) {\n        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);\n    }\n    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);\n}", "target": 0}
{"code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\thid_set_drvdata(hdev, priv);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}", "target": 0}
{"code": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n\t\tflush_rq->tag = -1;\n\t}\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\tfq->flush_running_idx ^= 1;\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->degree--;\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}", "target": 1}
{"code": "static inline void set_attr(map<string, bufferlist>& attrs, const char* key, const char* value)\n{\n  bufferlist bl;\n  encode(value,bl);\n  attrs.emplace(key, std::move(bl));\n}", "target": 0}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "ff_layout_encode_layoutreturn(struct xdr_stream *xdr,\n\t\tconst void *voidargs,\n\t\tconst struct nfs4_xdr_opaque_data *ff_opaque)\n{\n\tconst struct nfs4_layoutreturn_args *args = voidargs;\n\tstruct nfs4_flexfile_layoutreturn_args *ff_args = ff_opaque->data;\n\tstruct xdr_buf tmp_buf = {\n\t\t.head = {\n\t\t\t[0] = {\n\t\t\t\t.iov_base = page_address(ff_args->pages[0]),\n\t\t\t},\n\t\t},\n\t\t.buflen = PAGE_SIZE,\n\t};\n\tstruct xdr_stream tmp_xdr;\n\t__be32 *start;\n\tdprintk(\"%s: Begin\\n\", __func__);\n\txdr_init_encode(&tmp_xdr, &tmp_buf, NULL, NULL);\n\tff_layout_encode_ioerr(&tmp_xdr, args, ff_args);\n\tff_layout_encode_iostats_array(&tmp_xdr, args, ff_args);\n\tstart = xdr_reserve_space(xdr, 4);\n\t*start = cpu_to_be32(tmp_buf.len);\n\txdr_write_pages(xdr, ff_args->pages, 0, tmp_buf.len);\n\tdprintk(\"%s: Return\\n\", __func__);\n}", "target": 0}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 0}
{"code": "static void fio_signal_handler_setup(void) {\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n  memset(&act, 0, sizeof(act));\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}", "target": 1}
{"code": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int xgene_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n\tcancel_work_sync(&ctx->workq);\n\thwmon_device_unregister(ctx->hwmon_dev);\n\tkfifo_free(&ctx->async_msg_fifo);\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\treturn 0;\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    memset((char *)&sct, 0, sizeof(sct));\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\tif (upid == INT_MIN)\n\t\treturn -ESRCH;\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\treturn ret;\n}", "target": 0}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}", "target": 0}
{"code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->actual_length;\n\t}\n\tif (!(size > 0))\n\t\treturn 0;\n\tif (size > urb->transfer_buffer_length) {\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "bbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BB_INIT(to, from->alloc);\n  if (r != 0) {\n    xfree(to->p);\n    *rto = 0;\n    return r;\n  }\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}", "target": 0}
{"code": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}", "target": 0}
{"code": "static inline int nlmsg_parse(struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\treturn nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),\n\t\t\t nlmsg_attrlen(nlh, hdrlen), policy);\n}", "target": 0}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 1}
{"code": "void DoEmbedProfile(const char* ProfileFile)\n{\n    FILE* f;\n    size_t size, EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n        f = fopen(ProfileFile, \"rb\");\n        if (f == NULL) return;\n        size = cmsfilelength(f);\n        EmbedBuffer = (cmsUInt8Number*) malloc(size + 1);\n        EmbedLen = fread(EmbedBuffer, 1, size, f);\n        fclose(f);\n        EmbedBuffer[EmbedLen] = 0;\n        write_icc_profile (&Compressor, EmbedBuffer, EmbedLen);\n        free(EmbedBuffer);\n}", "target": 0}
{"code": "gimp_channel_new_from_buffer (GimpImage     *image,\n                              GeglBuffer    *buffer,\n                              const gchar   *name,\n                              const GimpRGB *color)\n{\n  GimpChannel *channel;\n  GeglBuffer  *dest;\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (GEGL_IS_BUFFER (buffer), NULL);\n  channel = gimp_channel_new (image,\n                              gegl_buffer_get_width  (buffer),\n                              gegl_buffer_get_height (buffer),\n                              name, color);\n  dest = gimp_drawable_get_buffer (GIMP_DRAWABLE (channel));\n  gimp_gegl_buffer_copy (buffer, NULL, GEGL_ABYSS_NONE, dest, NULL);\n  return channel;\n}", "target": 0}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                goto invalid;\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r')\n        goto invalid;\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n')\n        goto invalid;\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\ntrunc:\n    return (-2);\ninvalid:\n    return (-5);\n}", "target": 1}
{"code": "void lsetCommand(client *c) {\n    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_LIST)) return;\n    long index;\n    robj *value = c->argv[3];\n    if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))\n        return;\n    if (o->encoding == OBJ_ENCODING_QUICKLIST) {\n        quicklist *ql = o->ptr;\n        int replaced = quicklistReplaceAtIndex(ql, index,\n                                               value->ptr, sdslen(value->ptr));\n        if (!replaced) {\n            addReply(c,shared.outofrangeerr);\n        } else {\n            addReply(c,shared.ok);\n            signalModifiedKey(c,c->db,c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"lset\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    } else {\n        serverPanic(\"Unknown list encoding\");\n    }\n}", "target": 0}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "static void udf_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, udf_i_callback);\n}", "target": 0}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "xml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n    return NULL;\n}", "target": 0}
{"code": "lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)\n{\n  lt_dlhandle handle = 0;\n  assert (iface); \n  while ((handle = lt_dlhandle_iterate (iface, handle)))\n    {\n      lt_dlhandle cur = handle;\n      if (cur && cur->info.name && streq (cur->info.name, module_name))\n\tbreak;\n    }\n  return handle;\n}", "target": 0}
{"code": "TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\tcs_dst->state = cs_src->state;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "create_durable_v2_buf(struct cifs_open_parms *oparms)\n{\n\tstruct cifs_fid *pfid = oparms->fid;\n\tstruct create_durable_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->dcontext.Timeout = cpu_to_le32(oparms->tcon->handle_timeout);\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}", "target": 0}
{"code": "int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 3;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tunsigned long arg)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err;\n\tint nsems;\n\tstruct list_head tasks;\n\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\tval = arg >> 32;\n#else\n\tval = arg;\n#endif\n\tsma = sem_lock_check(ns, semid);\n\tif (IS_ERR(sma))\n\t\treturn PTR_ERR(sma);\n\tINIT_LIST_HEAD(&tasks);\n\tnsems = sma->sem_nsems;\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n\t\tgoto out_unlock;\n\terr = security_sem_semctl(sma, SETVAL);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = -EINVAL;\n\tif(semnum < 0 || semnum >= nsems)\n\t\tgoto out_unlock;\n\tcurr = &sma->sem_base[semnum];\n\terr = -ERANGE;\n\tif (val > SEMVMX || val < 0)\n\t\tgoto out_unlock;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\tcurr->semval = val;\n\tcurr->sempid = task_tgid_vnr(current);\n\tsma->sem_ctime = get_seconds();\n\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\terr = 0;\nout_unlock:\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\treturn err;\n}", "target": 1}
{"code": "void VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables) {\n  HuffmanTablesSegment *current, *next;\n  if (huffman_tables == NULL) return;\n  current = &huffman_tables->root;\n  next = current->next;\n  WebPSafeFree(current->start);\n  current->start = NULL;\n  current->next = NULL;\n  current = next;\n  while (current != NULL) {\n    next = current->next;\n    WebPSafeFree(current->start);\n    WebPSafeFree(current);\n    current = next;\n  }\n}", "target": 0}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\tcredssp_free(transport->credssp);\n\treturn TRUE;\n}", "target": 0}
{"code": "Status XlaOpKernelContext::ConstantInputAsShape(int index, TensorShape* shape,\n                                                xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  std::vector<int64_t> dims;\n  TF_RETURN_IF_ERROR(LiteralToInt64Vector(literal, &dims));\n  int64_t num_elements = 1;\n  for (auto i = dims.begin(); i != dims.end(); ++i) {\n    num_elements = MultiplyWithoutOverflow(num_elements, *i);\n    if (num_elements < 0)\n      return errors::InvalidArgument(\n          \"The total elements specified by orig_input_shape is too large.\",\n          \"Encountered overflow after multiplying\", *i,\n          \", result: \", num_elements);\n  }\n  *shape = TensorShape(dims);\n  return OkStatus();\n}", "target": 0}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "dump_dest_constraint_hop(const struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\tchar *fp;\n\tdebug_f(\"user %s hostname %s is_ca %d nkeys %u\",\n\t    dch->user == NULL ? \"(null)\" : dch->user,\n\t    dch->hostname == NULL ? \"(null)\" : dch->hostname,\n\t    dch->is_ca, dch->nkeys);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tfp = NULL;\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (fp = sshkey_fingerprint(dch->keys[i],\n\t\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug_f(\"key %u/%u: %s%s%s key_is_ca %d\", i, dch->nkeys,\n\t\t    dch->keys[i] == NULL ? \"\" : sshkey_ssh_name(dch->keys[i]),\n\t\t    dch->keys[i] == NULL ? \"\" : \" \",\n\t\t    dch->keys[i] == NULL ? \"none\" : fp,\n\t\t    dch->key_is_ca[i]);\n\t\tfree(fp);\n\t}\n}", "target": 0}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\ndone:\n    *_str = str;\n    return 0;\n}", "target": 0}
{"code": "static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\treturn max;\n}", "target": 1}
{"code": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\tmight_sleep();\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\tanon_vma_lock_write(anon_vma);\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\treturn 0;\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static struct rq *__migrate_task(struct rq *rq, struct task_struct *p, int dest_cpu)\n{\n\tif (unlikely(!cpu_active(dest_cpu)))\n\t\treturn rq;\n\tif (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))\n\t\treturn rq;\n\trq = move_queued_task(rq, p, dest_cpu);\n\treturn rq;\n}", "target": 0}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 0}
{"code": "static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tstruct inet6_protocol *ops;\n\tif (!(features & NETIF_F_V6_CSUM))\n\t\tfeatures &= ~NETIF_F_SG;\n\tif (unlikely(skb_shinfo(skb)->gso_type &\n\t\t     ~(SKB_GSO_UDP |\n\t\t       SKB_GSO_DODGY |\n\t\t       SKB_GSO_TCP_ECN |\n\t\t       SKB_GSO_TCPV6 |\n\t\t       0)))\n\t\tgoto out;\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\trcu_read_lock();\n\tops = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\tif (likely(ops && ops->gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->gso_segment(skb, features);\n\t}\n\trcu_read_unlock();\n\tif (unlikely(IS_ERR(segs)))\n\t\tgoto out;\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\tipv6h->payload_len = htons(skb->len - skb->mac_len -\n\t\t\t\t\t   sizeof(*ipv6h));\n\t}\nout:\n\treturn segs;\n}", "target": 0}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        if(q.slice().xSampling!=1 || q.slice().ySampling!=1)\n        {\n             THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << q.name() << \"\\\" channel in framebuffer \"\n\t\t\t\t\"are not 1\");\n        }\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n  _Data->_outputFrameBuffer=fr;\n}", "target": 0}
{"code": "static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\n{\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t) c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 0}
{"code": "int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)\n{\n    int result;\n    if (handle == NULL)\n    {\n        LogError(\"Failure: handle is invalid.\");\n        result = MU_FAILURE;\n    }\n    else if (enlargeSize == 0)\n    {\n        LogError(\"Failure: enlargeSize size is 0.\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b = (BUFFER*)handle;\n        unsigned char* temp = (unsigned char*)realloc(b->buffer, b->size + enlargeSize);\n        if (temp == NULL)\n        {\n            LogError(\"Failure: allocating temp buffer.\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            b->buffer = temp;\n            b->size += enlargeSize;\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "force_removal (Device *device,\n               ForceRemovalCompleteFunc callback,\n               gpointer user_data)\n{\n  if (device->priv->device_is_mounted && device->priv->device_mount_paths->len > 0)\n    {\n      gboolean remove_dir_on_unmount;\n      if (mount_file_has_device (device->priv->device_file, NULL, &remove_dir_on_unmount) ||\n          is_device_in_fstab (device, NULL))\n        {\n          g_print (\"**** NOTE: Force unmounting device %s\\n\", device->priv->device_file);\n          force_unmount (device, callback, user_data);\n          goto pending;\n        }\n    }\n  if (device->priv->id_usage != NULL && strcmp (device->priv->id_usage, \"crypto\") == 0)\n    {\n      GList *devices;\n      GList *l;\n      devices = daemon_local_get_all_devices (device->priv->daemon);\n      for (l = devices; l != NULL; l = l->next)\n        {\n          Device *d = DEVICE (l->data);\n          if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n              && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n            {\n              if (d->priv->dm_name != NULL && g_str_has_prefix (d->priv->dm_name, \"udisks-luks-uuid-\"))\n                {\n                  g_print (\"**** NOTE: Force luks teardown device %s (cleartext %s)\\n\",\n                           device->priv->device_file,\n                           d->priv->device_file);\n                  force_luks_teardown (device, d, callback, user_data);\n                  goto pending;\n                }\n            }\n        }\n    }\n  if (callback != NULL)\n    callback (device, TRUE, user_data);\n pending:\n  ;\n}", "target": 0}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "static int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}", "target": 0}
{"code": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}", "target": 0}
{"code": "sanitize (GPtrArray *array)\n{\n        int i;\n        GPtrArray *new;\n        g_debug (\"before sanitizing\");\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        print_configuration (array->pdata[i], \"before\");\n                }\n        }\n        for (i = 1; i < array->len; ++i) {\n                int j;\n                for (j = 0; j < i; ++j) {\n                        GnomeRRConfig *this = array->pdata[j];\n                        GnomeRRConfig *other = array->pdata[i];\n                        if (this && other && gnome_rr_config_equal (this, other)) {\n                                g_debug (\"removing duplicate configuration\");\n                                gnome_rr_config_free (this);\n                                array->pdata[j] = NULL;\n                                break;\n                        }\n                }\n        }\n        for (i = 0; i < array->len; ++i) {\n                GnomeRRConfig *config = array->pdata[i];\n                if (config) {\n                        gboolean all_off = TRUE;\n                        int j;\n                        for (j = 0; config->outputs[j] != NULL; ++j) {\n                                if (config->outputs[j]->on)\n                                        all_off = FALSE;\n                        }\n                        if (all_off) {\n                                gnome_rr_config_free (array->pdata[i]);\n                                array->pdata[i] = NULL;\n                        }\n                }\n        }\n        new = g_ptr_array_new ();\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        g_ptr_array_add (new, array->pdata[i]);\n                        print_configuration (array->pdata[i], \"Final\");\n                }\n        }\n        if (new->len > 0) {\n                g_ptr_array_add (new, NULL);\n        } else {\n                g_ptr_array_free (new, TRUE);\n                new = NULL;\n        }\n        g_ptr_array_free (array, TRUE);\n        return new;\n}", "target": 0}
{"code": "hphp_libxml_input_buffer(const char *URI, xmlCharEncoding enc) {\n  if (s_libxml_errors->m_entity_loader_disabled) {\n    return nullptr;\n  }\n  return __xmlParserInputBufferCreateFilename(URI, enc);\n}", "target": 0}
{"code": "void color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg->color_space = OPJ_CLRSPC_SRGB;\n}", "target": 1}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "void set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\tmmu_notifier_invalidate_range_start(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n\tmmu_notifier_invalidate_range_end(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n}", "target": 0}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "void SecurityManager::on_validation_failed(\n        const ParticipantProxyData& participant_data,\n        const SecurityException& exception) const\n{\n    if (participant_->security_attributes().allow_unauthenticated_participants)\n    {\n        participant_->pdp()->notifyAboveRemoteEndpoints(participant_data, false);\n    }\n    if (strlen(exception.what()) > 0)\n    {\n        EPROSIMA_LOG_ERROR(SECURITY_AUTHENTICATION, exception.what());\n    }\n    EPROSIMA_LOG_INFO(SECURITY, \"Authentication failed for participant \" <<\n            participant_data.m_guid);\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::UNAUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 0}
{"code": "static ut64 r_buf_read64le (RBuffer *buf, ut64 off) {\n\tut8 data[8] = {0};\n\tr_buf_read_at (buf, off, data, 8);\n\treturn r_read_le64 (data);\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}", "target": 0}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\treturn local;\n}", "target": 1}
{"code": "AP4_StszAtom::AP4_StszAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags)\n{\n    stream.ReadUI32(m_SampleSize);\n    stream.ReadUI32(m_SampleCount);\n    if (m_SampleSize == 0) { \n        if (m_SampleCount > (size-8)/4) {\n            m_SampleCount = 0;\n            return;\n        }\n        AP4_Cardinal sample_count = m_SampleCount;\n        m_Entries.SetItemCount(sample_count);\n        unsigned char* buffer = new unsigned char[sample_count*4];\n        AP4_Result result = stream.Read(buffer, sample_count*4);\n        if (AP4_FAILED(result)) {\n            delete[] buffer;\n            return;\n        }\n        for (unsigned int i=0; i<sample_count; i++) {\n            m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n        }\n        delete[] buffer;\n    }\n}", "target": 0}
{"code": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\trandom_ether_addr(dev->dev_addr);\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "    long XmpValue::size() const\n    {\n        std::ostringstream os;\n        write(os);\n        return static_cast<long>(os.str().size());\n    }", "target": 0}
{"code": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\tint try_retval;\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\tfreeaddrinfo(*addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\treturn out;\n}", "target": 1}
{"code": "int sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp) {\n\tsctp_addip_param_t *asconf_param;\n\tunion sctp_params param;\n\tint length, plen;\n\tparam.v = (sctp_paramhdr_t *) param_hdr;\n\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n\t\tlength = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tif (param.v > chunk_end - length ||\n\t\t    length < sizeof(sctp_paramhdr_t))\n\t\t\treturn 0;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n\t\t\t    sizeof(sctp_paramhdr_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tparam.v += WORD_ROUND(length);\n\t}\n\tif (param.v != chunk_end)\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  if (strlen(line) == 0)\n    return -1;\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 0}
{"code": "njs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n    value = scope[njs_scope_index_value(index)];\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n        *newval = *value;\n        value = newval;\n    }\n    scope[njs_scope_index_value(index)] = value;\n    return value;\n}", "target": 0}
{"code": "static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers++;\n        return hc->fd;\n    }\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n            sr->fd_is_fdt      = MK_TRUE;\n            return fd;\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\tatomic_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}", "target": 0}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int vhost_attach_cgroups(struct vhost_dev *dev)\n{\n\tstruct vhost_attach_cgroups_struct attach;\n\tattach.owner = current;\n\tvhost_work_init(&attach.work, vhost_attach_cgroups_work);\n\tvhost_work_queue(dev, &attach.work);\n\tvhost_work_flush(dev, &attach.work);\n\treturn attach.ret;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    const Index input_outer_dim_size = segment_ids.dimension(0);\n    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n    config = GetGpuLaunchConfig(data_size, d);\n    TF_CHECK_OK(\n        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n                        config.block_count, config.thread_per_block, 0,\n                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n                        num_segments, segment_ids.data(), data, output.data()));\n  }", "target": 1}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "void CxImage::Startup(uint32_t imagetype)\n{\n\tpDib = pSelection = pAlpha = NULL;\n\tppLayers = ppFrames = NULL;\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\n    info.dwType = imagetype;\n\tinfo.fQuality = 90.0f;\n\tinfo.nAlphaMax = 255;\n\tinfo.nBkgndIndex = -1;\n\tinfo.bEnabled = true;\n\tinfo.nJpegScale = 1;\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\n\tint16_t test = 1;\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg;\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 1}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n\t}\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 0}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "void *mempool_getbuffer(MemoryPoolHandle handle, size_t expected_buffer_size) {\n  int rc;\n  int bufs_to_allocate;\n  int bufs_that_can_be_allocated = 0;\n  struct memory_pool_element *pool_item = NULL;\n  struct mempool *pool = (struct mempool *)handle;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_getbuffer called for invalid \"\n      \"expected_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if (pool == NULL) {\n    return NULL;\n  }\n  if (pool->mempool_item_size != expected_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               expected_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return NULL;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if (pool->free_bufs_in_pool == 0) {\n    bufs_to_allocate = pool->expandable_size / pool->mempool_item_size;\n    bufs_that_can_be_allocated = pool_can_expand_by(pool);\n    if (bufs_that_can_be_allocated > 0) {\n      bufs_to_allocate = ((bufs_to_allocate > bufs_that_can_be_allocated)\n                              ? bufs_that_can_be_allocated\n                              : bufs_to_allocate);\n      rc = freelist_allocate(pool, bufs_to_allocate);\n      if (rc != 0) {\n        if ((pool->flags & ENABLE_LOCKING) != 0) {\n          pthread_mutex_unlock(&pool->lock);\n        }\n        return NULL;\n      }\n    } else {\n      if ((pool->flags & ENABLE_LOCKING) != 0) {\n        pthread_mutex_unlock(&pool->lock);\n      }\n      return NULL;\n    }\n  }\n  if (pool->free_list != NULL) {\n    pool_item = pool->free_list;\n    pool->free_list = pool_item->next;\n    pool_item->next = (struct memory_pool_element *)NULL;\n    pool->free_bufs_in_pool--;\n  }\n  if (pool_item) {\n    pool->number_of_bufs_shared++;\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return (void *)pool_item;\n}", "target": 0}
{"code": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tpreempt_disable();\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tlocal_flush_tlb();\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      const void *input_pointer = sgx_params->input;\n      uint64_t input_size = sgx_params->input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(input_pointer));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  const void *output_pointer = sgx_params->output;\n  uint64_t output_size = sgx_params->output_size;\n  if (!TrustedPrimitives::IsOutsideEnclave(output_pointer, output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(output_pointer, output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 0}
{"code": "file_fmtcheck(struct magic_set *ms, const char *desc, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %\" SIZE_T_FORMAT \"u: format `%s' does not match\"\n\t\t    \" with `%s'\", file, line, desc, def);\n\treturn ptr;\n}", "target": 0}
{"code": "nvkm_vmm_node_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_node_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "void *malloc(size_t size)\n{\n\tstruct free_arena_header *fp;\n\tstruct free_arena_header *pah;\n\tsize_t fsize;\n\tif (size == 0)\n\t\treturn NULL;\n\tif (size > PTRDIFF_MAX) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tsize = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;\n\tfor (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;\n\t     fp = fp->next_free) {\n\t\tif (fp->a.size >= size) {\n\t\t\treturn __malloc_from_block(fp, size);\n\t\t}\n\t}\n\tfsize = (size + MALLOC_CHUNK_MASK) & ~MALLOC_CHUNK_MASK;\n#if _KLIBC_MALLOC_USES_SBRK\n\tfp = (struct free_arena_header *)sbrk(fsize);\n#else\n\tfp = (struct free_arena_header *)\n\t    mmap(NULL, fsize, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#endif\n\tif (fp == (struct free_arena_header *)MAP_FAILED) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\t\n\t}\n\tfp->a.type = ARENA_TYPE_FREE;\n\tfp->a.size = fsize;\n\tfor (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;\n\t     pah = pah->a.prev) {\n\t\tif (pah < fp)\n\t\t\tbreak;\n\t}\n\tfp->a.next = pah->a.next;\n\tfp->a.prev = pah;\n\tpah->a.next = fp;\n\tfp->a.next->a.prev = fp;\n\tfp = __free_block(fp);\n\treturn __malloc_from_block(fp, size);\n}", "target": 0}
{"code": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}", "target": 0}
{"code": "string SummarizeArray<bool>(int64_t limit, int64_t num_elts,\n                            const TensorShape& tensor_shape, const char* data,\n                            const bool print_v2) {\n  if (data == nullptr) {\n    return strings::StrCat(\"\");  \n  }\n  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);\n  for (int64_t i = 0; i < num_elts; ++i)\n    mutable_data.get()[i] = data[i] ? 1 : 0;\n  bool* array = reinterpret_cast<bool*>(mutable_data.get());\n  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,\n                                      print_v2);\n}", "target": 0}
{"code": "ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n  bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));\n  const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                 ? options->serverNameOverride().value()\n                                                 : server_name_indication_;\n  if (!server_name_indication.empty()) {\n    const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n    RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  if (options && !options->verifySubjectAltNameListOverride().empty()) {\n    SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n  bool has_alpn_defined = !parsed_alpn_protocols_.empty();\n  if (options) {\n    has_alpn_defined |= parseAndSetAlpn(options->applicationProtocolListOverride(), *ssl_con);\n  }\n  if (options && !has_alpn_defined && !options->applicationProtocolFallback().empty()) {\n    parseAndSetAlpn(options->applicationProtocolFallback(), *ssl_con);\n  }\n  if (allow_renegotiation_) {\n    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);\n  }\n  SSL_set_enforce_rsa_key_usage(ssl_con.get(), enforce_rsa_key_usage_);\n  if (max_session_keys_ > 0) {\n    if (session_keys_single_use_) {\n      absl::WriterMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n        if (SSL_SESSION_should_be_single_use(session)) {\n          session_keys_.pop_front();\n        }\n      }\n    } else {\n      absl::ReaderMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n      }\n    }\n  }\n  return ssl_con;\n}", "target": 1}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "static long hugetlbfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tloff_t hpage_size = huge_page_size(h);\n\tloff_t hole_start, hole_end;\n\thole_start = round_up(offset, hpage_size);\n\thole_end = round_down(offset + len, hpage_size);\n\tif (hole_end > hole_start) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\ti_mmap_lock_write(mapping);\n\t\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\t\thugetlb_vmdelete_list(&mapping->i_mmap,\n\t\t\t\t\t\thole_start >> PAGE_SHIFT,\n\t\t\t\t\t\thole_end  >> PAGE_SHIFT);\n\t\ti_mmap_unlock_write(mapping);\n\t\tremove_inode_hugepages(inode, hole_start, hole_end);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TEST_F(TestSPIFFEValidator, TestGetTrustBundleStore) {\n  initialize();\n  auto cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/non_spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  validator().trustBundleStores().emplace(\"example.com\", X509StorePtr(X509_STORE_new()));\n  EXPECT_TRUE(validator().getTrustBundleStore(cert.get()));\n}", "target": 1}
{"code": "void SFS_ObjectMethodCall(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n\tSFS_AddString(parser, \"(\");\n\tSFS_Params(parser);\n\tSFS_AddString(parser, \")\");\n}", "target": 0}
{"code": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tint i;\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++)\n\t\tnew_data[i].seen = true;\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}", "target": 0}
{"code": "static int read_payload_length_info(struct LATMContext *ctx, GetBitContext *gb)\n{\n    uint8_t tmp;\n    if (ctx->frame_length_type == 0) {\n        int mux_slot_length = 0;\n        do {\n            tmp = get_bits(gb, 8);\n            mux_slot_length += tmp;\n        } while (tmp == 255);\n        return mux_slot_length;\n    } else if (ctx->frame_length_type == 1) {\n        return ctx->frame_length;\n    } else if (ctx->frame_length_type == 3 ||\n               ctx->frame_length_type == 5 ||\n               ctx->frame_length_type == 7) {\n        skip_bits(gb, 2);          \n    }\n    return 0;\n}", "target": 0}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "void BezierOval(double w, double h, char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-w,-w,h*BzK,-w*BzK,h,h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",w*BzK,h,w,h*BzK,w);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",w,-h*BzK,w*BzK,-h,-h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-w*BzK,-h,-w,-h*BzK,-w,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\tfp = skb->data;\n\tn = 1;\n\tname_len = fp[n++];\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\tmemcpy(name, fp+n, name_len); n+=name_len;\n\tname[name_len] = '\\0';\n\tattr_len = fp[n++];\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n\tattr[attr_len] = '\\0';\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}", "target": 0}
{"code": "static void sanitize_string(char *s, char *new) {\n\tsize_t i,j, l = strlen(s), ls=l;\n\tfor(i=0,j=0;i<ls;i++) {\n\t\tif(s[i] < ' ' || s[i] > 127) {\n\t\t\tsprintf(new + j, \"\\\\x%02x\", s[i] & 0xff);\n\t\t\tj  += 3;\n\t\t} else new[j] = s[i];\n\t\tj++;\n\t}\n\tnew[j] = 0;\n}", "target": 0}
{"code": "int smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_debug(SMB, \"request\\n\");\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\twork->tcon = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "decode_definite_short_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *bytes_obj = fp_read_object(self, length);\n    if (!bytes_obj)\n        return NULL;\n    const char *bytes = PyBytes_AS_STRING(bytes_obj);\n    PyObject *ret = PyUnicode_FromStringAndSize(bytes, length);\n    Py_DECREF(bytes_obj);\n    if (ret && string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "coolkey_find_matching_cert(sc_card_t *card, sc_cardctl_coolkey_object_t *in_obj, sc_cardctl_coolkey_object_t **cert_obj) {\n\tsc_cardctl_coolkey_find_object_t fobj;\n\tsc_cardctl_coolkey_attribute_t template[2];\n\tu8 obj_class[4];\n\tint r;\n\ttemplate[0].attribute_type = CKA_CLASS;\n\ttemplate[0].attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\ttemplate[0].attribute_length = sizeof(obj_class);\n\ttemplate[0].attribute_value = obj_class;\n\tulong2bebytes(obj_class, CKO_CERTIFICATE);\n\ttemplate[1].attribute_type = CKA_ID;\n\ttemplate[1].object = in_obj;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_GET_ATTRIBUTE, &template[1]);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\ttemplate[0].object = NULL; \n\ttemplate[1].object = NULL; \n\tfobj.type = SC_CARDCTL_COOLKEY_FIND_BY_TEMPLATE;\n\tfobj.obj = NULL;\n\tfobj.coolkey_template = &template[0];\n\tfobj.template_count=2;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_FIND_OBJECT, &fobj);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\t*cert_obj = fobj.obj;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "del_aubio_filterbank (aubio_filterbank_t * fb)\n{\n  del_fmat (fb->filters);\n  AUBIO_FREE (fb);\n}", "target": 0}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 0}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "static int segmented_write_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t       struct segmented_address addr,\n\t\t\t       void *data,\n\t\t\t       unsigned int size)\n{\n\tint rc;\n\tulong linear;\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast<CTCBeamSearchDecoderParams*>(node->user_data);\n  const int top_paths = option->top_paths;\n  TF_LITE_ENSURE(context, option->beam_width >= top_paths);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3 * top_paths + 1);\n  const TfLiteTensor* inputs = GetInput(context, node, kInputsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(inputs), 3);\n  TF_LITE_ENSURE_EQ(context, inputs->type, kTfLiteFloat32);\n  const int batch_size = SizeOfDimension(inputs, 1);\n  const TfLiteTensor* sequence_length =\n      GetInput(context, node, kSequenceLengthTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(sequence_length), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(sequence_length), batch_size);\n  TF_LITE_ENSURE_EQ(context, sequence_length->type, kTfLiteInt32);\n  for (int i = 0; i < top_paths; ++i) {\n    TfLiteTensor* indices = GetOutput(context, node, i);\n    SetTensorToDynamic(indices);\n    TfLiteTensor* values = GetOutput(context, node, i + top_paths);\n    SetTensorToDynamic(values);\n    TfLiteTensor* output_shape = GetOutput(context, node, i + 2 * top_paths);\n    SetTensorToDynamic(output_shape);\n  }\n  TfLiteTensor* log_probability_output =\n      GetOutput(context, node, top_paths * 3);\n  TfLiteIntArray* log_probability_output_shape_array = TfLiteIntArrayCreate(2);\n  log_probability_output_shape_array->data[0] = batch_size;\n  log_probability_output_shape_array->data[1] = top_paths;\n  return context->ResizeTensor(context, log_probability_output,\n                               log_probability_output_shape_array);\n}", "target": 1}
{"code": "xsltFreeKeyDef(xsltKeyDefPtr keyd) {\n    if (keyd == NULL)\n\treturn;\n    if (keyd->comp != NULL)\n\txmlXPathFreeCompExpr(keyd->comp);\n    if (keyd->usecomp != NULL)\n\txmlXPathFreeCompExpr(keyd->usecomp);\n    if (keyd->name != NULL)\n\txmlFree(keyd->name);\n    if (keyd->nameURI != NULL)\n\txmlFree(keyd->nameURI);\n    if (keyd->match != NULL)\n\txmlFree(keyd->match);\n    if (keyd->use != NULL)\n\txmlFree(keyd->use);\n    if (keyd->nsList != NULL)\n        xmlFree(keyd->nsList);\n    memset(keyd, -1, sizeof(xsltKeyDef));\n    xmlFree(keyd);\n}", "target": 0}
{"code": "int fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\t\tif (ret)\n\t\t\tret = -EINVAL;\n\t\tif (!ret && CONFIG_IS_ENABLED(FIT_SIGNATURE)) {\n\t\t\tret = fdt_check_no_at(fit, 0);\n\t\t\tif (ret) {\n\t\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n    filename = gdTestFilePath2(\"tiff\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n    fclose(fp);\n    free(filename);\n    return act_size;\n}", "target": 0}
{"code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\tBUG_ON(!send_ioctx);\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); \n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tif (ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx)) {\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\t\treturn false;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\t\treturn true;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int ras_putdata(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts)\n{\n\tint ret;\n\tswitch (hdr->type) {\n\tcase RAS_TYPE_STD:\n\t\tret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}", "target": 1}
{"code": "void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));\n    tTcpIpPacketParsingResult packetReview;\n    packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                               pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n                                               FALSE,\n                                               __FUNCTION__);\n    if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n    {\n        auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;\n        auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);\n        auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;\n        VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n        VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;\n        VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);\n        VHeader->gso_size = (USHORT)m_ParentNBL->MSS();\n        VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);\n        VHeader->csum_offset = TCP_CHECKSUM_OFFSET;\n    }\n}", "target": 0}
{"code": "ClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));\n}", "target": 0}
{"code": "void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])\n{\n  unsigned int i,j;\n  int16_t mask;\n#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)\n#error \"KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!\"\n#endif\n  for(i=0;i<KYBER_N/8;i++) {\n    for(j=0;j<8;j++) {\n      mask = -(int16_t)((msg[i] >> j)&1);\n      r->coeffs[8*i+j] = mask & ((KYBER_Q+1)/2);\n    }\n  }\n}", "target": 1}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}", "target": 0}
{"code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}", "target": 1}
{"code": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_file || vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}", "target": 1}
{"code": "static int file_exp(STANZA *s)\n{\n    BIGNUM *a = NULL, *e = NULL, *exp = NULL, *ret = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(e = getBN(s, \"E\"))\n            || !TEST_ptr(exp = getBN(s, \"Exp\"))\n            || !TEST_ptr(ret = BN_new()))\n        goto err;\n    if (!TEST_true(BN_exp(ret, a, e, ctx))\n            || !equalBN(\"A ^ E\", exp, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(e);\n    BN_free(exp);\n    BN_free(ret);\n    return st;\n}", "target": 0}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    if ((int)size < 0) return; \n    if (save + size < save) return; \n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 0}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "static void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\tcancel_delayed_work_sync(&bdi->input_current_limit_work);\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}", "target": 0}
{"code": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\tzend_string *filename;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tbuffer = zend_string_alloc(len, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}", "target": 1}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n\t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n\terror = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (error < 0)\n\t\treturn error;\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}", "target": 0}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "static int __init random_int_secret_init(void)\n{\n\tget_random_bytes(random_int_secret, sizeof(random_int_secret));\n\treturn 0;\n}", "target": 0}
{"code": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}", "target": 1}
{"code": "int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len,\n\t\t\t\tunsigned int __user *u_msg_prio,\n\t\t\t\tconst struct timespec __user *u_abs_timeout)\n{\n\tstruct audit_aux_data_mq_sendrecv *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (!audit_enabled)\n\t\treturn 0;\n\tif (likely(!context))\n\t\treturn 0;\n\tax = kmalloc(sizeof(*ax), GFP_ATOMIC);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tif (u_msg_prio != NULL) {\n\t\tif (get_user(ax->msg_prio, u_msg_prio)) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tax->msg_prio = 0;\n\tif (u_abs_timeout != NULL) {\n\t\tif (copy_from_user(&ax->abs_timeout, u_abs_timeout, sizeof(ax->abs_timeout))) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tmemset(&ax->abs_timeout, 0, sizeof(ax->abs_timeout));\n\tax->mqdes = mqdes;\n\tax->msg_len = msg_len;\n\tax->d.type = AUDIT_MQ_SENDRECV;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "static bool comp_add_to_data(zckCtx *zck, zckComp *comp, const char *src,\n                             size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n    if((comp->data_size > comp->data_size + src_size) ||\n       (src_size > comp->data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading data\");\n        return false;\n    }\n    comp->data = zrealloc(comp->data, comp->data_size + src_size);\n    if (!comp->data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to compressed buffer\",\n        (long long unsigned) src_size);\n    memcpy(comp->data + comp->data_size, src, src_size);\n    comp->data_size += src_size;\n    comp->data_loc += src_size;\n    return true;\n}", "target": 0}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "fs::path TranslatePath(const std::string& utf8_url_path) {\n#if (defined(_WIN32) || defined(_WIN64))\n  std::wstring url_path = Utf8To16(utf8_url_path);\n  std::vector<std::wstring> words;\n  boost::split(words, url_path, boost::is_any_of(L\"/\"),\n               boost::token_compress_on);\n#else\n  std::vector<std::string> words;\n  boost::split(words, utf8_url_path, boost::is_any_of(\"/\"),\n               boost::token_compress_on);\n#endif  \n  fs::path path;\n  for (auto& word : words) {\n#if (defined(_WIN32) || defined(_WIN64))\n    if (word == L\".\" || word == L\"..\") {\n#else\n    if (word == \".\" || word == \"..\") {\n#endif\n      continue;\n    }\n    fs::path p{ word };\n    if (!p.parent_path().empty()) {\n      continue;\n    }\n    path /= p;\n  }\n  return path;\n}\n}  ", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags,\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id = sp->so_owner_id.id;\n\tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}", "target": 1}
{"code": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n        default:\n        {\n        }\n        break;\n    }\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}", "target": 1}
{"code": "bool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n    d->updateStmtHandleState();\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n    r = SQLPrepare(d->hStmt,\n                    toSQLTCHAR(query).data(),\n                    (SQLINTEGER) query.length());\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "QStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n    QString joinedTableTypeString = tableType.join(u',');\n    r = SQLTables(hStmt,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   toSQLTCHAR(joinedTableTypeString).data(),\n                   joinedTableTypeString.length() );\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}", "target": 1}
{"code": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}", "target": 0}
{"code": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  \n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  \n    else {  \n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  \n      thread->twups = thread;  \n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        work++;\n        if (!iswhite(uv))  \n          markvalue(g, uv->v);  \n      }\n    }\n  }\n  return work;\n}", "target": 0}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "envoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 50s\n      type: STATIC\n      circuit_breakers:\n        thresholds:\n        - priority: DEFAULT\n          max_connections: 10000\n          max_pending_requests: 10000\n          max_requests: 10000\n          max_retries: 10000\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}", "target": 0}
{"code": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return stride_;\n    }\n    const TensorShape stride_shape = ctx->InputShape(2);\n    if (!TensorShapeUtils::IsVector(stride_shape)) {\n      return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                     stride_shape.DebugString());\n    }\n    if (stride_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> stride;\n    auto status = ctx->ConstantInputAsIntVector(2, &stride);\n    if (!status.ok()) {\n      return status;\n    }\n    return stride;\n  }", "target": 1}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n    if (numHardlinks > 1) {\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n    return rc;\n}", "target": 1}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "static void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}", "target": 0}
{"code": "static void _php_pgsql_notice_handler(void *resource_id, const char *message)\n{\n\tphp_pgsql_notice *notice;\n\tTSRMLS_FETCH();\n\tif (! PGG(ignore_notices)) {\n\t\tnotice = (php_pgsql_notice *)emalloc(sizeof(php_pgsql_notice));\n\t\tnotice->message = _php_pgsql_trim_message(message, (int *)&notice->len);\n\t\tif (PGG(log_notices)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%s\", notice->message);\n\t\t}\n\t\tzend_hash_index_update(&PGG(notices), (ulong)resource_id, (void **)&notice, sizeof(php_pgsql_notice *), NULL);\n\t}\n}", "target": 0}
{"code": "static int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static u32 gasp_specifier_id(__be32 *p)\n{\n\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n}", "target": 0}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteDepthwiseConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  int unused_output_height, unused_output_width;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      filter_height, filter_width, params->padding, &unused_output_height,\n      &unused_output_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int num_channels = filter->dims->data[kDepthwiseConvQuantizedDimension];\n    return tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift), num_channels);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "utf16le_mbc_to_code(const UChar* p, const UChar* end)\n{\n  OnigCodePoint code;\n  UChar c0 = *p;\n  UChar c1 = *(p+1);\n  if (UTF16_IS_SURROGATE_FIRST(c1)) {\n    if (end - p < 4) return 0;\n    code = ((((c1 - 0xd8) << 2) + ((c0  & 0xc0) >> 6) + 1) << 16)\n         + ((((c0 & 0x3f) << 2) + (p[3] - 0xdc)) << 8)\n         + p[2];\n  }\n  else {\n    code = c1 * 256 + p[0];\n  }\n  return code;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false , context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context->status().ok()) return;\n    const string& prefix_string = prefix.scalar<tstring>()();\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                       -1,  true,\n                       i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }", "target": 0}
{"code": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}", "target": 1}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}", "target": 1}
{"code": "static void seek_floppy(void)\n{\n\tint track;\n\tblind_seek = 0;\n\tdebug_dcl(DP->flags, \"calling disk change from %s\\n\", __func__);\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (DP->flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp();\n\t\tif (raw_cmd->track != DRS->track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\tdo_floppy = seek_interrupt;\n\toutput_byte(FD_SEEK);\n\toutput_byte(UNIT(current_drive));\n\tif (output_byte(track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}", "target": 0}
{"code": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\tpr_debug(\"Sending CC\\n\");\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\tskb_queue_tail(&local->tx_queue, skb);\n\terr = 0;\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\treturn err;\n}", "target": 0}
{"code": "void *js_touserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\tif (!strcmp(tag, v->u.object->u.user.tag))\n\t\t\treturn v->u.object->u.user.data;\n\tjs_typeerror(J, \"not a %s\", tag);\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "void SslSPIFFECertValidatorIntegrationTest::addStringMatcher(\n    const envoy::type::matcher::v3::StringMatcher& matcher) {\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n}", "target": 0}
{"code": "static void log_handler(uint32_t level, const char *msg, void *arg)\n{\n\tfprintf(stdout, msg, arg);\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\tif (!user_data)\n\t\treturn -1;\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\tiso_packet_size = BufferSize / NumberOfPackets;\n\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}", "target": 1}
{"code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 0}
{"code": "void sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\tif (!port)\n\t\treturn;\t\t  \n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\treturn;\n}", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}", "target": 1}
{"code": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn err;\n}", "target": 1}
{"code": "static void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    return;\n  }\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}", "target": 0}
{"code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}", "target": 0}
{"code": "MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "CACHE_BITMAP_V2_ORDER* copy_cache_bitmap_v2_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V2_ORDER* order)\n{\n\tCACHE_BITMAP_V2_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\tif (!dst || !order)\n\t\tgoto fail;\n\t*dst = *order;\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v2_order(context, dst);\n\treturn NULL;\n}", "target": 0}
{"code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 0}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 0}
{"code": "static int __init personal_pci_init(void)\n{\n\tif (machine_is_personal_server())\n\t\tpci_common_init(&personal_server_pci);\n\treturn 0;\n}", "target": 1}
{"code": "void ide_atapi_cmd(IDEState *s)\n{\n    uint8_t *buf;\n    buf = s->io_buffer;\n#ifdef DEBUG_IDE_ATAPI\n    {\n        int i;\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n            printf(\" %02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n    if (s->sense_key == UNIT_ATTENTION &&\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n        ide_atapi_cmd_check_status(s);\n        return;\n    }\n    if (!s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        s->cdrom_changed = 0;\n        s->sense_key = UNIT_ATTENTION;\n        s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n        return;\n    }\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n    {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        return;\n    }\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n        return;\n    }\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 0}
{"code": "set_cs_start(const char* line)\n{\n    static int cs_start_set = 0;\n    char *p, *q, *r;\n    if ((p = strstr(line, \"string currentfile\"))\n        && strstr(line, \"readstring\")) {\n        for (q = p; q != line && q[-1] != '/'; --q)\n            ;\n        if (q != line) {\n            for (r = q; r != p && !isspace((unsigned char) *r) && *r != '{'; ++r)\n                ;\n            if (cs_start_set)\n                free((char*) cs_start);\n            cs_start = p = malloc(r - q + 1);\n            memcpy(p, q, r - q);\n            p[r - q] = 0;\n            cs_start_set = 1;\n        }\n    }\n}", "target": 0}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n    curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n    curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->mounts = 0;\n\tnew_ns->pending_mounts = 0;\n\treturn new_ns;\n}", "target": 0}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n        c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n        if (c16->Curves[i] == NULL) {\n            for (j=0; j < i; j++) {\n                _cmsFree(ContextID, c16->Curves[j]);\n            }\n            _cmsFree(ContextID, c16->Curves);\n            _cmsFree(ContextID, c16);\n            return NULL;\n        }\n        if (nElements == 256) {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 0}
{"code": "static long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\tmemset(&buf, 0, sizeof(buf));\n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\tmutex_lock(&client->ioctl_mutex);\n\terr = handler->func(client, &buf);\n\tmutex_unlock(&client->ioctl_mutex);\n\tif (err >= 0) {\n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "void dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}", "target": 1}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn epir;\n}", "target": 0}
{"code": "static void *command_init(struct pci_dev *dev, int offset)\n{\n\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tint err;\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n\tif (err) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn cmd;\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static gpa_t FNAME(gva_to_gpa_nested)(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t      u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr_nested)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "static void hardware_enable(void *junk)\n{\n\traw_spin_lock(&kvm_lock);\n\thardware_enable_nolock(junk);\n\traw_spin_unlock(&kvm_lock);\n}", "target": 0}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "prepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "void lodepng_state_cleanup(LodePNGState* state)\n{\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}", "target": 0}
{"code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tsize_t size;\n\tmatrix = 0;\n\tif (numrows < 0 || numcols < 0) {\n\t\tgoto error;\n\t}\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\tgoto error;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = 0;\n\tif (!jas_safe_size_mul(numrows, numcols, &size)) {\n\t\tgoto error;\n\t}\n\tmatrix->datasize_ = size;\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\treturn matrix;\nerror:\n\tif (matrix) {\n\t\tjas_matrix_destroy(matrix);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void preproc_mount_mnt_dir(void) {\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); \n\t\telse {\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); \n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); \n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}", "target": 0}
{"code": "static long do_locks(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct flock64 kernel;\n\tstruct oabi_flock64 user;\n\tmm_segment_t fs;\n\tlong ret;\n\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t   sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.l_type\t= user.l_type;\n\tkernel.l_whence\t= user.l_whence;\n\tkernel.l_start\t= user.l_start;\n\tkernel.l_len\t= user.l_len;\n\tkernel.l_pid\t= user.l_pid;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n\tset_fs(fs);\n\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n\t\tuser.l_type\t= kernel.l_type;\n\t\tuser.l_whence\t= kernel.l_whence;\n\t\tuser.l_start\t= kernel.l_start;\n\t\tuser.l_len\t= kernel.l_len;\n\t\tuser.l_pid\t= kernel.l_pid;\n\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t &user, sizeof(user)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n            cursor += entryLen;\n        }\n    }\n}", "target": 1}
{"code": "static Jsi_RC SysRunMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsi_isMain(interp))\n        return SysRunModuleCmd(interp, args, _this, ret, funcPtr);\n    return JSI_OK;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "ecma_op_function_call_native (ecma_object_t *func_obj_p, \n                              ecma_value_t this_arg_value, \n                              const ecma_value_t *arguments_list_p, \n                              uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) func_obj_p;\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, native_function_p->realm_value);\n#endif \n  jerry_call_info_t call_info;\n  call_info.function = ecma_make_object_value (func_obj_p);\n  call_info.this_value = this_arg_value;\n  ecma_object_t *new_target_p = JERRY_CONTEXT (current_new_target_p);\n  call_info.new_target = (new_target_p == NULL) ? ECMA_VALUE_UNDEFINED : ecma_make_object_value (new_target_p);\n  JERRY_ASSERT (native_function_p->native_handler_cb != NULL);\n  ecma_value_t ret_value = native_function_p->native_handler_cb (&call_info, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (ecma_is_value_exception (ret_value)))\n  {\n    ecma_throw_exception (ret_value);\n    return ECMA_VALUE_ERROR;\n  }\n#if JERRY_DEBUGGER\n  JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n{\n\tint result = js_regexec(prog, string, sub, eflags);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\treturn result;\n}", "target": 0}
{"code": "vmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tu32 i, ring_idx;\n\tstruct Vmxnet3_RxDesc *rxd;\n\tif (!rq->rx_ring[0].base)\n\t\treturn;\n\tfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\n\t\tfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\t\tstruct Vmxnet3_RxDesc rxDesc;\n#endif\n\t\t\tvmxnet3_getRxDesc(rxd,\n\t\t\t\t&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\n\t\t\tif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t\t\trq->buf_info[ring_idx][i].skb) {\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t\t rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(rq->buf_info[ring_idx][i].skb);\n\t\t\t\trq->buf_info[ring_idx][i].skb = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\n\t\t\t\t\trq->buf_info[ring_idx][i].page) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t       rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tput_page(rq->buf_info[ring_idx][i].page);\n\t\t\t\trq->buf_info[ring_idx][i].page = NULL;\n\t\t\t}\n\t\t}\n\t\trq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[ring_idx].next2fill =\n\t\t\t\t\trq->rx_ring[ring_idx].next2comp = 0;\n\t}\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\trq->comp_ring.next2proc = 0;\n}", "target": 0}
{"code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); \n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); \n        if( pxNewQueue != NULL )\n        {\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); \n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif \n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n        return pxNewQueue;\n    }", "target": 0}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n}", "target": 1}
{"code": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\trose_start_t3timer(sk);\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}", "target": 0}
{"code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in6_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 0}
{"code": "BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}", "target": 0}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}", "target": 1}
{"code": "int mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; \n    int decode_all = (!limit && !offset);\n    s = luaL_checklstring(L,1,&len); \n    if (offset < 0 || limit < 0) \n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n    if (decode_all) limit = INT_MAX;\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n    if (!decode_all) {\n        int offset = len - c.left;\n        luaL_checkstack(L, 1, \"in function mp_unpack_full\");\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        lua_insert(L, 2);\n        cnt += 1; \n    }\n    return cnt;\n}", "target": 0}
{"code": "static inline void context_set_translation_type(struct context_entry *context,\n\t\t\t\t\t\tunsigned long value)\n{\n\tcontext->lo &= (((u64)-1) << 4) | 3;\n\tcontext->lo |= (value & 3) << 2;\n}", "target": 0}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "static int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\t\tif (quota == RUNTIME_INF)\n\t\t\tquota = parent_quota;\n\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\treturn -EINVAL;\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\treturn 0;\n}", "target": 0}
{"code": "makeDirTree(const string &path, const StaticString &mode, uid_t owner, gid_t group) {\n\tstruct stat buf;\n\tvector<string> paths;\n\tvector<string>::reverse_iterator rit;\n\tstring current = path;\n\tmode_t modeBits;\n\tint ret;\n\tif (stat(path.c_str(), &buf) == 0) {\n\t\treturn;\n\t}\n\tmodeBits = parseModeString(mode);\n\twhile (current != \"/\" && current != \".\" && getFileType(current) == FT_NONEXISTANT) {\n\t\tpaths.push_back(current);\n\t\tcurrent = extractDirName(current);\n\t}\n\tfor (rit = paths.rbegin(); rit != paths.rend(); rit++) {\n\t\tcurrent = *rit;\n\t\tdo {\n\t\t\tret = mkdir(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EEXIST) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint e = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot create directory '\" + current + \"'\",\n\t\t\t\t\te, current);\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tret = chmod(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = chown(current.c_str(), owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\tchar message[1024];\n\t\t\t\tint e = errno;\n\t\t\t\tsnprintf(message, sizeof(message) - 1,\n\t\t\t\t\t\"Cannot change the directory '%s' its UID to %lld and GID to %lld\",\n\t\t\t\t\tcurrent.c_str(), (long long) owner, (long long) group);\n\t\t\t\tmessage[sizeof(message) - 1] = '\\0';\n\t\t\t\tthrow FileSystemException(message, e, path);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int pdf_findobj(struct pdf_struct *pdf)\n{\n    const char *start, *q, *q2, *q3, *eof;\n    struct pdf_obj *obj;\n    off_t bytesleft;\n    unsigned genid, objid;\n    pdf->nobjs++;\n    pdf->objs = cli_realloc2(pdf->objs, sizeof(*pdf->objs)*pdf->nobjs);\n    if (!pdf->objs) {\n\tcli_warnmsg(\"cli_pdf: out of memory parsing objects (%u)\\n\", pdf->nobjs);\n\treturn -1;\n    }\n    obj = &pdf->objs[pdf->nobjs-1];\n    memset(obj, 0, sizeof(*obj));\n    start = pdf->map+pdf->offset;\n    bytesleft = pdf->size - pdf->offset;\n    q2 = cli_memstr(start, bytesleft, \" obj\", 4);\n    if (!q2)\n\treturn 0;\n    bytesleft -= q2 - start;\n    q = findNextNonWSBack(q2-1, start);\n    while (q > start && isdigit(*q)) { q--; }\n    genid = atoi(q);\n    q = findNextNonWSBack(q-1,start);\n    while (q > start && isdigit(*q)) { q--; }\n    objid = atoi(q);\n    obj->id = (objid << 8) | (genid&0xff);\n    obj->start = q2+4 - pdf->map;\n    obj->flags = 0;\n    bytesleft -= 4;\n    eof = pdf->map + pdf->size;\n    q = pdf->map + obj->start;\n    while (q < eof && bytesleft > 0) {\n\toff_t p_stream, p_endstream;\n\tq2 = pdf_nextobject(q, bytesleft);\n\tif (!q2)\n\t    return 0;\n\tbytesleft -= q2 - q;\n\tif (find_stream_bounds(q-1, q2-q, bytesleft + (q2-q), &p_stream, &p_endstream)) {\n\t    obj->flags |= 1 << OBJ_STREAM;\n\t    q2 = q-1 + p_endstream + 6;\n\t    bytesleft -= q2 - q + 1;\n\t} else if ((q3 = cli_memstr(q-1, q2-q+1, \"endobj\", 6))) {\n\t    q2 = q3 + 6;\n\t    pdf->offset = q2 - pdf->map;\n\t    return 1; \n\t} else {\n\t    q2++;\n\t}\n\tq = q2;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void init_timeout(void *arg)\n{\n\tint local_port = *(int *)arg;\n\tinfo(\"init_timeout: srv_init\\n\");\n\tsrv_init((uint16_t)local_port);\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "static const jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tconst jpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}", "target": 0}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 0}
{"code": "void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,\n                  const IndexType* index_data, int* output_dims,\n                  ParamType* output_data,\n                  const ParamType* expected_output_data) {\n  TfLiteIntArray* pdims = IntArrayFromInts(param_dims);\n  TfLiteIntArray* idims = IntArrayFromInts(index_dims);\n  TfLiteIntArray* odims = IntArrayFromInts(output_dims);\n  constexpr int inputs_size = 2;\n  constexpr int outputs_size = 1;\n  constexpr int tensors_size = inputs_size + outputs_size;\n  TfLiteTensor tensors[tensors_size] = {\n      CreateTensor(param_data, pdims),\n      CreateTensor(index_data, idims),\n      CreateTensor(output_data, odims),\n  };\n  int inputs_array_data[] = {2, 0, 1};\n  TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);\n  int outputs_array_data[] = {1, 2};\n  TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);\n  const TfLiteRegistration registration = Register_GATHER_ND();\n  micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,\n                             outputs_array, nullptr);\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());\n  TfLiteTensor* actual_output_tensor = &tensors[2];\n  TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;\n  const int output_size = ElementCount(*actual_output_dims);\n  for (int i = 0; i < output_size; ++i) {\n    TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);\n  }\n}", "target": 1}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "irc_server_get_prefix_char_for_mode (struct t_irc_server *server, char mode)\n{\n    const char *prefix_chars;\n    int index;\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        index = irc_server_get_prefix_mode_index (server, mode);\n        if (index >= 0)\n            return prefix_chars[index];\n    }\n    return ' ';\n}", "target": 0}
{"code": "TfLiteStatus SimpleOpEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = tflite::GetInput(context, node, 0);\n  const TfLiteTensor* input2 = tflite::GetInput(context, node, 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  *output_data = *(input1->data.i32) + *(input2->data.i32);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "  void readEOF() noexcept override {\n    LOG(INFO) << \"Got EOF\";\n    auto chain = IOBuf::create(0);\n    for (size_t i = 0; i < 1000 * 1000; i++) {\n      auto buf = IOBuf::create(10);\n      buf->append(10);\n      memset(buf->writableData(), 'x', 10);\n      chain->prependChain(std::move(buf));\n    }\n    socket_->writeChain(&writeCallback_, std::move(chain));\n  }", "target": 0}
{"code": "static inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 5,\n        errors::InvalidArgument(\"tensor_in must be 1-dimensional and 5 \"\n                                \"elements\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      output_shape.AddDim(shape_vec(i));\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> padding, out;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    LaunchAvgPooling3dGradOp<Device, T>::launch(\n        context, output_shape, out_backprop, window, stride, out, padding,\n        data_format_, output);\n  }", "target": 1}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelPacket\n      *magick_restrict q;\n    ssize_t\n      x;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}", "target": 0}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n}", "target": 0}
{"code": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                if (!lua_checkstack(lua, 1)) {\n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}", "target": 0}
{"code": "nfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_setaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\nout:\n\treturn status;\n}", "target": 0}
{"code": "dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 2 > length)\n            return -1;\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n        if (i + 2 + optlen > length)\n            return -1;\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n        i += 2 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t       void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\t*pout_len = in_len;\n\t\treturn 0;\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n\t\t\t\t      pout_len);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}", "target": 0}
{"code": "  void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,\n                            const Tensor& in1) override {\n    OP_REQUIRES(\n        ctx, in0.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in0.dims()));\n    OP_REQUIRES(\n        ctx, in1.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in1.dims()));\n  }", "target": 1}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tif (!kvp_transaction.active) {\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\tkvp_transaction.active = false;\n\tif (channel->onchannel_callback == NULL)\n\t\treturn;\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\tif (error) {\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n\tkvp_data->data.key_size = 2*(keylen + 1); \n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n\tkvp_data->data.value_size = 2*(valuelen + 1); \n\tkvp_data->data.value_type = REG_SZ; \n\ticmsghdrp->status = HV_S_OK;\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    const std::vector<int64> out_sizes = {batch, out_rows, out_cols, depth};\n    TensorShape out_shape(out_sizes);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n    functor::Dilation<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), stride_rows, stride_cols, rate_rows, rate_cols,\n        pad_top, pad_left, output->tensor<T, 4>());\n  }", "target": 0}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n    if (njs_slow_path(!array->object.fast_array)) {\n        return NJS_OK;\n    }\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n    length = array->length;\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n            prop->value = array->start[i];\n        }\n    }\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n    return NJS_OK;\n}", "target": 0}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "absl::StatusOr<tensorflow::Tensor> DecompressTensorFromProto(\n    const tensorflow::TensorProto& proto) {\n  if (!IsSupported(proto.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(proto.dtype()),\n        \" is not supported for decompression.\"));\n  }\n  if (proto.dtype() == tensorflow::DT_STRING) {\n    tensorflow::Tensor tensor;\n    REVERB_CHECK(tensor.FromProto(proto));\n    return tensor;\n  } else {\n    tensorflow::Tensor tensor(proto.dtype(),\n                              tensorflow::TensorShape(proto.tensor_shape()));\n    const auto& tensor_content = proto.tensor_content();\n    SnappyUncompressToString(tensor_content, tensor.tensor_data().size(),\n                             const_cast<char*>(tensor.tensor_data().data()));\n    return tensor;\n  }\n}", "target": 0}
{"code": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}", "target": 1}
{"code": "test_keys ( ELG_secret_key *sk, unsigned int nbits, int nodie )\n{\n  ELG_public_key pk;\n  gcry_mpi_t test = gcry_mpi_new ( 0 );\n  gcry_mpi_t out1_a = gcry_mpi_new ( nbits );\n  gcry_mpi_t out1_b = gcry_mpi_new ( nbits );\n  gcry_mpi_t out2 = gcry_mpi_new ( nbits );\n  int failed = 0;\n  pk.p = sk->p;\n  pk.g = sk->g;\n  pk.y = sk->y;\n  gcry_mpi_randomize ( test, nbits, GCRY_WEAK_RANDOM );\n  do_encrypt ( out1_a, out1_b, test, &pk );\n  decrypt ( out2, out1_a, out1_b, sk );\n  if ( mpi_cmp( test, out2 ) )\n    failed |= 1;\n  sign ( out1_a, out1_b, test, sk );\n  if ( !verify( out1_a, out1_b, test, &pk ) )\n    failed |= 2;\n  gcry_mpi_release ( test );\n  gcry_mpi_release ( out1_a );\n  gcry_mpi_release ( out1_b );\n  gcry_mpi_release ( out2 );\n  if (failed && !nodie)\n    log_fatal (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  if (failed && DBG_CIPHER)\n    log_debug (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  return failed;\n}", "target": 0}
{"code": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "get_authname(int type)\n{\n\tstatic char buf[1024];\n\tswitch (type) {\n\tcase SSH_CMSG_AUTH_PASSWORD:\n\t\treturn \"password\";\n\tcase SSH_CMSG_AUTH_RSA:\n\t\treturn \"rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS_RSA:\n\t\treturn \"rhosts-rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS:\n\t\treturn \"rhosts\";\n\tcase SSH_CMSG_AUTH_TIS:\n\tcase SSH_CMSG_AUTH_TIS_RESPONSE:\n\t\treturn \"challenge-response\";\n#if defined(KRB4) || defined(KRB5)\n\tcase SSH_CMSG_AUTH_KERBEROS:\n\t\treturn \"kerberos\";\n#endif\n\t}\n\tsnprintf(buf, sizeof buf, \"bad-auth-msg-%d\", type);\n\treturn buf;\n}", "target": 0}
{"code": "_pdfioDictRead(pdfio_file_t   *pdf,\t\n               pdfio_obj_t    *obj,\t\n               _pdfio_token_t *tb,\t\n               size_t         depth)\t\n{\n  pdfio_dict_t\t\t*dict;\t\t\n  char\t\t\tkey[256];\t\n  _pdfio_value_t\tvalue;\t\t\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    if (!strcmp(key, \">>\"))\n    {\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n  }\n  return (NULL);\n}", "target": 0}
{"code": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}", "target": 1}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": "static inline void skb_reserve(struct sk_buff *skb, int len)\n{\n\tskb->data += len;\n\tskb->tail += len;\n}", "target": 0}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "static int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}", "target": 1}
{"code": "  StringSanMatcher(int general_name_type, envoy::type::matcher::v3::StringMatcher matcher)\n      : general_name_type_(general_name_type), matcher_(matcher) {}", "target": 0}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "static DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) {\n\tut64 size = 0;\n\tchar *data = NULL;\n\tst64 read;\n\tDexString *string = NULL;\n\tread = rz_buf_uleb128(buf, &size);\n\tif (UT64_ADD_OVFCHK(size, 1)) {\n\t\treturn NULL;\n\t}\n\tdata = malloc(size + 1);\n\tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tdata[size] = 0;\n\tstring = RZ_NEW0(DexString);\n\tif (!string) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\t*pread = read;\n\tstring->size = size;\n\tstring->offset = offset;\n\tstring->data = data;\n\treturn string;\n}", "target": 0}
{"code": "ProcStoreNamedColor(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xStoreNamedColorReq);\n    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixWriteAccess);\n    if (rc == Success) {\n        xColorItem def;\n        if (OsLookupColor(pcmp->pScreen->myNum, (char *) &stuff[1],\n                          stuff->nbytes, &def.red, &def.green, &def.blue)) {\n            def.flags = stuff->flags;\n            def.pixel = stuff->pixel;\n            return StoreColors(pcmp, 1, &def, client);\n        }\n        return BadName;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "static void validate_set_si_mode(struct bnx2x *bp)\n{\n\tu8 func = BP_ABS_FUNC(bp);\n\tu32 val;\n\tval = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\tif (val != 0xffff) {\n\t\tbp->mf_mode = MULTI_FUNCTION_SI;\n\t\tbp->mf_config[BP_VN(bp)] =\n\t\t\tMF_CFG_RD(bp, func_mf_config[func].config);\n\t} else\n\t\tBNX2X_DEV_INFO(\"illegal MAC address for SI\\n\");\n}", "target": 0}
{"code": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tif (i > 15) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.AdjustTotalArcSize(&Arc);\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n  GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n  DataIO.UnpVolume=false;\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  AnySolidDataUnpackedWell=false;\n  ArcAnalyzed=false;\n  StartTime.SetCurrentTime();\n  LastCheckedSymlink.clear();\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                ALG_ID *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}", "target": 1}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "_PUBLIC_ char *fgets_slash(char *s2,int maxlen,XFILE *f)\n{\n  char *s=s2;\n  int len = 0;\n  int c;\n  bool start_of_line = true;\n  if (x_feof(f))\n    return(NULL);\n  if (maxlen <2) return(NULL);\n  if (!s2)\n    {\n      maxlen = MIN(maxlen,8);\n      s = (char *)malloc(maxlen);\n    }\n  if (!s) return(NULL);\n  *s = 0;\n  while (len < maxlen-1)\n    {\n      c = x_getc(f);\n      switch (c)\n\t{\n\tcase '\\r':\n\t  break;\n\tcase '\\n':\n\t  while (len > 0 && s[len-1] == ' ')\n\t    {\n\t      s[--len] = 0;\n\t    }\n\t  if (len > 0 && s[len-1] == '\\\\')\n\t    {\n\t      s[--len] = 0;\n\t      start_of_line = true;\n\t      break;\n\t    }\n\t  return(s);\n\tcase EOF:\n\t  if (len <= 0 && !s2) \n\t    SAFE_FREE(s);\n\t  return(len>0?s:NULL);\n\tcase ' ':\n\t  if (start_of_line)\n\t    break;\n\tdefault:\n\t  start_of_line = false;\n\t  s[len++] = c;\n\t  s[len] = 0;\n\t}\n      if (!s2 && len > maxlen-3)\n\t{\n\t  char *t;\n\t  maxlen *= 2;\n\t  t = realloc_p(s, char, maxlen);\n\t  if (!t) {\n\t    DEBUG(0,(\"fgets_slash: failed to expand buffer!\\n\"));\n\t    SAFE_FREE(s);\n\t    return(NULL);\n\t  } else s = t;\n\t}\n    }\n  return(s);\n}", "target": 0}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 0}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n    *len = encoded_pt_len;\n    **p = *len;\n    *p += 1;\n    memcpy(*p, encodedPoint, *len);\n    *len += 1;\n    OPENSSL_free(encodedPoint);\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}", "target": 1}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "void jas_deprecated(const char *s)\n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n}", "target": 0}
{"code": "void recovery_delete_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n    next_character();\n}", "target": 0}
{"code": "static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tif (mm->context.asce_limit == (1UL << 31))\n\t\tpgtable_pmd_page_dtor(virt_to_page(pgd));\n\tcrst_table_free(mm, (unsigned long *) pgd);\n}", "target": 0}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "finish_stop(int stop_count)\n{\n\tif (tracehook_notify_jctl(stop_count == 0, CLD_STOPPED)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, CLD_STOPPED);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tdo {\n\t\tschedule();\n\t} while (try_to_freeze());\n\tcurrent->exit_code = 0;\n}", "target": 0}
{"code": "static int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\nfree:\n\tkfree(table);\nout:\n\tmdev->sysctl = NULL;\n\treturn -ENOBUFS;\n}", "target": 0}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "static struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\tpacket_write(fd[1], request.buf, request.len);\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}", "target": 0}
{"code": "static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}", "target": 0}
{"code": "cmsSEQ* CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n)\n{\n    cmsSEQ* Seq;\n    cmsUInt32Number i;\n    if (n == 0) return NULL;\n    if (n > 255) return NULL;\n    Seq = (cmsSEQ*) _cmsMallocZero(ContextID, sizeof(cmsSEQ));\n    if (Seq == NULL) return NULL;\n    Seq -> ContextID = ContextID;\n    Seq -> seq      = (cmsPSEQDESC*) _cmsCalloc(ContextID, n, sizeof(cmsPSEQDESC));\n    Seq -> n        = n;\n    if (Seq -> seq == NULL) {\n        _cmsFree(ContextID, Seq);\n        return NULL;\n    }\n    for (i=0; i < n; i++) {\n        Seq -> seq[i].Manufacturer = NULL;\n        Seq -> seq[i].Model        = NULL;\n        Seq -> seq[i].Description  = NULL;\n    }\n    return Seq;\n}", "target": 0}
{"code": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\treturn new_port;\n}", "target": 1}
{"code": "get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "static void read_version(struct pbap_data *pbap, GObexApparam *apparam)\n{\n\tconst guint8 *data;\n\tuint8_t value[16];\n\tgsize len;\n\tif (!(pbap->supported_features & FOLDER_VERSION_FEATURE))\n\t\treturn;\n\tif (!g_obex_apparam_get_bytes(apparam, PRIMARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->primary, data, len)) {\n\t\tmemcpy(pbap->primary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"PrimaryCounter\");\n\t}\n\tif (!g_obex_apparam_get_bytes(apparam, SECONDARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->secondary, data, len)) {\n\t\tmemcpy(pbap->secondary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"SecondaryCounter\");\n\t}\n}", "target": 1}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "doIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; \n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; \n  default:\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n  }\n}", "target": 1}
{"code": "static int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); \n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}", "target": 0}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n{\n    int rc = 0;\n    int pollrc = 0;\n    time_t start = time(NULL);\n    gnutls_session *session = session_data;\n    do {\n        rc = gnutls_handshake(*session);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n            if (pollrc < 0) {\n                rc = -1;\n            }\n        }\n    } while (((time(NULL) - start) < (timeout_ms/1000)) &&\n            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n    return rc;\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "gvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n  g_file_replace_contents_async (file, str->str, str->len,\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}", "target": 1}
{"code": "resolve_op_end (FlatpakTransaction *self,\n                FlatpakTransactionOperation *op,\n                const char *checksum,\n                GFile *sideload_path,\n                GBytes *metadata_bytes)\n{\n  g_autoptr(GBytes) old_metadata_bytes = NULL;\n  old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL);\n  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n  emit_eol_and_maybe_skip (self, op);\n }", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\temit(J, F, OP_ENDTRY);\n\t\tL3 = emitjump(J, F, OP_JUMP); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 0}
{"code": "static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n    switch(algorithm) {\n    case TPM_ALG_SHA1:\n        return EVP_sha1();\n    case ALG_SHA256_VALUE:\n        return EVP_sha256();\n    case TPM_ALG_SHA384:\n        return EVP_sha384();\n    case TPM_ALG_SHA512:\n        return EVP_sha512();\n    default:\n        return NULL;\n    }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(context, grad_in.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected grad shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "static void opt_kfree_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_options_rcu, rcu));\n}", "target": 0}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "int tls_free_buffers(OSSL_RECORD_LAYER *rl)\n{\n    if (rl->direction == OSSL_RECORD_DIRECTION_WRITE) {\n        if (rl->nextwbuf < rl->numwpipes) {\n            if (rl->nextwbuf != 0\n                    || rl->numwpipes != 1\n                    || TLS_BUFFER_get_left(&rl->wbuf[0]) != 0)\n                return 0;\n        }\n        tls_release_write_buffer(rl);\n        return 1;\n    }\n    if (rl->curr_rec < rl->num_recs || TLS_BUFFER_get_left(&rl->rbuf) != 0)\n        return 0;\n    return tls_release_read_buffer(rl);\n}", "target": 1}
{"code": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\n}", "target": 1}
{"code": "  static Status Compute(OpKernelContext* context,\n                        const typename TTypes<T, 1>::ConstTensor& values,\n                        const typename TTypes<T, 1>::ConstTensor& value_range,\n                        int32_t nbins, typename TTypes<Tout, 1>::Tensor& out) {\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    Tensor index_to_bin_tensor;\n    TF_RETURN_IF_ERROR(context->forward_input_or_allocate_temp(\n        {0}, DataTypeToEnum<int32>::value, TensorShape({values.size()}),\n        &index_to_bin_tensor));\n    auto index_to_bin = index_to_bin_tensor.flat<int32>();\n    const double step = static_cast<double>(value_range(1) - value_range(0)) /\n                        static_cast<double>(nbins);\n    const double nbins_minus_1 = static_cast<double>(nbins - 1);\n    const Eigen::Tensor<int32, 1, 1> nans_tensor =\n        values.isnan().template cast<int32>();\n    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();\n    const int num_nans = reduced_tensor(0);\n    if (num_nans > 0) {\n      return errors::InvalidArgument(\"Histogram values must not contain NaN\");\n    }\n    index_to_bin.device(d) =\n        ((values.cwiseMax(value_range(0)) - values.constant(value_range(0)))\n             .template cast<double>() /\n         step)\n            .cwiseMin(nbins_minus_1)\n            .template cast<int32>();\n    out.setZero();\n    for (int32_t i = 0; i < index_to_bin.size(); i++) {\n      out(index_to_bin(i)) += Tout(1);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "relax_ng_parse(const char *path, xml_read_cb cb, void *arg)\n{\n\txmlTextReaderPtr reader;\n\txmlRelaxNGValidCtxtPtr rngvalidctx;\n\tint read;\n\tint error;\n\treader = xmlNewTextReaderFilename(path);\n\tif (reader == NULL)\n\t\treturn pr_val_err(\"Couldn't get XML '%s' file.\", path);\n\terror = xmlTextReaderRelaxNGSetSchema(reader, schema);\n\tif (error) {\n\t\terror = pr_val_err(\"Couldn't set Relax NG schema.\");\n\t\tgoto free_reader;\n\t}\n\trngvalidctx = xmlRelaxNGNewValidCtxt(schema);\n\tif (rngvalidctx == NULL) {\n\t\terror = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");\n\t\tgoto free_reader;\n\t}\n\txmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,\n\t    relax_ng_log_warn, NULL);\n\terror = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);\n\tif (error) {\n\t\terror = pr_val_err(\"Invalid XML document\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,\n\t    NULL);\n\twhile ((read = xmlTextReaderRead(reader)) == 1) {\n\t\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\t\tgoto free_valid_ctx;\n\t\t}\n\t\terror = cb(reader, arg);\n\t\tif (error)\n\t\t\tgoto free_valid_ctx;\n\t}\n\tif (read < 0) {\n\t\terror = pr_val_err(\"Error parsing XML document.\");\n\t\tgoto free_valid_ctx;\n\t}\n\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\n\txmlFreeTextReader(reader);\n\treturn 0;\nfree_valid_ctx:\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\nfree_reader:\n\txmlFreeTextReader(reader);\n\treturn error;\n}", "target": 1}
{"code": "static int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}", "target": 0}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n#endif\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n out:\n\treturn err;\n}", "target": 1}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn 1;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tfreewbmp(wbmp);\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t\treturn 1;\n\t}\n\tfreewbmp(wbmp);\n\treturn 0;\n}", "target": 0}
{"code": "static uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\tif (nbytes > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn NULL;\n\t}\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\tnew_header->raw_data_len = new_raw_len;\n\treturn result;\n}", "target": 0}
{"code": "static char *tls_text_name(X509_NAME *name, int nid)\n{\n\tint     pos;\n\tX509_NAME_ENTRY *entry;\n\tASN1_STRING *entry_str;\n\tint     utf8_length;\n\tunsigned char *utf8_value;\n\tchar *result;\n\tif (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {\n\t\treturn NULL;\n    }\n    entry = X509_NAME_get_entry(name, pos);\n    g_return_val_if_fail(entry != NULL, NULL);\n    entry_str = X509_NAME_ENTRY_get_data(entry);\n    g_return_val_if_fail(entry_str != NULL, NULL);\n    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {\n    \tg_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));\n    \treturn NULL;\n    }\n    if (has_internal_nul((char *)utf8_value, utf8_length)) {\n    \tg_warning(\"NUL character in hostname in certificate\");\n    \tOPENSSL_free(utf8_value);\n    \treturn NULL;\n    }\n    result = g_strdup((char *) utf8_value);\n\tOPENSSL_free(utf8_value);\n\treturn result;\n}", "target": 0}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "static inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tpmd_clear(pmdp);\n\treturn pmd;\n}", "target": 0}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "static void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    MOVAtom fake_atom = { .size = size };\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}", "target": 0}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "void set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::createCombined(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t requiredStorage = offsetof(HeapFullStorage, align) + capacity;\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  auto storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix) HeapPrefix(kIOBufInUse | kDataInUse, mallocSize);\n  new (&storage->shared) SharedInfo(freeInternalBuf, storage);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n  }\n  auto bufAddr = reinterpret_cast<uint8_t*>(&storage->align);\n  uint8_t* storageEnd = reinterpret_cast<uint8_t*>(storage) + mallocSize;\n  auto actualCapacity = size_t(storageEnd - bufAddr);\n  unique_ptr<IOBuf> ret(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      bufAddr,\n      actualCapacity,\n      bufAddr,\n      0));\n  return ret;\n}", "target": 0}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 0}
{"code": "init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "target": 0}
{"code": "TfLiteStatus ReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  ReluOpData* data = static_cast<ReluOpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteInt8) {\n    CalculateReluOpData<int8_t>(input, output, data);\n  } else if (input->type == kTfLiteUInt8) {\n    CalculateReluOpData<uint8_t>(input, output, data);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tif (!lower_file->f_op->mmap)\n\t\treturn -ENODEV;\n\treturn generic_file_mmap(file, vma);\n}", "target": 0}
{"code": "void* IOBuf::operator new(size_t size) {\n  if (size > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t fullSize = offsetof(HeapStorage, buf) + size;\n  auto storage = static_cast<HeapStorage*>(checkedMalloc(fullSize));\n  new (&storage->prefix) HeapPrefix(kIOBufInUse, fullSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, fullSize);\n  }\n  return &(storage->buf);\n}", "target": 0}
{"code": "static void addrconf_ip6_tnl_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"init ip6-ip6: add_dev failed\\n\");\n\t\treturn;\n\t}\n\tip6_tnl_add_linklocal(idev);\n}", "target": 0}
{"code": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}", "target": 1}
{"code": "hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->clear ();\n}", "target": 1}
{"code": "addnode(struct env *env, const char *key, const char *value)\n{\n\tstruct envnode *node;\n\tnode = createnode(key, value);\n\tRB_INSERT(envtree, &env->root, node);\n\tenv->count++;\n}", "target": 0}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\tif (gid_eq(root_gid, current_gid())) {\n\t\tint mode = (table->mode >> 3) & 7;\n\t\treturn (mode << 3) | mode;\n\t}\n\treturn table->mode;\n}", "target": 1}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\treturn gdImageCrop(im, &crop);\n}", "target": 0}
{"code": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}", "target": 0}
{"code": "static int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "static void dp8393x_instance_init(Object *obj)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n    dp8393xState *s = DP8393X(obj);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_mmio(sbd, &s->prom);\n    sysbus_init_irq(sbd, &s->irq);\n}", "target": 0}
{"code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\tif (!ss_initialized) {\n\t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}", "target": 0}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "  add_authorized_client(const std::string &name, std::string &&cert) {\n    client_t &client = client_root;\n    named_cert_t named_cert;\n    named_cert.name = name;\n    named_cert.cert = std::move(cert);\n    named_cert.uuid = uuid_util::uuid_t::generate().string();\n    client.named_devices.emplace_back(named_cert);\n    if (!config::sunshine.flags[config::flag::FRESH_STATE]) {\n      save_state();\n    }\n  }", "target": 0}
{"code": "cdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}", "target": 0}
{"code": "static inline __u32 skb_get_rxhash(struct sk_buff *skb)\n{\n\tif (!skb->l4_rxhash)\n\t\t__skb_get_rxhash(skb);\n\treturn skb->rxhash;\n}", "target": 0}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip_lock);\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "std::string sanitizeNameForWindowList(const std::string& name) {\n    std::string result = name;\n    if (result[0] == '\\\"')\n        result[0] = ' ';\n    for (size_t i = 1; i < result.size(); ++i) {\n        if (result[i - 1] == '>' && result[i] == ']')\n            result[i] = ' ';\n        if (result[i] == '\\\"')\n            result[i] = ' ';\n    }\n    return result;\n}", "target": 1}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn 0;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read byte 32768. Assuming open disc. Skipping validity check\\n\");\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\tsbi->s_anchor = uopt->anchor;\n\tif (!udf_find_anchor(sb, fileset)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static uint8_t search_next_ip(void)\n{       \n\tuint8_t range_count, offset_count;\n\tuint8_t start, end;\n\tuint8_t max_count;\n\tif(dhcps_addr_pool_set){\n#if LWIP_VERSION_MAJOR >= 2\n\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n#else\n\t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n\t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n#endif\n\t}else{\n\t\tstart = 0;\n\t\tend = 255;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor (range_count = 0; range_count < (max_count = 8); range_count++) {\n\t\tfor (offset_count = 0;offset_count < 32; offset_count++) {\n\t\t\tif ((((ip_table.ip_range[range_count] >> offset_count) & 0x01) == 0) \n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) >= start)\n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) <= end)) {\n\t\t\t\txSemaphoreGive(dhcps_ip_table_semaphore); \n\t\t\t\treturn ((range_count * 32) + (offset_count + 1));\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore); \n\treturn 0;\n}", "target": 0}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "g_file_set_contents_full(const gchar *filename,\n\t\t\t const gchar *contents,\n\t\t\t gssize length,\n\t\t\t GFileSetContentsFlags flags,\n\t\t\t int mode,\n\t\t\t GError **error)\n{\n\tgint fd;\n\tgssize wrote;\n\tif (length < 0)\n\t\tlength = strlen(contents);\n\tfd = g_open(filename, O_CREAT, mode);\n\tif (fd <= 0) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"could not open %s file\",\n\t\t\t    filename);\n\t\treturn FALSE;\n\t}\n\twrote = write(fd, contents, length);\n\tif (wrote != length) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"did not write %s file\",\n\t\t\t    filename);\n\t\tg_close(fd, NULL);\n\t\treturn FALSE;\n\t}\n\treturn g_close(fd, error);\n}", "target": 0}
{"code": "_PUBLIC_ char **file_lines_load(const char *fname, int *numlines, size_t maxsize, TALLOC_CTX *mem_ctx)\n{\n\tchar *p;\n\tsize_t size;\n\tp = file_load(fname, &size, maxsize, mem_ctx);\n\tif (!p) return NULL;\n\treturn file_lines_parse(p, size, numlines, mem_ctx);\n}", "target": 0}
{"code": "hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n{\n\tHStore\t   *hs = PG_GETARG_HS(0);\n\tHEntry\t   *entries = ARRPTR(hs);\n\tchar\t   *ptr = STRPTR(hs);\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);\n\tHStore\t   *out;\n\tint\t\t\tnkeys;\n\tPairs\t   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);\n\tPairs\t   *out_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\tlastidx = 0;\n\tint\t\t\ti;\n\tint\t\t\tout_count = 0;\n\tif (nkeys == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tout_pairs = palloc(sizeof(Pairs) * nkeys);\n\tbufsiz = 0;\n\tfor (i = 0; i < nkeys; ++i)\n\t{\n\t\tint\t\t\tidx = hstoreFindKey(hs, &lastidx,\n\t\t\t\t\t\t\t\t\t  key_pairs[i].key, key_pairs[i].keylen);\n\t\tif (idx >= 0)\n\t\t{\n\t\t\tout_pairs[out_count].key = key_pairs[i].key;\n\t\t\tbufsiz += (out_pairs[out_count].keylen = key_pairs[i].keylen);\n\t\t\tout_pairs[out_count].val = HS_VAL(entries, ptr, idx);\n\t\t\tbufsiz += (out_pairs[out_count].vallen = HS_VALLEN(entries, idx));\n\t\t\tout_pairs[out_count].isnull = HS_VALISNULL(entries, idx);\n\t\t\tout_pairs[out_count].needfree = false;\n\t\t\t++out_count;\n\t\t}\n\t}\n\tout = hstorePairs(out_pairs, out_count, bufsiz);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "static int fetch_objects(struct repository *repo,\n\t\t\t const char *remote_name,\n\t\t\t const struct object_id *oids,\n\t\t\t int oid_nr)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tint i;\n\tFILE *child_in;\n\tif (git_env_bool(\"GIT_NO_LAZY_FETCH\", 0)) {\n\t\tstatic int warning_shown;\n\t\tif (!warning_shown) {\n\t\t\twarning_shown = 1;\n\t\t\twarning(_(\"lazy fetching disabled; some objects may not be available\"));\n\t\t}\n\t\treturn -1;\n\t}\n\tchild.git_cmd = 1;\n\tchild.in = -1;\n\tif (repo != the_repository)\n\t\tprepare_other_repo_env(&child.env, repo->gitdir);\n\tstrvec_pushl(&child.args, \"-c\", \"fetch.negotiationAlgorithm=noop\",\n\t\t     \"fetch\", remote_name, \"--no-tags\",\n\t\t     \"--no-write-fetch-head\", \"--recurse-submodules=no\",\n\t\t     \"--filter=blob:none\", \"--stdin\", NULL);\n\tif (start_command(&child))\n\t\tdie(_(\"promisor-remote: unable to fork off fetch subprocess\"));\n\tchild_in = xfdopen(child.in, \"w\");\n\ttrace2_data_intmax(\"promisor\", repo, \"fetch_count\", oid_nr);\n\tfor (i = 0; i < oid_nr; i++) {\n\t\tif (fputs(oid_to_hex(&oids[i]), child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t\tif (fputc('\\n', child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t}\n\tif (fclose(child_in) < 0)\n\t\tdie_errno(_(\"promisor-remote: could not close stdin to fetch subprocess\"));\n\treturn finish_command(&child) ? -1 : 0;\n}", "target": 0}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 0}
{"code": "void CxImage::Ghost(const CxImage *from)\n{\n\tif (from){\n\t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\n\t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\n\t\tpDib = from->pDib;\n        pDibLimit = from->pDibLimit;\n\t\tpSelection = from->pSelection;\n\t\tpAlpha = from->pAlpha;\n\t\tppLayers = from->ppLayers;\n\t\tppFrames = from->ppFrames;\n\t\tinfo.pGhost=(CxImage *)from;\n\t}\n}", "target": 0}
{"code": "kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n    return 0;\n}", "target": 1}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static inline struct inode *vfs_select_inode(struct dentry *dentry,\n\t\t\t\t\t     unsigned open_flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n\treturn inode;\n}", "target": 0}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 0}
{"code": "compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}", "target": 1}
{"code": "static void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n    }\n  }\n}", "target": 0}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "target": 1}
{"code": "static void encode_test_stateid(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_test_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_TEST_STATEID, decode_test_stateid_maxsz, hdr);\n\tencode_uint32(xdr, 1);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}", "target": 0}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "static void iommu_disable_protect_mem_regions(struct intel_iommu *iommu)\n{\n\tu32 pmen;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tpmen = readl(iommu->reg + DMAR_PMEN_REG);\n\tpmen &= ~DMA_PMEN_EPM;\n\twritel(pmen, iommu->reg + DMAR_PMEN_REG);\n\tIOMMU_WAIT_OP(iommu, DMAR_PMEN_REG,\n\t\treadl, !(pmen & DMA_PMEN_PRS), pmen);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}", "target": 0}
{"code": "static int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_unregister_llc_proto;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_unregister_llc_proto:\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}", "target": 0}
{"code": "buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "void dns_server_init(struct netif * pnetif)\n{\n\tuint8_t *ip;\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n\tdns_server_pcb = udp_new();\n\tif (dns_server_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n\tudp_recv(dns_server_pcb, dnss_receive_udp_packet_handler, NULL);\n}", "target": 0}
{"code": "check_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n                return FALSE;\n            }\n        }\n    }\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n    return FALSE;\n}", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpte_unmap(page_table);\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGSEGV;\n\tif (!(flags & FAULT_FLAG_WRITE) && !mm_forbids_zeropage(mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\tif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &memcg))\n\t\tgoto oom_free_page;\n\t__SetPageUptodate(page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\n\tmem_cgroup_commit_charge(page, memcg, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\t\tdown_write(&mm->mmap_sem);\n\t\tif (!mmget_still_valid(mm))\n\t\t\tgoto skip_mm;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n\t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n\t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\tskip_mm:\n\t\tup_write(&mm->mmap_sem);\n\t\tmmput(mm);\n\t}\n}", "target": 0}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 0}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n  buf = xd3_alloc_output (stream, buf);\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n again:\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}", "target": 1}
{"code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "static unsigned int caif_poll(struct file *file,\n\t\t\t\tstruct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned int mask;\n\tstruct caifsock *cf_sk = container_of(sk, struct caifsock, sk);\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err)\n\t\tmask |= POLLERR;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue) ||\n\t\t(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) && tx_flow_is_on(cf_sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\treturn mask;\n}", "target": 0}
{"code": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\toidc_debug(r, \"enter\");\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "SSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0),\n\t\t\t\t\t\t anon_cred(0), cert_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  certfile = X509_CertFile.getData();\n  keyfile = X509_KeyFile.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "static inline const void *choose_neigh_daddr(struct rt6_info *rt,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\tstruct in6_addr *p = &rt->rt6i_gateway;\n\tif (!ipv6_addr_any(p))\n\t\treturn (const void *) p;\n\telse if (skb)\n\t\treturn &ipv6_hdr(skb)->daddr;\n\treturn daddr;\n}", "target": 0}
{"code": "static void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}", "target": 1}
{"code": "GF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs,  0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "void PackLinuxElf32::updateLoader(OutputFile * )\n{\n    unsigned start = linker->getSymbolOffset(\"_start\");\n    unsigned vbase = get_te32(&elfout.phdr[0].p_vaddr);\n    set_te32(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tkvm_get_kvm(kvm);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 0}
{"code": "void __mb2_cache_entry_free(struct mb2_cache_entry *entry)\n{\n\tkmem_cache_free(mb2_entry_cache, entry);\n}", "target": 0}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "int btrfs_run_qgroups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret = 0;\n\tif (trans->transaction->state != TRANS_STATE_COMMIT_DOING)\n\t\tlockdep_assert_held(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\treturn ret;\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tret = update_qgroup_limit_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tret = update_qgroup_status_item(trans);\n\tif (ret)\n\t\tqgroup_mark_inconsistent(fs_info);\n\treturn ret;\n}", "target": 0}
{"code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\tmod_alias_patch_connection(srv, con, p);\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\treturn HANDLER_GO_ON;\n}", "target": 0}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {\n\t\tint len;\n\t\tchar *escaped_url = r_str_escape_sh (url);\n\t\tchar *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);\n\t\tchar *res = r_sys_cmd_str (command, NULL, &len);\n\t\tfree (escaped_url);\n\t\tfree (command);\n\t\tfree (curl_env);\n\t\tif (!res) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = len;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tfree (curl_env);\n#if __WINDOWS__\n\treturn http_get_w32 (url, code, rlen);\n#else\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n#if !HAVE_LIB_SSL\n\tif (ssl) {\n\t\teprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);\n\t\treturn NULL;\n\t}\n#endif\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 0}
{"code": "de265_error decoder_context::decode_some(bool* did_work)\n{\n  de265_error err = DE265_OK;\n  *did_work = false;\n  if (image_units.empty()) { return DE265_OK; }  \n  if ( ! image_units.empty() ) { \n    image_unit* imgunit = image_units[0];\n    slice_unit* sliceunit = imgunit->get_next_unprocessed_slice_segment();\n    if (sliceunit != NULL) {\n      if (sliceunit->flush_reorder_buffer) {\n        dpb.flush_reorder_buffer();\n      }\n      *did_work = true;\n      err = decode_slice_unit_parallel(imgunit, sliceunit);\n      if (err) {\n        return err;\n      }\n    }\n  }\n  if ( ( image_units.size()>=2 && image_units[0]->all_slice_segments_processed()) ||\n       ( image_units.size()>=1 && image_units[0]->all_slice_segments_processed() &&\n         nal_parser.number_of_NAL_units_pending()==0 &&\n         (nal_parser.is_end_of_stream() || nal_parser.is_end_of_frame()) )) {\n    image_unit* imgunit = image_units[0];\n    *did_work=true;\n    imgunit->img->mark_all_CTB_progress(CTB_PROGRESS_PREFILTER);\n    if (img->decctx->num_worker_threads)\n      run_postprocessing_filters_parallel(imgunit);\n    else\n      run_postprocessing_filters_sequential(imgunit->img);\n    for (int i=0;i<imgunit->suffix_SEIs.size();i++) {\n      const sei_message& sei = imgunit->suffix_SEIs[i];\n      err = process_sei(&sei, imgunit->img);\n      if (err != DE265_OK)\n        break;\n    }\n    push_picture_to_output_queue(imgunit);\n    delete imgunit;\n    pop_front(image_units);\n  }\n  return err;\n}", "target": 0}
{"code": "static bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; \n\tif (unlikely(rthdr->it_version))\n\t\treturn false; \n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; \n\treturn true;\n}", "target": 0}
{"code": "static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tu32 sid;\n\tint rc;\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\tif (!opts)\n\t\treturn 0;\n\tif (opts->fscontext) {\n\t\trc = parse_sid(sb, opts->fscontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->context) {\n\t\trc = parse_sid(sb, opts->context, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->rootcontext) {\n\t\tstruct inode_security_struct *root_isec;\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\trc = parse_sid(sb, opts->rootcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->defcontext) {\n\t\trc = parse_sid(sb, opts->defcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\treturn 0;\nout_bad_option:\n\tpr_warn(\"SELinux: unable to change security options \"\n\t       \"during remount (dev %s, type=%s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}", "target": 1}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}", "target": 0}
{"code": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\tmight_sleep();\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\t*_page = page;\n\treturn kmap(page);\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\treturn NULL;\n}", "target": 0}
{"code": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  if (MinSize > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n  destroy_range(this->begin(), this->end());\n  if (!this->isSmall())\n    free(this->begin());\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *host,\n                                   MemoryRegion *mr)\n{\n    RAMBlock *new_block;\n    ram_addr_t max_size = size;\n    size = HOST_PAGE_ALIGN(uc, size);\n    max_size = HOST_PAGE_ALIGN(uc, max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    if (new_block == NULL)\n        return NULL;\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->page_size = uc->qemu_real_host_page_size;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    uc->invalid_addr = UC_ERR_OK;\n    ram_block_add(mr->uc, new_block);\n    if (uc->invalid_error != UC_ERR_OK) {\n        g_free(new_block);\n        return NULL;\n    }\n    return new_block;\n}", "target": 0}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "_client_list_free_node(t_client *client)\n{\n\tchar *msg;\n\tchar *cidinfo;\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\tfree(client);\n}", "target": 0}
{"code": "int rose_add_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node != NULL)\n\t\tgoto out;\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\trose_loopback_neigh->count++;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\treturn err;\n}", "target": 0}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t             _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "bool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n  const TfLiteTensor* padding = GetInput(context, node, 1);\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "ImagingConvertInPlace(Imaging imIn, const char *mode) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (strcmp(imIn->mode, \"L\") == 0 && strcmp(mode, \"1\") == 0) {\n        convert = l2bit;\n    } else if (strcmp(imIn->mode, \"1\") == 0 && strcmp(mode, \"L\") == 0) {\n        convert = bit2l;\n    } else {\n        return ImagingError_ModeError();\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imIn->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imIn;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        return;\n    }\n    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}", "target": 1}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\tmutex_lock(&ctx->ring_lock);\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\tif (head == tail)\n\t\tgoto out;\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\treturn ret;\n}", "target": 0}
{"code": "crm_send_tls(gnutls_session * session, const char *buf, size_t len)\n{\n    const char *unsent = buf;\n    int rc = 0;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message size: %d\", len);\n    while (TRUE) {\n        rc = gnutls_record_send(*session, unsent, len);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_debug(\"Retry\");\n        } else if (rc < 0) {\n            crm_err(\"Connection terminated rc = %d\", rc);\n            break;\n        } else if (rc < len) {\n            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n        } else {\n            crm_debug(\"Sent %d bytes\", rc);\n            break;\n        }\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "static int start_netprobe(const struct sa *turn_srv,\n\t\t\t  int proto, bool secure,\n\t\t\t  const char *username, const char *password)\n{\n\tint err;\n\tre_printf(\"starting netprobe with TURN%s-server %J\"\n\t\t  \" (proto=%s) ..\\n\",\n\t\t  secure ? \"S\" : \"\", turn_srv,\n\t\t  net_proto2name(proto));\n#define PACKET_COUNT 50\n#define PACKET_INTERVAL 20\n\tif (netprobec >= ARRAY_SIZE(netprobev)) {\n\t\twarning(\"reached maximum %zu netprobes\\n\", netprobec);\n\t\treturn 0;\n\t}\n\tnetprobev[netprobec].turn_srv = *turn_srv;\n\tnetprobev[netprobec].secure = secure;\n\tnetprobev[netprobec].proto = proto;\n\terr = netprobe_alloc(&netprobev[netprobec].np,\n\t\t\t     turn_srv, proto, secure,\n\t\t\t     username, password,\n\t\t\t     PACKET_COUNT, PACKET_INTERVAL,\n\t\t\t     netprobe_handler, (void *)netprobec);\n\tif (err) {\n\t\twarning(\"could not create netprobe (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnetprobec++;\n out:\n\treturn err;\n}", "target": 0}
{"code": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    if (!r->iov.iov_base) {\n        r->buflen = SCSI_DMA_BUF_SIZE;\n        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n    }\n    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}", "target": 0}
{"code": "static int me_unknown(struct page *p, unsigned long pfn)\n{\n\tpr_err(\"Memory failure: %#lx: Unknown page state\\n\", pfn);\n\treturn MF_FAILED;\n}", "target": 0}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "int rdma_create_qp(struct rdma_cm_id *id, struct ib_pd *pd,\n\t\t   struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct rdma_id_private *id_priv;\n\tstruct ib_qp *qp;\n\tint ret;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tif (id->device != pd->device) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tqp_init_attr->port_num = id->port_num;\n\tqp = ib_create_qp(pd, qp_init_attr);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto out_err;\n\t}\n\tif (id->qp_type == IB_QPT_UD)\n\t\tret = cma_init_ud_qp(id_priv, qp);\n\telse\n\t\tret = cma_init_conn_qp(id_priv, qp);\n\tif (ret)\n\t\tgoto out_destroy;\n\tid->qp = qp;\n\tid_priv->qp_num = qp->qp_num;\n\tid_priv->srq = (qp->srq != NULL);\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, 0);\n\treturn 0;\nout_destroy:\n\tib_destroy_qp(qp);\nout_err:\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, ret);\n\treturn ret;\n}", "target": 0}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n        return 1;\n} ", "target": 0}
{"code": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n\tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket;\n\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n\t       g_options.only_desired_port == 0) {\n\t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n\t\t\tdesired_port = 49152;\n\t}\n\tif (tcp_socket == NULL)\n\t\tgoto cleanup_tcp;\n\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n\tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n\t    desired_port != real_port) {\n\t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n\tprintf(\"%u|\", real_port);\n\tfflush(stdout);\n\tuint16_t pid;\n\tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\targs->usb_sock = usb_sock;\n\t\targs->tcp = tcp_conn_accept(tcp_socket);\n\t\tif (args->tcp == NULL) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tcontinue;\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\ncleanup_tcp:\n\tif (tcp_socket!= NULL)\n\t\ttcp_close(tcp_socket);\ncleanup_usb:\n\tif (usb_sock != NULL)\n\t\tusb_close(usb_sock);\n\treturn;\n}", "target": 1}
{"code": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static bool append_rets(RStrBuf *sb, RBinWasmTypeVec *rets) {\n\tbool ret = true;\n\tif (!rets->count) {\n\t\tret &= r_strbuf_append (sb, \"nil\");\n\t} else if (rets->count == 1) {\n\t\tret &= r_strbuf_append (sb, r_bin_wasm_valuetype_to_string (rets->types[0]));\n\t} else {\n\t\tret &= strbuf_append_type_vec (sb, rets);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}", "target": 1}
{"code": "static void smb_set_posix_lock_done(struct tevent_req *subreq)\n{\n\tstruct smb_request *req = NULL;\n\tNTSTATUS status;\n\tbool ok;\n\tok = smbd_smb1_do_locks_extract_smbreq(subreq, talloc_tos(), &req);\n\tSMB_ASSERT(ok);\n\tstatus = smbd_smb1_do_locks_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tchar params[2] = {0};\n\t\tsend_trans2_replies(\n\t\t\treq->conn,\n\t\t\treq,\n\t\t\tNT_STATUS_OK,\n\t\t\tparams,\n\t\t\t2,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t0xffff);\n\t} else {\n\t\treply_nterror(req, status);\n\t\tok = srv_send_smb(\n\t\t\treq->xconn,\n\t\t\t(char *)req->outbuf,\n\t\t\ttrue,\n\t\t\treq->seqnum+1,\n\t\t\tIS_CONN_ENCRYPTED(req->conn),\n\t\t\tNULL);\n\t\tif (!ok) {\n\t\t\texit_server_cleanly(\"smb_set_posix_lock_done: \"\n\t\t\t\t\t    \"srv_send_smb failed.\");\n\t\t}\n\t}\n\tTALLOC_FREE(req);\n\treturn;\n}", "target": 0}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "static int mmac_rotate(const MMacro *mac, unsigned int n)\n{\n    if (--n < mac->nparam)\n        n = (n + mac->rotate) % mac->nparam;\n    return n+1;\n}", "target": 0}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "ftrace_filter_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 0}
{"code": "int qemu_ram_resize(ram_addr_t base, ram_addr_t newsize, Error **errp)\n{\n    RAMBlock *block = find_ram_block(base);\n    assert(block);\n    newsize = TARGET_PAGE_ALIGN(newsize);\n    if (block->used_length == newsize) {\n        return 0;\n    }\n    if (!(block->flags & RAM_RESIZEABLE)) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length mismatch: %s: 0x\" RAM_ADDR_FMT\n                         \" in != 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->used_length);\n        return -EINVAL;\n    }\n    if (block->max_length < newsize) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length too large: %s: 0x\" RAM_ADDR_FMT\n                         \" > 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->max_length);\n        return -EINVAL;\n    }\n    cpu_physical_memory_clear_dirty_range(block->offset, block->used_length);\n    block->used_length = newsize;\n    cpu_physical_memory_set_dirty_range(block->offset, block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n    memory_region_set_size(block->mr, newsize);\n    if (block->resized) {\n        block->resized(block->idstr, newsize, block->host);\n    }\n    return 0;\n}", "target": 0}
{"code": "GF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "expand_command(struct eventlog *evlog, char **newbuf)\n{\n    size_t len, bufsize = strlen(evlog->command) + 1;\n    char *cp, *buf;\n    int ac;\n    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n    if (evlog->argv == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n\t*newbuf = NULL;\n\tdebug_return_str(evlog->command);\n    }\n    for (ac = 1; evlog->argv[ac] != NULL; ac++)\n\tbufsize += strlen(evlog->argv[ac]) + 1;\n    if ((buf = malloc(bufsize)) == NULL)\n\tsudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n    cp = buf;\n    len = strlcpy(cp, evlog->command, bufsize);\n    if (len >= bufsize)\n\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n    cp += len;\n    bufsize -= len;\n    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n\tif (bufsize < 2)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\t*cp++ = ' ';\n\tbufsize--;\n\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n\tif (len >= bufsize)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\tcp += len;\n\tbufsize -= len;\n    }\n    *newbuf = buf;\n    debug_return_str(buf);\n}", "target": 0}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "const char *cgit_loginurl(void)\n{\n\tstatic const char *login_url;\n\tif (!login_url)\n\t\tlogin_url = fmtalloc(\"%s?p=login\", cgit_rooturl());\n\treturn login_url;\n}", "target": 0}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n\tcase FBIOGET_VBLANK: {\n\t\tstruct fb_vblank vblank;\n\t\tmemset(&vblank, 0, sizeof(vblank));\n\t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_VSYNC;\n\t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}", "target": 1}
{"code": "void net_tx_pkt_update_ip_hdr_checksum(struct NetTxPkt *pkt)\n{\n    uint16_t csum;\n    assert(pkt);\n    struct ip_header *ip_hdr;\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = 0;\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n}", "target": 0}
{"code": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\treturn 1;\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}", "target": 1}
{"code": "static int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\tcreds = get_current_cred();\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (!ret)\n\t\treturn id;\n\tput_cred(creds);\n\treturn ret;", "target": 1}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 1}
{"code": "static int v2g_incoming_v2gtp(struct v2g_connection* conn) {\n    int rv;\n    rv = connection_read(conn, conn->buffer, V2GTP_HEADER_LENGTH);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv == 0)\n        return 1;\n    if (rv != V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) too short: expected %d, got %d\", V2GTP_HEADER_LENGTH, rv);\n        return -1;\n    }\n    rv = read_v2gtpHeader(conn->buffer, &conn->payload_len);\n    if (rv == -1) {\n        dlog(DLOG_LEVEL_ERROR, \"Invalid v2gtp header\");\n        return -1;\n    }\n    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {\n        dlog(DLOG_LEVEL_ERROR, \"payload too long: have %d, would need %d\", DEFAULT_BUFFER_SIZE,\n             conn->payload_len + V2GTP_HEADER_LENGTH);\n        return -1;\n    }\n    rv = connection_read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv != conn->payload_len) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) too short: expected %d, got %d\", conn->payload_len, rv);\n        return -1;\n    }\n    conn->buffer_pos = V2GTP_HEADER_LENGTH;\n    conn->stream.size = conn->payload_len + V2GTP_HEADER_LENGTH;\n    return 0;\n}", "target": 1}
{"code": "static int __init dev_prepare_static_identity_mapping(struct device *dev, int hw)\n{\n\tint ret;\n\tif (!iommu_should_identity_map(dev, 1))\n\t\treturn 0;\n\tret = domain_add_dev_info(si_domain, dev);\n\tif (!ret)\n\t\tdev_info(dev, \"%s identity mapping\\n\",\n\t\t\t hw ? \"Hardware\" : \"Software\");\n\telse if (ret == -ENODEV)\n\t\tret = 0;\n\treturn ret;\n}", "target": 0}
{"code": "static void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\tclts();\n}", "target": 0}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n    OP_REQUIRES(\n        c,\n        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),\n        errors::InvalidArgument(\"serialized_summary_metadata must be scalar\"));\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  \n    if (tensor.dtype() == DT_STRING) {\n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }", "target": 0}
{"code": "urlCheckRequest(const HttpRequest * r)\n{\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n    switch (r->url.getScheme()) {\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_CACHE_OBJECT:\n        return true;\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n    case AnyP::PROTO_GOPHER:\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        return false;\n#endif\n    default:\n        return false;\n    }\n    return false;\n}", "target": 1}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "static void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tSAS_DPRINTK(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t    port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\tSAS_DPRINTK(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\tSAS_DPRINTK(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t    port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}", "target": 0}
{"code": "drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tkref_init(&state->ref);\n\tstate->allow_modeset = true;\n\tstate->crtcs = kcalloc(dev->mode_config.num_crtc,\n\t\t\t       sizeof(*state->crtcs), GFP_KERNEL);\n\tif (!state->crtcs)\n\t\tgoto fail;\n\tstate->planes = kcalloc(dev->mode_config.num_total_plane,\n\t\t\t\tsizeof(*state->planes), GFP_KERNEL);\n\tif (!state->planes)\n\t\tgoto fail;\n\tdrm_dev_get(dev);\n\tstate->dev = dev;\n\tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\n\", state);\n\treturn 0;\nfail:\n\tdrm_atomic_state_default_release(state);\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "ActivationPtr createActivation(Protobuf::Arena& arena, const StreamInfo::StreamInfo& info,\n                               const Http::RequestHeaderMap* request_headers,\n                               const Http::ResponseHeaderMap* response_headers,\n                               const Http::ResponseTrailerMap* response_trailers) {\n  auto activation = std::make_unique<Activation>();\n  activation->InsertValueProducer(Request,\n                                  std::make_unique<RequestWrapper>(arena, request_headers, info));\n  activation->InsertValueProducer(Response, std::make_unique<ResponseWrapper>(\n                                                arena, response_headers, response_trailers, info));\n  activation->InsertValueProducer(Connection, std::make_unique<ConnectionWrapper>(info));\n  activation->InsertValueProducer(Upstream, std::make_unique<UpstreamWrapper>(info));\n  activation->InsertValueProducer(Source, std::make_unique<PeerWrapper>(info, false));\n  activation->InsertValueProducer(Destination, std::make_unique<PeerWrapper>(info, true));\n  activation->InsertValueProducer(Metadata,\n                                  std::make_unique<MetadataProducer>(info.dynamicMetadata()));\n  activation->InsertValueProducer(FilterState,\n                                  std::make_unique<FilterStateWrapper>(info.filterState()));\n  return activation;\n}", "target": 0}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 0}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "static int midi_setup_sysex_roland_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "static int seed_from_timestamp_and_pid(uint32_t *seed) {\n#ifdef HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n#else\n    *seed = (uint32_t)time(NULL);\n#endif\n#if defined(_WIN32)\n    *seed ^= (uint32_t)_getpid();\n#elif defined(HAVE_GETPID)\n    *seed ^= (uint32_t)getpid();\n#endif\n    return 0;\n}", "target": 0}
{"code": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\treturn ret;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = tl;\n\t  break;\n     }\n     return TRUE;\n}", "target": 0}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "static int acurite_leak_detector_decode(r_device* decoder, uint8_t* bb)\n{\n    int parity = parity_bytes(&bb[2], 4);\n    if (parity) {\n        decoder_log_bitrow(decoder, 1, __func__, bb, 7 * 8, \"bad parity\");\n        return DECODE_FAIL_MIC;\n    }\n    char const* channel_str = acurite_getChannel(bb[0]);\n    if (*channel_str == 'E') {\n        decoder_logf(decoder, 1, __func__, \"Acurite TXR sensor : bad channel Ch %s\", channel_str);\n        return DECODE_FAIL_SANITY;\n    }\n    int sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];\n    int battery_low = (bb[2] & 0x40) == 0;\n    int is_wet = (bb[3] & 0x10) >> 4;\n    data_t* data;\n    data = data_make(\n            \"model\",                \"\",             DATA_STRING, \"Acurite-Leak\",\n            \"id\",                   \"\",             DATA_INT,    sensor_id,\n            \"channel\",              NULL,           DATA_STRING, channel_str,\n            \"battery_ok\",           \"Battery\",      DATA_INT,    !battery_low,\n            \"leak_detected\",        \"Leak\",         DATA_INT,    is_wet,\n            \"mic\",                  \"Integrity\",    DATA_STRING, \"CHECKSUM\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}", "target": 0}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "  Status Init(DataType input_type, const string& fill = \"\", int width = -1,\n              int precision = -1, bool scientific = false,\n              bool shortest = false) {\n    TF_CHECK_OK(NodeDefBuilder(\"op\", \"AsString\")\n                    .Input(FakeInput(input_type))\n                    .Attr(\"fill\", fill)\n                    .Attr(\"precision\", precision)\n                    .Attr(\"scientific\", scientific)\n                    .Attr(\"shortest\", shortest)\n                    .Attr(\"width\", width)\n                    .Finalize(node_def()));\n    return InitOp();\n  }", "target": 0}
{"code": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}", "target": 0}
{"code": "static inline void *nvme_addr_to_cmb(NvmeCtrl *n, hwaddr addr)\n{\n    hwaddr base = n->params.legacy_cmb ? n->cmb.mem.addr : n->cmb.cba;\n    return &n->cmb.buf[addr - base];\n}", "target": 0}
{"code": "\tvoid Execute(CommandSource &source, const std::vector<Anope::string> &params) anope_override\n\t{\n\t\tconst NickAlias *na;\n\t\tif (!(na = NickAlias::Find(params[0])))\n\t\t\tsource.Reply(NICK_X_NOT_REGISTERED, params[0].c_str());\n\t\telse if (na->nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\tsource.Reply(NICK_X_SUSPENDED, na->nc->display.c_str());\n\t\telse if (!na->nc->email.equals_ci(params[1]))\n\t\t\tsource.Reply(_(\"Incorrect email address.\"));\n\t\telse\n\t\t{\n\t\t\tif (SendResetEmail(source.GetUser(), na, source.service))\n\t\t\t{\n\t\t\t\tLog(LOG_COMMAND, source, this) << \"for \" << na->nick << \" (group: \" << na->nc->display << \")\";\n\t\t\t\tsource.Reply(_(\"Password reset email for \\002%s\\002 has been sent.\"), na->nick.c_str());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}", "target": 0}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,\n                errors::InvalidArgument(\"Input min must not be empty.\"));\n    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,\n                errors::InvalidArgument(\"Input max must not be empty.\"));\n    const float input_min_float = ctx->input(1).flat<float>()(0);\n    const float input_max_float = ctx->input(2).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n    qint32 used_min_quantized;\n    qint32 used_max_quantized;\n    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n    const float used_min_float = std::min(\n        0.0f,\n        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n    const float used_max_float =\n        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n    output_min->flat<float>().setConstant(used_min_float);\n    output_max->flat<float>().setConstant(used_max_float);\n  }", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": "static void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->stack);\n\tkfree(state);\n}", "target": 0}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  if (s == se)\n    return UV_EINVAL;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d >= de)\n    return UV_EINVAL;\n  *d++ = '\\0';\n  return d - ds;  \n}", "target": 0}
{"code": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}", "target": 1}
{"code": "SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                  const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                  Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));\n  auto status = socket->initialize(state, handshaker_factory_cb);\n  if (status.ok()) {\n    return socket;\n  } else {\n    return status;\n  }\n}", "target": 0}
{"code": "mcs_send_connect_initial(STREAM mcs_data)\n{\n\tint datalen = mcs_data->end - mcs_data->data;\n\tint length = 9 + 3 * 34 + 4 + datalen;\n\tSTREAM s;\n\ts = iso_init(length + 5);\n\tber_out_header(s, MCS_CONNECT_INITIAL, length);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_BOOLEAN, 1);\n\tout_uint8(s, 0xff);\t\n\tmcs_out_domain_params(s, 34, 2, 0, 0xffff);\t\n\tmcs_out_domain_params(s, 1, 1, 1, 0x420);\t\n\tmcs_out_domain_params(s, 0xffff, 0xfc17, 0xffff, 0xffff);\t\n\tber_out_header(s, BER_TAG_OCTET_STRING, datalen);\n\tout_uint8p(s, mcs_data->data, datalen);\n\ts_mark_end(s);\n\tiso_send(s);\n}", "target": 0}
{"code": "int main(int argc, char *argv[]) {\n  struct mschm_decompressor *chmd;\n  struct mschmd_header *chm;\n  struct mschmd_file *file, **f;\n  unsigned int numf, i;\n  setbuf(stdout, NULL);\n  setbuf(stderr, NULL);\n  user_umask = umask(0); umask(user_umask);\n  MSPACK_SYS_SELFTEST(i);\n  if (i) return 0;\n  if ((chmd = mspack_create_chm_decompressor(NULL))) {\n    for (argv++; *argv; argv++) {\n      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}\n\tchmd->close(chmd, chm);\n      }\n      else {\n\tprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n      }\n    }\n    mspack_destroy_chm_decompressor(chmd);\n  }\n  return 0;\n}", "target": 1}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static void timestamp(void)\n{\n    struct compile_time * const oct = &official_compile_time;\n    const struct tm *tp, *best_gm;\n    time(&oct->t);\n    best_gm = NULL;\n    tp = localtime(&oct->t);\n    if (tp) {\n        oct->local = *tp;\n        best_gm = &oct->local;\n        oct->have_local = true;\n    }\n    tp = gmtime(&oct->t);\n    if (tp) {\n        oct->gm = *tp;\n        best_gm = &oct->gm;\n        oct->have_gm = true;\n        if (!oct->have_local)\n            oct->local = oct->gm;\n    } else {\n        oct->gm = oct->local;\n    }\n    if (best_gm) {\n        oct->posix = make_posix_time(best_gm);\n        oct->have_posix = true;\n    }\n}", "target": 0}
{"code": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char* name;\n#define __LSMATTRLEN  (5 +  21 +  7 +  1)\n\tchar path[__LSMATTRLEN];\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (on_exec) {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t} else {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t}\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\treturn -1;\n\t}\n\treturn labelfd;\n}", "target": 0}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "void CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / getreal(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}", "target": 0}
{"code": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  bool connecting = connecting_;\n  connecting_ = false;\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}", "target": 1}
{"code": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|dao-truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "QTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\tcntsize(in, &sumlen, &nnode);\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\tfillQT(&state, in);\n\treturn out;\n}", "target": 0}
{"code": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_iqueue *fiq = &fc->iq;\n\tif (test_and_set_bit(FR_FINISHED, &req->flags))\n\t\tgoto put_request;\n\tspin_lock(&fiq->waitq.lock);\n\tlist_del_init(&req->intr_entry);\n\tspin_unlock(&fiq->waitq.lock);\n\tWARN_ON(test_bit(FR_PENDING, &req->flags));\n\tWARN_ON(test_bit(FR_SENT, &req->flags));\n\tif (test_bit(FR_BACKGROUND, &req->flags)) {\n\t\tspin_lock(&fc->bg_lock);\n\t\tclear_bit(FR_BACKGROUND, &req->flags);\n\t\tif (fc->num_background == fc->max_background) {\n\t\t\tfc->blocked = 0;\n\t\t\twake_up(&fc->blocked_waitq);\n\t\t} else if (!fc->blocked) {\n\t\t\tif (waitqueue_active(&fc->blocked_waitq))\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t}\n\t\tif (fc->num_background == fc->congestion_threshold && fc->sb) {\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t\tspin_unlock(&fc->bg_lock);\n\t}\n\twake_up(&req->waitq);\n\tif (req->end)\n\t\treq->end(fc, req);\nput_request:\n\tfuse_put_request(fc, req);\n}", "target": 0}
{"code": "CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const\n{\n  CephXAuthorizer *a = new CephXAuthorizer(cct);\n  a->session_key = session_key;\n  a->nonce = ((uint64_t)rand() << 32) + rand();\n  __u8 authorizer_v = 1;\n  ::encode(authorizer_v, a->bl);\n  ::encode(global_id, a->bl);\n  ::encode(service_id, a->bl);\n  ::encode(ticket, a->bl);\n  a->base_bl = a->bl;\n  CephXAuthorize msg;\n  msg.nonce = a->nonce;\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, a->bl, error)) {\n    ldout(cct, 0) << \"failed to encrypt authorizer: \" << error << dendl;\n    delete a;\n    return 0;\n  }\n  return a;\n}", "target": 0}
{"code": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}", "target": 1}
{"code": "void kvm_release_pfn_clean(kvm_pfn_t pfn)\n{\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}", "target": 1}
{"code": "vmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 0}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "    std::ostream& operator<<(std::ostream& os, const Rational& r)\n    {\n        return os << r.first << \"/\" << r.second;\n    }", "target": 0}
{"code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}", "target": 1}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) {\n  string container;\n  string ta_handle;\n  if (ctx->input_dtype(0) != DT_RESOURCE) {\n    TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle));\n    ResourceMgr* rm = ctx->resource_manager();\n    if (rm == nullptr) return errors::Internal(\"No resource manager.\");\n    TF_RETURN_IF_ERROR(\n        ctx->step_container()->Lookup(rm, container + ta_handle, tensor_array));\n    return OkStatus();\n  } else {\n    return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);\n  }\n}", "target": 1}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n  return (result);\n}", "target": 1}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemset(&line, 0, sizeof(line));\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {\n  std::vector<std::string> dirs;\n  const std::string patched = PatchPattern(d);\n  StringPiece dir(patched);\n  bool is_directory = d[d.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || (d[d.size() - 1] == '\\\\');\n#endif\n  if (is_directory) {\n    dir = io::Dirname(dir);\n  }\n  while (!dir.empty()) {\n    dirs.emplace_back(dir);\n    StringPiece new_dir(io::Dirname(dir));\n    if (dir == new_dir) break;\n    dir = new_dir;\n  }\n  std::reverse(dirs.begin(), dirs.end());\n  return dirs;\n}", "target": 0}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}", "target": 0}
{"code": "static void context__cleanup_out_packets(struct mosquitto *context)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n}", "target": 0}
{"code": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\tassert(n >= 0 && n < 32);\n\tassert(!(v & (~JAS_ONES(n))));\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n    return true;\n}", "target": 0}
{"code": "static void encode_compound_hdr(struct xdr_stream *xdr,\n\t\t\t\tstruct rpc_rqst *req,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tstruct rpc_auth *auth = req->rq_cred->cr_auth;\n\thdr->replen = RPC_REPHDRSIZE + auth->au_rslack + 3 + hdr->taglen;\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tencode_string(xdr, hdr->taglen, hdr->tag);\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\n}", "target": 0}
{"code": "int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,\n        sig, sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){\n  char *pIter = *ppIter;\n  if( pIter ){\n    int iIter = *piIter;\n    while( iIter<iNext ){\n      if( 0==(*pIter & 0xFE) ){\n        iIter = -1;\n        pIter = 0;\n        break;\n      }\n      fts3GetDeltaPosition(&pIter, &iIter);\n    }\n    *piIter = iIter;\n    *ppIter = pIter;\n  }\n}", "target": 0}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 0}
{"code": "bool ArcMemory::Seek(int64 Offset,int Method)\n{\n  if (!Loaded)\n    return false;\n  if (Method==SEEK_SET)\n    SeekPos=Min(Offset,ArcData.Size());\n  else\n    if (Method==SEEK_CUR || Method==SEEK_END)\n    {\n      if (Method==SEEK_END)\n        SeekPos=ArcData.Size();\n      SeekPos+=(uint64)Offset;\n      if (SeekPos>ArcData.Size())\n        SeekPos=Offset<0 ? 0 : ArcData.Size();\n    }\n  return true;\n}", "target": 0}
{"code": "static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  \n}", "target": 1}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "int tcp_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n\tunsigned int eaten = skb->len;\n\tint err;\n\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n\tif (!err) {\n\t\teaten -= skb->len;\n\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "push_tag(struct readbuffer *obuf, char *cmdname, int cmd)\n{\n    obuf->tag_stack[obuf->tag_sp] = New(struct cmdtable);\n    obuf->tag_stack[obuf->tag_sp]->cmdname = allocStr(cmdname, -1);\n    obuf->tag_stack[obuf->tag_sp]->cmd = cmd;\n    obuf->tag_sp++;\n    if (obuf->tag_sp >= TAG_STACK_SIZE || obuf->flag & (RB_SPECIAL & ~RB_NOBR))\n\tappend_tags(obuf);\n}", "target": 0}
{"code": "const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "void mark_files_ro(struct super_block *sb)\n{\n\tstruct file *f;\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, f) {\n\t\tif (!file_count(f))\n\t\t\tcontinue;\n\t\tif (!(f->f_mode & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tspin_lock(&f->f_lock);\n\t\tf->f_mode &= ~FMODE_WRITE;\n\t\tspin_unlock(&f->f_lock);\n\t\tif (file_check_writeable(f) != 0)\n\t\t\tcontinue;\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t\tfile_release_write(f);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n}", "target": 1}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "  static void launch(OpKernelContext* context, bool cudnn_use_autotune,\n                     const Tensor& input, const Tensor& filter,\n                     const std::array<int64, 3>& dilations,\n                     const std::array<int64, 3>& strides, const Padding padding,\n                     TensorFormat data_format, Tensor* output) {\n    OP_REQUIRES(context, data_format == FORMAT_NHWC,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports the NHWC \"\n                                        \"tensor format.\"));\n    OP_REQUIRES(context,\n                dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports dilated rates \"\n                                        \"of 1.\"));\n    OP_REQUIRES(context, filter.dim_size(3) == input.dim_size(input.dims() - 1),\n                errors::InvalidArgument(\n                    \"Number of channels in filter (\", filter.dim_size(3),\n                    \") must match last dimension of input (\",\n                    input.dim_size(input.dims() - 1), \")\"));\n    functor::CuboidConvolution<CPUDevice, T>()(\n        context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),\n        input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],\n        strides[0], BrainPadding2EigenPadding(padding));\n  }", "target": 0}
{"code": "int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}", "target": 1}
{"code": "int main(void)\n{\n\tint fd;\n\tunsigned int i;\n\tunsigned int start = 0;\n\tunsigned int _gap = ~0;\n\tunsigned int gap = _gap / 8;\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tchar *data;\n\tfd = open(dev, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\tthread_func(start, start + gap, fd);\n\tsleep(1000000);\n\treturn EXIT_FAILURE;\n}", "target": 0}
{"code": "std::wstring Utf8To16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 0}
{"code": "static int count_args(const char **argv)\n{\n\tint i = 0;\n\tif (argv) {\n\t\twhile (argv[i] != NULL)\n\t\t\ti++;\n\t}\n\treturn i;\n}", "target": 0}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "bgp_attr_unintern (struct attr **attr)\n{\n  struct attr *ret;\n  struct attr tmp;\n  (*attr)->refcnt--;\n  tmp = *(*attr);\n  if ((*attr)->extra)\n    {\n      tmp.extra = bgp_attr_extra_new ();\n      memcpy (tmp.extra, (*attr)->extra, sizeof (struct attr_extra));\n    }\n  if ((*attr)->refcnt == 0)\n    {    \n      ret = hash_release (attrhash, *attr);\n      assert (ret != NULL);\n      bgp_attr_extra_free (*attr);\n      XFREE (MTYPE_ATTR, *attr);\n      *attr = NULL;\n    }\n  bgp_attr_unintern_sub (&tmp);\n  bgp_attr_extra_free (&tmp);\n}", "target": 0}
{"code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 0}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}", "target": 0}
{"code": "static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\treturn ret;\n}", "target": 0}
{"code": "Archive::Archive(RAROptions *InitCmd)\n{\n  Cmd=NULL; \n  DummyCmd=(InitCmd==NULL);\n  Cmd=DummyCmd ? (new RAROptions):InitCmd;\n  OpenShared=Cmd->OpenShared;\n  Format=RARFMT15;\n  Solid=false;\n  Volume=false;\n  MainComment=false;\n  Locked=false;\n  Signed=false;\n  FirstVolume=false;\n  NewNumbering=false;\n  SFXSize=0;\n  LatestTime.Reset();\n  Protected=false;\n  Encrypted=false;\n  FailedHeaderDecryption=false;\n  BrokenHeader=false;\n  LastReadBlock=0;\n  CurBlockPos=0;\n  NextBlockPos=0;\n  RecoverySize=-1;\n  RecoveryPercent=-1;\n  memset(&MainHead,0,sizeof(MainHead));\n  memset(&CryptHead,0,sizeof(CryptHead));\n  memset(&EndArcHead,0,sizeof(EndArcHead));\n  VolNumber=0;\n  VolWrite=0;\n  AddingFilesSize=0;\n  AddingHeadersSize=0;\n  *FirstVolumeName=0;\n  Splitting=false;\n  NewArchive=false;\n  SilentOpen=false;\n#ifdef USE_QOPEN\n  ProhibitQOpen=false;\n#endif\n}", "target": 0}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "SecureSocket::secureAccept(int socket)\n{\n    createSSL();\n    SSL_set_fd(m_ssl->m_ssl, socket);\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n    static int retry;\n    checkResult(r, retry);\n    if (isFatal()) {\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; \n    }\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; \n            }\n        }\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}", "target": 0}
{"code": "GF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)\n{\n\tu32 i, count, stype;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\tstype = gf_isom_get_media_subtype(file, track, 1);\n\tswitch (stype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\tavcc = gf_isom_avc_config_get(file, track, 1);\n\tif (!avcc)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tif (level) avcc->AVCLevelIndication = level;\n\tif (compat) avcc->profile_compatibility = compat;\n\tif (profile) avcc->AVCProfileIndication = profile;\n\tcount = gf_list_count(avcc->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);\n\t\tif (profile) slc->data[1] = profile;\n\t\tif (level) slc->data[3] = level;\n\t}\n\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\tgf_odf_avc_cfg_del(avcc);\n\treturn e;\n}", "target": 0}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force __u32) daddr;\n\thash[1] = net_secret[13];\n\thash[2] = net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "void DoImageProjectiveTransformOp(OpKernelContext* ctx,\n                                  const Interpolation& interpolation,\n                                  const Mode& fill_mode) {\n  const Tensor& images_t = ctx->input(0);\n  const Tensor& transform_t = ctx->input(1);\n  OP_REQUIRES(ctx, images_t.shape().dims() == 4,\n              errors::InvalidArgument(\"Input images must have rank 4\"));\n  OP_REQUIRES(ctx,\n              (TensorShapeUtils::IsMatrix(transform_t.shape()) &&\n               (transform_t.dim_size(0) == images_t.dim_size(0) ||\n                transform_t.dim_size(0) == 1) &&\n               transform_t.dim_size(1) == 8),\n              errors::InvalidArgument(\n                  \"Input transform should be num_images x 8 or 1 x 8\"));\n  int32_t out_height, out_width;\n  if (ctx->num_inputs() >= 3) {\n    const Tensor& shape_t = ctx->input(2);\n    OP_REQUIRES(ctx, shape_t.dims() == 1,\n                errors::InvalidArgument(\"output shape must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"output shape must have two elements\",\n                                        shape_t.shape().DebugString()));\n    auto shape_vec = shape_t.vec<int32>();\n    out_height = shape_vec(0);\n    out_width = shape_vec(1);\n    OP_REQUIRES(ctx, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n  } else {\n    out_height = images_t.shape().dim_size(1);\n    out_width = images_t.shape().dim_size(2);\n  }\n  T fill_value(0);\n  if (ctx->num_inputs() >= 4) {\n    const Tensor& fill_value_t = ctx->input(3);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(fill_value_t.shape()),\n                errors::InvalidArgument(\"fill_value must be a scalar\",\n                                        fill_value_t.shape().DebugString()));\n    fill_value = static_cast<T>(*(fill_value_t.scalar<float>().data()));\n  }\n  Tensor* output_t;\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(0,\n                                TensorShape({images_t.dim_size(0), out_height,\n                                             out_width, images_t.dim_size(3)}),\n                                &output_t));\n  auto output = output_t->tensor<T, 4>();\n  auto images = images_t.tensor<T, 4>();\n  auto transform = transform_t.matrix<float>();\n  (FillProjectiveTransform<Device, T>(interpolation))(\n      ctx->eigen_device<Device>(), &output, images, transform, fill_mode,\n      fill_value);\n}", "target": 1}
{"code": "callbacks_screen2board(gdouble *X, gdouble *Y, gint x, gint y) {\n\tif ((screenRenderInfo.scaleFactorX > 0.001)||(screenRenderInfo.scaleFactorY > 0.001)) {\n\t\t*X = screenRenderInfo.lowerLeftX + (x / screenRenderInfo.scaleFactorX);\n\t\t*Y = screenRenderInfo.lowerLeftY + ((screenRenderInfo.displayHeight - y)\n\t\t\t/ screenRenderInfo.scaleFactorY);\n\t}\n\telse {\n\t\t*X = *Y = 0.0;\n\t}\n}", "target": 0}
{"code": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask, gfp_t gfp_mask)\n{\n\tspin_lock_irq(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock_irq(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock_irq(&hugetlb_lock);\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tif (!vq || !vq->used)\n\t\treturn;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 0}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "u32 smm_get_cpu_smbase(unsigned int cpu_num)\n{\n\tif (cpu_num < CONFIG_MAX_CPUS) {\n\t\tif (cpus[cpu_num].active)\n\t\t\treturn cpus[cpu_num].smbase;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n    *rval = c & s->cbits;\n    return 0;\n}", "target": 0}
{"code": "  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }", "target": 0}
{"code": "display_debug_not_supported (struct dwarf_section *section,\n\t\t\t     void *file ATTRIBUTE_UNUSED)\n{\n  printf (_(\"Displaying the debug contents of section %s is not yet supported.\\n\"),\n\t    section->name);\n  return 1;\n}", "target": 0}
{"code": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout = NULL;\n\tif (out == NULL)\n\t\ttmpout = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\ttmpout = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(tmpout, 0);\n\t\t}\n\telse\n\t\ttmpout = out;\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\tr = 1;\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\t}", "target": 1}
{"code": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\tif (a->num_values)\n\t{\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n             case MAPI_ATTACH_MIME_TAG:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n                case MAPI_ATTACH_CONTENT_ID:\n                    assert(a->type == szMAPI_STRING);\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\tfs_info->uuid_root = uuid_root;\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\treturn ret;\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "void jspReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n      jsvAddName(execInfo.root, dst);\n  }\n  jspReplaceWith(dst, src);\n}", "target": 0}
{"code": "raptor_rdfxml_parse_start(raptor_parser* rdf_parser)\n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  if(!uri)\n    return 1;\n  raptor_sax2_set_option(rdf_xml_parser->sax2,\n                         RAPTOR_OPTION_NORMALIZE_LANGUAGE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rdf_xml_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);\n  if(rdf_xml_parser->id_set) {\n    raptor_free_id_set(rdf_xml_parser->id_set);\n    rdf_xml_parser->id_set = NULL;\n  }\n  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {\n    rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);\n    if(!rdf_xml_parser->id_set)\n      return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}", "target": 1}
{"code": "DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n\tint pad, int subsamp, unsigned char *dstBuf, int width, int pitch,\n\tint height, int pixelFormat, int flags)\n{\n\tconst unsigned char *srcPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\ttjinstance *this=(tjinstance *)handle;\n\tif(!this) _throwg(\"tjDecodeYUV(): Invalid handle\");\n\tthis->isInstanceError=FALSE;\n\tif(srcBuf==NULL || pad<0 || !isPow2(pad) || subsamp<0 || subsamp>=NUMSUBOPT\n\t\t|| width<=0 || height<=0)\n\t\t_throw(\"tjDecodeYUV(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tsrcPlanes[0]=srcBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tsrcPlanes[1]=srcPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tsrcPlanes[1]=srcPlanes[0]+strides[0]*ph0;\n\t\tsrcPlanes[2]=srcPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjDecodeYUVPlanes(handle, srcPlanes, strides, subsamp, dstBuf, width,\n\t\tpitch, height, pixelFormat, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "static int on_version_message(struct nvnc_client* client)\n{\n\tstruct nvnc* server = client->server;\n\tif (client->buffer_len - client->buffer_index < 12)\n\t\treturn 0;\n\tchar version_string[13];\n\tmemcpy(version_string, client->msg_buffer + client->buffer_index, 12);\n\tversion_string[12] = '\\0';\n\tif (strcmp(RFB_VERSION_MESSAGE, version_string) != 0)\n\t\treturn handle_unsupported_version(client);\n\tuint8_t buf[sizeof(struct rfb_security_types_msg) +\n\t\tSECURITY_TYPES_MAX] = {};\n\tstruct rfb_security_types_msg* security =\n\t\t(struct rfb_security_types_msg*)buf;\n\tsecurity->n = 0;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_VENCRYPT;\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES256;\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES;\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_APPLE_DH;\n\t\t}\n#endif\n\t} else {\n\t\tsecurity->n = 1;\n\t\tsecurity->types[0] = RFB_SECURITY_TYPE_NONE;\n\t}\n\tif (security->n == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n\tstream_write(client->net_stream, security, sizeof(*security) +\n\t\t\tsecurity->n, NULL, NULL);\n\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_SECURITY;\n\treturn 12;\n}", "target": 1}
{"code": "void DetectSignatureApplyActions(Packet *p,\n        const Signature *s, const uint8_t alert_flags)\n{\n    PACKET_UPDATE_ACTION(p, s->action);\n    if (s->action & ACTION_DROP) {\n        if (p->alerts.drop.action == 0) {\n            p->alerts.drop.num = s->num;\n            p->alerts.drop.action = s->action;\n            p->alerts.drop.s = (Signature *)s;\n        }\n    } else if (s->action & ACTION_PASS) {\n        if ((p->flow != NULL) &&\n                (alert_flags & (PACKET_ALERT_FLAG_STATE_MATCH|PACKET_ALERT_FLAG_STREAM_MATCH)))\n        {\n            FlowSetNoPacketInspectionFlag(p->flow);\n        }\n    }\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_symlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsString name;\n    V9fsString symname;\n    V9fsFidState *dfidp;\n    V9fsQID qid;\n    struct stat stbuf;\n    int32_t dfid;\n    int err = 0;\n    gid_t gid;\n    size_t offset = 7;\n    v9fs_string_init(&name);\n    v9fs_string_init(&symname);\n    err = pdu_unmarshal(pdu, offset, \"dssd\", &dfid, &name, &symname, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_symlink(pdu->tag, pdu->id, dfid, name.data, symname.data, gid);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    err = v9fs_co_symlink(pdu, dfidp, &name, symname.data, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err =  pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_symlink_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n    v9fs_string_free(&symname);\n}", "target": 0}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 p_total_data_size,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n    if (p_total_data_size < 12) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 \n    p_data += 2;\n    opj_write_bytes(p_data, 10,\n                    2);                                                   \n    p_data += 2;\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        \n    p_data += 2;\n    p_data += 4;\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        \n    ++p_data;\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      \n    ++p_data;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    * p_data_written = 12;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unmap;\n\t}\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tsymlink = bh->b_data;\n\t}\n\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout_unlock_inode:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\nout_unmap:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 0}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  const PixelChannels\n    *color_1,\n    *color_2;\n  double\n    distance;\n  ssize_t\n    i;\n  color_1=(const PixelChannels *) x;\n  color_2=(const PixelChannels *) y;\n  distance=0.0;\n  for (i=0; i < MaxPixelChannels; i++)\n    distance+=color_1->channel[i]-(double) color_2->channel[i];\n  return(distance < 0.0 ? -1 : distance > 0.0 ? 1 : 0);\n}", "target": 0}
{"code": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_call_handlers(ndp, msg);;\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}", "target": 1}
{"code": "Resource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\tif (uri.find(\"../\") != std::string::npos)\n\t\treturn NULL;\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; \n\tif (sb.st_mode & S_IFDIR) { \n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { \n\t\tres = readFile(path, sb);\n\t} else { \n\t\treturn NULL;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n    lua_pushnil(_state);\n    lua_setglobal(_state, \"load\");\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n    cluaopen_globals(_state);\n    execfile(\"dlua/macro.lua\", true, true);\n    execstring(\"chk_startgame = { }\", \"base\");\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n    lua_register(_state, \"crawl_require\", _clua_require);\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 0}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "static FormatCode getFormatCode(const _AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\tassert(false);\n\treturn kUndefined;\n}", "target": 0}
{"code": "unknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", tpm2_error_get(rc));\n    return buf;\n}", "target": 1}
{"code": "x509_vfy_callback_indicate_success(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 1}
{"code": "static struct sock *__udp4_lib_mcast_demux_lookup(struct net *net,\n\t\t\t\t\t\t  __be16 loc_port, __be32 loc_addr,\n\t\t\t\t\t\t  __be16 rmt_port, __be32 rmt_addr,\n\t\t\t\t\t\t  int dif)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(loc_port);\n\tunsigned int count, slot = udp_hashfn(net, hnum, udp_table.mask);\n\tstruct udp_hslot *hslot = &udp_table.hash[slot];\n\tif (hslot->count > 10)\n\t\treturn NULL;\n\trcu_read_lock();\nbegin:\n\tcount = 0;\n\tresult = NULL;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tif (__udp_is_mcast_sock(net, sk,\n\t\t\t\t\tloc_port, loc_addr,\n\t\t\t\t\trmt_port, rmt_addr,\n\t\t\t\t\tdif, hnum)) {\n\t\t\tresult = sk;\n\t\t\t++count;\n\t\t}\n\t}\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\tif (result) {\n\t\tif (count != 1 ||\n\t\t    unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(!__udp_is_mcast_sock(net, result,\n\t\t\t\t\t\t       loc_port, loc_addr,\n\t\t\t\t\t\t       rmt_port, rmt_addr,\n\t\t\t\t\t\t       dif, hnum))) {\n\t\t\tsock_put(result);\n\t\t\tresult = NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}", "target": 0}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n{\n\tif (caplen <= 1) { \n\t\tND_PRINT((ndo, \"|OSI\"));\n\t\treturn;\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n\tcase NLPID_CLNP:\n\t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n\tcase NLPID_ISIS:\n\t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {\n\tut64 sz = 0;\n\tif (evp == NULL) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tif (evp->value) {\n\t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\t}\n\treturn sz;\n}", "target": 1}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "static void evdev_queue_syn_dropped(struct evdev_client *client)\n{\n\tunsigned long flags;\n\tstruct input_event ev;\n\tktime_t time;\n\ttime = ktime_get();\n\tif (client->clkid != CLOCK_MONOTONIC)\n\t\ttime = ktime_sub(time, ktime_get_monotonic_offset());\n\tev.time = ktime_to_timeval(time);\n\tev.type = EV_SYN;\n\tev.code = SYN_DROPPED;\n\tev.value = 0;\n\tspin_lock_irqsave(&client->buffer_lock, flags);\n\tclient->buffer[client->head++] = ev;\n\tclient->head &= client->bufsize - 1;\n\tif (unlikely(client->head == client->tail)) {\n\t\tclient->tail = (client->head - 1) & (client->bufsize - 1);\n\t\tclient->packet_head = client->tail;\n\t}\n\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n}", "target": 0}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "cib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n    if (session == NULL) {\n        return NULL;\n    }\n    buf = calloc(1, chunk_size);\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n           __FUNCTION__, rdnSeqBuf_len);\n#endif\n    return -1;\n  }\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n  str = (char*)&packet->payload[offset+5];\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n  return(is_printable);\n}", "target": 0}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "void LibRaw::remove_caseSubstr(char *string, char *subStr) \n{\n  char *found;\n  while ((found = strcasestr(string,subStr))) {\n    if (!found) return;\n    int fill_len = strlen(subStr);\n    int p = found - string;\n    for (int i=p; i<p+fill_len; i++) {\n      string[i] = 32;\n    }\n  }\n  trimSpaces (string);\n}", "target": 0}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static int tiocgetd(struct tty_struct *tty, int __user *p)\n{\n\tstruct tty_ldisc *ld;\n\tint ret;\n\tld = tty_ldisc_ref_wait(tty);\n\tret = put_user(ld->ops->num, p);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}", "target": 0}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\tif ( input <= 0.0 || output <= 0.0 ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "s_free(STREAM s)\n{\n\tfree(s->data);\n\tfree(s);\n}", "target": 0}
{"code": "eb_get_object(struct eb_objects *eb, unsigned long handle)\n{\n\tif (eb->and < 0) {\n\t\tif (handle >= -eb->and)\n\t\t\treturn NULL;\n\t\treturn eb->lut[handle];\n\t} else {\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *node;\n\t\thead = &eb->buckets[handle & eb->and];\n\t\thlist_for_each(node, head) {\n\t\t\tstruct drm_i915_gem_object *obj;\n\t\t\tobj = hlist_entry(node, struct drm_i915_gem_object, exec_node);\n\t\t\tif (obj->exec_handle == handle)\n\t\t\t\treturn obj;\n\t\t}\n\t\treturn NULL;\n\t}\n}", "target": 0}
{"code": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\tcontext.id = \"client\";\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\tdb__open(&config);\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.subs);\n\tif(db.subs){\n\t\tsub = db.subs;\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}", "target": 1}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  \n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: \n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } ", "target": 0}
{"code": "sc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}", "target": 0}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* input_state = GetInput(context, node, kInputState);\n  const TfLiteTensor* gate_weight = GetInput(context, node, kGateWeight);\n  const TfLiteTensor* gate_bias = GetInput(context, node, kGateBias);\n  const TfLiteTensor* candidate_weight =\n      GetInput(context, node, kCandidateWeight);\n  const TfLiteTensor* candidate_bias = GetInput(context, node, kCandidateBias);\n  TfLiteTensor* output = GetOutput(context, node, kOutput);\n  TfLiteTensor* output_state = GetOutput(context, node, kOutputState);\n  TfLiteTensor* activation = GetTemporary(context, node, kActivation);\n  TfLiteTensor* concat = GetTemporary(context, node, kConcat);\n  auto cpu_backend_context = CpuBackendContext::GetFromContext(context);\n  if (gate_weight->type == kTfLiteFloat32) {\n    GruImpl(input, input_state, gate_weight, gate_bias, candidate_weight,\n            candidate_bias, output, output_state, activation, concat,\n            cpu_backend_context);\n  } else {\n    context->ReportError(context,\n                         \"Unsupported combination of data types for GruCell\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\tpr_warn(\"Shutting down device not found\\n\");\n\treturn NULL;\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma) { }", "target": 1}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 0}
{"code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}", "target": 1}
{"code": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}", "target": 1}
{"code": "initpyfribidi (void)\n{\n\tPyObject *module;\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}", "target": 1}
{"code": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}", "target": 1}
{"code": "char *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tchar *ret = NULL;\n\tint j;\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j< bin->dyn_entries; j++) {\n\t\tif (bin->dyn_buf[j].d_tag == DT_RPATH || bin->dyn_buf[j].d_tag == DT_RUNPATH) {\n\t\t\tif (!(ret = calloc (1, ELF_STRING_LENGTH))) {\n\t\t\t\tperror (\"malloc (rpath)\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return((image->columns+7)/8);\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}", "target": 1}
{"code": "static inline void exit_io_context(void)\n{\n}", "target": 1}
{"code": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 0}
{"code": "router_get_hashes_impl(const char *s, size_t s_len, digests_t *digests,\n                       const char *start_str,\n                       const char *end_str, char end_c)\n{\n  const char *start=NULL, *end=NULL;\n  if (router_get_hash_impl_helper(s,s_len,start_str,end_str,end_c,\n                                  &start,&end)<0)\n    return -1;\n  if (crypto_digest_all(digests, start, end-start)) {\n    log_warn(LD_BUG,\"couldn't compute digests\");\n    return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 0}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "\t\tauto GetKey(Local<Context> context) -> Local<Name> {\n\t\t\tauto key_inner = key->CopyInto();\n\t\t\treturn (key_inner->IsString() || key_inner->IsSymbol()) ?\n\t\t\t\tkey_inner.As<Name>() : Unmaybe(key_inner->ToString(context)).As<Name>();\n\t\t}", "target": 0}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "GF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n        apr_size_t len, int linelimit)\n{\n    apr_size_t i = 0;\n    while (i < len) {\n        char c = buffer[i];\n        ap_xlate_proto_from_ascii(&c, 1);\n        if (ctx->state == BODY_CHUNK_END) {\n            if (c == LF) {\n                ctx->state = BODY_CHUNK;\n            }\n            i++;\n            continue;\n        }\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                return APR_EGENERAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            ctx->chunkbits = sizeof(long) * 8;\n            ctx->chunk_used = 0;\n        }\n        if (c == ';' || c == CR) {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (c == LF) {\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state != BODY_CHUNK_EXT) {\n            int xvalue = 0;\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                return APR_EGENERAL;\n            }\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits <= 0 || ctx->remaining < 0) {\n                return APR_ENOSPC;\n            }\n        }\n        i++;\n    }\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n    return APR_SUCCESS;\n}", "target": 1}
{"code": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 1}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "void lcdSetPixels_ArrayBuffer_flat(JsGraphics *gfx, short x, short y, short pixelCount, unsigned int col) {\n  unsigned char *ptr = (unsigned char*)gfx->backendData;\n  unsigned int idx = lcdGetPixelIndex_ArrayBuffer(gfx,x,y,pixelCount);\n  ptr += idx>>3;\n  unsigned int whiteMask = (1U<<gfx->data.bpp)-1;\n  bool shortCut = (col==0 || (col&whiteMask)==whiteMask) && (!(gfx->data.flags&JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE)); \n  while (pixelCount--) { \n    if (gfx->data.bpp&7) {\n      idx = idx & 7;\n      if (shortCut && idx==0) {\n        int wholeBytes = (gfx->data.bpp*(pixelCount+1)) >> 3;\n        if (wholeBytes) {\n          char c = (char)(col?0xFF:0);\n          pixelCount = (short)(pixelCount+1 - (wholeBytes*8/gfx->data.bpp));\n          while (wholeBytes--) {\n            *ptr = c;\n            ptr++;\n          }\n          continue;\n        }\n      }\n      unsigned int mask = (unsigned int)(1<<gfx->data.bpp)-1;\n      unsigned int existing = (unsigned int)*ptr;\n      unsigned int bitIdx = (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB) ? 8-(idx+gfx->data.bpp) : idx;\n      assert(ptr>=gfx->backendData && ptr<((char*)gfx->backendData + graphicsGetMemoryRequired(gfx)));\n      *ptr = (char)((existing&~(mask<<bitIdx)) | ((col&mask)<<bitIdx));\n      if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE) {\n        ptr++;\n      } else {\n        idx += gfx->data.bpp;\n        if (idx>=8) ptr++;\n      }\n    } else { \n      int i;\n      for (i=0;i<gfx->data.bpp;i+=8) {\n        *ptr = (char)(col >> i);\n        ptr++;\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 0}
{"code": "int nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\t\t\tlen = skb->len - offset;\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n\t\tsk_eat_skb(sk, skb, 0);\n\t\tif (!desc->count)\n\t\t\tbreak;\n\t\ttp->copied_seq = seq;\n\t}\n\ttp->copied_seq = seq;\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}", "target": 0}
{"code": "static int send_header(void *data, const char *key, const char *val)\n{\n    ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,\n                key, \": \", val, CRLF, NULL);\n    return 1;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"handle must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }", "target": 0}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "static int update_server_from_aliases(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    if (!r->connection->vhost_lookup_data) { \n        if (matches_aliases(r->server, host)) {\n            s = r->server;\n            goto found;\n        }\n    }\n    return HTTP_BAD_REQUEST;\nfound:\n    r->server = s;\n    return HTTP_OK;\n}", "target": 0}
{"code": "static void dns_callback(void *arg, const struct sockaddr *sa, int salen)\n{\n\tstruct PgSocket *server = arg;\n\tstruct PgDatabase *db = server->pool->db;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_in6 sa_in6;\n\tserver->dns_token = NULL;\n\tif (!sa) {\n\t\tdisconnect_server(server, true, \"server dns lookup failed\");\n\t\treturn;\n\t} else if (sa->sa_family == AF_INET) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in, sa, sizeof(sa_in));\n\t\tsa_in.sin_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in;\n\t\tsalen = sizeof(sa_in);\n\t\tslog_debug(server, \"dns_callback: inet4: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in6, sa, sizeof(sa_in6));\n\t\tsa_in6.sin6_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in6;\n\t\tsalen = sizeof(sa_in6);\n\t\tslog_debug(server, \"dns_callback: inet6: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else {\n\t\tdisconnect_server(server, true, \"unknown address family: %d\", sa->sa_family);\n\t\treturn;\n\t}\n\tconnect_server(server, sa, salen);\n}", "target": 0}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "static void rose_timer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, timer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\t\n\tcase ROSE_STATE_4:\t\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose->state = ROSE_STATE_2;\n\t\trose_start_t3timer(sk);\n\t\tbreak;\n\tcase ROSE_STATE_2:\t\n\t\trose->neighbour->use--;\n\t\trose_disconnect(sk, ETIMEDOUT, -1, -1);\n\t\tbreak;\n\tcase ROSE_STATE_3:\t\n\t\tif (rose->condition & ROSE_COND_ACK_PENDING) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_enquiry_response(sk);\n\t\t}\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "cifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tWARN_ON(server->srv_count < 0);\n\tput_net(cifs_net_ns(server));\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tif (CIFS_SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\tif (from_reconnect)\n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\tcifs_crypto_secmech_release(server);\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\tserver->hostname = NULL;\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}", "target": 0}
{"code": "  AvgPoolGradOp(OpKernelConstruction* ctx, int num_spatial_dims)\n      : XlaOpKernel(ctx), num_spatial_dims_(num_spatial_dims) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(ctx, ksize_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateKernelSizes(ksize_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(ctx, stride_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateStrides(stride_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(ctx, padding_ != EXPLICIT,\n                errors::Unimplemented(\n                    \"XLA does not support avgpoolgrad with explicit padding.\"));\n    OP_REQUIRES(ctx, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    string data_format;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(ctx, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n  }", "target": 0}
{"code": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "njs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_object_t              *object;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n    promise = njs_argument(args, 0);\n    if (njs_slow_path(!njs_is_object(promise))) {\n        goto failed;\n    }\n    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n                                     njs_object_t);\n    if (njs_slow_path(object == NULL)) {\n        goto failed;\n    }\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n    njs_set_function(&constructor, function);\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\nfailed:\n    njs_type_error(vm, \"required a promise object\");\n    return NJS_ERROR;\n}", "target": 1}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\tif (radiotap_header->it_version)\n\t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  \n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 0}
{"code": "static inline void native_tss_invalidate_io_bitmap(void)\n{\n\tthis_cpu_write(cpu_tss_rw.x86_tss.io_bitmap_base,\n\t\t       IO_BITMAP_OFFSET_INVALID);\n}", "target": 0}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret > PARAM_MAX ) {\n    ret = defaultval;\n  }\n  if ( ret < 1 ) ret = defaultval;\n  return ret;\n}", "target": 0}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\treturn (err < 0) ? err : 0;\n}", "target": 0}
{"code": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\ti = port->index;\n\tmemset(&sync, 0, sizeof(sync));\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}", "target": 0}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    const TensorList* input_list = nullptr;\n    OP_REQUIRES_OK(c, GetInputList(c, 0, &input_list));\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n                errors::InvalidArgument(\"size must be a scalar\"));\n    int32_t size = c->input(1).scalar<int32>()();\n    OP_REQUIRES(\n        c, size >= 0,\n        errors::InvalidArgument(\n            \"TensorListSlice expects size to be non-negative. Got: \", size));\n    std::unique_ptr<Tensor> maybe_result =\n        c->forward_input(0, 0, DT_VARIANT, TensorShape{},\n                         c->input_memory_type(0), AllocatorAttributes());\n    if (maybe_result != nullptr) {\n      TensorList* out = maybe_result->scalar<Variant>()().get<TensorList>();\n      if (out->RefCountIsOne()) {\n        out->tensors().resize(size, Tensor(DT_INVALID));\n        c->set_output(0, *maybe_result);\n        return;\n      }\n    }\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    TensorList output_list;\n    output_list.element_shape = input_list->element_shape;\n    output_list.element_dtype = input_list->element_dtype;\n    output_list.max_num_elements = input_list->max_num_elements;\n    if (size > input_list->tensors().size()) {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().end());\n      output_list.tensors().resize(size, Tensor(DT_INVALID));\n    } else {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().begin() + size);\n    }\n    result->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "nl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}", "target": 0}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, output_tensor->type, kTfLiteInt64);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, output_tensor, outputSize);\n}", "target": 1}
{"code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\twrite_metapage(mp);\n\tIREAD_UNLOCK(ipbmap);\n\treturn (0);\n}", "target": 1}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "inline PointerReader ListReader::getPointerElement(ElementCount index) const {\n  return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>(\n      ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& values_tensor = ctx->input(0);\n    const Tensor& value_range_tensor = ctx->input(1);\n    const Tensor& nbins_tensor = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument(\"value_range should be a vector.\"));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    \"value_range should be a vector of 2 elements.\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument(\"nbins should be a scalar.\"));\n    const auto values = values_tensor.flat<T>();\n    const auto value_range = value_range_tensor.flat<T>();\n    const auto nbins = nbins_tensor.scalar<int32>()();\n    OP_REQUIRES(\n        ctx, (value_range(0) < value_range(1)),\n        errors::InvalidArgument(\"value_range should satisfy value_range[0] < \"\n                                \"value_range[1], but got '[\",\n                                value_range(0), \", \", value_range(1), \"]'\"));\n    OP_REQUIRES(\n        ctx, (nbins > 0),\n        errors::InvalidArgument(\"nbins should be a positive number, but got '\",\n                                nbins, \"'\"));\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nbins}), &out_tensor));\n    auto out = out_tensor->flat<Tout>();\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute(\n                 ctx, values, value_range, nbins, out));\n  }", "target": 1}
{"code": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\tpipe_lock(pipe);\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\tret = fuse_dev_do_write(fud, &cs, len);\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\nout:\n\tkvfree(bufs);\n\treturn ret;\n}", "target": 1}
{"code": "GF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n    if (type != EXPR_TYPE_INT)\n        return false;\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n    *val_rtrn = (1u << ndx);\n    return true;\n}", "target": 0}
{"code": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = \n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}", "target": 0}
{"code": "static inline u32 nla_get_u32(struct nlattr *nla)\n{\n\treturn *(u32 *) nla_data(nla);\n}", "target": 0}
{"code": "static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)\n{\n\tbdaddr_t bdaddr;\n\tint err;\n\tif (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))\n\t\treturn -EFAULT;\n\thci_dev_lock(hdev);\n\terr = hci_blacklist_add(hdev, &bdaddr, 0);\n\thci_dev_unlock(hdev);\n\treturn err;\n}", "target": 0}
{"code": "static void rb_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      struct ring_buffer_event *event)\n{\n\tlocal_inc(&cpu_buffer->entries);\n\trb_update_write_stamp(cpu_buffer, event);\n\trb_end_commit(cpu_buffer);\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestPrefixHeaderMatch) {\n  auto headers = TestRequestHeaderMapImpl{{\"prefix-header\", \"AAABBBjwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 2);\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_EQ(tokens[0]->token(), \"BBBjwt_token\");\n  EXPECT_TRUE(tokens[1]->isIssuerSpecified(\"issuer6\"));\n  EXPECT_EQ(tokens[1]->token(), \"jwt_token\");\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.get(Http::LowerCaseString(\"prefix-header\")));\n}", "target": 0}
{"code": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\tBUG_ON(parent == mnt);\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\tlist_splice(&head, n->list.prev);\n\tn->mounts += n->pending_mounts;\n\tn->pending_mounts = 0;\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}", "target": 0}
{"code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\tmemset(&u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\tent = find_entity(mdev, u_ent.id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\treturn info_for_irq(irq)->evtchn;\n}", "target": 1}
{"code": "irc_nick_realloc_prefixes (struct t_irc_server *server,\n                           int old_length, int new_length)\n{\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *new_prefixes;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        for (ptr_nick = ptr_channel->nicks; ptr_nick;\n             ptr_nick = ptr_nick->next_nick)\n        {\n            if (ptr_nick->prefixes)\n            {\n                new_prefixes = realloc (ptr_nick->prefixes, new_length + 1);\n                if (new_prefixes)\n                {\n                    ptr_nick->prefixes = new_prefixes;\n                    if (new_length > old_length)\n                    {\n                        memset (ptr_nick->prefixes + old_length,\n                                ' ',\n                                new_length - old_length);\n                    }\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n            else\n            {\n                ptr_nick->prefixes = malloc (new_length + 1);\n                if (ptr_nick->prefixes)\n                {\n                    memset (ptr_nick->prefixes, ' ', new_length);\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "int __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}", "target": 0}
{"code": "void Lab2ITU(const cmsCIELab* Lab, cmsUInt16Number Out[3])\n{\n\tOut[0] = (cmsUInt16Number) floor((double) (Lab -> L / 100.)* 65535. );\n\tOut[1] = (cmsUInt16Number) floor((double) (Lab -> a / 170.)* 65535. + 32768. );\n\tOut[2] = (cmsUInt16Number) floor((double) (Lab -> b / 200.)* 65535. + 24576. );\n}", "target": 0}
{"code": "static void free_todo_entries(TodoEntry **todos) {\n        for (TodoEntry *x = *todos; x && x->dir; x++) {\n                closedir(x->dir);\n                free(x->dirname);\n        }\n        freep(todos);\n}", "target": 0}
{"code": "static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n\t\topt = NULL;\n\trcu_read_unlock();\n\treturn opt;\n}", "target": 0}
{"code": "uint64_t HeaderMapImpl::byteSizeInternal() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 0}
{"code": "PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"EXIF Support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Supported EXIF Version\", \"0220\");\n\tphp_info_print_table_row(2, \"Supported filetypes\", \"JPEG, TIFF\");\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"enabled\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"disabled\");\n\t}\n\tphp_info_print_table_row(2, \"Extended EXIF tag formats\", \"Canon, Casio, Fujifilm, Nikon, Olympus, Samsung, Panasonic, DJI, Sony, Pentax, Minolta, Sigma, Foveon, Kyocera, Ricoh, AGFA, Epson\");\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "void audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tcontext = audit_get_context(tsk, 0, 0);\n\tif (likely(!context))\n\t\treturn;\n\tif (context->in_syscall && context->auditable)\n\t\taudit_log_exit(context, tsk);\n\taudit_free_context(context);\n}", "target": 0}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "int sss_certmap_expand_mapping_rule(struct sss_certmap_ctx *ctx,\n                                    const uint8_t *der_cert, size_t der_size,\n                                    char **_expanded, char ***_domains)\n{\n    return expand_mapping_rule_ex(ctx, der_cert, der_size, false,\n                                  _expanded, _domains);\n}", "target": 0}
{"code": "START_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}", "target": 1}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 0}
{"code": "static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)\n{\n\text4_io_end_t *io_end = bh->b_private;\n\tstruct workqueue_struct *wq;\n\tstruct inode *inode;\n\tunsigned long flags;\n\tif (!test_clear_buffer_uninit(bh) || !io_end)\n\t\tgoto out;\n\tif (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {\n\t\tprintk(\"sb umounted, discard end_io request for inode %lu\\n\",\n\t\t\tio_end->inode->i_ino);\n\t\text4_free_io_end(io_end);\n\t\tgoto out;\n\t}\n\tio_end->flag = EXT4_IO_UNWRITTEN;\n\tinode = io_end->inode;\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n\twq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\nout:\n\tbh->b_private = NULL;\n\tbh->b_end_io = NULL;\n\tclear_buffer_uninit(bh);\n\tend_buffer_async_write(bh, uptodate);\n}", "target": 0}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "static inline int mystrcmp(char **p, const char *sample)\n{\n    int len = strlen(sample);\n    if (strncmp(*p, sample, len) == 0) {\n        (*p) += len;\n        return 1;\n    } else\n        return 0;\n}", "target": 0}
{"code": "void BinaryProtocolReader::readStringBody(StrType& str, int32_t size) {\n  checkStringSize(size);\n  if (size == 0) {\n    str.clear();\n    return;\n  }\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n        if (fd < 0)\n                return -errno;\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 0}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \n    case kTfLiteFloat32:\n      return AverageEvalFloat<kernel_type>(context, node, params, data, input,\n                                           output);\n    case kTfLiteUInt8:\n      return AverageEvalQuantizedUint8<kernel_type>(context, node, params, data,\n                                                    input, output);\n    case kTfLiteInt8:\n      return AverageEvalQuantizedInt8<kernel_type>(context, node, params, data,\n                                                   input, output);\n    case kTfLiteInt16:\n      return AverageEvalQuantizedInt16<kernel_type>(context, node, params, data,\n                                                    input, output);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n    if (!lua_checkstack(lua, argc + 1)) {\n        ldbLogRedisReply(\"max lua stack reached\");\n        return;\n    }\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       \n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               \n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  \n    ldb.step = 0;               \n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             \n}", "target": 0}
{"code": "int extractVersionQuadFromString(const char* string, int* quad) {\n    const char* nextNumber = string;\n    for (int i = 0; i < 4; i++) {\n        quad[i] = (int)strtol(nextNumber, (char**)&nextNumber, 10);\n        if (*nextNumber != 0) {\n            nextNumber++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  PointInfo\n    resolution;\n  size_t\n    columns,\n    rows;\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  if (images != (Image *) NULL)\n    {\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}", "target": 0}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "static void add_binary_option(gpointer key, gpointer value, gpointer user_data)\n{\n\tuint8_t *option = value;\n\tstruct dhcp_packet *packet = user_data;\n\tdhcp_add_binary_option(packet, option);\n}", "target": 0}
{"code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\treturn 0;\n}", "target": 0}
{"code": "int rtnl_dump_request_n(struct rtnl_handle *rth, struct nlmsghdr *n)\n{\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct iovec iov = {\n\t\t.iov_base = n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tn->nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\tn->nlmsg_pid = 0;\n\tn->nlmsg_seq = rth->dump = ++rth->seq;\n\treturn sendmsg(rth->fd, &msg, 0);\n}", "target": 0}
{"code": "static void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t   union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint i;\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_RECONF:\n\t\t\tif (asoc->reconf_enable &&\n\t\t\t    !asoc->peer.reconf_capable)\n\t\t\t\tasoc->peer.reconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (asoc->prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_I_DATA:\n\t\t\tif (sctp_sk(asoc->base.sk)->strm_interleave)\n\t\t\t\tasoc->intl_enable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 0}
{"code": "std::unique_ptr<BytecodeModule> hbc::generateBytecode(\n    Module *M,\n    raw_ostream &OS,\n    const BytecodeGenerationOptions &options,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGen,\n    std::unique_ptr<BCProviderBase> baseBCProvider) {\n  auto BM = generateBytecodeModule(\n      M,\n      M->getTopLevelFunction(),\n      options,\n      segment,\n      sourceMapGen,\n      std::move(baseBCProvider));\n  if (!BM) {\n    return {};\n  }\n  if (options.format == OutputFormatKind::EmitBundle) {\n    assert(BM != nullptr);\n    BytecodeSerializer BS{OS, options};\n    BS.serialize(*BM, sourceHash);\n  }\n  if (sourceMapGen)\n    BM->populateSourceMap(sourceMapGen);\n  return BM;\n}", "target": 0}
{"code": "static inline void sem_unlock(struct sem_array *sma, int locknum)\n{\n\tif (locknum == -1) {\n\t\tspin_unlock(&sma->sem_perm.lock);\n\t} else {\n\t\tstruct sem *sem = sma->sem_base + locknum;\n\t\tspin_unlock(&sem->lock);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "struct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}", "target": 0}
{"code": "hybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}", "target": 0}
{"code": "hybiDecodeCleanup(ws_ctx_t *wsctx)\n{\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->nReadRaw = 0;\n  wsctx->nToRead= 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n  rfbLog(\"cleaned up wsctx\\n\");\n}", "target": 0}
{"code": "static int __init proc_genhd_init(void)\n{\n\tproc_create(\"diskstats\", 0, NULL, &proc_diskstats_operations);\n\tproc_create(\"partitions\", 0, NULL, &proc_partitions_operations);\n\treturn 0;\n}", "target": 0}
{"code": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void RtmpProtocol::sendInvoke(const string &cmd, const AMFValue &val) {\n    AMFEncoder enc;\n    enc << cmd << ++_send_req_id << val;\n    sendRequest(MSG_CMD, enc.data());\n}", "target": 0}
{"code": "R_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tr_str_ansi_strip (o);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}", "target": 0}
{"code": "static int rb_head_page_set(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t    struct buffer_page *head,\n\t\t\t    struct buffer_page *prev,\n\t\t\t    int old_flag, int new_flag)\n{\n\tstruct list_head *list;\n\tunsigned long val = (unsigned long)&head->list;\n\tunsigned long ret;\n\tlist = &prev->list;\n\tval &= ~RB_FLAG_MASK;\n\tret = cmpxchg((unsigned long *)&list->next,\n\t\t      val | old_flag, val | new_flag);\n\tif ((ret & ~RB_FLAG_MASK) != val)\n\t\treturn RB_PAGE_MOVED;\n\treturn ret & RB_FLAG_MASK;\n}", "target": 0}
{"code": "void rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n  FreeTLS(client);\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n  free(client->vncRec);\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif \n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n  free(client);\n}", "target": 0}
{"code": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n\twait_queue_t wait;\n\tunsigned long flags;\n\tif (!tty)\n\t\treturn;\n\tif (!timeout)\n\t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (serial->disconnected)\n\t\treturn;\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}", "target": 0}
{"code": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}", "target": 0}
{"code": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\n\t\t\t\tconst char *unix_socket)\n{\n\tGIOChannel *handle;\n\tIPADDR *own_ip = NULL;\n\tconst char *errmsg;\n\tchar *errmsg2;\n\tchar ipaddr[MAX_IP_LEN];\n        int port;\n\tg_return_if_fail(ip != NULL || unix_socket != NULL);\n\tsignal_emit(\"server connecting\", 2, server, ip);\n\tif (server->connrec->no_connect)\n\t\treturn;\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\tif (handle == NULL) {\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\tif (own_ip != NULL) {\n\t\t\t\tnet_ip2host(own_ip, ipaddr);\n\t\t\t\terrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n\t\t\t}\n\t\t\tserver->no_reconnect = TRUE;\n\t\t}\n\t\tif (server->connrec->use_ssl && errno == ENOSYS)\n\t\t\tserver->no_reconnect = TRUE;\n\t\tserver->connection_lost = TRUE;\n\t\tserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\n\t\tg_free(errmsg2);\n\t} else {\n\t\tserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\n\t\tif (server->connrec->use_ssl)\n\t\t\tserver_connect_callback_init_ssl(server, handle);\n\t\telse\n#endif\n\t\tserver->connect_tag =\n\t\t\tg_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n\t\t\t\t    (GInputFunction)\n\t\t\t\t    server_connect_callback_init,\n\t\t\t\t    server);\n\t}\n}", "target": 1}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "static void fpm_child_init(struct fpm_worker_pool_s *wp) \n{\n\tfpm_globals.max_requests = wp->config->pm_max_requests;\n\tfpm_globals.listening_socket = dup(wp->listening_socket);\n\tif (0 > fpm_stdio_init_child(wp)  ||\n\t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}", "target": 0}
{"code": "EXPORTED int examine_request(struct transaction_t *txn, const char *uri)\n{\n    int ret = 0, sasl_result = 0;\n    const char *query;\n    const struct namespace_t *namespace;\n    struct request_line_t *req_line = &txn->req_line;\n    if (!uri) uri = req_line->uri;\n    if ((ret = check_method(txn))) return ret;\n    if (!(txn->req_uri = parse_uri(txn->meth, uri, 1, &txn->error.desc))) {\n        return HTTP_BAD_REQUEST;\n    }\n    if ((ret = preauth_check_hdrs(txn))) return ret;\n    if ((ret = check_namespace(txn))) return ret;\n    ret = auth_check_hdrs(txn, &sasl_result);\n    if (ret && ret != HTTP_UNAUTHORIZED) return ret;\n    namespace = txn->req_tgt.namespace;\n    buf_printf(&txn->buf, \"%s%s\", config_ident,\n               namespace->well_known ? strrchr(namespace->well_known, '/') :\n               namespace->prefix);\n    proc_register(buf_cstring(&txn->buf), txn->conn->clienthost, httpd_userid,\n                  txn->req_tgt.path, txn->req_line.meth);\n    buf_reset(&txn->buf);\n    if (!httpd_userid && namespace->need_auth(txn)) {\n        ret = HTTP_UNAUTHORIZED;\n    }\n    if (ret) return client_need_auth(txn, sasl_result);\n    construct_hash_table(&txn->req_qparams, 10, 1);\n    query = URI_QUERY(txn->req_uri);\n    if (query) parse_query_params(txn, query);\n    postauth_check_hdrs(txn);\n    return 0;\n}", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "char* oidc_util_javascript_escape(apr_pool_t *pool, const char *s) {\n    const char *cp;\n    char *output;\n    size_t outputlen;\n    int i;\n    if (s == NULL) {\n        return NULL;\n    }\n    outputlen = 0;\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n        case '\"':\n        case '\\\\':\n        case '/':\n        case 0x0D:\n        case 0x0A:\n            outputlen += 2;\n            break;\n        case '<':\n        case '>':\n            outputlen += 4;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n    i = 0;\n    output = apr_palloc(pool, outputlen + 1);\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n            (void)strcpy(&output[i], \"\\\\'\");\n            i += 2;\n            break;\n        case '\"':\n            (void)strcpy(&output[i], \"\\\\\\\"\");\n            i += 2;\n            break;\n        case '\\\\':\n            (void)strcpy(&output[i], \"\\\\\\\\\");\n            i += 2;\n            break;\n        case '/':\n            (void)strcpy(&output[i], \"\\\\/\");\n            i += 2;\n            break;\n        case 0x0D:\n            (void)strcpy(&output[i], \"\\\\r\");\n            i += 2;\n            break;\n        case 0x0A:\n            (void)strcpy(&output[i], \"\\\\n\");\n            i += 2;\n            break;\n        case '<':\n            (void)strcpy(&output[i], \"\\\\x3c\");\n            i += 4;\n            break;\n        case '>':\n            (void)strcpy(&output[i], \"\\\\x3e\");\n            i += 4;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = '\\0';\n    return output;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape(\n      ctx->input(base_index + 2).vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}", "target": 1}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void sr_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t  int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\tif (phy_id) {\n\t\tnetdev_dbg(netdev, \"Only internal phy supported\\n\");\n\t\treturn;\n\t}\n\tnetdev_dbg(netdev, \"sr_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t   phy_id, loc, val);\n\tsr_share_write_word(dev, 1, loc, res);\n}", "target": 0}
{"code": "njs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = pargs->args.data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1,\n                            &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_rejected = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_rejected->u.native = njs_promise_any_reject_element_functions;\n    on_rejected->args_count = 1;\n    context = on_rejected->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    arguments[0] = capability->resolve;\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\tksm_migrate_page(newpage, page);\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}", "target": 1}
{"code": "static void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\tmctp_dev_put(mdev);\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.ping_group_range.range;\n\tunsigned int seq;\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}", "target": 0}
{"code": "static int php_curl_option_url(php_curl *ch, const char *url, const int len) \n{\n\tif (PG(open_basedir) && *PG(open_basedir)) {\n#if LIBCURL_VERSION_NUM >= 0x071304\n\t\tcurl_easy_setopt(ch->cp, CURLOPT_PROTOCOLS, CURLPROTO_ALL & ~CURLPROTO_FILE);\n#else\n\t\tphp_url *uri;\n\t\tif (!(uri = php_url_parse_ex(url, len))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid URL '%s'\", url);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (uri->scheme && !strncasecmp(\"file\", uri->scheme, sizeof(\"file\"))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Protocol 'file' disabled in cURL\");\n\t\t\tphp_url_free(uri);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_url_free(uri);\n#endif\n\t}\n\treturn php_curl_option_str(ch, CURLOPT_URL, url, len, 0);\n}", "target": 0}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tif ( *end == '\\n')\n\t\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       1, 1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }", "target": 1}
{"code": "bool VerifySparsity(const RuntimeShape& weights_shape,\n                    const RuntimeShape& input_shape,\n                    const RuntimeShape& output_shape,\n                    const TfLiteSparsity* sparsity) {\n  const int weights_dims_count = weights_shape.DimensionsCount();\n  const int output_dims_count = output_shape.DimensionsCount();\n  const int w0_size = sparsity->dim_metadata[0].dense_size;\n  const int accum_depth = weights_shape.Dims(weights_dims_count - 1);\n  const int output_elements = output_shape.FlatSize();\n  const int input_elements = input_shape.FlatSize();\n  const int batches = FlatSizeSkipDim(output_shape, output_dims_count - 1);\n  const int output_depth = MatchingDim(weights_shape, weights_dims_count - 2,\n                                       output_shape, output_dims_count - 1);\n  const int max_batch_index = batches - 1;\n  const int max_output = max_batch_index * output_depth + w0_size;\n  const int max_batch_depth = accum_depth * max_batch_index;\n  if (output_elements < max_output) return false;\n  for (int i = 0; i < sparsity->dim_metadata[1].array_indices->size; ++i) {\n    if (input_elements <=\n        max_batch_depth + sparsity->dim_metadata[1].array_indices->data[i])\n      return false;\n  }\n  return true;\n}", "target": 0}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tnr = 0; \n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 0}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "        friend std::ostream& operator<<(std::ostream& os, const query_string& qs)\n        {\n            os << \"[ \";\n            for (size_t i = 0; i < qs.key_value_pairs_.size(); ++i)\n            {\n                if (i)\n                    os << \", \";\n                os << qs.key_value_pairs_[i];\n            }\n            os << \" ]\";\n            return os;\n        }", "target": 0}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "static int vhost_vdpa_open(struct inode *inode, struct file *filep)\n{\n\tstruct vhost_vdpa *v;\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint nvqs, i, r, opened;\n\tv = container_of(inode->i_cdev, struct vhost_vdpa, cdev);\n\topened = atomic_cmpxchg(&v->opened, 0, 1);\n\tif (opened)\n\t\treturn -EBUSY;\n\tnvqs = v->nvqs;\n\tr = vhost_vdpa_reset(v);\n\tif (r)\n\t\tgoto err;\n\tvqs = kmalloc_array(nvqs, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev = &v->vdev;\n\tfor (i = 0; i < nvqs; i++) {\n\t\tvqs[i] = &v->vqs[i];\n\t\tvqs[i]->handle_kick = handle_vq_kick;\n\t}\n\tvhost_dev_init(dev, vqs, nvqs, 0, 0, 0, false,\n\t\t       vhost_vdpa_process_iotlb_msg);\n\tdev->iotlb = vhost_iotlb_alloc(0, 0);\n\tif (!dev->iotlb) {\n\t\tr = -ENOMEM;\n\t\tgoto err_init_iotlb;\n\t}\n\tr = vhost_vdpa_alloc_domain(v);\n\tif (r)\n\t\tgoto err_init_iotlb;\n\tvhost_vdpa_set_iova_range(v);\n\tfilep->private_data = v;\n\treturn 0;\nerr_init_iotlb:\n\tvhost_dev_cleanup(&v->vdev);\n\tkfree(vqs);\nerr:\n\tatomic_dec(&v->opened);\n\treturn r;\n}", "target": 0}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      context->ReportError(context,\n                           \"Params type '%s' are not supported by gather_nd.\",\n                           TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "skip_varname(const char *s, bool aok)\n{\n\tsize_t alen;\n\tif (s && ksh_isalphx(*s)) {\n\t\twhile (*++s && ksh_isalnux(*s))\n\t\t\t;\n\t\tif (aok && *s == '[' && (alen = array_ref_len(s)))\n\t\t\ts += alen;\n\t}\n\treturn (s);\n}", "target": 0}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "gsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n        if (client->priv->protocol_timeout) {\n                g_source_remove (client->priv->protocol_timeout);\n                client->priv->protocol_timeout = 0;\n        }\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n        *mask_ret = 0;\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}", "target": 1}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n  int res, xerrno = 0;\n  struct stat st;\n  char *ptr;\n  if (pathlen == 0) {\n    return 0;\n  }\n  pr_fs_clear_cache();\n  res = pr_fsio_lstat(path, &st);\n  if (res < 0) {\n    xerrno = errno;\n    pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n      strerror(xerrno));\n    errno = xerrno;\n    return -1;\n  }\n  if (S_ISLNK(st.st_mode)) {\n    errno = EPERM;\n    return -1;\n  }\n  ptr = strrchr(path, '/');\n  if (ptr != NULL) {\n    char *new_path;\n    size_t new_pathlen;\n    pr_signals_handle();\n    new_pathlen = ptr - path;\n    if (new_pathlen == pathlen) {\n      return 0;\n    }\n    new_path = pstrndup(p, path, new_pathlen);\n    pr_log_debug(DEBUG10,\n      \"AllowChrootSymlink: path '%s' not a symlink, checking '%s'\", path,\n      new_path);\n    res = is_symlink_path(p, new_path, new_pathlen);\n    if (res < 0) {\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\nerror:\n\tkfree(mc);\n\treturn NULL;\n}", "target": 1}
{"code": "acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,\n\t\t\t\t  void *context)\n{\n\tunsigned int irq;\n\tacpi_irq_stats_init();\n\tif (gsi != acpi_gbl_FADT.sci_interrupt)\n\t\treturn AE_BAD_PARAMETER;\n\tif (acpi_irq_handler)\n\t\treturn AE_ALREADY_ACQUIRED;\n\tif (acpi_gsi_to_irq(gsi, &irq) < 0) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (ACPI GSI %d) not registered\\n\",\n\t\t       gsi);\n\t\treturn AE_OK;\n\t}\n\tacpi_irq_handler = handler;\n\tacpi_irq_context = context;\n\tif (request_irq(irq, acpi_irq, IRQF_SHARED, \"acpi\", acpi_irq)) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (IRQ%d) allocation failed\\n\", irq);\n\t\tacpi_irq_handler = NULL;\n\t\treturn AE_NOT_ACQUIRED;\n\t}\n\tacpi_sci_irq = irq;\n\treturn AE_OK;\n}", "target": 0}
{"code": "ConnectionManagerImpl::ActiveStream::~ActiveStream() {\n  stream_info_.onRequestComplete();\n  if (!stream_info_.hasAnyResponseFlag() && !stream_info_.responseCode()) {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination);\n  }\n  connection_manager_.stats_.named_.downstream_rq_active_.dec();\n  if (request_headers_ != nullptr) {\n    request_headers_->refreshByteSize();\n  }\n  if (response_headers_ != nullptr) {\n    response_headers_->refreshByteSize();\n  }\n  if (response_trailers_ != nullptr) {\n    response_trailers_->refreshByteSize();\n  }\n  for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n    access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                    stream_info_);\n  }\n  for (const auto& log_handler : access_log_handlers_) {\n    log_handler->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n  }\n  if (stream_info_.healthCheck()) {\n    connection_manager_.config_.tracingStats().health_check_.inc();\n  }\n  if (active_span_) {\n    Tracing::HttpTracerUtility::finalizeDownstreamSpan(\n        *active_span_, request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n        stream_info_, *this);\n  }\n  if (state_.successful_upgrade_) {\n    connection_manager_.stats_.named_.downstream_cx_upgrades_active_.dec();\n  }\n  ASSERT(state_.filter_call_state_ == 0);\n}", "target": 0}
{"code": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}", "target": 1}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\tspin_lock_init(&port->dev_list_lock);\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}", "target": 1}
{"code": "static inline void skb_queue_splice_tail(const struct sk_buff_head *list,\n\t\t\t\t\t struct sk_buff_head *head)\n{\n\tif (!skb_queue_empty(list)) {\n\t\t__skb_queue_splice(list, head->prev, (struct sk_buff *) head);\n\t\thead->qlen += list->qlen;\n\t}\n}", "target": 0}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "static QString mountPoint(const RemoteFsDevice::Details &details, bool create)\n{\n    if (details.isLocalFile()) {\n        return details.url.path();\n    }\n    return Utils::cacheDir(QLatin1String(\"mount/\")+details.name, create);\n}", "target": 0}
{"code": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& image = context->input(0);\n    OP_REQUIRES(context, image.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        image.shape().DebugString()));\n    OP_REQUIRES(context, image.NumElements() > 0,\n                errors::Internal(\"Invalid image provided.\"));\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n        errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n    const int32 height = static_cast<int32>(image.dim_size(0));\n    const int32 width = static_cast<int32>(image.dim_size(1));\n    const int32 channels = static_cast<int32>(image.dim_size(2));\n    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                errors::InvalidArgument(\"image too wide to encode\"));\n    OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                errors::InvalidArgument(\n                    \"image must have 1, 2, 3, or 4 channels, got \", channels));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &output));\n    if (desired_channel_bits_ == 8) {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint8>().data(), width, height,\n                      width * channels, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    } else {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint16>().data(), width, height,\n                      width * channels * 2, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    }\n  }", "target": 0}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}", "target": 1}
{"code": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    if (!hashtable_seed) {\n        json_object_seed(0);\n    }\n    json_init(&object->json, JSON_OBJECT);\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n    object->serial = 0;\n    object->visited = 0;\n    return &object->json;\n}", "target": 0}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "ldns_str2rdf_tag(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data;\n\tconst char* ptr;\n\tif (strlen(str) > 255) {\n\t\treturn LDNS_STATUS_INVALID_TAG;\n\t}\n\tfor (ptr = str; *ptr; ptr++) {\n\t\tif (! isalnum((unsigned char)*ptr)) {\n\t\t\treturn LDNS_STATUS_INVALID_TAG;\n\t\t}\n\t}\n\tdata = LDNS_XMALLOC(uint8_t, strlen(str) + 1);\n        if (!data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\tdata[0] = strlen(str);\n\tmemcpy(data + 1, str, strlen(str));\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_TAG, strlen(str) + 1, data);\n\tif (!*rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n\tND_TCHECK2(*s, 1);\n    }\n    return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 0}
{"code": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\t   struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n}", "target": 0}
{"code": "static void perform_renew(void)\n{\n\tbb_info_msg(\"Performing a DHCP renew\");\n\tswitch (state) {\n\tcase BOUND:\n\t\tchange_listen_mode(LISTEN_KERNEL);\n\tcase RENEWING:\n\tcase REBINDING:\n\t\tstate = RENEW_REQUESTED;\n\t\tbreak;\n\tcase RENEW_REQUESTED: \n\t\tudhcp_run_script(NULL, \"deconfig\");\n\tcase REQUESTING:\n\tcase RELEASED:\n\t\tchange_listen_mode(LISTEN_RAW);\n\t\tstate = INIT_SELECTING;\n\t\tbreak;\n\tcase INIT_SELECTING:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!data || !length) return GF_BAD_PARAM;\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\t\tgf_filter_pck_send(pck);\n\t}\n\tif (txtin_check_blocking(ctx))\n\t\tctx->is_suspended = GF_TRUE;\n\treturn GF_OK;", "target": 0}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}", "target": 1}
{"code": "static inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 0}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "static int amf_get_field_value2(GetByteContext *gb,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n        int ret = amf_tag_skip(gb);\n        if (ret < 0)\n            return -1;\n    }\n    if (bytestream2_get_bytes_left(gb) < 3)\n        return -1;\n    bytestream2_get_byte(gb);\n    for (;;) {\n        int size = bytestream2_get_be16(gb);\n        if (!size)\n            break;\n        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n            return -1;\n        bytestream2_skip(gb, size);\n        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n            switch (bytestream2_get_byte(gb)) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream2_get_be16(gb);\n                if (dst_size < 1)\n                    return -1;\n                if (dst_size < len + 1)\n                    len = dst_size - 1;\n                bytestream2_get_buffer(gb, dst, len);\n                dst[len] = 0;\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = amf_tag_skip(gb);\n        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n            return -1;\n    }\n    return -1;\n}", "target": 0}
{"code": "FramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_pixelBuffer(nullptr)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}", "target": 1}
{"code": "static int seed_from_windows_cryptoapi(uint32_t *seed)\n{\n    HINSTANCE hAdvAPI32 = NULL;\n    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n    CRYPTGENRANDOM pCryptGenRandom = NULL;\n    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n    HCRYPTPROV hCryptProv = 0;\n    BYTE data[sizeof(uint32_t)];\n    int ok;\n    hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");\n    if(hAdvAPI32 == NULL)\n        return 1;\n    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \"CryptAcquireContextA\");\n    if (!pCryptAcquireContext)\n        return 1;\n    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \"CryptGenRandom\");\n    if (!pCryptGenRandom)\n        return 1;\n    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \"CryptReleaseContext\");\n    if (!pCryptReleaseContext)\n        return 1;\n    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n        return 1;\n    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n    pCryptReleaseContext(hCryptProv, 0);\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32((char *)data);\n    return 0;\n}", "target": 0}
{"code": "static void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN, decode_open_maxsz, hdr);\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "target": 0}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "void log_flush(LOG_MODE new_mode) {\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);\n    if(log_mode!=LOG_MODE_CONFIGURED || new_mode!=LOG_MODE_ERROR)\n        log_mode=new_mode;\n    if(new_mode!=LOG_MODE_BUFFER) {\n        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);\n        while(head) {\n            struct LIST *tmp=head;\n            head=head->next;\n            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);\n            str_free(tmp);\n        }\n        head=tail=NULL;\n        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);\n}", "target": 1}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "static int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}", "target": 0}
{"code": "ModuleSQL::~ModuleSQL()\n{\n\tif (Dispatcher)\n\t{\n\t\tDispatcher->join();\n\t\tDispatcher->OnNotify();\n\t\tdelete Dispatcher;\n\t}\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tdelete i->second;\n\t}\n\tmysql_library_end();\n}", "target": 0}
{"code": "device_linux_md_stop_authorized_cb (Daemon *daemon,\n                                    Device *device,\n                                    DBusGMethodInvocation *context,\n                                    const gchar *action_id,\n                                    guint num_user_data,\n                                    gpointer *user_data_elements)\n{\n  int n;\n  char *argv[10];\n  GError *error;\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--stop\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"LinuxMdStop\", TRUE, device, argv, NULL, linux_md_stop_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 0}
{"code": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n        assert(t);\n        if (unit_stop_pending(UNIT(t)))\n                return;\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n        dual_timestamp_get(&t->last_trigger);\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n        timer_set_state(t, TIMER_RUNNING);\n        return;\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}", "target": 1}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n\t}\n\tskb->len = hdrlen + per_fragm;\n\treturn 0;\n}", "target": 1}
{"code": "int IniParser::write_file(const string & filename, IniSection & section)\n{\n    Pathname pn(filename);\n    PathInfo::assert_dir (pn.dirname ());\n    mode_t file_umask = section.isPrivate()? 0077: 0022;\n    mode_t orig_umask = umask(file_umask);\n    unlink(filename.c_str());\n    ofstream of(filename.c_str());\n    if (!of.good()) {\n        y2error (\"Can not open file %s for write\", filename.c_str());\n        return -1;\n    }\n    write_helper (section, of, 0);\n    of.close();\n    umask(orig_umask);\n    return 0;\n}", "target": 0}
{"code": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\n\t\treturn;\n\tif (task_no_new_privs(current))\n\t\treturn;\n\tinode = file_inode(bprm->file);\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\tmutex_lock(&inode->i_mutex);\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmutex_unlock(&inode->i_mutex);\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  auto size = (std::is_integral<T>::value\n                   ? ((Eigen::numext::abs(limit - start) +\n                       Eigen::numext::abs(delta) - T(1)) /\n                      Eigen::numext::abs(delta))\n                   : (Eigen::numext::ceil(\n                         Eigen::numext::abs((limit - start) / delta))));\n  if (size > std::numeric_limits<int64_t>::max()) {\n    return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                   std::numeric_limits<int64_t>::max());\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}", "target": 1}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tstruct evtchn_loop_ctrl ctrl = { 0 };\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu, &ctrl);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n\t__this_cpu_inc(irq_epoch);\n}", "target": 0}
{"code": "static long vhost_vdpa_set_config_call(struct vhost_vdpa *v, u32 __user *argp)\n{\n\tstruct vdpa_callback cb;\n\tint fd;\n\tstruct eventfd_ctx *ctx;\n\tcb.callback = vhost_vdpa_config_cb;\n\tcb.private = v->vdpa;\n\tif (copy_from_user(&fd, argp, sizeof(fd)))\n\t\treturn  -EFAULT;\n\tctx = fd == VHOST_FILE_UNBIND ? NULL : eventfd_ctx_fdget(fd);\n\tswap(ctx, v->config_ctx);\n\tif (!IS_ERR_OR_NULL(ctx))\n\t\teventfd_ctx_put(ctx);\n\tif (IS_ERR(v->config_ctx))\n\t\treturn PTR_ERR(v->config_ctx);\n\tv->vdpa->config->set_config_cb(v->vdpa, &cb);\n\treturn 0;\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"Bundle-ID %u: \", l2info.bundle));\n        p+=l2info.header_len;\n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            return l2info.header_len;\n        default:\n            break;\n        }\n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n    graphic_hw_update(vd->dcl.con);\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n    }\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}", "target": 0}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}", "target": 1}
{"code": "static int smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)\n{\n\tint free_len;\n\tfree_len = (int)(work->response_sz -\n\t\t(get_rfc1002_len(work->response_buf) + 4)) - hdr2_len;\n\treturn free_len;\n}", "target": 0}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "__acquires(&fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tif (!fc->connected)\n\t\tgoto out_free;\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\tgoto out_free;\n\t}\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}", "target": 0}
{"code": "static void xennet_make_txreqs(\n\tstruct xennet_gnttab_make_txreq *info,\n\tstruct page *page,\n\tunsigned int offset, unsigned int len)\n{\n\tpage += offset >> PAGE_SHIFT;\n\toffset &= ~PAGE_MASK;\n\twhile (len) {\n\t\tinfo->page = page;\n\t\tinfo->size = 0;\n\t\tgnttab_foreach_grant_in_range(page, offset, len,\n\t\t\t\t\t      xennet_make_one_txreq,\n\t\t\t\t\t      info);\n\t\tpage++;\n\t\toffset = 0;\n\t\tlen -= info->size;\n\t}\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}", "target": 1}
{"code": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return ksize_;\n    }\n    const TensorShape ksize_shape = ctx->InputShape(1);\n    if (!TensorShapeUtils::IsVector(ksize_shape)) {\n      return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                     ksize_shape.DebugString());\n    }\n    if (ksize_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> ksize;\n    auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n    if (!status.ok()) {\n      return status;\n    }\n    return ksize;\n  }", "target": 1}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n}", "target": 0}
{"code": "static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)\n{\n\tmemset(task, 0, sizeof(*task));\n\tatomic_set(&task->tk_count, 1);\n\ttask->tk_flags  = task_setup_data->flags;\n\ttask->tk_ops = task_setup_data->callback_ops;\n\ttask->tk_calldata = task_setup_data->callback_data;\n\tINIT_LIST_HEAD(&task->tk_task);\n\ttask->tk_garb_retry = 2;\n\ttask->tk_cred_retry = 2;\n\ttask->tk_rebind_retry = 2;\n\ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n\ttask->tk_owner = current->tgid;\n\ttask->tk_workqueue = task_setup_data->workqueue;\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\ttask->tk_action = rpc_prepare_task;\n\ttask->tk_start = ktime_get();\n\tdprintk(\"RPC:       new task initialized, procpid %u\\n\",\n\t\t\t\ttask_pid_nr(current));\n}", "target": 0}
{"code": "\t\tauto GetTargetAndAlsoCheckForProxy() -> Local<Object> {\n\t\t\tauto object = Local<Object>::Cast(Deref(target));\n\t\t\tif (HasProxy(object)) {\n\t\t\t\tthrow RuntimeTypeError(\"Object is or has proxy\");\n\t\t\t}\n\t\t\treturn object;\n\t\t}", "target": 0}
{"code": "unique_ptr<IOBuf> IOBuf::takeOwnership(\n    void* buf,\n    std::size_t capacity,\n    std::size_t offset,\n    std::size_t length,\n    FreeFunction freeFn,\n    void* userData,\n    bool freeOnError,\n    TakeOwnershipOption option) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  DCHECK(\n      !userData || (userData && freeFn) ||\n      (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)));\n  HeapFullStorage* storage = nullptr;\n  auto rollback = makeGuard([&] {\n    if (storage) {\n      free(storage);\n    }\n    takeOwnershipError(freeOnError, buf, freeFn, userData);\n  });\n  size_t requiredStorage = sizeof(HeapFullStorage);\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix)\n      HeapPrefix(kIOBufInUse | kSharedInfoInUse, mallocSize);\n  new (&storage->shared)\n      SharedInfo(freeFn, userData, true );\n  auto result = unique_ptr<IOBuf>(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      static_cast<uint8_t*>(buf),\n      capacity,\n      static_cast<uint8_t*>(buf) + offset,\n      length));\n  rollback.dismiss();\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n    if (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)) {\n      io_buf_alloc_cb(buf, capacity);\n    }\n  }\n  return result;\n}", "target": 0}
{"code": "SIZED_STRING* sized_string_dup(\n    SIZED_STRING* s)\n{\n  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n      sizeof(SIZED_STRING) + s->length);\n  if (result == NULL)\n    return NULL;\n  result->length = s->length;\n  result->flags = s->flags;\n  strncpy(result->c_string, s->c_string, s->length + 1);\n  return result;\n}", "target": 0}
{"code": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "uint64_t countBytesForTest(const HeaderMapImpl& headers) {\n  uint64_t byte_size = 0;\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto* byte_size = static_cast<uint64_t*>(context);\n        *byte_size += header.key().getStringView().size() + header.value().getStringView().size();\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &byte_size);\n  return byte_size;\n}", "target": 0}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_ISO_8859_2_TO_LOWER_CASE(code);\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_LOWER)\n       && (flags & ONIGENC_CASE_UPCASE)) {\n      if (code >= 0xB1 && code <= 0xBF) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x10;\n      }\n      else {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x20;\n      }\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "    LoaderExifDataJpeg::LoaderExifDataJpeg(PreviewId id, const Image &image, int parIdx)\n        : Loader(id, image),\n          dataKey_(param_[parIdx].dataKey_)\n    {\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            size_ = pos->sizeDataArea(); \n            if (size_ == 0 && pos->typeId() == undefined)\n                size_ = pos->size(); \n        }\n        if (size_ == 0) return;\n        valid_ = true;\n    }", "target": 0}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->stacksize = 0;\n  L->twups = L;  \n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}", "target": 0}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; \n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "void LibRaw::android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}", "target": 0}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "static void ide_atapi_cmd_read(IDEState *s, int lba, int nb_sectors,\n                               int sector_size)\n{\n#ifdef DEBUG_IDE_ATAPI\n    printf(\"read %s: LBA=%d nb_sectors=%d\\n\", s->atapi_dma ? \"dma\" : \"pio\",\n        lba, nb_sectors);\n#endif\n    if (s->atapi_dma) {\n        ide_atapi_cmd_read_dma(s, lba, nb_sectors, sector_size);\n    } else {\n        ide_atapi_cmd_read_pio(s, lba, nb_sectors, sector_size);\n    }\n}", "target": 0}
{"code": "void test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}", "target": 1}
{"code": "static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,\n\t\t\t\tunsigned int stack_top, const struct smm_loader_params *params)\n{\n\tunsigned int i;\n\tunsigned int size;\n\tif (smm_create_map(smbase, num_cpus, params)) {\n\t\tif (cpus[num_cpus].active) {\n\t\t\tif (cpus[num_cpus - 1].smbase +\n\t\t\t\tparams->smm_main_entry_offset < stack_top) {\n\t\t\t\tprintk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);\n\t\t\t\tprintk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t\t\t\t__func__, cpus[num_cpus].smbase, stack_top);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);\n\t\treturn 0;\n\t}\n\tprintk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t__func__, cpus[num_cpus-1].smbase, stack_top);\n\tsize = cpus[0].code_end - cpus[0].code_start;\n\tfor (i = 1; i < num_cpus; i++) {\n\t\tmemcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);\n\t\tprintk(BIOS_DEBUG,\n\t\t\t\"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",\n\t\t\tcpus[i].code_start, i);\n\t\tprintk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",\n\t\t\t__func__, cpus[0].code_start, cpus[i].code_start, size);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}", "target": 1}
{"code": "static int region_list_contains_offset(struct fdt_region_state *info,\n\t\t\t\t       const void *fdt, int target)\n{\n\tstruct fdt_region *reg;\n\tint num;\n\ttarget += fdt_off_dt_struct(fdt);\n\tfor (reg = info->region, num = 0; num < info->count; reg++, num++) {\n\t\tif (target >= reg->offset && target < reg->offset + reg->size)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\tif ((unsigned long)key & alignmask)\n\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n\treturn cipher->setkey(tfm, key, keylen);\n}", "target": 0}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "crm_create_anon_tls_session(int csock, int type , void *credentials)\n{\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n    case GNUTLS_SERVER:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n        break;\n    case GNUTLS_CLIENT:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n        break;\n    }\n    return session;\n}", "target": 0}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "static const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\treturn buf.buf;\n}", "target": 0}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\tready = xchg(&control_block->ready, 0);\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}", "target": 1}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\tbond->params = bonding_defaults;\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\tbond_dev->destructor = bond_destructor;\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\tbond_dev->features |= NETIF_F_LLTX;\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}", "target": 1}
{"code": "callbacks_new_project_activate (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tif (mainProject->last_loaded >= 0) {\n\t\tif (!interface_get_alert_dialog_response (\n\t\t\t_(\"Do you want to close any open layers \"\n\t\t\t\"and start a new project?\"),\n\t\t\t_(\"Starting a new project will cause all currently \"\n\t\t\t\"open layers to be closed. Any unsaved changes \"\n\t\t\t\"will be lost.\"),\n\t\t\tFALSE, NULL, GTK_STOCK_CLOSE, GTK_STOCK_CANCEL))\n\t\t\treturn;\n\t}\n\tgerbv_unload_all_layers (mainProject);\n\tcallbacks_update_layer_tree ();\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\tif (mainProject->project) {\n\t    g_free(mainProject->project);\n\t    mainProject->project = NULL;\n\t}\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "void FoFiTrueType::cvtEncoding(char **encoding,\n\t\t\t       FoFiOutputFunc outputFunc,\n\t\t\t       void *outputStream) {\n  const char *name;\n  GooString *buf;\n  int i;\n  (*outputFunc)(outputStream, \"/Encoding 256 array\\n\", 20);\n  if (encoding) {\n    for (i = 0; i < 256; ++i) {\n      if (!(name = encoding[i])) {\n\tname = \".notdef\";\n      }\n      buf = GooString::format(\"dup {0:d} /\", i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n      (*outputFunc)(outputStream, name, strlen(name));\n      (*outputFunc)(outputStream, \" put\\n\", 5);\n    }\n  } else {\n    for (i = 0; i < 256; ++i) {\n      buf = GooString::format(\"dup {0:d} /c{1:02x} put\\n\", i, i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n    }\n  }\n  (*outputFunc)(outputStream, \"readonly def\\n\", 13);\n}", "target": 0}
{"code": "rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t   struct ring_buffer_event *event)\n{\n\tunsigned long addr = (unsigned long)event;\n\tstruct buffer_page *bpage = cpu_buffer->commit_page;\n\tstruct buffer_page *start;\n\taddr &= PAGE_MASK;\n\tif (likely(bpage->page == (void *)addr)) {\n\t\tlocal_dec(&bpage->entries);\n\t\treturn;\n\t}\n\trb_inc_page(cpu_buffer, &bpage);\n\tstart = bpage;\n\tdo {\n\t\tif (bpage->page == (void *)addr) {\n\t\t\tlocal_dec(&bpage->entries);\n\t\t\treturn;\n\t\t}\n\t\trb_inc_page(cpu_buffer, &bpage);\n\t} while (bpage != start);\n\tRB_WARN_ON(cpu_buffer, 1);\n}", "target": 0}
{"code": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\treturn 0;\n}", "target": 0}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "u8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\tnfc_llcp_build_gb(local);\n\t*general_bytes_len = local->gb_len;\n\tnfc_llcp_local_put(local);\n\treturn local->gb;\n}", "target": 0}
{"code": "static int srv_init(uint16_t lport)\n{\n\tstruct sa laddr;\n\tstruct tcp_sock *tsock;\n\tint err;\n\tinfo(\"srv_init: lport=%d\\n\", (int)lport);\n\terr = sa_set_str(&laddr, \"0.0.0.0\", lport);\n\tif (err)\n\t\treturn err;\n\terr = http_listen(&verifyd.sock, &laddr, http_req_handler, NULL);\n\tif (err) {\n\t\tre_fprintf(stderr, \"http_listen: failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\ttsock = http_sock_tcp(verifyd.sock);\n\tif (tsock) {\n\t\ttcp_sock_local_get(tsock, &laddr);\n\t}\n\tre_fprintf(stderr, \"verifyd: listening on %J\\n\", &laddr);\n\treturn 0;\n}", "target": 0}
{"code": "int gru_handle_user_call_os(unsigned long cb)\n{\n\tstruct gru_tlb_fault_handle *tfh;\n\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\tSTAT(call_os);\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\tgru_check_context_placement(gts);\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\tret = -EAGAIN;\n\tcbrnum = thread_cbr_number(gts, ucbnum);\n\tif (gts->ts_gru) {\n\t\ttfh = get_tfh_by_index(gts->ts_gru, cbrnum);\n\t\tcbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,\n\t\t\t\tgts->ts_ctxnum, ucbnum);\n\t\tret = gru_user_dropin(gts, tfh, cbk);\n\t}\nexit:\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 1}
{"code": "inline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}", "target": 0}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "juniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        mh = (const struct juniper_monitor_header *)p;\n        ND_TCHECK(*mh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                   EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }", "target": 0}
{"code": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}", "target": 1}
{"code": "int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) \n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}", "target": 0}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "int ziplistSafeToAdd(unsigned char* zl, size_t add) {\n    size_t len = zl? ziplistBlobLen(zl): 0;\n    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)\n        return 0;\n    return 1;\n}", "target": 0}
{"code": "Ztring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\n{\n    time_t Time=(time_t)Value;\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\n    struct tm Gmt_Temp;\n    struct tm *Gmt=localtime_r(&Time, &Gmt_Temp);\n    #elif defined(_MSC_VER)\n    struct tm Gmt_Temp;\n    errno_t localtime_s_Result=localtime_s(&Gmt_Temp , &Time);\n    struct tm* Gmt=localtime_s_Result?NULL:&Gmt_Temp;\n    #else\n    struct tm *Gmt=localtime(&Time);\n    #endif\n    Ztring DateT;\n    Ztring Date;\n    if (Gmt)\n    {\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\n    Date+=DateT;\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\n    Date+=DateT;\n    Date+=__T(\" \");\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\n    Date+=DateT;\n    assign (Date.c_str());\n    }\n    return *this;\n}", "target": 0}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "yy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  YY_USE (yylocationp);\n  YY_USE (parm);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yykind < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);\n# endif\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\n\tint i;\n\tint j;\n\tint x;\n\tint c;\n\tint numcolors;\n\tint actualnumcolors;\n\tswitch (hdr->maptype) {\n\tcase RAS_MT_NONE:\n\t\tbreak;\n\tcase RAS_MT_EQUALRGB:\n\t\t{\n\t\tjas_eprintf(\"warning: palettized images not fully supported\\n\");\n\t\tnumcolors = 1 << hdr->depth;\n\t\tassert(numcolors <= RAS_CMAP_MAXSIZ);\n\t\tactualnumcolors = hdr->maplength / 3;\n\t\tfor (i = 0; i < numcolors; i++) {\n\t\t\tcmap->data[i] = 0;\n\t\t}\n\t\tif ((hdr->maplength % 3) || hdr->maplength < 0 ||\n\t\t  hdr->maplength > 3 * numcolors) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tfor (j = 0; j < actualnumcolors; j++) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tx = RAS_RED(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tx = RAS_GREEN(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tx = RAS_BLUE(c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmap->data[j] |= x;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "teardown_digests(cms_context *ctx)\n{\n\tstruct digest *digests = ctx->digests;\n\tif (!digests)\n\t\treturn;\n\tfor (int i = 0; i < n_digest_params; i++) {\n\t\tif (digests[i].pk11ctx) {\n\t\t\tPK11_Finalize(digests[i].pk11ctx);\n\t\t\tPK11_DestroyContext(digests[i].pk11ctx, PR_TRUE);\n\t\t}\n\t\tif (digests[i].pe_digest) {\n\t\t\tdigests[i].pe_digest = NULL;\n\t\t}\n\t}\n\tPORT_Free(digests);\n\tctx->digests = NULL;\n}", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "static void ossl_disassociate_connection(struct Curl_easy *data,\n                                         int sockindex)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool isproxy = FALSE;\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n      SSL_set_ex_data(backend->handle, data_idx, NULL);\n      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n    }\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                      &old_ssl_sessionid, NULL, sockindex));\n    if(incache)\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n    Curl_ssl_sessionid_unlock(data);\n  }\n}", "target": 0}
{"code": "  void SetInput(const std::vector<float>& data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "ProcXkbBell(ClientPtr client)\n{\n    REQUEST(xkbBellReq);\n    DeviceIntPtr dev;\n    WindowPtr\t pWin;\n    int rc;\n    REQUEST_SIZE_MATCH(xkbBellReq);\n    if (!(client->xkbClientFlags&_XkbClientInitialized))\n\treturn BadAccess;\n    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);\n    CHK_ATOM_OR_NONE(stuff->name);\n    if ((stuff->forceSound)&&(stuff->eventOnly)) {\n\tclient->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);\n\treturn BadMatch;\n    }\n    if (stuff->percent < -100 || stuff->percent > 100) {\n\tclient->errorValue = _XkbErrCode2(0x2,stuff->percent);\n\treturn BadValue;\n    }\n    if (stuff->duration<-1) {\n\tclient->errorValue = _XkbErrCode2(0x3,stuff->duration);\n\treturn BadValue;\n    }\n    if (stuff->pitch<-1) {\n\tclient->errorValue = _XkbErrCode2(0x4,stuff->pitch);\n\treturn BadValue;\n    }\n    if (stuff->bellClass == XkbDfltXIClass) {\n\tif (dev->kbdfeed!=NULL)\n\t     stuff->bellClass= KbdFeedbackClass;\n\telse stuff->bellClass= BellFeedbackClass;\n    }\n    if (stuff->window!=None) {\n\trc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n\tif (rc != Success) {\n\t    client->errorValue= stuff->window;\n\t    return rc;\n\t}\n    }\n    else pWin= NULL;\n    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,\n                  stuff->pitch, stuff->duration, stuff->percent,\n                  stuff->forceSound, stuff->eventOnly, stuff->name);\n    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||\n                            (stuff->deviceSpec == XkbUseCorePtr)))\n    {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next)\n        {\n            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))\n            {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);\n                if (rc == Success)\n                    _XkbBell(client, other, pWin, stuff->bellClass,\n                             stuff->bellID, stuff->pitch, stuff->duration,\n                             stuff->percent, stuff->forceSound,\n                             stuff->eventOnly, stuff->name);\n            }\n        }\n        rc = Success; \n    }\n    return rc;\n}", "target": 0}
{"code": "    long PreviewImage::writeFile(const std::wstring& wpath) const\n    {\n        std::wstring name = wpath + wextension();\n        DataBuf buf(pData_, size_);\n        return Exiv2::writeFile(buf, name);\n    }", "target": 0}
{"code": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}", "target": 1}
{"code": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if (!i)\n    return NULL;\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n    return i->next;\n}", "target": 0}
{"code": "void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n\t\t\t\t  sector_t block)\n{\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tstruct mb2_cache_entry *entry;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(entry, node, head, e_hash_list) {\n\t\tif (entry->e_key == key && entry->e_block == block) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\thlist_bl_unlock(head);\n\t\t\tspin_lock(&cache->c_lru_list_lock);\n\t\t\tif (!list_empty(&entry->e_lru_list)) {\n\t\t\t\tlist_del_init(&entry->e_lru_list);\n\t\t\t\tcache->c_entry_count--;\n\t\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t\t}\n\t\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\t\tmb2_cache_entry_put(cache, entry);\n\t\t\treturn;\n\t\t}\n\t}\n\thlist_bl_unlock(head);\n}", "target": 0}
{"code": "int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n\t\t       unsigned int cmd, void __user *arg)\n{\n\tint ret;\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n}", "target": 0}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void hsr_del_node(struct list_head *self_node_db)\n{\n\tstruct hsr_node *node;\n\trcu_read_lock();\n\tnode = list_first_or_null_rcu(self_node_db, struct hsr_node, mac_list);\n\trcu_read_unlock();\n\tif (node) {\n\t\tlist_del_rcu(&node->mac_list);\n\t\tkfree(node);\n\t}\n}", "target": 0}
{"code": "TensorBuffer* FromProtoField<ResourceHandle>(Allocator* a,\n                                             const TensorProto& in, int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<ResourceHandle>* buf = new Buffer<ResourceHandle>(a, n);\n  ResourceHandle* data = buf->template base<ResourceHandle>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = ProtoHelper<ResourceHandle>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, ResourceHandle());\n  } else {\n    const int64_t real_n = n < in_n ? n : in_n;\n    for (int64_t i = 0; i < real_n; ++i) {\n      Status s = ResourceHandle::BuildResourceHandle(in.resource_handle_val(i),\n                                                     &data[i]);\n      if (!s.ok()) {\n        LOG(ERROR) << \"Could not decode resource handle from proto \\\"\"\n                   << in.resource_handle_val(i).ShortDebugString()\n                   << \"\\\", returned status: \" << s.ToString();\n        buf->Unref();\n        return nullptr;\n      }\n    }\n    for (int64_t i = in_n; i < n; ++i) {\n      data[i] = ResourceHandle();\n    }\n  }\n  return buf;\n}", "target": 0}
{"code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\tefi_init();\n\tio_port_init();\n#ifdef CONFIG_IA64_GENERIC\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\tparse_early_param();\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n#ifdef CONFIG_ACPI\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t\n# endif\n#endif \n\tfind_memory();\n\tia64_sal_init(__va(efi.sal_systab));\n#ifdef CONFIG_ITANIUM\n\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n#else\n\t{\n\t\tu64 num_phys_stacked;\n\t\tif (ia64_pal_rse_info(&num_phys_stacked, 0) == 0 && num_phys_stacked > 96)\n\t\t\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n\t}\n#endif\n#ifdef CONFIG_SMP\n\tcpu_physical_id(0) = hard_smp_processor_id();\n#endif\n\tcpu_init();\t\n\tmmu_context_init();\t\n\tcheck_sal_cache_flush();\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\tif (!nomca)\n\t\tia64_mca_init();\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}", "target": 0}
{"code": "bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector<uint32> sizes(n);\n  if (!d->ReadSizes(&sizes)) return false;\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    ps[i].FromProto(proto);\n  }\n  return true;\n}", "target": 1}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "irc_server_reconnect_schedule (struct t_irc_server *server)\n{\n    int minutes, seconds;\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n    {\n        if (server->reconnect_delay == 0)\n            server->reconnect_delay = IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY);\n        else\n            server->reconnect_delay = server->reconnect_delay * weechat_config_integer (irc_config_network_autoreconnect_delay_growing);\n        if ((weechat_config_integer (irc_config_network_autoreconnect_delay_max) > 0)\n            && (server->reconnect_delay > weechat_config_integer (irc_config_network_autoreconnect_delay_max)))\n            server->reconnect_delay = weechat_config_integer (irc_config_network_autoreconnect_delay_max);\n        server->reconnect_start = time (NULL);\n        minutes = server->reconnect_delay / 60;\n        seconds = server->reconnect_delay % 60;\n        if ((minutes > 0) && (seconds > 0))\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s, %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes),\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n        else if (minutes > 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes));\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n    }\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n}", "target": 0}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  unsigned timeout)\n{\n\tstruct dj_report *dj_report;\n\tint retval;\n\tdj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\n\tif (!dj_report)\n\t\treturn -ENOMEM;\n\tdj_report->report_id = REPORT_ID_DJ_SHORT;\n\tdj_report->device_index = 0xFF;\n\tdj_report->report_type = REPORT_TYPE_CMD_SWITCH;\n\tdj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\n\tdj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;\n\tretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\n\tkfree(dj_report);\n\tmsleep(50);\n\treturn retval;\n}", "target": 0}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\tinfo(\"ecall(%p): start\\n\", ecall);\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\tecall->call_type = call_type;\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n out:\n\treturn err;\n}", "target": 1}
{"code": "static int smm_stub_place_staggered_entry_points(char *base,\n\tconst struct smm_loader_params *params, const struct rmodule *smm_stub)\n{\n\tsize_t stub_entry_offset;\n\tint rc = 1;\n\tstub_entry_offset = rmodule_entry_offset(smm_stub);\n\tif (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {\n\t\trc = smm_place_entry_code((unsigned int)base,\n\t\t\tparams->num_concurrent_save_states,\n\t\t\t(unsigned int)params->stack_top, params);\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\tif (unmergeable) {\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\tname = create_unique_id(s);\n\t}\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;", "target": 0}
{"code": "struct kobject *get_disk(struct gendisk *disk)\n{\n\tstruct module *owner;\n\tstruct kobject *kobj;\n\tif (!disk->fops)\n\t\treturn NULL;\n\towner = disk->fops->owner;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&disk_to_dev(disk)->kobj);\n\tif (kobj == NULL) {\n\t\tmodule_put(owner);\n\t\treturn NULL;\n\t}\n\treturn kobj;\n}", "target": 0}
{"code": "void ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\tint reserved = 0;\n\tstruct extent_status *es = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\tif (!len)\n\t\treturn;\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\nretry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}", "target": 1}
{"code": "static UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                               UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                               int transferDir)\n{\n\tUINT32 EndpointAddress;\n\tUINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets;\n\tUINT32 ErrorCount, OutputBufferSize;\n\tBYTE* packetDescriptorData;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tStream_Read_UINT32(s, TransferFlags);   \n\tStream_Read_UINT32(s, StartFrame);      \n\tStream_Read_UINT32(s, NumberOfPackets); \n\tStream_Read_UINT32(s, ErrorCount);      \n\tif (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4)\n\t\treturn ERROR_INVALID_DATA;\n\tpacketDescriptorData = Stream_Pointer(s);\n\tStream_Seek(s, NumberOfPackets * 12);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\treturn pdev->isoch_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame,\n\t    ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize,\n\t    (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_isoch_transfer_cb, 2000);\n}", "target": 0}
{"code": "static void read_conf(FILE *conffile)\n{\n    char *buffer, *line, *val;\n    buffer = loadfile(conffile);\n    for (line = strtok(buffer, \"\\r\\n\"); line; line = strtok(NULL, \"\\r\\n\")) {\n        if (!strncmp(line, \"export \", 7))\n            continue;\n        val = strchr(line, '=');\n        if (!val) {\n            printf(\"invalid configuration line\\n\");\n            break;\n        }\n        *val++ = '\\0';\n        if (!strcmp(line, \"JSON_INDENT\"))\n            conf.indent = atoi(val);\n        if (!strcmp(line, \"JSON_COMPACT\"))\n            conf.compact = atoi(val);\n        if (!strcmp(line, \"JSON_ENSURE_ASCII\"))\n            conf.ensure_ascii = atoi(val);\n        if (!strcmp(line, \"JSON_PRESERVE_ORDER\"))\n            conf.preserve_order = atoi(val);\n        if (!strcmp(line, \"JSON_SORT_KEYS\"))\n            conf.sort_keys = atoi(val);\n        if (!strcmp(line, \"STRIP\"))\n            conf.strip = atoi(val);\n        if (!strcmp(line, \"HASHSEED\")) {\n            conf.have_hashseed = 1;\n            conf.hashseed = atoi(val);\n        } else {\n            conf.have_hashseed = 0;\n        }\n    }\n    free(buffer);\n}", "target": 0}
{"code": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}", "target": 1}
{"code": "static void init_security_types(struct nvnc* server)\n{\n#define ADD_SECURITY_TYPE(type) \\\n\tassert(server->n_security_types < MAX_SECURITY_TYPES); \\\n\tserver->security_types[server->n_security_types++] = (type);\n\tif (server->n_security_types > 0)\n\t\treturn;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_VENCRYPT);\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES256);\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES);\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_APPLE_DH);\n\t\t}\n#endif\n\t} else {\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_NONE);\n\t}\n\tif (server->n_security_types == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n#undef ADD_SECURITY_TYPE\n}", "target": 0}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\t(void) spp;\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p, false);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "static void xmt_remove_link_for_descriptor(GF_XMTParser* parser, GF_Descriptor* desc) {\n\tu32 i=0;\n\tXMT_ODLink *l, *to_del=NULL;\n\twhile ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i)) ) {\n\t\tif (l->od && l->od == (GF_ObjectDescriptor*)desc) {\n\t\t\tl->od = NULL;\n\t\t\tto_del = l;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (to_del) {\n\t\ti=0;\n\t\tGF_Descriptor* subdesc;\n\t\twhile ((subdesc = gf_list_enum(((GF_ObjectDescriptor*)desc)->ESDescriptors, &i))) {\n\t\t\tif (subdesc) xmt_remove_link_for_descriptor(parser, subdesc);\n\t\t}\n\t\tgf_list_del_item(parser->od_links, to_del);\n\t\tif (to_del->desc_name) gf_free(to_del->desc_name);\n\t\tgf_list_del(to_del->mf_urls);\n\t\tgf_free(to_del);\n\t}\n\tXMT_ESDLink *esdl, *esdl_del=NULL;\n\ti=0;\n\twhile ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {\n\t\tif (esdl->esd && esdl->esd == (GF_ESD*)desc) {\n\t\t\tesdl->esd = NULL;\n\t\t\tesdl_del = esdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (esdl_del) {\n\t\tgf_list_del_item(parser->esd_links, esdl_del);\n\t\tif (esdl_del->desc_name) gf_free(esdl_del->desc_name);\n\t\tgf_free(esdl_del);\n\t}\n}", "target": 0}
{"code": "static void my_gballoc_free(void* ptr)\n{\n    free(ptr);\n}", "target": 0}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_t = ctx->input(0);\n    const Tensor& rate_t = ctx->input(1);\n    TensorShape samples_shape;\n    OP_REQUIRES_OK(ctx, tensor::MakeShape(shape_t, &samples_shape));\n    const int64_t num_samples = samples_shape.num_elements();\n    samples_shape.AppendShape(rate_t.shape());\n    Tensor* samples_t = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n    if (num_samples == 0) return;\n    const auto rate_flat = rate_t.flat<T>().data();\n    const int64_t num_rate = rate_t.NumElements();\n    auto samples_flat = samples_t->flat<U>().data();\n    random::PhiloxRandom rng = generator_.ReserveRandomOutputs(\n        num_samples * num_rate, kReservedSamplesPerOutput);\n    functor::PoissonFunctor<CPUDevice, T, U>()(\n        ctx, ctx->eigen_device<CPUDevice>(), rate_flat, num_rate, num_samples,\n        rng, samples_flat);\n  }", "target": 1}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": " struct timespec ns_to_timespec(const s64 nsec)\n {\n \tstruct timespec ts;\n\ts32 rem;\n \tif (!nsec)\n \t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n \treturn ts;\n }", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 0}
{"code": "simple_upscale(j_decompress_ptr cinfo,\n               JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "SkBitmap Clipboard::ReadImage(Buffer buffer) const {\n  ScopedGObject<GdkPixbuf>::Type pixbuf(\n      gtk_clipboard_wait_for_image(clipboard_));\n  if (!pixbuf.get())\n    return SkBitmap();\n  gfx::CanvasSkia canvas(gdk_pixbuf_get_width(pixbuf.get()),\n                         gdk_pixbuf_get_height(pixbuf.get()),\n                         false);\n  {\n    skia::ScopedPlatformPaint scoped_platform_paint(canvas.sk_canvas());\n    cairo_t* context = scoped_platform_paint.GetPlatformSurface();\n    gdk_cairo_set_source_pixbuf(context, pixbuf.get(), 0.0, 0.0);\n    cairo_paint(context);\n  }\n  return canvas.ExtractBitmap();\n}", "target": 0}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "ConnectToRFBServer(rfbClient* client,const char *hostname, int port)\n{\n  if (client->serverPort==-1) {\n    const char* magic=\"vncLog0.0\";\n    char buffer[10];\n    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));\n    client->vncRec = rec;\n    rec->file = fopen(client->serverHost,\"rb\");\n    rec->tv.tv_sec = 0;\n    rec->readTimestamp = FALSE;\n    rec->doNotSleep = FALSE;\n    if (!rec->file) {\n      rfbClientLog(\"Could not open %s.\\n\",client->serverHost);\n      return FALSE;\n    }\n    setbuf(rec->file,NULL);\n    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {\n      rfbClientLog(\"File %s was not recorded by vncrec.\\n\",client->serverHost);\n      fclose(rec->file);\n      return FALSE;\n    }\n    client->sock = -1;\n    return TRUE;\n  }\n#ifndef WIN32\n  if(IsUnixSocket(hostname))\n    client->sock = ConnectClientToUnixSock(hostname);\n  else\n#endif\n  {\n#ifdef LIBVNCSERVER_IPv6\n    client->sock = ConnectClientToTcpAddr6(hostname, port);\n    if (client->sock == -1)\n#endif\n    {\n      unsigned int host;\n      if (!StringToIPAddr(hostname, &host)) {\n        rfbClientLog(\"Couldn't convert '%s' to host address\\n\", hostname);\n        return FALSE;\n      }\n      client->sock = ConnectClientToTcpAddr(host, port);\n    }\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC server\\n\");\n    return FALSE;\n  }\n  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))\n     return FALSE;\n  return SetNonBlocking(client->sock);\n}", "target": 0}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "auth_iochannel_watch (GIOChannel   *source,\n                      GIOCondition  condition,\n                      IceConn       ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        gboolean               keep_going;\n        data = ice_conn->context;\n        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n        case IceProcessMessagesSuccess:\n                keep_going = TRUE;\n                break;\n        case IceProcessMessagesIOError:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\");\n                free_ice_connection_watch (data);\n                disconnect_ice_connection (ice_conn);\n                keep_going = FALSE;\n                break;\n        case IceProcessMessagesConnectionClosed:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\");\n                free_ice_connection_watch (data);\n                keep_going = FALSE;\n                break;\n        default:\n                g_assert_not_reached ();\n        }\n        return keep_going;\n}", "target": 0}
{"code": "njs_promise_perform_all_settled_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled, *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    on_rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->magic8 = 1; \n    on_fulfilled->args_count = 1;\n    on_rejected->args_count = 1;\n    on_rejected->context = context;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static void adpt_ia64_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_IA64;\n}", "target": 1}
{"code": "      \\param[out] colors At return, contains the list of 3d object colors.\n      \\return List of 3d object vertices.\n    **/\n    template<typename tf, typename tc>", "target": 0}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\tbh_lock_sock(sk);\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 0}
{"code": "static int xen_evtchn_cpu_prepare(unsigned int cpu)\n{\n\tint ret = 0;\n\txen_cpu_init_eoi(cpu);\n\tif (evtchn_ops->percpu_init)\n\t\tret = evtchn_ops->percpu_init(cpu);\n\treturn ret;\n}", "target": 0}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "static ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\tmutex_lock(&ldata->output_lock);\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}", "target": 0}
{"code": "  bool IsSupported(const NodeDef* node) const override {\n    if (!node || node->input_size() < 2) {\n      return false;\n    }\n    return IsAnyMul(*node) && node->input(0) == node->input(1);\n  }", "target": 0}
{"code": "save_positions (GPtrArray *page_names)\n{\n\tguint i;\n\tGHashTable *ht;\n\tht = g_hash_table_new (g_str_hash, g_str_equal);\n\tfor (i = 0; i < page_names->len; i++)\n\t\tg_hash_table_insert (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));\n\treturn ht;\n}", "target": 0}
{"code": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "XML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler) {\n  if (parser != NULL)\n    parser->m_commentHandler = handler;\n}", "target": 0}
{"code": "static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (f2fs_readonly(F2FS_I_SB(inode)->sb))\n\t\treturn -EROFS;\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\tret = check_swap_activate(file, sis->max);\n\tif (ret)\n\t\treturn ret;\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tf2fs_precache_extents(inode);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn 0;\n}", "target": 0}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}", "target": 1}
{"code": "Status CreateTempFileBadString(Env* env, char value, uint64 size,\n                               const string suffix, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", suffix));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  TF_RETURN_IF_ERROR(file->Append(std::string(size, value)));\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "static int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn rc;\n\t}\n\treturn genlmsg_reply(msg, info);\n}", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "SSLNetVConnection::populate_protocol(std::string_view *results, int n) const\n{\n  int retval = 0;\n  if (n > retval) {\n    results[retval] = map_tls_protocol_to_tag(getSSLProtocol());\n    if (!results[retval].empty()) {\n      ++retval;\n    }\n    if (n > retval) {\n      retval += super::populate_protocol(results + retval, n - retval);\n    }\n  }\n  return retval;\n}", "target": 0}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res)\n\t\treturn -ENOMEM;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t}\nout:\n\tkfree(child_res);\n\treturn ret;\n}", "target": 1}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "void URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n\tif (uri == NULL) {\n\t\treturn;\n\t}\n\tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n}", "target": 0}
{"code": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\treturn err;\n}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!rdp || !rdp->fips_decrypt)\n\t\treturn FALSE;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }", "target": 1}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n    ogs_msleep(300);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\tif (num <= 0)\n\t\treturn 0;\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\treturn num;\n}", "target": 0}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n    if (!pdu)\n        return NULL;\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n    return newpdu;\n}", "target": 1}
{"code": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    if (!lua_checkstack(lua, 5)) {\n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n    char *p = reply;\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}", "target": 0}
{"code": "win_init_some(win_T *newp, win_T *oldp)\n{\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n    win_copy_options(oldp, newp);\n}", "target": 0}
{"code": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void HTTPSession::onCertificateRequest(uint16_t requestId,\n                                       std::unique_ptr<IOBuf> authRequest) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE_REQUEST on\" << *this << \", requestId=\" << requestId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::UPSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    } else {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::DOWNSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (codec_->generateCertificate(writeBuf_,\n                                  authenticator.first,\n                                  std::move(authenticator.second)) > 0) {\n    scheduleWrite();\n  }\n}", "target": 0}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "void RunOneAveragePoolTest(const PoolParams& params,\n                           const RuntimeShape& input_shape,\n                           const int8* input_data,\n                           const RuntimeShape& output_shape) {\n  const int buffer_size = output_shape.FlatSize();\n  std::vector<int8> optimized_averagePool_output(buffer_size);\n  std::vector<int8> reference_averagePool_output(buffer_size);\n  reference_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     reference_averagePool_output.data());\n  optimized_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     optimized_averagePool_output.data());\n  for (int i = 0; i < buffer_size; i++) {\n    EXPECT_TRUE(reference_averagePool_output[i] ==\n                optimized_averagePool_output[i]);\n  }\n}", "target": 1}
{"code": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "  CloseNotifyConnector(EventBase* evb, const SocketAddress& addr) {\n    evb_ = evb;\n    ssl_ = AsyncSSLSocket::newSocket(std::make_shared<SSLContext>(), evb_);\n    ssl_->connect(this, addr);\n  }", "target": 0}
{"code": "    inline PluginEndpointSecurityAttributesMask mask() const\n    {\n        PluginEndpointSecurityAttributesMask rv = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_submessage_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n        if (is_submessage_origin_authenticated) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n        if (is_payload_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_ENCRYPTED;\n        return rv;\n    }", "target": 1}
{"code": "\tCommandAuthenticate(Module* Creator, SimpleExtItem<SaslAuthenticator>& ext, GenericCap& Cap)\n\t\t: Command(Creator, \"AUTHENTICATE\", 1), authExt(ext), cap(Cap)\n\t{\n\t\tworks_before_reg = true;\n\t\tallow_empty_last_param = false;\n\t}", "target": 0}
{"code": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "script_autoload(\n    char_u\t*name,\n    int\t\treload)\t    \n{\n    char_u\t*p;\n    char_u\t*scriptname, *tofree;\n    int\t\tret = FALSE;\n    int\t\ti;\n    int\t\tret_sid;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    if (p == NULL || p == name)\n\treturn FALSE;\n    tofree = scriptname = autoload_name(name);\n    if (scriptname == NULL)\n\treturn FALSE;\n    for (i = 0; i < ga_loaded.ga_len; ++i)\n\tif (STRCMP(((char_u **)ga_loaded.ga_data)[i] + 9, scriptname + 9) == 0)\n\t    break;\n    if (!reload && i < ga_loaded.ga_len)\n\tret = FALSE;\t    \n    else\n    {\n\tif (i == ga_loaded.ga_len && ga_grow(&ga_loaded, 1) == OK)\n\t{\n\t    ((char_u **)ga_loaded.ga_data)[ga_loaded.ga_len++] = scriptname;\n\t    tofree = NULL;\n\t}\n\tif (source_in_path(p_rtp, scriptname, DIP_START, &ret_sid) == OK)\n\t    ret = TRUE;\n    }\n    vim_free(tofree);\n    return ret;\n}", "target": 0}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "  Status CalculateOutputIndexValueRowID(\n      const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return Status::OK();\n    }\n    INDEX_TYPE current_output_column = 0;\n    INDEX_TYPE current_value_rowid = value_rowids(0);\n    if (current_value_rowid >= parent_output_index.size()) {\n      return errors::InvalidArgument(\n          \"Got current_value_rowid=\", current_value_rowid,\n          \" which is not less than \", parent_output_index.size());\n    }\n    INDEX_TYPE current_output_index = parent_output_index[current_value_rowid];\n    result->push_back(current_output_index);\n    for (INDEX_TYPE i = 1; i < index_size; ++i) {\n      INDEX_TYPE next_value_rowid = value_rowids(i);\n      if (next_value_rowid == current_value_rowid) {\n        if (current_output_index >= 0) {\n          ++current_output_column;\n          if (current_output_column < output_size) {\n            current_output_index += output_index_multiplier;\n          } else {\n            current_output_index = -1;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        if (next_value_rowid >= parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Got next_value_rowid=\", next_value_rowid,\n              \" which is not less than \", parent_output_index.size());\n        }\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    if (result->size() != value_rowids.size()) {\n      return errors::InvalidArgument(\"Invalid row ids.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n  return tmp;\n}", "target": 0}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 0}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\treturn 0;\n}", "target": 1}
{"code": "OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n        static const char module[]=\"OJPEGDecode\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n{\n\tconst char *hostname_left;\n\tif (!strcasecmp(cert_hostname, hostname)) { \n\t\treturn TRUE;\n\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { \n\t\thostname_left = strchr(hostname, '.');\n\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "m_split(struct mbuf *m0, int len0, int wait)\n{\n\tstruct mbuf *m, *n;\n\tunsigned len = len0, remain, olen;\n\tfor (m = m0; m && len > m->m_len; m = m->m_next)\n\t\tlen -= m->m_len;\n\tif (m == NULL)\n\t\treturn (NULL);\n\tremain = m->m_len - len;\n\tif (m0->m_flags & M_PKTHDR) {\n\t\tMGETHDR(n, wait, m0->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tif (m_dup_pkthdr(n, m0, wait)) {\n\t\t\tm_freem(n);\n\t\t\treturn (NULL);\n\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "void Server::CheckDocRoot() {\n  try {\n    if (!fs::exists(doc_root_) || !fs::is_directory(doc_root_)) {\n      LOG_ERRO(\"Doc root is not an existing directory!\");\n      return;\n    }\n    if (doc_root_.is_relative()) {\n      doc_root_ = fs::absolute(doc_root_);\n    }\n    doc_root_ = fs::canonical(doc_root_);\n  } catch (fs::filesystem_error& e) {\n    LOG_ERRO(\"Doc root error: %s\", e.what());\n    doc_root_.clear();\n  }\n  LOG_INFO(\"Doc root: %s\", doc_root_.u8string().c_str());\n}", "target": 0}
{"code": "static int selinux_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n{\n\tu32 size;\n\tint error;\n\tchar *context = NULL;\n\tstruct inode_security_struct *isec;\n\tif (strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\tisec = inode_security(inode);\n\tif (has_cap_mac_admin(false))\n\t\terror = security_sid_to_context_force(&selinux_state,\n\t\t\t\t\t\t      isec->sid, &context,\n\t\t\t\t\t\t      &size);\n\telse\n\t\terror = security_sid_to_context(&selinux_state, isec->sid,\n\t\t\t\t\t\t&context, &size);\n\tif (error)\n\t\treturn error;\n\terror = size;\n\tif (alloc) {\n\t\t*buffer = context;\n\t\tgoto out_nofree;\n\t}\n\tkfree(context);\nout_nofree:\n\treturn error;\n}", "target": 0}
{"code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n    if (plen < 0)\n        return 0;\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice;\n      status_ = TensorSlice::BuildTensorSlice(tsp, &ss_slice);\n      if (!status_.ok()) return;\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 0}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void sendClean( char* str ) {\n    CleanupOutput(str);\n    send(str);\n}", "target": 0}
{"code": "FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte, bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\tpgprintk(\"%s: gpte %llx spte %p\\n\", __func__, (u64)gpte, spte);\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn,\n\t\t\tno_dirty_log && (pte_access & ACC_WRITE_MASK));\n\tif (!slot)\n\t\treturn false;\n\tpfn = gfn_to_pfn_memslot_atomic(slot, gfn);\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\tmmu_set_spte(vcpu, slot, spte, pte_access, gfn, pfn, NULL);\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}", "target": 0}
{"code": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}", "target": 1}
{"code": "_XimEncodeSavedStatusValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (sctp_chunk_pending(ack))\n\t\t\tcontinue;\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    obj->reserveDynProps(nProp);\n    t = obj->makeDynProp(realKey.get());\n  } else {\n    t = obj->getPropLval(ctx, key.get());\n  }\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_uintersect,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args ) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "ofpacts_parse(char *str, const struct ofpact_parse_params *pp,\n              bool allow_instructions, enum ofpact_type outer_action)\n{\n    if (pp->depth >= MAX_OFPACT_PARSE_DEPTH) {\n        return xstrdup(\"Action nested too deeply\");\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth++;\n    uint32_t orig_size = pp->ofpacts->size;\n    char *error = ofpacts_parse__(str, pp, allow_instructions, outer_action);\n    if (error) {\n        pp->ofpacts->size = orig_size;\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth--;\n    return error;\n}", "target": 0}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 0}
{"code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n    gr_face_destroy(face);\n    return 0;\n}", "target": 1}
{"code": "TfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  const TfLiteTensor* axis = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, axis->type, kTfLiteInt32);\n  if (input->type == kTfLiteInt8) {\n    OpData* data = static_cast<OpData*>(node->user_data);\n    const TfLiteTensor* output = GetOutput(context, node, 0);\n    const double real_multiplier = static_cast<double>(input->params.scale) /\n                                   static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &data->shift);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static char* umocktypes_stringify_bool_ptr(const bool** value)\n{\n    char* result;\n    result = (char*)my_gballoc_malloc(8);\n    if (result != NULL)\n    {\n        if (*value == NULL)\n        {\n            (void)strcpy(result, \"{NULL}\");\n        }\n        else if (*(*value) == true)\n        {\n            (void)strcpy(result, \"{true}\");\n        }\n        else\n        {\n            (void)strcpy(result, \"{false}\");\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "static int bad_format_check(const char *pattern, char *fmt) {\n    GError *gerr = NULL;\n    GRegex *re = g_regex_new(pattern, G_REGEX_EXTENDED, 0, &gerr);\n    GMatchInfo *mi;\n    if (gerr != NULL) {\n        rrd_set_error(\"cannot compile regular expression: %s (%s)\", gerr->message,pattern);\n        return 1;\n    }\n    int m = g_regex_match(re, fmt, 0, &mi);\n    g_match_info_free (mi);\n    g_regex_unref(re);\n    if (!m) {\n        rrd_set_error(\"invalid format string '%s' (should match '%s')\",fmt,pattern);\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void die_upon_dubious_ownership(const char *gitfile, const char *worktree,\n\t\t\t\tconst char *gitdir)\n{\n\tstruct strbuf report = STRBUF_INIT, quoted = STRBUF_INIT;\n\tconst char *path;\n\tif (ensure_valid_ownership(gitfile, worktree, gitdir, &report))\n\t\treturn;\n\tstrbuf_complete(&report, '\\n');\n\tpath = gitfile ? gitfile : gitdir;\n\tsq_quote_buf_pretty(&quoted, path);\n\tdie(_(\"detected dubious ownership in repository at '%s'\\n\"\n\t      \"%s\"\n\t      \"To add an exception for this directory, call:\\n\"\n\t      \"\\n\"\n\t      \"\\tgit config --global --add safe.directory %s\"),\n\t    path, report.buf, quoted.buf);\n}", "target": 0}
{"code": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask  &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\tnetlink_table_grab();\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\tnetlink_table_ungrab();\n}", "target": 0}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\tunlink(RUN_LIB_FILE);\t\t\t  \n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}", "target": 0}
{"code": "bit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\treturn result;\n}", "target": 0}
{"code": "SYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct timex __user *, utx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\terr = kc->clock_adj(which_clock, &ktx);\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\treturn err;\n}", "target": 0}
{"code": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n        g_return_val_if_fail (client != NULL, TRUE);\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n        return TRUE;\n}", "target": 1}
{"code": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn starting_runtime - remaining;\n}", "target": 1}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "static bool dir_is_in_dump_location(const char *dump_dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0\n     && dump_dir_name[len] == '/'\n     && !strstr(dump_dir_name + len, \"/.\")\n    ) {\n        return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\tif (mode[0] != 'a' && mode[0] != 'w')\n\t\treturn NULL;\n\tif (mode[1] &&\n\t    (mode[1] != '+' || mode[2]))\n\t\treturn NULL;\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "}\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))\n\t\treturn true;", "target": 1}
{"code": "static int __init net_secret_init(void)\n{\n\tget_random_bytes(net_secret, sizeof(net_secret));\n\treturn 0;\n}", "target": 0}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "static bool map_info2_flags_to_sbuf(const SMB_STRUCT_STAT *psbuf,\n\t\t\t\tconst uint32_t smb_fflags,\n\t\t\t\tconst uint32_t smb_fmask,\n\t\t\t\tint *stat_fflags)\n{\n\tuint32_t max_fmask = 0;\n\tint i;\n\t*stat_fflags = psbuf->st_ex_flags;\n\tfor (i = 0; i < ARRAY_SIZE(info2_flags_map); ++i) {\n\t    max_fmask |= info2_flags_map[i].smb_fflag;\n\t    if (smb_fmask & info2_flags_map[i].smb_fflag) {\n\t\t    if (smb_fflags & info2_flags_map[i].smb_fflag) {\n\t\t\t    *stat_fflags |= info2_flags_map[i].stat_fflag;\n\t\t    } else {\n\t\t\t    *stat_fflags &= ~info2_flags_map[i].stat_fflag;\n\t\t    }\n\t    }\n\t}\n\tif ((smb_fmask & max_fmask) != smb_fmask) {\n\t\treturn False;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "static int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}", "target": 0}
{"code": "char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\tlen = M_list_str_len(parts);\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\tcount = (len == 1) ? 2 : 1;\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}", "target": 1}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}", "target": 0}
{"code": "void KPasswordDlg::keyPressed( QKeyEvent *e )\n{\n  static bool waitForAuthentication = false;\n  if (!waitForAuthentication) {\n\tswitch ( e->key() )\n\t{\n\t\tcase Key_Backspace:\n\t\t\t{\n\t\t\t\tint len = password.length();\n\t\t\t\tif ( len ) {\n\t\t\t\t\tpassword.truncate( len - 1 );\n\t\t\t\t\tif( stars )\n\t\t\t\t\t\tshowStars();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Key_Return:\n            timer.stop();\n\t\t\twaitForAuthentication = true;\n\t\t\tif ( tryPassword() )\n\t\t\t\temit passOk();\n\t\t\telse\n\t\t\t{\n\t\t\t\tlabel->setText( glocale->translate(\"Failed\") );\n\t\t\t\tpassword = \"\";\n\t\t\t\ttimerMode = 1;\n\t\t\t\ttimer.start( 1500, TRUE );\n\t\t\t}\n\t\t\twaitForAuthentication = false;\n\t\t\tbreak;\n\t\tcase Key_Escape:\n\t\t\temit passCancel();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( password.length() < MAX_PASSWORD_LENGTH )\n\t\t\t{\n\t\t\t\tpassword += (char)e->ascii();\n\t\t\t\tif( stars )\n\t\t\t\t\tshowStars();\n\t\t\t\ttimer.changeInterval( 10000 );\n\t\t\t}\n\t}\n  }\n}", "target": 0}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                      std::numeric_limits<int8_t>::min());\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    data->input_zero_point = input->params.zero_point;\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}", "target": 0}
{"code": "std::string Utf16To8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 0}
{"code": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc)\n\t\tsnd_mem_proc->proc_fops = &snd_mem_proc_fops;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    qemu_vfree(r->iov.iov_base);\n}", "target": 1}
{"code": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n    GTextFieldSaved(gt);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto value = ctx->input(0);\n    OP_REQUIRES(ctx, value.dims() >= 1,\n                errors::InvalidArgument(\"value should be at least rank 1.\"));\n    OP_REQUIRES(\n        ctx, value.dim_size(0) > loc_,\n        errors::InvalidArgument(\"0th dimension of value = \", value.dim_size(0),\n                                \" must be greater than loc_ = \", loc_));\n    auto update = ctx->input(1);\n    OP_REQUIRES(\n        ctx, value.dims() == update.dims(),\n        errors::InvalidArgument(\"value and update shape doesn't match: \",\n                                value.shape().DebugString(), \" vs. \",\n                                update.shape().DebugString()));\n    for (int i = 1; i < value.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, value.dim_size(i) == update.dim_size(i),\n          errors::InvalidArgument(\"value and update shape doesn't match \",\n                                  value.shape().DebugString(), \" vs. \",\n                                  update.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, 1 == update.dim_size(0),\n                errors::InvalidArgument(\"update shape doesn't match: \",\n                                        update.shape().DebugString()));\n    Tensor output = value;  \n    const auto& d = ctx->eigen_device<Device>();\n    OP_REQUIRES_OK(\n        ctx, ::tensorflow::functor::DoParallelConcat(d, update, loc_, &output));\n    ctx->set_output(0, output);\n  }", "target": 0}
{"code": "static void vc_uniscr_delete(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemcpy(&ln[x], &ln[x + nr], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[cols - nr], ' ', nr);\n\t}\n}", "target": 0}
{"code": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "void infra_wait_limit_dec(struct infra_cache* infra, struct comm_reply* rep,\n\tstruct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tif(d->mesh_wait > 0)\n\t\t\td->mesh_wait--;\n\t\tlock_rw_unlock(&entry->lock);\n\t}\n}", "target": 0}
{"code": "DefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n    uint32_t key = DefragHashGetKey(p);\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n        hb->head = dt;\n        hb->tail = dt;\n        DefragTrackerInit(dt,p);\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n    dt = hb->head;\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; \n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n                dt->hprev = pdt;\n                DefragTrackerInit(dt,p);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n            if (DefragTrackerCompare(dt, p) != 0) {\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 0}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "static int netlink_realloc_groups(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tunsigned int groups;\n\tunsigned long *new_groups;\n\tint err = 0;\n\tnetlink_table_grab();\n\tgroups = nl_table[sk->sk_protocol].groups;\n\tif (!nl_table[sk->sk_protocol].registered) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\tif (nlk->ngroups >= groups)\n\t\tgoto out_unlock;\n\tnew_groups = krealloc(nlk->groups, NLGRPSZ(groups), GFP_ATOMIC);\n\tif (new_groups == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tmemset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,\n\t       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));\n\tnlk->groups = new_groups;\n\tnlk->ngroups = groups;\n out_unlock:\n\tnetlink_table_ungrab();\n\treturn err;\n}", "target": 0}
{"code": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "absl::Status SslSocket::initialize(InitialState state,\n                                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  auto status_or_ssl = ctx_->newSsl(transport_socket_options_);\n  if (!status_or_ssl.ok()) {\n    return status_or_ssl.status();\n  }\n  info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n      std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n  return absl::OkStatus();\n}", "target": 0}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "AnyP::UriScheme::defaultPort() const\n{\n    switch (theScheme_) {\n    case AnyP::PROTO_HTTP:\n        return 80;\n    case AnyP::PROTO_HTTPS:\n        return 443;\n    case AnyP::PROTO_FTP:\n        return 21;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS:\n        return 5683;\n    case AnyP::PROTO_GOPHER:\n        return 70;\n    case AnyP::PROTO_WAIS:\n        return 210;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return CACHE_HTTP_PORT;\n    case AnyP::PROTO_WHOIS:\n        return 43;\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static inline void arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t struct mm_struct *mm)\n{\n\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n}", "target": 1}
{"code": "static void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\treturn;\n\t}\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\tsas_discover_event(port, DISCE_RESUME);\n}", "target": 0}
{"code": "nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\tif (args->count != args->len)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\treturn min_t(int, out_buf_len, free_len);\n}", "target": 1}
{"code": "static void mmtimer_setup_int_0(int cpu, u64 expires)\n{\n\tu64 val;\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 0UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), -1L);\n\tmmtimer_clr_int_pending(0);\n\tval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC1_INT_CONFIG_IDX_SHFT) |\n\t\t((u64)cpu_physical_id(cpu) <<\n\t\t\tSH_RTC1_INT_CONFIG_PID_SHFT);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_CONFIG), val);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 1UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), expires);\n}", "target": 0}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "static inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\t\tchg = to - from;\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\tif (hugepage_subpool_get_pages(spool, chg)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\tret = hugetlb_acct_memory(h, chg);\n\tif (ret < 0) {\n\t\thugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\nout_err:\n\tresv_map_put(vma);\n\treturn ret;\n}", "target": 0}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static bool gguf_ex_read_0(const std::string & fname) {\n    struct gguf_init_params params = {\n         false,\n         NULL,\n    };\n    struct gguf_context * ctx = gguf_init_from_file(fname.c_str(), params);\n    if (!ctx) {\n        fprintf(stderr, \"%s: failed to load '%s'\\n\", __func__, fname.c_str());\n        return false;\n    }\n    printf(\"%s: version:      %d\\n\", __func__, gguf_get_version(ctx));\n    printf(\"%s: alignment:   %zu\\n\", __func__, gguf_get_alignment(ctx));\n    printf(\"%s: data offset: %zu\\n\", __func__, gguf_get_data_offset(ctx));\n    {\n        const int n_kv = gguf_get_n_kv(ctx);\n        printf(\"%s: n_kv: %d\\n\", __func__, n_kv);\n        for (int i = 0; i < n_kv; ++i) {\n            const char * key = gguf_get_key(ctx, i);\n            printf(\"%s: kv[%d]: key = %s\\n\", __func__, i, key);\n        }\n    }\n    {\n        const char * findkey = \"some.parameter.string\";\n        const int keyidx = gguf_find_key(ctx, findkey);\n        if (keyidx == -1) {\n            printf(\"%s: find key: %s not found.\\n\", __func__, findkey);\n        } else {\n            const char * key_value = gguf_get_val_str(ctx, keyidx);\n            printf(\"%s: find key: %s found, kv[%d] value = %s\\n\", __func__, findkey, keyidx, key_value);\n        }\n    }\n    {\n        const int n_tensors = gguf_get_n_tensors(ctx);\n        printf(\"%s: n_tensors: %d\\n\", __func__, n_tensors);\n        for (int i = 0; i < n_tensors; ++i) {\n            const char * name   = gguf_get_tensor_name  (ctx, i);\n            const size_t offset = gguf_get_tensor_offset(ctx, i);\n            printf(\"%s: tensor[%d]: name = %s, offset = %zu\\n\", __func__, i, name, offset);\n        }\n    }\n    gguf_free(ctx);\n    return true;\n}", "target": 0}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "static MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n  char\n    colorspace[MagickPathExtent];\n  ssize_t\n    count;\n  unsigned long\n    columns,\n    depth,\n    rows;\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional (2)\"));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"tensor_in must not be empty (2)\"));\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }", "target": 0}
{"code": "static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tunsigned char *p;\n\twhile (total_sg_needed) {\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsg_init_table(sg, sg_per_table);\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\t\t\tp = kmap(pg);\n\t\t\tmemset(p, init_payload, PAGE_SIZE);\n\t\t\tkunmap(pg);\n\t\t}\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &in_backprop));\n    if (input.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropInput<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        in_backprop->tensor<T, 4>());\n  }", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "pte_t *huge_pmd_share(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t      unsigned long addr, pud_t *pud)\n{\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tstruct vm_area_struct *svma;\n\tunsigned long saddr;\n\tpte_t *spte = NULL;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\ti_mmap_assert_locked(mapping);\n\tvma_interval_tree_foreach(svma, &mapping->i_mmap, idx, idx) {\n\t\tif (svma == vma)\n\t\t\tcontinue;\n\t\tsaddr = page_table_shareable(svma, vma, addr, idx);\n\t\tif (saddr) {\n\t\t\tspte = huge_pte_offset(svma->vm_mm, saddr,\n\t\t\t\t\t       vma_mmu_pagesize(svma));\n\t\t\tif (spte) {\n\t\t\t\tget_page(virt_to_page(spte));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!spte)\n\t\tgoto out;\n\tptl = huge_pte_lock(hstate_vma(vma), mm, spte);\n\tif (pud_none(*pud)) {\n\t\tpud_populate(mm, pud,\n\t\t\t\t(pmd_t *)((unsigned long)spte & PAGE_MASK));\n\t\tmm_inc_nr_pmds(mm);\n\t} else {\n\t\tput_page(virt_to_page(spte));\n\t}\n\tspin_unlock(ptl);\nout:\n\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\treturn pte;\n}", "target": 0}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "uipbuf_clear(void)\n{\n  uip_len = 0;\n  uip_ext_len = 0;\n  uip_last_proto = 0;\n  uipbuf_clear_attr();\n}", "target": 0}
{"code": "bool IsFullyConnectedOpSupported(const TfLiteRegistration* registration,\n                                 const TfLiteNode* node,\n                                 TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  const auto* fc_params =\n      reinterpret_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const int kInput = 0;\n  const int kWeights = 1;\n  const int kBias = 2;\n  if (fc_params->weights_format != kTfLiteFullyConnectedWeightsFormatDefault) {\n    return false;\n  }\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* weights = GetInput(context, node, kWeights);\n  if (!IsFloatType(input->type)) {\n    return false;\n  }\n  if (!IsFloatType(weights->type) || !IsConstantTensor(weights)) {\n    return false;\n  }\n  if (input->dims->data[input->dims->size - 1] != NumElements(input)) {\n    return false;\n  }\n  if (node->inputs->size > 2) {\n    const TfLiteTensor* bias = GetInput(context, node, kBias);\n    if (!IsFloatType(bias->type) || !IsConstantTensor(bias)) {\n      return false;\n    }\n  }\n  TfLiteFusedActivation activation = fc_params->activation;\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}", "target": 1}
{"code": "int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  int total_size;\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (root_table == NULL) {\n    total_size = BuildHuffmanTable(NULL, root_bits,\n                                   code_lengths, code_lengths_size, NULL);\n  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n  } else {   \n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}", "target": 1}
{"code": "static int process_options(int argc, char *argv[], char *operation)\n{\n  int error= 0;\n  int i= 0;\n  if ((error= handle_options(&argc, &argv, my_long_options, get_one_option)))\n    goto exit;\n  if (opt_print_defaults)\n  {\n    error= -1;\n    goto exit;\n  }\n  if (opt_basedir)\n  {\n    i= (int)strlength(opt_basedir);\n    if (opt_basedir[i-1] != FN_LIBCHAR || opt_basedir[i-1] != FN_LIBCHAR2)\n    {\n      char buff[FN_REFLEN];\n      memset(buff, 0, sizeof(buff));\n      strncpy(buff, opt_basedir, sizeof(buff) - 1);\n#ifdef __WIN__\n      strncat(buff, \"/\", sizeof(buff) - strlen(buff) - 1);\n#else\n      strncat(buff, FN_DIRSEP, sizeof(buff) - strlen(buff) - 1);\n#endif\n      buff[sizeof(buff) - 1]= 0;\n      my_free(opt_basedir);\n      opt_basedir= my_strdup(buff, MYF(MY_FAE));\n    }\n  }\n  if (!opt_no_defaults && ((error= get_default_values())))\n  {\n    error= -1;\n    goto exit;\n  }\n  strcpy(operation, \"\");\n  if ((error = check_options(argc, argv, operation)))\n  {\n    goto exit;\n  }\n  if (opt_verbose)\n  {\n    printf(\"#    basedir = %s\\n\", opt_basedir);\n    printf(\"# plugin_dir = %s\\n\", opt_plugin_dir);\n    printf(\"#    datadir = %s\\n\", opt_datadir);\n    printf(\"# plugin_ini = %s\\n\", opt_plugin_ini);\n  }\nexit:\n  return error;\n}", "target": 0}
{"code": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {\n    keyReference *keys;\n    UNUSED(cmd);\n    UNUSED(argv);\n    UNUSED(argc);\n    keys = getKeysPrepareResult(result, 1);\n    keys[0].pos = 1; \n    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;\n    return 1;\n}", "target": 1}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 1}
{"code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n  if (rar->bytes_unconsumed > 0) {\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "target": 1}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\tst->timeout = PFTM_UNLINKED;\n\tpf_postprocess_addr(st);\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],\n\t\t    st->src.seqhi, st->src.seqlo + 1,\n\t\t    TH_RST|TH_ACK, 0, 0, 0, 1, st->tag,\n\t\t    st->key[PF_SK_WIRE]->rdomain);\n\t}\n\tif (st->key[PF_SK_STACK]->proto == IPPROTO_TCP)\n\t\tpf_set_protostate(st, PF_PEER_BOTH, TCPS_CLOSED);\n\tRBT_REMOVE(pf_state_tree_id, &tree_id, st);\n#if NPFLOW > 0\n\tif (st->state_flags & PFSTATE_PFLOW)\n\t\texport_pflow(st);\n#endif\t\n#if NPFSYNC > 0\n\tpfsync_delete_state(st);\n#endif\t\n\tpf_src_tree_remove_state(st);\n\tpf_detach_state(st);\n}", "target": 1}
{"code": "add_serials(struct deltas_head *deltas, ...)\n{\n\tstruct delta_head delta;\n\tva_list vl;\n\tdoc_data_init(&delta.doc_data);\n\tva_start(vl, deltas);\n\twhile ((delta.serial = va_arg(vl, unsigned long)) != END)\n\t\tck_assert_int_eq(0, deltas_head_add(deltas, &delta));\n\tva_end(vl);\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}", "target": 1}
{"code": "  absl::string_view failureReason() const override { return NotReadyReason; }", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "njs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n    frame = &vm->active_frame->native;\n    while (frame->native) {\n        frame = frame->previous;\n    }\n    start = frame;\n    end = frame->free;\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n    do {\n        n--;\n        value = njs_scope_value(vm, lambda->closures[n]);\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n        closure[n] = value;\n    } while (n != 0);\n    return NJS_OK;\n}", "target": 0}
{"code": "int __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "static bool __init is_skylake_era(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, int status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 0}
{"code": "static inline void skb_mac_header_rebuild(struct sk_buff *skb)\n{\n\tif (skb_mac_header_was_set(skb)) {\n\t\tconst unsigned char *old_mac = skb_mac_header(skb);\n\t\tskb_set_mac_header(skb, -skb->mac_len);\n\t\tmemmove(skb_mac_header(skb), old_mac, skb->mac_len);\n\t}\n}", "target": 0}
{"code": "SMB2_open_free(struct smb_rqst *rqst)\n{\n\tint i;\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}", "target": 0}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n\thook_del_nick_can_register(check_registration_keywords);\n\thook_del_user_can_register(check_registration_keywords);\n\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n}", "target": 0}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withscores = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 0}
{"code": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, true);\n\treturn 0;\n}", "target": 1}
{"code": "void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT index = 0;\n\tif (formatList == NULL)\n\t\treturn;\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\t\tfree(formatList->formats);\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); \n\tconst QFileInfo newFileNameInfo(name);\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (name.contains(\"config.ini\"))\n\t{\n\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";\n\t\treturn;\n\t}\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) \n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 0}
{"code": "void handle_get_plugin_schema_resp(nng_aio *aio, neu_resp_check_schema_t *resp)\n{\n    if (resp->exist) {\n        char * schema_path = NULL;\n        size_t len         = 0;\n        char * buf         = NULL;\n        if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                             resp->schema)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            nlog_info(\"open %s error: %d\", schema_path, errno);\n            neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n            free(schema_path);\n            return;\n        }\n        neu_http_ok(aio, buf);\n        free(buf);\n        free(schema_path);\n    } else {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_PLUGIN_NOT_FOUND, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n    }\n}", "target": 0}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "void IOBuf::allocExtBuffer(\n    std::size_t minCapacity,\n    uint8_t** bufReturn,\n    SharedInfo** infoReturn,\n    std::size_t* capacityReturn) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t mallocSize = goodExtBufferSize(minCapacity);\n  auto buf = static_cast<uint8_t*>(checkedMalloc(mallocSize));\n  initExtBuffer(buf, mallocSize, infoReturn, capacityReturn);\n  (*infoReturn)->userData = reinterpret_cast<void*>(mallocSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(buf, mallocSize);\n  }\n  *bufReturn = buf;\n}", "target": 0}
{"code": "static void adapter_stop(struct btd_adapter *adapter)\n{\n\treply_pending_requests(adapter);\n\tcancel_passive_scanning(adapter);\n\tremove_discovery_list(adapter);\n\tdiscovery_cleanup(adapter, 0);\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\tset_discovery_discoverable(adapter, false);\n\tadapter->discovering = false;\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\tif (adapter->dev_class) {\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}", "target": 0}
{"code": "static char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 0}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "static void copy_password_acl_validation_control(\n\tstruct ldb_request *req,\n\tstruct ldb_reply *ares)\n{\n\tstruct ldb_control *pav_ctrl = NULL;\n\tstruct dsdb_control_password_acl_validation *pav = NULL;\n\tpav_ctrl = ldb_request_get_control(\n\t\tdiscard_const(req),\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID);\n\tif (pav_ctrl == NULL) {\n\t\treturn;\n\t}\n\tpav = talloc_get_type_abort(\n\t\tpav_ctrl->data,\n\t\tstruct dsdb_control_password_acl_validation);\n\tif (pav == NULL) {\n\t\treturn;\n\t}\n\tldb_reply_add_control(\n\t\tares,\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID,\n\t\tfalse,\n\t\tpav);\n}", "target": 0}
{"code": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n\tunsigned int off = skb_gro_offset(skb);\n\tint flush = 1;\n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n\t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n\t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t     !NAPI_GRO_CB(skb)->csum_valid))\n\t\tgoto out;\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n\trcu_read_lock();\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\nunflush:\n\tflush = 0;\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr)); \n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}", "target": 1}
{"code": "static struct mb2_cache_entry *__entry_find(struct mb2_cache *cache,\n\t\t\t\t\t    struct mb2_cache_entry *entry,\n\t\t\t\t\t    u32 key)\n{\n\tstruct mb2_cache_entry *old_entry = entry;\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tif (entry)\n\t\thead = entry->e_hash_list_head;\n\telse\n\t\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\tif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\n\t\tnode = entry->e_hash_list.next;\n\telse\n\t\tnode = hlist_bl_first(head);\n\twhile (node) {\n\t\tentry = hlist_bl_entry(node, struct mb2_cache_entry,\n\t\t\t\t       e_hash_list);\n\t\tif (entry->e_key == key) {\n\t\t\tatomic_inc(&entry->e_refcnt);\n\t\t\tgoto out;\n\t\t}\n\t\tnode = node->next;\n\t}\n\tentry = NULL;\nout:\n\thlist_bl_unlock(head);\n\tif (old_entry)\n\t\tmb2_cache_entry_put(cache, old_entry);\n\treturn entry;\n}", "target": 0}
{"code": "static void GTextFieldSaved(GTextField *gt) {\n    GEvent e;\n    e.type = et_controlevent;\n    e.w = gt->g.base;\n    e.u.control.subtype = et_save;\n    e.u.control.g = &gt->g;\n    if ( gt->g.handle_controlevent != NULL )\n\t(gt->g.handle_controlevent)(&gt->g,&e);\n    else\n\tGDrawPostEvent(&e);\n}", "target": 0}
{"code": "void ssl_update_cache(SSL_CONNECTION *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_CONNECTION_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_CONNECTION_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(SSL_CONNECTION_GET_SSL(s),\n                                                s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\twhile ( size_left ) {\n\t\tuint32_t id;\n\t\tif ( size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template withdraw size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n} ", "target": 0}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm2]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        if (i >= MAX_CHANNELS - num_excl_chan - 7)\n            return n;\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n    return n;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, params.forward_output_shape(), &output));\n    const int32_t highest = static_cast<int32>(Eigen::NumTraits<T>::highest());\n    const int32_t lowest = static_cast<int32>(Eigen::NumTraits<T>::lowest());\n    Tensor int32_output(DT_INT32, params.forward_output_shape());\n    Tensor int32_input(DT_INT32, tensor_in.shape());\n    int32_input.flat<int32>() = tensor_in.flat<T>().template cast<int32>();\n    SpatialAvgPool<Device, int32>(context, &int32_output, int32_input, params,\n                                  padding_);\n    output->flat<T>() = int32_output.flat<int32>()\n                            .cwiseMax(lowest)\n                            .cwiseMin(highest)\n                            .template cast<T>();\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "yang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent)\n{\n    int i = 0, out_index = offset, space = 0;\n    while (i < size) {\n        switch (input[i]) {\n        case '\\n':\n            out_index -= space;\n            output[out_index] = '\\n';\n            space = 0;\n            i = read_indent(input, indent, size, i + 1, &out_index, output);\n            break;\n        case ' ':\n        case '\\t':\n            output[out_index] = input[i];\n            ++space;\n            break;\n        case '\\\\':\n            if (input[i + 1] == 'n') {\n                out_index -= space;\n                output[out_index] = '\\n';\n                space = 0;\n                i = read_indent(input, indent, size, i + 2, &out_index, output);\n            } else if (input[i + 1] == 't') {\n                output[out_index] = '\\t';\n                ++i;\n                ++space;\n            } else if (input[i + 1] == '\\\\') {\n                output[out_index] = '\\\\';\n                ++i;\n            } else if ((i + 1) != size && input[i + 1] == '\"') {\n                output[out_index] = '\"';\n                ++i;\n            } else {\n                LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, input + i);\n                return NULL;\n            }\n            break;\n        default:\n            output[out_index] = input[i];\n            space = 0;\n            break;\n        }\n        ++i;\n        ++out_index;\n    }\n    output[out_index] = '\\0';\n    if (size != out_index) {\n        output = realloc(output, out_index + 1);\n        LY_CHECK_ERR_RETURN(!output, LOGMEM(ctx), NULL);\n    }\n    return output;\n}", "target": 0}
{"code": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  \n  if (num_dims == 0) {\n    return true;\n  }\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    if (current < 0 || current >= num_dims) {\n      return false;\n    }\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "int ossl_dsa_check_params(const DSA *dsa, int checktype, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)\n        return ossl_ffc_params_simple_validate(dsa->libctx, &dsa->params,\n                                               FFC_PARAM_TYPE_DSA, ret);\n    else\n        return ossl_ffc_params_full_validate(dsa->libctx, &dsa->params,\n                                             FFC_PARAM_TYPE_DSA, ret);\n}", "target": 0}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, size, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}", "target": 0}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "p2la(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, out += 4) {\n        const UINT8 *rgba = &palette[*in++ * 4];\n        out[0] = out[1] = out[2] = L(rgba) / 1000;\n        out[3] = rgba[3];\n    }\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "    size_t operator()(const std::string &str) const\n    {\n        const size_t A = 6665339;\n        const size_t B = 2534641;\n        size_t h = fixedRandomNumber;\n        for (char ch : str)\n            h = (h * A) ^ (ch * B);\n        return h;\n    }", "target": 0}
{"code": "static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return; \n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; \n\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\t\tswitch(tag_id) {\n\t\tcase 274: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 296: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 282: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 283: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\tint err;\n\tprepare_to_copy(orig);\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\ttsk->stack = ti;\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\taccount_kernel_stack(ti, 1);\n\treturn tsk;\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}", "target": 0}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStream *bs, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i, count, nbBits;\n\tchar *ptr;\n\tScriptParser parser;\n\te = GF_OK;\n\tif (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;\n\tmemset(&parser, 0, sizeof(ScriptParser));\n\tparser.codec = codec;\n\tparser.script = n;\n\tparser.bs = bs;\n\tparser.length = 500;\n\tparser.string = (char *) gf_malloc(sizeof(char)* parser.length);\n\tparser.string[0] = 0;\n\tparser.identifiers = gf_list_new();\n\tparser.new_line = (char *) (codec->dec_memory_mode ? \"\\n\" : NULL);\n\tparser.indent = 0;\n\tif (gf_bs_read_int(bs, 1)) {\n\t\twhile (!gf_bs_read_int(bs, 1)) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t} else {\n\t\tnbBits = gf_bs_read_int(bs, 4);\n\t\tcount = gf_bs_read_int(bs, nbBits);\n\t\tfor (i=0; i<count; i++) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\tgf_bs_read_int(bs, 1);\n\tSFS_AddString(&parser, \"javascript:\");\n\tSFS_AddString(&parser, parser.new_line);\n\twhile (gf_bs_read_int(bs, 1)) {\n\t\tSFS_AddString(&parser, \"function \");\n\t\tSFS_Identifier(&parser);\n\t\tSFS_Arguments(&parser, GF_FALSE);\n\t\tSFS_Space(&parser);\n\t\tSFS_StatementBlock(&parser, GF_TRUE);\n\t\tSFS_Line(&parser);\n\t\tif (codec->LastError) {\n\t\t\te = codec->LastError;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tSFS_Line(&parser);\n\tif (script_field->script_text) gf_free(script_field->script_text);\n\tscript_field->script_text = (char *) gf_strdup(parser.string);\nexit:\n\twhile (gf_list_count(parser.identifiers)) {\n\t\tptr = (char *)gf_list_get(parser.identifiers, 0);\n\t\tgf_free(ptr);\n\t\tgf_list_rem(parser.identifiers, 0);\n\t}\n\tgf_list_del(parser.identifiers);\n\tif (parser.string) gf_free(parser.string);\n\treturn e;\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    return;\n  }\n  const absl::string_view header_value = absl::string_view(data, length);\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "smtp_log_no_mail(void)\n{\nint i;\nuschar * sep, * s;\ngstring * g = NULL;\nif (smtp_mailcmd_count > 0 || !LOGGING(smtp_no_mail))\n  return;\nif (sender_host_authenticated)\n  {\n  g = string_append(g, 2, US\" A=\", sender_host_authenticated);\n  if (authenticated_id) g = string_append(g, 2, US\":\", authenticated_id);\n  }\n#ifdef SUPPORT_TLS\ng = s_tlslog(g);\n#endif\nsep = smtp_connection_had[SMTP_HBUFF_SIZE-1] != SCH_NONE ?  US\" C=...\" : US\" C=\";\nfor (i = smtp_ch_index; i < SMTP_HBUFF_SIZE; i++)\n  if (smtp_connection_had[i] != SCH_NONE)\n    {\n    g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n    sep = US\",\";\n    }\nfor (i = 0; i < smtp_ch_index; i++)\n  {\n  g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n  sep = US\",\";\n  }\nif (!(s = string_from_gstring(g))) s = US\"\";\nlog_write(0, LOG_MAIN, \"no MAIL in %sSMTP connection from %s D=%s%s\",\n  f.tcp_in_fastopen ? f.tcp_in_fastopen_data ? US\"TFO* \" : US\"TFO \" : US\"\",\n  host_and_ident(FALSE), string_timesince(&smtp_connection_start), s);\n}", "target": 0}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }\n\treturn dst;\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "static void pptp_ctx_switch(struct triton_context_t *ctx, void *arg)\n{\n\tif (arg) {\n\t\tstruct ap_session *s = arg;\n\t\tnet = s->net;\n\t} else\n\t\tnet = def_net;\n\tlog_switch(ctx, arg);\n}", "target": 0}
{"code": "std::string ExpandFilePath(const std::string &filepath, void *) {\n  return filepath;\n#if 0\n#ifdef _WIN32\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n#else\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n  if (filepath.empty()) {\n    return \"\";\n  }\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    s = filepath;\n    return s;\n  }\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n#endif\n  return s;\n#endif\n#endif\n}", "target": 0}
{"code": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (avio_feof(f)) {\n            index->item_count = 0;\n            av_freep(&index->items);\n            return AVERROR_INVALIDDATA;\n        }\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "PHPAPI int php_lint_script(zend_file_handle *file)\n{\n\tzend_op_array *op_array;\n\tint retval = FAILURE;\n\tzend_try {\n\t\top_array = zend_compile_file(file, ZEND_INCLUDE);\n\t\tzend_destroy_file_handle(file);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t\tretval = SUCCESS;\n\t\t}\n\t} zend_end_try();\n\tif (EG(exception)) {\n\t\tzend_exception_error(EG(exception), E_ERROR);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "cib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n    int csock = 0;\n    if (client == NULL) {\n        return;\n    }\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    if (client->remote_auth_timeout) {\n        g_source_remove(client->remote_auth_timeout);\n    }\n    if (client->encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (client->session) {\n            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n            csock = GPOINTER_TO_INT(sock_ptr);\n            if (client->handshake_complete) {\n                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n            }\n            gnutls_deinit(*client->session);\n            gnutls_free(client->session);\n        }\n#endif\n    } else {\n        csock = GPOINTER_TO_INT(client->session);\n    }\n    client->session = NULL;\n    if (csock > 0) {\n        close(csock);\n    }\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client->recv_buf);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}", "target": 0}
{"code": "void RtmpProtocol::handle_C1_simple(const char *data){\n    char handshake_head = HANDSHAKE_PLAINTEXT;\n    onSendRawData(obtainBuffer(&handshake_head, 1));\n    RtmpHandshake s1(0);\n    onSendRawData(obtainBuffer((char *) &s1, C1_HANDSHARK_SIZE));\n    onSendRawData(obtainBuffer(data + 1, C1_HANDSHARK_SIZE));\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C2(data, len);\n    };\n}", "target": 0}
{"code": "bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n{\n\tFILE *f;\n\tchar line[400];\n\tsprintf(line, \"/proc/%d/uid_map\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\treturn false;\n\t}\n\t*answer = convert_id_to_ns(f, uid);\n\tfclose(f);\n\tif (*answer == -1)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "static void edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\tint bv = 0;\t\n\tif (break_state == -1)\n\t\tbv = 1;\t\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - error %d sending break set/clear command.\\n\",\n\t\t\t__func__, status);\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "static void cleanup_timers(struct list_head *head,\n\t\t\t   cputime_t utime, cputime_t stime,\n\t\t\t   unsigned long long sum_exec_runtime)\n{\n\tstruct cpu_timer_list *timer, *next;\n\tcputime_t ptime = cputime_add(utime, stime);\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, ptime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t ptime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, utime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t utime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (timer->expires.sched < sum_exec_runtime) {\n\t\t\ttimer->expires.sched = 0;\n\t\t} else {\n\t\t\ttimer->expires.sched -= sum_exec_runtime;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "static int snmp6_alloc_dev(struct inet6_dev *idev)\n{\n\tif (snmp_mib_init((void __percpu **)idev->stats.ipv6,\n\t\t\t  sizeof(struct ipstats_mib),\n\t\t\t  __alignof__(struct ipstats_mib)) < 0)\n\t\tgoto err_ip;\n\tidev->stats.icmpv6dev = kzalloc(sizeof(struct icmpv6_mib_device),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!idev->stats.icmpv6dev)\n\t\tgoto err_icmp;\n\tidev->stats.icmpv6msgdev = kzalloc(sizeof(struct icmpv6msg_mib_device),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!idev->stats.icmpv6msgdev)\n\t\tgoto err_icmpmsg;\n\treturn 0;\nerr_icmpmsg:\n\tkfree(idev->stats.icmpv6dev);\nerr_icmp:\n\tsnmp_mib_free((void __percpu **)idev->stats.ipv6);\nerr_ip:\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "void UpdateDownloader::CleanLeftovers()\n{\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n    try\n    {\n        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n        {\n            Settings::DeleteConfigValue(\"UpdateTempDir\");\n            return;\n        }\n    }\n    catch (Win32Exception&) \n    {\n        return;\n    }\n    tmpdir.append(1, '\\0'); \n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | \n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n}", "target": 0}
{"code": "int LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  if(!fname) \n    return ENOENT;\n  FILE *tfp = fopen(fname,\"wb\");\n  if(!tfp) \n    return errno;\n  if(!T.thumb)\n    {\n      fclose(tfp);\n      return LIBRAW_OUT_OF_ORDER_CALL;\n    }\n  try {\n    switch (T.tformat)\n      {\n      case LIBRAW_THUMBNAIL_JPEG:\n        jpeg_thumb_writer (tfp,T.thumb,T.tlength);\n        break;\n      case LIBRAW_THUMBNAIL_BITMAP:\n        fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n        fwrite (T.thumb, 1, T.tlength, tfp);\n        break;\n      default:\n        fclose(tfp);\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    fclose(tfp);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}", "target": 0}
{"code": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}", "target": 1}
{"code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\treturn 0;\n}", "target": 1}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type!=5) return 0; \n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}", "target": 1}
{"code": "krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *minor_status = 0;\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (!ctx->established)\n        return GSS_S_NO_CONTEXT;\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n    *minor_status = EINVAL;\n    return GSS_S_UNAVAILABLE;\n}", "target": 1}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\t\tath_txq_lock(sc, txq);\n\t\tbuffered = ath_tid_has_buffered(tid);\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n\tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\tbsg_set_block(bd, file);\n\tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\t*ppos = bytes_written;\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}", "target": 0}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 0}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n      __err:\n\treturn err;\n}", "target": 0}
{"code": "bool Url::Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tdisable_gif(svm);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\treturn 1;\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "hphp_libxml_input_buffer_noload(const char *URI, xmlCharEncoding enc) {\n  return nullptr;\n}", "target": 1}
{"code": "static void __exit acpi_custom_method_exit(void)\n{\n\tif (cm_dentry)\n\t\tdebugfs_remove(cm_dentry);\n }", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}", "target": 1}
{"code": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}", "target": 1}
{"code": "void rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}", "target": 0}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n  if (isInitiatedStream(streamId)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}", "target": 1}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);\n\t}\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\terr = btrfs_run_qgroups(trans);\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\tif (err < 0)\n\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t      \"failed to update qgroup status and info\");\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}", "target": 0}
{"code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "target": 0}
{"code": "parse_notification_delta(xmlTextReaderPtr reader,\n    struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head *tmp;\n\tunsigned long serial;\n\tint error;\n\terror = delta_head_create(&tmp);\n\tif (error)\n\t\treturn error;\n\terror = parse_long(reader, RRDP_ATTR_SERIAL, &serial);\n\tif (error)\n\t\tgoto delta_destroy;\n\ttmp->serial = serial;\n\terror = parse_doc_data(reader, true, true, &tmp->doc_data);\n\tif (error)\n\t\tgoto delta_destroy;\n\terror = deltas_parsed_add(&ctx->deltas, &tmp);\n\tif (error)\n\t\tgoto delta_destroy;\n\treturn 0;\ndelta_destroy:\n\tdelta_head_destroy(tmp);\n\treturn error;\n}", "target": 1}
{"code": "void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long vmflag)\n{\n\tunsigned long addr;\n\tunsigned long base_pages_to_flush = TLB_FLUSH_ALL;\n\tpreempt_disable();\n\tif (current->active_mm != mm)\n\t\tgoto out;\n\tif (!current->mm) {\n\t\tleave_mm(smp_processor_id());\n\t\tgoto out;\n\t}\n\tif ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))\n\t\tbase_pages_to_flush = (end - start) >> PAGE_SHIFT;\n\tif (base_pages_to_flush > tlb_single_page_flush_ceiling) {\n\t\tbase_pages_to_flush = TLB_FLUSH_ALL;\n\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\t\tlocal_flush_tlb();\n\t} else {\n\t\tfor (addr = start; addr < end;\taddr += PAGE_SIZE) {\n\t\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);\n\t\t\t__flush_tlb_single(addr);\n\t\t}\n\t}\n\ttrace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);\nout:\n\tif (base_pages_to_flush == TLB_FLUSH_ALL) {\n\t\tstart = 0UL;\n\t\tend = TLB_FLUSH_ALL;\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, end);\n\tpreempt_enable();\n}", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "static int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tmutex_lock(&floppy_mutex);\n\tUDP->cmos = v.cmos;\n\tUDP->max_dtr = v.max_dtr;\n\tUDP->hlt = v.hlt;\n\tUDP->hut = v.hut;\n\tUDP->srt = v.srt;\n\tUDP->spinup = v.spinup;\n\tUDP->spindown = v.spindown;\n\tUDP->spindown_offset = v.spindown_offset;\n\tUDP->select_delay = v.select_delay;\n\tUDP->rps = v.rps;\n\tUDP->tracks = v.tracks;\n\tUDP->timeout = v.timeout;\n\tUDP->interleave_sect = v.interleave_sect;\n\tUDP->max_errors = v.max_errors;\n\tUDP->flags = v.flags;\n\tUDP->read_track = v.read_track;\n\tmemcpy(UDP->autodetect, v.autodetect, sizeof(v.autodetect));\n\tUDP->checkfreq = v.checkfreq;\n\tUDP->native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "    const char* Image::typeName(uint16_t tag) const\n    {\n        const char* result = nullptr;\n        switch (tag ) {\n            case Exiv2::unsignedByte     : result = \"BYTE\"      ; break;\n            case Exiv2::asciiString      : result = \"ASCII\"     ; break;\n            case Exiv2::unsignedShort    : result = \"SHORT\"     ; break;\n            case Exiv2::unsignedLong     : result = \"LONG\"      ; break;\n            case Exiv2::unsignedRational : result = \"RATIONAL\"  ; break;\n            case Exiv2::signedByte       : result = \"SBYTE\"     ; break;\n            case Exiv2::undefined        : result = \"UNDEFINED\" ; break;\n            case Exiv2::signedShort      : result = \"SSHORT\"    ; break;\n            case Exiv2::signedLong       : result = \"SLONG\"     ; break;\n            case Exiv2::signedRational   : result = \"SRATIONAL\" ; break;\n            case Exiv2::tiffFloat        : result = \"FLOAT\"     ; break;\n            case Exiv2::tiffDouble       : result = \"DOUBLE\"    ; break;\n            case Exiv2::tiffIfd          : result = \"IFD\"       ; break;\n            default                      : result = \"unknown\"   ; break;\n        }\n        return result;\n    }", "target": 0}
{"code": "remove_this_reserved_job(conn c, job j)\n{\n    j = job_remove(j);\n    if (j) {\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        j->reserver = NULL;\n    }\n    c->soonest_job = NULL;\n    if (!job_list_any_p(&c->reserved_jobs)) conn_remove(c);\n    return j;\n}", "target": 0}
{"code": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}", "target": 1}
{"code": "static void *smm_stub_place_stacks(char *base, size_t size,\n\t\t\t\t   struct smm_loader_params *params)\n{\n\tsize_t total_stack_size;\n\tchar *stacks_top;\n\ttotal_stack_size = params->per_cpu_stack_size *\n\t\t\t   params->num_concurrent_stacks;\n\tprintk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",\n\t\t__func__, params->num_concurrent_stacks,\n\t\ttotal_stack_size);\n\tprintk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",\n\t\tsize, params->per_cpu_stack_size);\n\tif (params->num_concurrent_stacks < 1)\n\t\treturn NULL;\n\tif (total_stack_size > size)\n\t\treturn NULL;\n\tstacks_top = &base[total_stack_size];\n\tprintk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);\n\treturn stacks_top;\n}", "target": 0}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 0}
{"code": "static int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}", "target": 0}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = VM_FAULT_NOPAGE;\n\tloff_t size;\n\tsb_start_pagefault(sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\tret = VM_FAULT_SIGBUS;\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(sb);\n\treturn ret;\n}", "target": 0}
{"code": "GF_Err pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *)s;\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tif (ptr->version > 0) {\n\t\tptr->KID_count = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tif (ptr->KID_count) {\n\t\t\tu32 i;\n\t\t\tif (ptr->size / sizeof(bin128) < ptr->KID_count)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tptr->KIDs = gf_malloc(ptr->KID_count*sizeof(bin128));\n\t\t\tif (!ptr->KIDs)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\t\tgf_bs_read_data(bs, (char *) ptr->KIDs[i], 16);\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\t}\n\t\t}\n\t}\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->private_data_size) {\n\t\tif (ptr->size < ptr->private_data_size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\t\tif (!ptr->private_data)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "fbStore_a1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  *pixel = ((CARD32 *) bits) + ((i+x) >> 5);\n        CARD32  mask = FbStipMask((i+x) & 0x1f, 1);\n        CARD32 v = READ(values + i) & 0x80000000 ? mask : 0;\n        WRITE(pixel, (READ(pixel) & ~mask) | v);\n    }\n}", "target": 0}
{"code": "unsigned long _copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tunsigned long res = n;\n\tmight_fault();\n\tif (!should_fail_usercopy() && likely(access_ok(from, n))) {\n\t\tbarrier_nospec();\n\t\tinstrument_copy_from_user_before(to, from, n);\n\t\tres = raw_copy_from_user(to, from, n);\n\t\tinstrument_copy_from_user_after(to, from, n, res);\n\t}\n\tif (unlikely(res))\n\t\tmemset(to + (n - res), 0, res);\n\treturn res;\n}", "target": 0}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\treturn store_instr(ins.channel, &ins);\n}", "target": 1}
{"code": "static HashTable* spl_array_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(obj TSRMLS_CC);\n\tzval *tmp, *storage;\n\tint name_len;\n\tchar *zname;\n\tzend_class_entry *base;\n\t*is_temp = 0;\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\tif (HASH_OF(intern->array) == intern->std.properties) {\n\t\treturn intern->std.properties;\n\t} else {\n\t\tif (intern->debug_info == NULL) {\n\t\t\tALLOC_HASHTABLE(intern->debug_info);\n\t\t\tZEND_INIT_SYMTABLE_EX(intern->debug_info, zend_hash_num_elements(intern->std.properties) + 1, 0);\n\t\t}\n\t\tif (intern->debug_info->nApplyCount == 0) {\n\t\t\tzend_hash_clean(intern->debug_info);\n\t\t\tzend_hash_copy(intern->debug_info, intern->std.properties, (copy_ctor_func_t) zval_add_ref, (void *) &tmp, sizeof(zval *));\n\t\t\tstorage = intern->array;\n\t\t\tzval_add_ref(&storage);\n\t\t\tbase = (Z_OBJ_HT_P(obj) == &spl_handler_ArrayIterator) ? spl_ce_ArrayIterator : spl_ce_ArrayObject;\n\t\t\tzname = spl_gen_private_prop_name(base, \"storage\", sizeof(\"storage\")-1, &name_len TSRMLS_CC);\n\t\t\tzend_symtable_update(intern->debug_info, zname, name_len+1, &storage, sizeof(zval *), NULL);\n\t\t\tefree(zname);\n\t\t}\n\t\treturn intern->debug_info;\n\t}\n}", "target": 0}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}", "target": 0}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "static UINT ExtractRunLengthMegaMega(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\tif (!buffer_within_range(pbOrderHdr, 2, pbEnd))\n\t{\n\t\t*advance = 0;\n\t\treturn 0;\n\t}\n\trunLength = ((UINT16)pbOrderHdr[1]) | (((UINT16)pbOrderHdr[2]) << 8);\n\t(*advance) += 2;\n\treturn runLength;\n}", "target": 1}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n    : BasicHandler(parent),\n    _network(parent)\n{\n    connect(this, SIGNAL(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)),\n        network(), SLOT(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n    connect(this, SIGNAL(putRawLine(const QByteArray &)),\n        network(), SLOT(putRawLine(const QByteArray &)));\n}", "target": 0}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n  PolicyRights\n    rights;\n  const CoderInfo\n    *p;\n  size_t\n    extent;\n  ssize_t\n    i;\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}", "target": 0}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 0}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int rm_rf_children_inner(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                _cleanup_close_ int subdir_fd = -1;\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 1}
{"code": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\trs_filter_graph_helper(str, filter);\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_string_free(str, TRUE);\n}", "target": 1}
{"code": "DLLIMPORT const char *cfg_title(cfg_t *cfg)\n{\n\tif (cfg)\n\t\treturn cfg->title;\n\treturn NULL;\n}", "target": 0}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "static int bnx2x_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bnx2x_vlan_entry *vlan;\n\tDP(NETIF_MSG_IFUP, \"Adding VLAN %d\\n\", vid);\n\tvlan = kmalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\tvlan->vid = vid;\n\tvlan->hw = false;\n\tlist_add_tail(&vlan->link, &bp->vlan_reg);\n\tif (netif_running(dev))\n\t\tbnx2x_vlan_configure(bp, true);\n\treturn 0;\n}", "target": 0}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_BASE + DRAM1_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif (dst < prot_start && dst > prot_start - len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      blob_info->data=NULL;\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}", "target": 0}
{"code": "static ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (!MAY_PTRACE(task) || !ptrace_may_attach(task))\n\t\tgoto out;\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_process_vm(task, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           value_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               value_tensor->type == kTfLiteInt64));\n  TF_LITE_ENSURE(context, HaveSameShapes(key_tensor, value_tensor));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\tif (!fc)\n\t\treturn -EIO;\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}", "target": 1}
{"code": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "R_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}", "target": 0}
{"code": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}", "target": 0}
{"code": " static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n {\n\tUINT32 front;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}", "target": 0}
{"code": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n          return -1;\n        }\n      client->auth_end_offset = -1;\n    }\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n  return -1;\n}", "target": 1}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\tBUG_ON(!thresholds);\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\tsynchronize_rcu();\n\tmutex_unlock(&memcg->thresholds_lock);\n}", "target": 1}
{"code": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\tif (sk == NULL)\n\t\treturn 0;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "void thread_func(unsigned int start, unsigned int end, int fd)\n{\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tunsigned int i;\n\tchar *data;\n\tdata = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);\n\tif (data == MAP_FAILED) {\n\t\tprintf(\"mmap failed, get a better phone\\n\");\n\t\texit(0);\n\t}\n\tfor (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))\n\t\t*((unsigned long *)(data + i)) = 0xABADACC355001337;\n\treq.in_place_op = 1;\n\treq.entries = 2;\n\treq.byteoffset = 15;\n\treq.mode = QCEDEV_AES_MODE_CTR;\n\treq.op = QCEDEV_OPER_ENC;\n\treq.ivlen = 1;\n\treq.data_len = 0xFFFFFFFE;\n\treq.vbuf.src[0].len = 4;\n\treq.vbuf.src[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.src[0].vaddr = (uint8_t*)data;\n\treq.vbuf.src[1].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[0].len = 4;\n\treq.vbuf.dst[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.dst[0].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[1].vaddr = (uint8_t*)data;\n\tioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);\n\tprintf(\"exiting\\n\");\n\texit(0);\n}", "target": 0}
{"code": "int fit_config_verify_required_sigs(const void *fit, int conf_noffset,\n\t\t\t\t    const void *sig_blob)\n{\n\tint noffset;\n\tint sig_node;\n\tint verified = 0;\n\tint reqd_sigs = 0;\n\tbool reqd_policy_all = true;\n\tconst char *reqd_mode;\n\tsig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);\n\tif (sig_node < 0) {\n\t\tdebug(\"%s: No signature node found: %s\\n\", __func__,\n\t\t      fdt_strerror(sig_node));\n\t\treturn 0;\n\t}\n\treqd_mode = fdt_getprop(sig_blob, sig_node, \"required-mode\", NULL);\n\tif (reqd_mode && !strcmp(reqd_mode, \"any\"))\n\t\treqd_policy_all = false;\n\tdebug(\"%s: required-mode policy set to '%s'\\n\", __func__,\n\t      reqd_policy_all ? \"all\" : \"any\");\n\tfdt_for_each_subnode(noffset, sig_blob, sig_node) {\n\t\tconst char *required;\n\t\tint ret;\n\t\trequired = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,\n\t\t\t\t       NULL);\n\t\tif (!required || strcmp(required, \"conf\"))\n\t\t\tcontinue;\n\t\treqd_sigs++;\n\t\tret = fit_config_verify_sig(fit, conf_noffset, sig_blob,\n\t\t\t\t\t    noffset);\n\t\tif (ret) {\n\t\t\tif (reqd_policy_all) {\n\t\t\t\tprintf(\"Failed to verify required signature '%s'\\n\",\n\t\t\t\t       fit_get_name(sig_blob, noffset, NULL));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tverified++;\n\t\t\tif (!reqd_policy_all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (reqd_sigs && !verified) {\n\t\tprintf(\"Failed to verify 'any' of the required signature(s)\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "static void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\tskcipher_free_sgl(sk);\n\tsock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}", "target": 0}
{"code": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}", "target": 1}
{"code": "static int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 1}
{"code": "quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(\n    ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,\n    Type target, int quant_dim) {\n  auto shaped = target.dyn_cast<RankedTensorType>();\n  if (!shaped) return {};\n  ArrayRef<int64_t> new_shape = shaped.getShape();\n  SmallVector<double, 4> scales(qtype.getScales().begin(),\n                                qtype.getScales().end());\n  SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),\n                                      qtype.getZeroPoints().end());\n  if (new_shape.size() == shape.size()) {  \n    if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||\n        BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {\n      return {};\n    }\n  } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {\n    if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&\n        quant_dim == -1) {\n      quant_dim = shape.size() + quant_dim;\n    } else {\n      return {};\n    }\n  } else {\n    return {};\n  }\n  return quant::UniformQuantizedPerAxisType::get(\n      qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),\n      scales, zero_points, quant_dim, qtype.getStorageTypeMin(),\n      qtype.getStorageTypeMax());\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "void mesh_state_remove_reply(struct mesh_area* mesh, struct mesh_state* m,\n\tstruct comm_point* cp)\n{\n\tstruct mesh_reply* n, *prev = NULL;\n\tn = m->reply_list;\n\tif(!n) return; \n\twhile(n) {\n\t\tif(n->query_reply.c == cp) {\n\t\t\tif(prev) prev->next = n->next;\n\t\t\telse m->reply_list = n->next;\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&n->query_reply, mesh->env->cfg);\n\t\t\tn = n->next;\n\t\t\tcontinue;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\tif(!m->reply_list && !m->cb_list\n\t\t&& m->super_set.count == 0) {\n\t\tmesh->num_detached_states++;\n\t}\n\tif(!m->reply_list && !m->cb_list) {\n\t\tlog_assert(mesh->num_reply_states > 0);\n\t\tmesh->num_reply_states--;\n\t}\n}", "target": 0}
{"code": "static void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce, *tmp;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_for_each_entry_safe(jce, tmp, &txn->t_private_list, jce_list) {\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}", "target": 0}
{"code": "CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \"UTF-8\";\n    }\n    return sEncoding;\n}", "target": 1}
{"code": "void PrepareTFPass::runOnOperation() {\n  MLIRContext *ctx = &getContext();\n  RewritePatternSet patterns(ctx);\n  RewritePatternSet phase_2_patterns(ctx);\n  auto func = getOperation();\n  if (failed(ValidateOp(func))) {\n    func.emitError() << \"tfl-prepare-tf pass failed.\";\n    signalPassFailure();\n    return;\n  }\n  if (failed(ConvertTf2XlaOps(func, ctx))) {\n    signalPassFailure();\n    return;\n  }\n  patterns.add<ConvertTFDilatedConvOp<TF::Conv2DOp>, FusedBatchNormV3Pat,\n               ConvertTFDilatedConvOp<TF::DepthwiseConv2dNativeOp>>(ctx);\n  patterns.add<RemoveIdentity>(ctx);\n  TFL::populateWithGenerated(patterns);\n  TF::ReshapeOp::getCanonicalizationPatterns(patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(patterns));\n  if (failed(ConvertFakeQuantOps(func, ctx, use_fake_quant_num_bits_))) {\n    signalPassFailure();\n    return;\n  }\n  TFL::populateWithGenerated(phase_2_patterns);\n  if (unfold_batch_matmul_) {\n    TF::PopulateUnrollTfBatchMatMul(ctx, phase_2_patterns);\n  }\n  phase_2_patterns\n      .add<TF::ConvertTFEinsumOp, ConvertTFBroadcastTo, ConvertTFStridedSlice,\n           ConvertRfftToRfft2d, RemoveIdentity>(ctx);\n  phase_2_patterns.add<ConvertTFConv2D, ConvertTFDepthwiseConv2dNative>(\n      ctx, allow_bf16_and_f16_type_legalization_);\n  TF::ReshapeOp::getCanonicalizationPatterns(phase_2_patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(phase_2_patterns));\n}", "target": 0}
{"code": "TfLiteStatus Relu6Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  Relu6OpData* data = static_cast<Relu6OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  if (input->type == kTfLiteInt8) {\n    data->six_int8 = FloatToAsymmetricQuantizedInt8(6.0f, input->params.scale,\n                                                    input->params.zero_point);\n    data->zero_int8 = input->params.zero_point;\n  } else if (input->type == kTfLiteUInt8) {\n    data->six_uint8 = FloatToAsymmetricQuantizedUInt8(6.0f, input->params.scale,\n                                                      input->params.zero_point);\n    data->zero_uint8 = input->params.zero_point;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t\n\treturn (ret);\n}", "target": 1}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "static void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}", "target": 0}
{"code": "init_level(struct cert_stack *stack, unsigned int *_result)\n{\n\tstruct metadata_node *head_meta;\n\tunsigned int work_repo_level;\n\tunsigned int result;\n\tresult = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_meta = SLIST_FIRST(&stack->metas);\n\tif (head_meta != NULL && work_repo_level > head_meta->level)\n\t\tresult = work_repo_level;\n\t*_result = result;\n\treturn 0;\n}", "target": 0}
{"code": "int pam_modutil_drop_priv(pam_handle_t *pamh, struct _ykpam_privs *privs, struct passwd *pw) {\n    privs->saved_euid = geteuid();\n    privs->saved_egid = getegid();\n    if ((privs->saved_euid == pw->pw_uid) && (privs->saved_egid == pw->pw_gid)) {\n        D (privs->debug_file, \"Privilges already dropped, pretend it is all right\");\n        return 0;\n    }\n    privs->saved_groups_length = getgroups(0, NULL);\n    if (privs->saved_groups_length < 0) {\n        D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n        return -1;\n    }\n    if (privs->saved_groups_length > SAVED_GROUPS_MAX_LEN) {\n        D (privs->debug_file, \"too many groups, limiting.\");\n        privs->saved_groups_length = SAVED_GROUPS_MAX_LEN;\n    }\n    if (privs->saved_groups_length > 0) {\n        if (getgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n            D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n            goto free_out;\n        }\n    }\n    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n        D (privs->debug_file, \"initgroups: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (setegid(pw->pw_gid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (seteuid(pw->pw_uid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        goto free_out;\n    }\n    return 0;\nfree_out:\n    return -1;\n}", "target": 0}
{"code": "INST_HANDLER (lds) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "target": 0}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "  Status operator()(OpKernelContext* context,\n                    typename TTypes<Tindex>::ConstVec reverse_index_map,\n                    typename TTypes<T>::ConstVec grad_values,\n                    typename TTypes<T>::Vec d_values,\n                    typename TTypes<T>::Scalar d_default_value) {\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, device,\n        N, reverse_index_map, grad_values, d_values, visited));\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>\n        transform_iterator(counting_iterator, mask_values_fn);\n    std::size_t temp_storage_bytes = 0;\n    auto gpuprim_status = gpuprim::DeviceReduce::Sum(\n        nullptr, temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to calculate temp_storage_bytes, \"\n          \"status: \",\n          GpuGetErrorString(gpuprim_status));\n    }\n    Tensor temp_storage;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        DT_INT8, TensorShape({static_cast<int64_t>(temp_storage_bytes)}),\n        &temp_storage));\n    gpuprim_status = gpuprim::DeviceReduce::Sum(\n        temp_storage.flat<int8>().data(), temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to sum values from originally-empty \"\n          \"rows. temp_storage_bytes: \",\n          temp_storage_bytes, \", status: \", GpuGetErrorString(gpuprim_status));\n    }\n    return OkStatus();\n  }", "target": 1}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "BOOL freerdp_image_copy(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                        UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,\n                        DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,\n                        const gdiPalette* palette, UINT32 flags)\n{\n\tconst UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);\n\tconst UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);\n\tif ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))\n\t\treturn FALSE;\n\tif (!pDstData || !pSrcData)\n\t\treturn FALSE;\n\tif ((nWidth == 0) || (nHeight == 0))\n\t\treturn TRUE;\n\tif (nDstStep == 0)\n\t\tnDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\tif (nSrcStep == 0)\n\t\tnSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);\n\tconst BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,\n\t                             nSrcStep, srcByte, nWidth, nHeight);\n\tif (ovl)\n\t\treturn freerdp_image_copy_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t\t                                  nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t\t                                  palette, flags);\n\treturn freerdp_image_copy_no_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t                                     nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t                                     palette, flags);\n}", "target": 0}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tdown_read(&card->controls_rwsem);\n\tresult = snd_ctl_elem_read(card, control);\n\tup_read(&card->controls_rwsem);\n\tif (result < 0)\n\t\tgoto error;\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}", "target": 1}
{"code": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n  max_request_headers_kb_ = 96;\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  for (int i = 0; i < 20000; i++) {\n    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));\n  }\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}", "target": 0}
{"code": "static int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\tvips_tracked_init(); \n\tsize += 16;\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif \n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n                return( NULL );\n\t}\n\tg_mutex_lock( vips_tracked_mutex );\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif \n\tg_mutex_unlock( vips_tracked_mutex );\n\tVIPS_GATE_MALLOC( size ); \n        return( buf );\n}", "target": 1}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "slhc_free(struct slcompress *comp)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_free\");\n}", "target": 0}
{"code": "static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}", "target": 0}
{"code": "static u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\twhile (isspace(*numstr))\n\t\tnumstr++;\n\tif (*numstr == '-')\n\t\treturn -EINVAL;\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno == ERANGE && uli == ULONG_MAX)\n\t\treturn -ERANGE;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}", "target": 0}
{"code": "null_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int length = h->len;\n\tu_int caplen = h->caplen;\n\tu_int family;\n\tif (caplen < NULL_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|null]\"));\n\t\treturn (NULL_HDRLEN);\n\t}\n\tmemcpy((char *)&family, (const char *)p, sizeof(family));\n\tif ((family & 0xFFFF0000) != 0)\n\t\tfamily = SWAPLONG(family);\n\tif (ndo->ndo_eflag)\n\t\tnull_hdr_print(ndo, family, length);\n\tlength -= NULL_HDRLEN;\n\tcaplen -= NULL_HDRLEN;\n\tp += NULL_HDRLEN;\n\tswitch (family) {\n\tcase BSD_AFNUM_INET:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_INET6_BSD:\n\tcase BSD_AFNUM_INET6_FREEBSD:\n\tcase BSD_AFNUM_INET6_DARWIN:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_ISO:\n\t\tisoclns_print(ndo, p, length, caplen);\n\t\tbreak;\n\tcase BSD_AFNUM_APPLETALK:\n\t\tatalk_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tnull_hdr_print(ndo, family, length + NULL_HDRLEN);\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, caplen);\n\t}\n\treturn (NULL_HDRLEN);\n}", "target": 1}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n#ifdef HAVE_MKDTEMP\n    if (no_rc_dir && tmp_dir != rc_dir)\n\tif (rmdir(tmp_dir) != 0) {\n\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n\t    exit(1);\n\t}\n#endif\n    exit(i);\n}", "target": 0}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void *snd_malloc_sbus_pages(struct device *dev, size_t size,\n\t\t\t\t   dma_addr_t *dma_addr)\n{\n\tstruct sbus_dev *sdev = (struct sbus_dev *)dev;\n\tint pg;\n\tvoid *res;\n\tsnd_assert(size > 0, return NULL);\n\tsnd_assert(dma_addr != NULL, return NULL);\n\tpg = get_order(size);\n\tres = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);\n\tif (res != NULL)\n\t\tinc_snd_pages(pg);\n\treturn res;\n}", "target": 0}
{"code": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\t__u32 hash[4];\n\tmemcpy(hash, daddr, 16);\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "ServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n        if (args().check_client_certificates) {\n            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n        }\n    }\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n    return listen;\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n  SizeUnknown = 0x7F; \n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      if (PossibleSizeLength > BufferSize)\n        break;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n      BufferSize = PossibleSizeLength;\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n  BufferSize = 0;\n  return 0;\n}", "target": 0}
{"code": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static void f2fs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tclear_inode_flag(inode, FI_PIN_FILE);\n}", "target": 0}
{"code": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n\t\t\treturn -EBADR;\n\t\t}\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\treturn work_to_do;\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "child_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n  flatpak_close_fds_workaround (3);\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n  if (data->env_fd != -1)\n    drop_cloexec (data->env_fd);\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\"Failed to unblock signals when starting child\");\n      return;\n    }\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n      drop_cloexec (fd_map[i].final);\n    }\n  setsid ();\n  setpgid (0, 0);\n  if (data->set_tty)\n    {\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\"ioctl(%d, TIOCSCTTY, 0) failed: %s\",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "    PngImage::PngImage(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::png, mdExif | mdIptc | mdXmp | mdComment, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngImage:: Creating PNG image to memory\\n\";\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(pngBlank, sizeof(pngBlank)) != sizeof(pngBlank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngImage:: Failed to create PNG image on memory\\n\";\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\t\tkey.objectid = BTRFS_DEV_STATS_OBJECTID;\n\t\tkey.type = BTRFS_PERSISTENT_ITEM_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}", "target": 0}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static void nf_tables_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_expr *expr)\n{\n\tif (expr->ops->destroy)\n\t\texpr->ops->destroy(ctx, expr);\n\tmodule_put(expr->ops->type->owner);\n}", "target": 0}
{"code": "void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n    WifiPacket pkt(cbs,header_type,header,packet);\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}", "target": 0}
{"code": "static void _pam_log_int(const pam_handle_t *pamh,\n\t\t\t int err,\n\t\t\t const char *format,\n\t\t\t va_list args)\n{\n\tpam_vsyslog(pamh, err, format, args);\n}", "target": 0}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "int gru_set_context_option(unsigned long arg)\n{\n\tstruct gru_thread_state *gts;\n\tstruct gru_set_context_option_req req;\n\tint ret = 0;\n\tSTAT(set_context_option);\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\tgru_dbg(grudev, \"op %d, gseg 0x%lx, value1 0x%lx\\n\", req.op, req.gseg, req.val1);\n\tgts = gru_find_lock_gts(req.gseg);\n\tif (!gts) {\n\t\tgts = gru_alloc_locked_gts(req.gseg);\n\t\tif (IS_ERR(gts))\n\t\t\treturn PTR_ERR(gts);\n\t}\n\tswitch (req.op) {\n\tcase sco_blade_chiplet:\n\t\tif (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||\n\t\t    req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||\n\t\t    (req.val1 >= 0 && !gru_base[req.val1])) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tgts->ts_user_blade_id = req.val1;\n\t\t\tgts->ts_user_chiplet_id = req.val0;\n\t\t\tgru_check_context_placement(gts);\n\t\t}\n\t\tbreak;\n\tcase sco_gseg_owner:\n\t\tgts->ts_tgid_owner = current->tgid;\n\t\tbreak;\n\tcase sco_cch_req_slice:\n\t\tgts->ts_cch_req_slice = req.val1 & 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n        else {\n          warn (\"[http] Ignorning broken multipart/form-data\");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}", "target": 0}
{"code": "static int perf_release(struct inode *inode, struct file *file)\n{\n\tput_event(file->private_data);\n\treturn 0;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "bool Mfcc::Initialize(int input_length, double input_sample_rate) {\n  bool initialized = mel_filterbank_.Initialize(\n      input_length, input_sample_rate, filterbank_channel_count_,\n      lower_frequency_limit_, upper_frequency_limit_);\n  initialized &=\n      dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_);\n  initialized_ = initialized;\n  return initialized;\n}", "target": 1}
{"code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}", "target": 0}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}", "target": 1}
{"code": "_defbackend_gen_returntext(char *buffer, size_t buflen, char **dns)\n{\n    int dnidx;\n    int sidx;\n    struct suffix_repeat {\n        char *suffix;\n        int size;\n    } candidates[] = {\n        {\"dc=\", 3}, \n        {NULL, 0}\n    };\n    PR_snprintf(buffer, buflen, \"%s (\", DEFBE_NO_SUCH_SUFFIX);\n    for (dnidx = 0; dns[dnidx]; dnidx++) ; \n    dnidx--; \n    for (sidx = 0; candidates[sidx].suffix; sidx++) {\n        if (!PL_strncasecmp(dns[dnidx], candidates[sidx].suffix, candidates[sidx].size)) {\n            while (!PL_strncasecmp(dns[--dnidx], candidates[sidx].suffix, candidates[sidx].size)) ;\n            PL_strcat(buffer, dns[++dnidx]); \n            for (++dnidx; dns[dnidx]; dnidx++) {\n                PL_strcat(buffer, \",\");\n                PL_strcat(buffer, dns[dnidx]);\n            }\n            PL_strcat(buffer, \")\");\n            return; \n        }\n    }\n    PL_strcat(buffer, dns[dnidx]);\n    PL_strcat(buffer, \")\");\n    return;\n}", "target": 0}
{"code": "int gnutls_x509_ext_export_aia(gnutls_x509_aia_t aia,\n\t\t\t\t\t      gnutls_datum_t * ext)\n{\n\tint ret, result;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tunsigned int i;\n\tret = asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t  \"PKIX1.AuthorityInfoAccessSyntax\", &c2);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(ret);\n\t}\n\tfor (i=0;i<aia->size;i++) {\n\t\tresult = asn1_write_value(c2, \"\", \"NEW\", 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tresult = asn1_write_value(c2, \"?LAST.accessMethod\", aia->aia[i].oid.data, 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tret =\n\t\t    _gnutls_write_general_name(c2,\n\t\t\t\t\t\t   \"?LAST.accessLocation\",\n\t\t\t\t\t\t   aia->aia[i].san_type,\n\t\t\t\t\t\t   aia->aia[i].san.data,\n\t\t\t\t\t\t   aia->aia[i].san.size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}", "target": 1}
{"code": "matching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\tif (!parent_path) {\n\t\terr = count_mounts(ns, source_mnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\treturn 0;\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\tns->pending_mounts = 0;\n\treturn err;\n}", "target": 0}
{"code": "  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }", "target": 1}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n\tsecret[4] = net_secret[4] + (__force u32)dport;\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "int ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\tinode_dio_wait(inode);\n\tif (val) {\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tpercpu_down_write(&sbi->s_journal_flag_rwsem);\n\tjbd2_journal_lock_updates(journal);\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\tjbd2_journal_unlock_updates(journal);\n\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\tif (val)\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}", "target": 0}
{"code": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\treturn err;\n}", "target": 1}
{"code": "static inline void skb_reset_mac_header(struct sk_buff *skb)\n{\n\tskb->mac_header = skb->data - skb->head;\n}", "target": 0}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n{\n\tstruct mm_share *mms, *next;\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}", "target": 1}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "static void adpt_alpha_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ALPHA;\n}", "target": 1}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}", "target": 1}
{"code": "void cgit_tag_link(const char *name, const char *title, const char *class,\n\t\t   const char *tag)\n{\n\treporevlink(\"tag\", name, title, class, tag, NULL, NULL);\n}", "target": 0}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static GroupList collectGroups(const std::string &fulltext)\n{\n\tGroupList groupList; \n\tint lineNo = 1; \n\tbool inString = false; \n\tfor (unsigned int i=0; i<fulltext.length(); ++i) {\n\t\tif (fulltext[i] == '\\n') {\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (inString && fulltext.compare(i, 2, \"\\\\\\\"\") == 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fulltext[i] == '\"') {\n\t\t\tinString = !inString;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \"\n\t\t\ti++;\n\t\t\twhile (fulltext[i] != '\\n' && i<fulltext.length() ) i++;\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \" every character is comment\n\t\t\twhile (fulltext.compare(i, 2, \"*/\") != 0 && i<fulltext.length()) {\n\t\t\t\tif(fulltext[i]=='\\n'){\n\t\t\t\t\tlineNo++;\n\t\t\t\t\tisGroup=false;\n\t\t\t\t}\n\t\t\t\tcomment += fulltext[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(isGroup)\n\t\t\t\tgroupList.push_back(createGroup(comment,lineNo));\n\t\t}\n\t}\n\treturn groupList;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "PHP_FUNCTION(number_format)\n{\n\tdouble num;\n\tlong dec = 0;\n\tchar *thousand_sep = NULL, *dec_point = NULL;\n\tchar thousand_sep_chr = ',', dec_point_chr = '.';\n\tint thousand_sep_len = 0, dec_point_len = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d|ls!s!\", &num, &dec, &dec_point, &dec_point_len, &thousand_sep, &thousand_sep_len) == FAILURE) {\n\t\treturn;\n\t}\n\tswitch(ZEND_NUM_ARGS()) {\n\tcase 1:\n\t\tRETURN_STRING(_php_math_number_format(num, 0, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 2:\n\t\tRETURN_STRING(_php_math_number_format(num, dec, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 4:\n\t\tif (dec_point == NULL) {\n\t\t\tdec_point = &dec_point_chr;\n\t\t\tdec_point_len = 1;\n\t\t}\n\t\tif (thousand_sep == NULL) {\n\t\t\tthousand_sep = &thousand_sep_chr;\n\t\t\tthousand_sep_len = 1;\n\t\t}\n\t\tZ_TYPE_P(return_value) = IS_STRING;\n\t\tZ_STRVAL_P(return_value) = _php_math_number_format_ex_len(num, dec,\n\t\t\t\tdec_point, dec_point_len, thousand_sep, thousand_sep_len,\n\t\t\t\t&Z_STRLEN_P(return_value));\n\t\tbreak;\n\tdefault:\n\t\tWRONG_PARAM_COUNT;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "static int hns_roce_netdev_event(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct hns_roce_dev *hr_dev = NULL;\n\tu8 port = 0;\n\tint ret = 0;\n\thr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\n\tiboe = &hr_dev->iboe;\n\tfor (port = 0; port < hr_dev->caps.num_ports; port++) {\n\t\tif (dev == iboe->netdevs[port]) {\n\t\t\tret = handle_en_event(hr_dev, port, event);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "bool use_client_socket(int fd, PgAddr *addr,\n\t\t       const char *dbname, const char *username,\n\t\t       uint64_t ckey, int oldfd, int linkfd,\n\t\t       const char *client_enc, const char *std_string,\n\t\t       const char *datestyle, const char *timezone)\n{\n\tPgSocket *client;\n\tPktBuf tmp;\n\tclient = accept_client(fd, pga_is_unix(addr));\n\tif (client == NULL)\n\t\treturn false;\n\tclient->suspended = 1;\n\tif (!set_pool(client, dbname, username))\n\t\treturn false;\n\tchange_client_state(client, CL_ACTIVE);\n\tpktbuf_static(&tmp, client->cancel_key, 8);\n\tpktbuf_put_uint64(&tmp, ckey);\n\tclient->tmp_sk_oldfd = oldfd;\n\tclient->tmp_sk_linkfd = linkfd;\n\tvarcache_set(&client->vars, \"client_encoding\", client_enc);\n\tvarcache_set(&client->vars, \"standard_conforming_strings\", std_string);\n\tvarcache_set(&client->vars, \"datestyle\", datestyle);\n\tvarcache_set(&client->vars, \"timezone\", timezone);\n\treturn true;\n}", "target": 0}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "R_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if __UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}", "target": 0}
{"code": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "static inline union cpu_time_count cpu_time_sub(const clockid_t which_clock,\n\t\t\t\t\t\tunion cpu_time_count a,\n\t\t\t\t\t\tunion cpu_time_count b)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ta.sched -= b.sched;\n\t}  else {\n\t\ta.cpu = cputime_sub(a.cpu, b.cpu);\n\t}\n\treturn a;\n}", "target": 0}
{"code": "static unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}", "target": 1}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n    const char *base;\n    if (strchr(part, '/')) {\n        base = part;\n    }\n    else {\n        base = isarchive ? config_archivepartitiondir(part)\n                         : config_partitiondir(part);\n    }\n    assert(base != NULL);\n    snprintf(buf, MAX_MAILBOX_PATH, \"%s/sync./%lu/%s\",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n    if (cyrus_mkdir(buf, 0755)) {\n        syslog(LOG_ERR, \"IOERROR: failed to create %s/sync./%lu/ for reserve: %m\",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}", "target": 1}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "void lremCommand(client *c) {\n    robj *subject, *obj;\n    obj = c->argv[3];\n    long toremove;\n    long removed = 0;\n    if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))\n        return;\n    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);\n    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;\n    listTypeIterator *li;\n    if (toremove < 0) {\n        toremove = -toremove;\n        li = listTypeInitIterator(subject,-1,LIST_HEAD);\n    } else {\n        li = listTypeInitIterator(subject,0,LIST_TAIL);\n    }\n    listTypeEntry entry;\n    while (listTypeNext(li,&entry)) {\n        if (listTypeEqual(&entry,obj)) {\n            listTypeDelete(li, &entry);\n            server.dirty++;\n            removed++;\n            if (toremove && removed == toremove) break;\n        }\n    }\n    listTypeReleaseIterator(li);\n    if (removed) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"lrem\",c->argv[1],c->db->id);\n    }\n    if (listTypeLength(subject) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n    addReplyLongLong(c,removed);\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "sixel_allocator_calloc(\n    sixel_allocator_t    *allocator,  \n    size_t               nelm,        \n    size_t               elsize)      \n{\n    size_t n;\n    assert(allocator);\n    assert(allocator->fn_calloc);\n    n = nelm * elsize;\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_calloc(nelm, elsize);\n}", "target": 0}
{"code": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}", "target": 1}
{"code": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\tif (!fpl)\n\t\treturn NULL;\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}", "target": 0}
{"code": "void __meminit setup_zone_pageset(struct zone *zone)\n{\n\tint cpu;\n\tzone->pageset = alloc_percpu(struct per_cpu_pageset);\n\tfor_each_possible_cpu(cpu)\n\t\tzone_pageset_init(zone, cpu);\n}", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "find_entry2modify_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "nautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}", "target": 1}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices,\n                           const TfLiteTensor* updates,\n                           const TfLiteTensor* shape, TfLiteTensor* output) {\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(\n        context, CheckShapes<IndicesT>(\n                     context, GetTensorShape(indices), GetTensorShape(updates),\n                     GetTensorShape(shape), GetTensorData<IndicesT>(shape)));\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor<IndicesT>(context, shape, output));\n  }\n  switch (updates->type) {\n    case kTfLiteFloat32:\n      return ScatterNd<IndicesT, float>(indices, updates, output);\n    case kTfLiteUInt8:\n      return ScatterNd<IndicesT, uint8_t>(indices, updates, output);\n    case kTfLiteBool:\n      return ScatterNd<IndicesT, bool>(indices, updates, output);\n    case kTfLiteInt8:\n      return ScatterNd<IndicesT, int8_t>(indices, updates, output);\n    case kTfLiteInt32:\n      return ScatterNd<IndicesT, int32_t>(indices, updates, output);\n    case kTfLiteInt64:\n      return ScatterNd<IndicesT, int64_t>(indices, updates, output);\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Updates of type '%s' are not supported by scatter_nd.\",\n          TfLiteTypeGetName(updates->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tgf_bs_read_u8(bs); \n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); \n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 17);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tif ((iv_size!=8) && (iv_size!=16)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid constant IV size %d, must be 8 or 16\\n\", (u32) iv_size));\n\t\t\tptr->key_info[20] = 16;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\telse if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid IV size %d, must be 0, 8 or 16\\n\", (u32) iv_size));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "  static Status ParseEquation(const string& equation,\n                              OperandLabels* input_labels,\n                              Labels* output_labels,\n                              std::vector<DimensionType>* label_types,\n                              OperandLabelCounts* input_label_counts,\n                              LabelCounts* output_label_counts,\n                              gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                              bool* output_has_ellipsis) {\n    gtl::InlinedVector<string, 2> input_str;\n    string output_str;\n    TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n    absl::flat_hash_map<char, int> label_mapping;\n    int num_inputs = input_str.size();\n    input_labels->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n    }\n    MapToLabels(output_str, output_labels, &label_mapping);\n    int num_labels = label_mapping.size();\n    input_label_counts->resize(num_inputs);\n    input_has_ellipsis->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      input_label_counts->at(i).resize(num_labels);\n      input_has_ellipsis->at(i) = false;\n      for (const int label : input_labels->at(i)) {\n        if (label != kEllipsisLabel)\n          input_label_counts->at(i)[label] += 1;\n        else\n          input_has_ellipsis->at(i) = true;\n      }\n    }\n    output_label_counts->resize(num_labels);\n    *output_has_ellipsis = false;\n    for (const int label : *output_labels) {\n      if (label != kEllipsisLabel)\n        output_label_counts->at(label) += 1;\n      else\n        *output_has_ellipsis = true;\n    }\n    label_types->resize(num_labels);\n    for (int label = 0; label < num_labels; ++label) {\n      if (label == kEllipsisLabel) continue;\n      bool removed = (*output_label_counts)[label] == 0;\n      bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                    (*input_label_counts)[1][label] == 0;\n      (*label_types)[label] = GetDimensionType(removed, unique);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "  ~SubgraphGuard() {\n    if (status_ == kTfLiteOk) {\n      *is_subgraph_in_use_ = false;\n    }\n  }", "target": 0}
{"code": "static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr, u32 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "static int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tps->current_area--;\n\tskip_metadata(ps);\n\treturn 0;\n}", "target": 0}
{"code": "static int dp8393x_receive_filter(dp8393xState *s, const uint8_t * buf,\n                                  int size)\n{\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n    int i;\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_PRO) && (buf[0] & 1) == 0) {\n        return 0;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_AMC) && (buf[0] & 1) == 1) {\n        return SONIC_RCR_MC;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_BRD) && !memcmp(buf, bcast, sizeof(bcast))) {\n        return SONIC_RCR_BC;\n    }\n    for (i = 0; i < 16; i++) {\n        if (s->regs[SONIC_CE] & (1 << i)) {\n             if (!memcmp(buf, s->cam[i], sizeof(s->cam[i]))) {\n                 return 0;\n             }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "Array& ObjectData::reserveProperties(int numDynamic ) {\n  if (getAttribute(HasDynPropArr)) {\n    return dynPropArray();\n  }\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(numDynamic);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n  return setDynPropArray(\n      Array::attach(MixedArray::MakeReserveMixed(numDynamic))\n  );\n}", "target": 0}
{"code": "static int __init setup_psi(char *str)\n{\n\treturn kstrtobool(str, &psi_enable) == 0;\n}", "target": 0}
{"code": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}", "target": 1}
{"code": "void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME) {\n\t\tif (timer->hw.c_resolution)\n\t\t\tresolution = timer->hw.c_resolution(timer);\n\t\telse\n\t\t\tresolution = timer->hw.resolution;\n\t}\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}", "target": 0}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "static void naldmx_switch_timestamps(GF_NALUDmxCtx *ctx, GF_FilterPacket *pck)\n{\n\tif (!ctx->notime) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tctx->prev_cts = ctx->cts;\n\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (ctx->full_au_source) {\n\t\t\t\tctx->prev_dts = ctx->dts;\n\t\t\t\tctx->dts = ts;\n\t\t\t} else {\n\t\t\t\tGF_FilterClockType ck_type = gf_filter_pid_get_clock_info(ctx->ipid, NULL, NULL);\n\t\t\t\tif (ck_type==GF_FILTER_CLOCK_PCR_DISC)\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\telse if (ctx->dts<ts)\n\t\t\t\t\tctx->dts=ts;\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->pck_duration = gf_filter_pck_get_duration(pck);\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, NULL);\n\t}\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n  cNokogiriXmlSchema = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}", "target": 1}
{"code": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}", "target": 0}
{"code": "  QInt8() {}", "target": 1}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK2(*ext, sizeof(a));\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "void mctp_dev_put(struct mctp_dev *mdev)\n{\n\tif (mdev && refcount_dec_and_test(&mdev->refs)) {\n\t\tkfree(mdev->addrs);\n\t\tdev_put(mdev->dev);\n\t\tkfree_rcu(mdev, rcu);\n\t}\n}", "target": 0}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true ,\n                                                      endHeaders));\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n  return size.compressed;\n}", "target": 0}
{"code": "TRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint ch;\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision == 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\twhile (length-- > 0)\n\t{\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}", "target": 0}
{"code": "PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n    return SW_TRUE;\n}", "target": 1}
{"code": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\treturn 0;\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}", "target": 0}
{"code": "static int delete_path(const char *dump_dir_name)\n{\n    if (!dir_is_in_dump_location(dump_dir_name))\n    {\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);\n        return 400; \n    }\n    if (!dir_has_correct_permissions(dump_dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);\n        return 400; \n    }\n    if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dump_dir_name);\n            return 404; \n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dump_dir_name, (long)client_uid);\n        return 403; \n    }\n    delete_dump_dir(dump_dir_name);\n    return 0; \n}", "target": 0}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\tret = __nci_spi_send(nspi, skb, 0);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\tsmp_wmb();\n}", "target": 0}
{"code": "static int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\ttask->sched_info.cpu_time,\n\t\t\ttask->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}", "target": 0}
{"code": "static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\tStream_Read_UINT8(s, context->ColorLossLevel);         \n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); \n\tStream_Seek(s, 2);                                     \n\tcontext->Planes = Stream_Pointer(s);\n\tcontext->PlanesSize = total;\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}", "target": 0}
{"code": "int audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_aux_data_execve *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (likely(!audit_enabled || !context || context->dummy))\n\t\treturn 0;\n\tif (bprm->argv_len > (audit_argv_kb << 10))\n\t\treturn -E2BIG;\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tax->argc = bprm->argc;\n\tax->envc = bprm->envc;\n\tax->mm = bprm->mm;\n\tax->d.type = AUDIT_EXECVE;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    cmd_parse_list(idata, s);\n    return;\n  }\n  if (!ImapCheckSubscribed)\n    return;\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  if (!list.name || list.noselect)\n    return;\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}", "target": 1}
{"code": "get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}", "target": 1}
{"code": "choose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\tfor (;;) {\n\t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tif (!dev_is_sata(dev)) {\n\t\tsas_eh_finish_cmd(cmd);\n\t\treturn;\n\t}\n\tsas_end_task(cmd, task);\n\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n}", "target": 1}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n  }\n  return(ret);\n}", "target": 1}
{"code": "TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {\n  constexpr size_t size_t_bits = 8 * sizeof(size_t);\n  constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;\n  *product = a * b;\n  if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {\n    if (a != 0 && *product / a != b) return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)\n{\n\tstatic const GdkPixbufModulePattern signature[] = {\n\t\t{ \"  \\x1   \", \"zz znz\", 100 }, \n\t\t{ \"  \\x2   \", \"zz znz\", 100 },\n\t\t{ NULL, NULL, 0 }\n\t};\n\tstatic const gchar *mime_types[] = {\n\t\t\"image/x-icon\",\n\t\t\"image/x-ico\",\n\t\t\"image/x-win-bitmap\",\n                \"image/vnd.microsoft.icon\",\n                \"application/ico\",\n                \"image/ico\",\n                \"image/icon\",\n                \"text/ico\",\n\t\tNULL\n\t};\n\tstatic const gchar *extensions[] = {\n\t\t\"ico\",\n\t\t\"cur\",\n\t\tNULL\n\t};\n\tinfo->name = \"ico\";\n\tinfo->signature = (GdkPixbufModulePattern *) signature;\n\tinfo->description = NC_(\"image format\", \"Windows icon\");\n\tinfo->mime_types = (gchar **) mime_types;\n\tinfo->extensions = (gchar **) extensions;\n\tinfo->flags = GDK_PIXBUF_FORMAT_WRITABLE | GDK_PIXBUF_FORMAT_THREADSAFE;\n\tinfo->license = \"LGPL\";\n}", "target": 0}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }", "target": 1}
{"code": "static inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n    const uint8_t* a = (const uint8_t*)(a1);\n    uint8_t* b = (uint8_t*)(b1);\n    for (size_t i=0; i<len; i++) {\n        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n        if (d) return d;\n        a++;\n        b++;\n    }\n    return 0;\n}", "target": 0}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 0}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "matchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n    hl = strlen(h);\n    if (hl == 0)\n        return -1;\n    dl = strlen(d);\n    if (dl == 0)\n        return 1;\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            return 0;\n        }\n        if (0 == hl) {\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n        if (0 == dl) {\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; \n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n    if ('.' == d[dl])\n        return 1;\n    if ('.' == h[hl])\n        return -1;\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}", "target": 0}
{"code": "psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n\tif (newlen > 100 * 1024)\n\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n\t\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\tpsf->header.ptr = ptr ;\n\tpsf->header.len = newlen ;\n\treturn 0 ;\n} ", "target": 0}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "void test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1);\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}", "target": 1}
{"code": "static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\tcontext->msgs_in.inflight_bytes = 0;\n\tcontext->msgs_in.inflight_bytes12 = 0;\n\tcontext->msgs_in.inflight_count = 0;\n\tcontext->msgs_in.inflight_count12 = 0;\n\tcontext->msgs_in.queued_bytes = 0;\n\tcontext->msgs_in.queued_bytes12 = 0;\n\tcontext->msgs_in.queued_count = 0;\n\tcontext->msgs_in.queued_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n\t\tif(msg->qos > 0){\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\t\tif(msg->qos != 2){\n\t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n\t\t}else{\n\t\t\tmsg->dup = 0;\n\t\t}\n\t}\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tmsg->dup = 0;\n\t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n\t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\tu32 off;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "test_custom_handler(void **state)\n{\n    (void) state;\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x2A\");\n}", "target": 1}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tif (!dst)\n\t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, default_value_tensor->type, output_tensor->type);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           output_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               output_tensor->type == kTfLiteInt64));\n  return context->ResizeTensor(context, output_tensor,\n                               TfLiteIntArrayCopy(key_tensor->dims));\n}", "target": 1}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n    assert(size != 0); \n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n    return offset;\n}", "target": 1}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "int for_each_problem_in_dir(const char *path,\n                        uid_t caller_uid,\n                        int (*callback)(struct dump_dir *dd, void *arg),\n                        void *arg)\n{\n    DIR *dp = opendir(path);\n    if (!dp)\n    {\n        return 0;\n    }\n    int brk = 0;\n    struct dirent *dent;\n    while ((dent = readdir(dp)) != NULL)\n    {\n        if (dot_or_dotdot(dent->d_name))\n            continue; \n        char *full_name = concat_path_file(path, dent->d_name);\n        if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid))\n        {\n            int sv_logmode = logmode;\n            logmode = 0;\n            struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);\n            logmode = sv_logmode;\n            if (dd)\n            {\n                brk = callback ? callback(dd, arg) : 0;\n                dd_close(dd);\n            }\n        }\n        free(full_name);\n        if (brk)\n            break;\n    }\n    closedir(dp);\n    return brk;\n}", "target": 1}
{"code": "static void __net_exit sctp_net_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 1}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "static int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_NONE;\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& in_grads = context->input(0);\n    const Tensor& in_image = context->input(1);\n    const Tensor& out_image = context->input(2);\n    OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,\n                errors::InvalidArgument(\"inputs must be 4-dimensional\"));\n    const int64_t batch = in_grads.dim_size(0);\n    const int64_t rows = in_grads.dim_size(1);\n    const int64_t cols = in_grads.dim_size(2);\n    const int64_t depth = in_grads.dim_size(3);\n    OP_REQUIRES(\n        context,\n        in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&\n            in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&\n            out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&\n            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input_grads, input_image, and out_image should have the same \"\n            \"shape\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({batch, rows, cols, depth}), &output));\n    LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);\n    launcher.launch(context, this, in_grads, in_image, out_image, output);\n  }", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': \n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';':\t\t\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\t\t\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "static unsigned int ip6_hashfn(struct inet_frag_queue *q)\n{\n\tstruct frag_queue *fq;\n\tfq = container_of(q, struct frag_queue, q);\n\treturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "init_pyfribidi (void)\n{\n        PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "extract_auth_val(char **q)\n{\n    unsigned char *qq = *(unsigned char **)q;\n    int quoted = 0;\n    Str val = Strnew();\n    SKIP_BLANKS(qq);\n    if (*qq == '\"') {\n\tquoted = TRUE;\n\tStrcat_char(val, *qq++);\n    }\n    while (*qq != '\\0') {\n\tif (quoted && *qq == '\"') {\n\t    Strcat_char(val, *qq++);\n\t    break;\n\t}\n\tif (!quoted) {\n\t    switch (*qq) {\n\t    case '[':\n\t    case ']':\n\t    case '(':\n\t    case ')':\n\t    case '<':\n\t    case '>':\n\t    case '@':\n\t    case ';':\n\t    case ':':\n\t    case '\\\\':\n\t    case '\"':\n\t    case '/':\n\t    case '?':\n\t    case '=':\n\t    case ' ':\n\t    case '\\t':\n\t\tqq++;\n\t    case ',':\n\t\tgoto end_token;\n\t    default:\n\t\tif (*qq <= 037 || *qq == 0177) {\n\t\t    qq++;\n\t\t    goto end_token;\n\t\t}\n\t    }\n\t}\n\telse if (quoted && *qq == '\\\\')\n\t    Strcat_char(val, *qq++);\n\tStrcat_char(val, *qq++);\n    }\n  end_token:\n    *q = (char *)qq;\n    return val;\n}", "target": 0}
{"code": "snmp_ber_encode_timeticks(snmp_packet_t *snmp_packet, uint32_t timeticks)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "NOEXPORT void print_tmp_key(SSL *s) {\n    EVP_PKEY *key;\n    if (!SSL_get_peer_tmp_key(s, &key)) {\n        sslerror(\"SSL_get_peer_tmp_key\");\n        return;\n    }\n    switch (EVP_PKEY_id(key)) {\n    case EVP_PKEY_RSA:\n        s_log(LOG_INFO, \"Peer temporary key: RSA, %d bits\", EVP_PKEY_bits(key));\n        break;\n    case EVP_PKEY_DH:\n        s_log(LOG_INFO, \"Peer temporary key: DH, %d bits\", EVP_PKEY_bits(key));\n        break;\n#ifndef OPENSSL_NO_EC\n    case EVP_PKEY_EC:\n        {\n            EC_KEY *ec=EVP_PKEY_get1_EC_KEY(key);\n            int nid=EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\n            const char *cname=EC_curve_nid2nist(nid);\n            EC_KEY_free(ec);\n            if (cname == NULL)\n                cname=OBJ_nid2sn(nid);\n            s_log(LOG_INFO, \"Peer temporary key: ECDH, %s, %d bits\", cname, EVP_PKEY_bits(key));\n        }\n        break;\n#endif\n    default:\n        s_log(LOG_INFO, \"Peer temporary key: %s, %d bits\", OBJ_nid2sn(EVP_PKEY_id(key)),\n                   EVP_PKEY_bits(key));\n    }\n    EVP_PKEY_free(key);\n}", "target": 0}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}", "target": 1}
{"code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}", "target": 0}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "static char *pool_strdup(const char *s)\n{\n\tchar *r = pool_alloc(strlen(s) + 1);\n\tstrcpy(r, s);\n\treturn r;\n}", "target": 1}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    VLOG(3) << \"Read of size: \" << len;\n    s_->setReadCB(nullptr);\n    s_->getEventBase()->runInLoop([this]() { s_->setReadCB(this); });\n  }", "target": 0}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  \n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  \n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 0}
{"code": "CertificateValidationContextConfigImpl::getSubjectAltNameMatchers(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config) {\n  if (!config.match_typed_subject_alt_names().empty() &&\n      !config.match_subject_alt_names().empty()) {\n    throw EnvoyException(\"SAN-based verification using both match_typed_subject_alt_names and \"\n                         \"the deprecated match_subject_alt_names is not allowed\");\n  }\n  std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n      subject_alt_name_matchers(config.match_typed_subject_alt_names().begin(),\n                                config.match_typed_subject_alt_names().end());\n  for (const envoy::type::matcher::v3::StringMatcher& matcher : config.match_subject_alt_names()) {\n    static constexpr std::array<\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType, 4>\n        san_types{envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS};\n    for (const auto san_type : san_types) {\n      subject_alt_name_matchers.emplace_back();\n      subject_alt_name_matchers.back().set_san_type(san_type);\n      *subject_alt_name_matchers.back().mutable_matcher() = matcher;\n    }\n  }\n  return subject_alt_name_matchers;\n}", "target": 0}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}", "target": 1}
{"code": "xfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL)) !=\n\t       (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_SUBCLASS_MASK)) == 0);\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tdown_write_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t  XFS_IOLOCK_DEP(lock_flags));\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tdown_read_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t XFS_IOLOCK_DEP(lock_flags));\n\t}\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_MMAPLOCK_SHARED)\n\t\tmraccess_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}", "target": 0}
{"code": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lower[i] =\n        std::min(interpolation->lower[i], interpolation->upper[i]);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}", "target": 0}
{"code": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": "static WERROR dnsserver_complex_operate_zone(struct dnsserver_state *dsstate,\n\t\t\t\t\tTALLOC_CTX *mem_ctx,\n\t\t\t\t\tstruct dnsserver_zone *z,\n\t\t\t\t\tconst char *operation,\n\t\t\t\t\tconst unsigned int client_version,\n\t\t\t\t\tenum DNS_RPC_TYPEID typeid_in,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rin,\n\t\t\t\t\tenum DNS_RPC_TYPEID *typeid_out,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rout)\n{\n\tif (strcasecmp(operation, \"QueryDwordProperty\") == 0) {\n\t\tif (typeid_in == DNSSRV_TYPEID_LPSTR) {\n\t\t\treturn dnsserver_query_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\trin->String,\n\t\t\t\t\t\tclient_version,\n\t\t\t\t\t\ttypeid_out,\n\t\t\t\t\t\trout);\n\t\t}\n\t}\n\tDEBUG(0,(\"dnsserver: Invalid zone operation %s\", operation));\n\treturn WERR_DNS_ERROR_INVALID_PROPERTY;\n}", "target": 0}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "ecma_op_function_call_native_built_in (ecma_object_t *func_obj_p, \n                                       ecma_value_t this_arg_value, \n                                       const ecma_value_t *arguments_list_p, \n                                       uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, ext_func_obj_p->u.built_in.realm_value);\n#endif \n  ecma_value_t ret_value =\n    ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "juniper_services_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_services_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t svc_set_id[2];\n            uint8_t dir_iif[4];\n        };\n        const struct juniper_services_header *sh;\n        l2info.pictype = DLT_JUNIPER_SERVICES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        sh = (const struct juniper_services_header *)p;\n        ND_TCHECK(*sh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u flags 0x%02x service-set-id 0x%04x iif %u: \",\n                   sh->svc_id,\n                   sh->flags_len,\n                   EXTRACT_16BITS(&sh->svc_set_id),\n                   EXTRACT_24BITS(&sh->dir_iif[1])));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static int client_mpvio_read_packet(struct st_plugin_vio *mpv, uchar **buf)\n{\n  MCPVIO_EXT *mpvio= (MCPVIO_EXT*)mpv;\n  MYSQL *mysql= mpvio->mysql;\n  ulong  pkt_len;\n  if (mpvio->cached_server_reply.pkt)\n  {\n    *buf= mpvio->cached_server_reply.pkt;\n    mpvio->cached_server_reply.pkt= 0;\n    mpvio->packets_read++;\n    return mpvio->cached_server_reply.pkt_len;\n  }\n  if (mpvio->packets_read == 0)\n  {\n    if (client_mpvio_write_packet(mpv, 0, 0))\n      return (int)packet_error;\n  }\n  pkt_len= (*mysql->methods->read_change_user_result)(mysql);\n  mpvio->last_read_packet_len= pkt_len;\n  *buf= mysql->net.read_pos;\n  if (pkt_len == packet_error || **buf == 254)\n    return (int)packet_error; \n  if (pkt_len && **buf == 1)\n  {\n    (*buf)++;\n    pkt_len--;\n  }\n  mpvio->packets_read++;\n  return pkt_len;\n}", "target": 0}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "static size_t ssl_compute_padding_length( size_t len,\n                                          size_t granularity )\n{\n    return( ( granularity - ( len + 1 ) % granularity ) % granularity );\n}", "target": 0}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static void php_ifd_set32u(char *data, size_t value, int motorola_intel)\n{\n\tif (motorola_intel) {\n\t\tdata[0] = (value & 0xFF000000) >> 24;\n\t\tdata[1] = (value & 0x00FF0000) >> 16;\n\t\tdata[2] = (value & 0x0000FF00) >>  8;\n\t\tdata[3] = (value & 0x000000FF);\n\t} else {\n\t\tdata[3] = (value & 0xFF000000) >> 24;\n\t\tdata[2] = (value & 0x00FF0000) >> 16;\n\t\tdata[1] = (value & 0x0000FF00) >>  8;\n\t\tdata[0] = (value & 0x000000FF);\n\t}\n}", "target": 0}
{"code": "gopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}", "target": 1}
{"code": "date_strftime_internal(int argc, VALUE *argv, VALUE self,\n\t\t       const char *default_fmt,\n\t\t       void (*func)(VALUE, struct tmx *))\n{\n    VALUE vfmt;\n    const char *fmt;\n    long len;\n    char buffer[SMALLBUF], *buf = buffer;\n    struct tmx tmx;\n    VALUE str;\n    rb_scan_args(argc, argv, \"01\", &vfmt);\n    if (argc < 1)\n\tvfmt = rb_usascii_str_new2(default_fmt);\n    else {\n\tStringValue(vfmt);\n\tif (!rb_enc_str_asciicompat_p(vfmt)) {\n\t    rb_raise(rb_eArgError,\n\t\t     \"format should have ASCII compatible encoding\");\n\t}\n    }\n    fmt = RSTRING_PTR(vfmt);\n    len = RSTRING_LEN(vfmt);\n    (*func)(self, &tmx);\n    if (memchr(fmt, '\\0', len)) {\n\tconst char *p = fmt, *pe = fmt + len;\n\tstr = rb_str_new(0, 0);\n\twhile (p < pe) {\n\t    len = date_strftime_alloc(&buf, p, &tmx);\n\t    rb_str_cat(str, buf, len);\n\t    p += strlen(p);\n\t    if (buf != buffer) {\n\t\txfree(buf);\n\t\tbuf = buffer;\n\t    }\n\t    for (fmt = p; p < pe && !*p; ++p);\n\t    if (p > fmt) rb_str_cat(str, fmt, p - fmt);\n\t}\n\trb_enc_copy(str, vfmt);\n\treturn str;\n    }\n    else\n\tlen = date_strftime_alloc(&buf, fmt, &tmx);\n    str = rb_str_new(buf, len);\n    if (buf != buffer) xfree(buf);\n    rb_enc_copy(str, vfmt);\n    return str;\n}", "target": 0}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int nr_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": "LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}", "target": 1}
{"code": "void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\nagain:\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\t\tu64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);\n\t\tif (reserved > trans->chunk_bytes_reserved) {\n\t\t\tconst u64 min_needed = reserved - thresh;\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\twait_event(cur_trans->chunk_reserve_wait,\n\t\t\t   atomic64_read(&cur_trans->chunk_bytes_reserved) <=\n\t\t\t   min_needed);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tgoto again;\n\t\t}\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret) {\n\t\t\tatomic64_add(thresh, &cur_trans->chunk_bytes_reserved);\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\tif (!nr_pages)\n\t\treturn;\n\tpage = pfn_to_page(pfn);\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}", "target": 0}
{"code": "std::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n  return dbc;\n}", "target": 1}
{"code": "static void __route4_delete_filter(struct route4_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}", "target": 0}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  if (axis < -1) {\n    return errors::InvalidArgument(\"axis should be at least -1, got \", axis);\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 0}
{"code": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (tuple[index].has_value()) {\n      return Status(errors::InvalidArgument(\n          \"The tensor for index '\", index, \"' for key '\", key.scalar<int64>()(),\n          \"' was already initialized '\", dtypes_.size(), \"'.\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n  cur_token = * indx;\n  mailbox_list = NULL;\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n  * indx = cur_token;\n  * result = group;\n  return MAILIMF_NO_ERROR;\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        out[outlen] = '\\0';\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (ret == -1)\n        goto exit;\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == -1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 0}
{"code": "gopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    delete gopherState;\n}", "target": 1}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 0}
{"code": "ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n    if (p_key)\n\trb_ivar_set(self, id_key_set, Qtrue);\n    return self;\n}", "target": 0}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}", "target": 0}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\t*prev = NULL;\t\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1}
{"code": "nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tconst struct nvkm_vmm_page *page = vmm->func->page;\n\tstruct nvkm_vma *next = vma;\n\tBUG_ON(vma->part);\n\tif (vma->mapref || !vma->sparse) {\n\t\tdo {\n\t\t\tconst bool map = next->memory != NULL;\n\t\t\tconst u8  refd = next->refd;\n\t\t\tconst u64 addr = next->addr;\n\t\t\tu64 size = next->size;\n\t\t\twhile ((next = node(next, next)) && next->part &&\n\t\t\t       (next->memory != NULL) == map &&\n\t\t\t       (next->refd == refd))\n\t\t\t\tsize += next->size;\n\t\t\tif (map) {\n\t\t\t\tnvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,\n\t\t\t\t\t\t\tsize, vma->sparse);\n\t\t\t} else\n\t\t\tif (refd != NVKM_VMA_PAGE_NONE) {\n\t\t\t\tnvkm_vmm_ptes_put(vmm, &page[refd], addr, size);\n\t\t\t}\n\t\t} while (next && next->part);\n\t}\n\tnext = vma;\n\tdo {\n\t\tif (next->memory)\n\t\t\tnvkm_vmm_unmap_region(vmm, next);\n\t} while ((next = node(vma, next)) && next->part);\n\tif (vma->sparse && !vma->mapref) {\n\t\tnvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);\n\t} else\n\tif (vma->sparse) {\n\t\tnvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);\n\t}\n\trb_erase(&vma->tree, &vmm->root);\n\tvma->page = NVKM_VMA_PAGE_NONE;\n\tvma->refd = NVKM_VMA_PAGE_NONE;\n\tvma->used = false;\n\tvma->user = false;\n\tnvkm_vmm_put_region(vmm, vma);\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 0}
{"code": "static void* my_gballoc_realloc(void* ptr, size_t size)\n{\n    return realloc(ptr, size);\n}", "target": 0}
{"code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument(\"No row_partition_types given.\");\n    }\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 0}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "void WasmBinaryBuilder::read() {\n  if (DWARF) {\n    if (!hasDWARFSections()) {\n      DWARF = false;\n    }\n  }\n  readHeader();\n  readSourceMapHeader();\n  while (more()) {\n    uint8_t sectionCode = getInt8();\n    uint32_t payloadLen = getU32LEB();\n    if (uint64_t(pos) + uint64_t(payloadLen) > input.size()) {\n      throwError(\"Section extends beyond end of input\");\n    }\n    auto oldPos = pos;\n    if (sectionCode != BinaryConsts::Section::User &&\n        sectionCode != BinaryConsts::Section::Code) {\n      if (!seenSections.insert(BinaryConsts::Section(sectionCode)).second) {\n        throwError(\"section seen more than once: \" +\n                   std::to_string(sectionCode));\n      }\n    }\n    switch (sectionCode) {\n      case BinaryConsts::Section::Start:\n        readStart();\n        break;\n      case BinaryConsts::Section::Memory:\n        readMemory();\n        break;\n      case BinaryConsts::Section::Type:\n        readTypes();\n        break;\n      case BinaryConsts::Section::Import:\n        readImports();\n        break;\n      case BinaryConsts::Section::Function:\n        readFunctionSignatures();\n        break;\n      case BinaryConsts::Section::Code:\n        if (DWARF) {\n          codeSectionLocation = pos;\n        }\n        readFunctions();\n        break;\n      case BinaryConsts::Section::Export:\n        readExports();\n        break;\n      case BinaryConsts::Section::Element:\n        readElementSegments();\n        break;\n      case BinaryConsts::Section::Global:\n        readGlobals();\n        break;\n      case BinaryConsts::Section::Data:\n        readDataSegments();\n        break;\n      case BinaryConsts::Section::DataCount:\n        readDataCount();\n        break;\n      case BinaryConsts::Section::Table:\n        readTableDeclarations();\n        break;\n      case BinaryConsts::Section::Tag:\n        readTags();\n        break;\n      default: {\n        readUserSection(payloadLen);\n        if (pos > oldPos + payloadLen) {\n          throwError(\"bad user section size, started at \" +\n                     std::to_string(oldPos) + \" plus payload \" +\n                     std::to_string(payloadLen) +\n                     \" not being equal to new position \" + std::to_string(pos));\n        }\n        pos = oldPos + payloadLen;\n      }\n    }\n    if (pos != oldPos + payloadLen) {\n      throwError(\"bad section size, started at \" + std::to_string(oldPos) +\n                 \" plus payload \" + std::to_string(payloadLen) +\n                 \" not being equal to new position \" + std::to_string(pos));\n    }\n  }\n  validateBinary();\n  processNames();\n}", "target": 0}
{"code": "static ssize_t cm_write(struct file *file, const char __user * user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic char *buf;\n\tstatic u32 max_size;\n\tstatic u32 uncopied_bytes;\n\tstruct acpi_table_header table;\n\tacpi_status status;\n\tif (!(*ppos)) {\n\t\tif (count <= sizeof(struct acpi_table_header))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&table, user_buf,\n\t\t\t\t   sizeof(struct acpi_table_header)))\n\t\t\treturn -EFAULT;\n\t\tuncopied_bytes = max_size = table.length;\n\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\tif ((*ppos > max_size) ||\n\t    (*ppos + count > max_size) ||\n\t    (*ppos + count < count) ||\n\t    (count > uncopied_bytes))\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf + (*ppos), user_buf, count)) {\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\treturn -EFAULT;\n\t}\n\tuncopied_bytes -= count;\n\t*ppos += count;\n\tif (!uncopied_bytes) {\n\t\tstatus = acpi_install_method(buf);\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EINVAL;\n\t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);\n\t}\n\treturn count;\n}", "target": 0}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n  if (ecc_25519_gf_is_zero(&ctx->r))\n    return false;\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n  return ecc_25519_gf_is_zero(&tmp);\n}", "target": 0}
{"code": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "xmlValidNormalizeString(xmlChar *str) {\n    xmlChar *dst;\n    const xmlChar *src;\n    if (str == NULL)\n        return;\n    src = str;\n    dst = str;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n}", "target": 0}
{"code": "static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\tflush_work(&gsm->tx_work);\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}", "target": 1}
{"code": "void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n{\n    QListIterator<QList<QByteArray>> i(params);\n    while (i.hasNext()) {\n        QList<QByteArray> msg = i.next();\n        putCmd(cmd, msg, prefix);\n    }\n}", "target": 0}
{"code": "void release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}", "target": 0}
{"code": "void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;\n    zset *zset = zobj->ptr;\n    if (zset->zsl->length <= server.zset_max_ziplist_entries &&\n        maxelelen <= server.zset_max_ziplist_value)\n            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n    OP_REQUIRES(context, num_streams >= 0,\n                errors::InvalidArgument(\n                    \"Num_streams input cannot be a negative integer\"));\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }", "target": 0}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "void zend_throw_exception_internal(zval *exception TSRMLS_DC) \n{\n#ifdef HAVE_DTRACE\n\tif (DTRACE_EXCEPTION_THROWN_ENABLED()) {\n\t\tconst char *classname;\n\t\tzend_uint name_len;\n\t\tif (exception != NULL) {\n\t\t\tzend_get_object_classname(exception, &classname, &name_len TSRMLS_CC);\n\t\t\tDTRACE_EXCEPTION_THROWN((char *)classname);\n\t\t} else {\n\t\t\tDTRACE_EXCEPTION_THROWN(NULL);\n\t\t}\n\t}\n#endif \n\tif (exception != NULL) {\n\t\tzval *previous = EG(exception);\n\t\tzend_exception_set_previous(exception, EG(exception) TSRMLS_CC);\n\t\tEG(exception) = exception;\n\t\tif (previous) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!EG(current_execute_data)) {\n\t\tif(EG(exception)) {\n\t\t\tzend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n\t\t}\n\t\tzend_error(E_ERROR, \"Exception thrown without a stack frame\");\n\t}\n\tif (zend_throw_exception_hook) {\n\t\tzend_throw_exception_hook(exception TSRMLS_CC);\n\t}\n\tif (EG(current_execute_data)->opline == NULL ||\n\t    (EG(current_execute_data)->opline+1)->opcode == ZEND_HANDLE_EXCEPTION) {\n\t\treturn;\n\t}\n\tEG(opline_before_exception) = EG(current_execute_data)->opline;\n\tEG(current_execute_data)->opline = EG(exception_op);\n}", "target": 0}
{"code": "ikev2_sub_print(netdissect_options *ndo,\n\t\tstruct isakmp *base,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ikev2_sub0_print(ndo, base, np,\n\t\t\t\t      ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    if (codeBlock) {\n      pushCallStack(codeBlock, ip);\n    } else {\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}", "target": 1}
{"code": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n                                 config.match_subject_alt_names().end()),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 0}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}", "target": 1}
{"code": "ref_stack_pop_block(ref_stack_t *pstack)\n{\n    s_ptr bot = pstack->bot;\n    uint count = pstack->p + 1 - bot;\n    ref_stack_block *pcur =\n    (ref_stack_block *) pstack->current.value.refs;\n    ref_stack_block *pnext =\n    (ref_stack_block *) pcur->next.value.refs;\n    uint used;\n    ref *body;\n    ref next;\n    if (pnext == 0)\n        return_error(pstack->params->underflow_error);\n    used = r_size(&pnext->used);\n    body = (ref *) (pnext + 1) + pstack->params->bot_guard;\n    next = pcur->next;\n    if (used + count > pstack->body_size) {\n        uint moved = pstack->body_size - count;\n        uint left;\n        if (moved == 0)\n            return_error(gs_error_Fatal);\n        memmove(bot + moved, bot, count * sizeof(ref));\n        left = used - moved;\n        memcpy(bot, body + left, moved * sizeof(ref));\n        refset_null_new(body + left, moved, 0);\n        r_dec_size(&pnext->used, moved);\n        pstack->p = pstack->top;\n        pstack->extension_used -= moved;\n    } else {\n        memcpy(body + used, bot, count * sizeof(ref));\n        pstack->bot = bot = body;\n        pstack->top = bot + pstack->body_size - 1;\n        gs_free_ref_array(pstack->memory, &pstack->current,\n                          \"ref_stack_pop_block\");\n        pstack->current = next;\n        pstack->p = bot + (used + count - 1);\n        pstack->extension_size -= pstack->body_size;\n        pstack->extension_used -= used;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\tfor (n = 0; n < count; n++) {\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    value[n] - min < field->maxusage &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\tfor (n = 0; n < count; n++) {\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->value[n] - min < field->maxusage\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& value[n] - min < field->maxusage\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 0}
{"code": "static int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}", "target": 0}
{"code": "void HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n  if (!*ptr_to_entry) {\n    return;\n  }\n  HeaderEntryImpl* entry = *ptr_to_entry;\n  const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();\n  subtractSize(size_to_subtract);\n  *ptr_to_entry = nullptr;\n  headers_.erase(entry->entry_);\n}", "target": 0}
{"code": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n  if (self.db_ == nullptr) {\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n  if (primary) {\n    return self.connection_;\n  }\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}", "target": 0}
{"code": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\treturn 0;\n}", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "static void ext4_invalidatepage(struct page *page, unsigned long offset)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\tif (ext4_should_dioread_nolock(page->mapping->host))\n\t\text4_invalidatepage_free_endio(page, offset);\n\tif (offset == 0)\n\t\tClearPageChecked(page);\n\tif (journal)\n\t\tjbd2_journal_invalidatepage(journal, page, offset);\n\telse\n\t\tblock_invalidatepage(page, offset);\n}", "target": 0}
{"code": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}", "target": 0}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    FileContainerFree(s->files_ts);\n    FileContainerFree(s->files_tc);\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "    void assignRemoteEndpoints(\n            const ParticipantProxyData& ) override\n    {\n    }", "target": 1}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n\thid->version = req->version;\n\thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n\tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "disable_priv_mode ()\n{\n  int e;\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "target": 0}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t} else {\n\t\tBUG();\n\t}\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy * 2);\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t input0_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t input2_size =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {input0_size, 0, input2_size};\n  const int64_t output_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "epass2003_hook_path(struct sc_path *path, int inc)\n{\n\tu8 fid_h = path->value[path->len - 2];\n\tu8 fid_l = path->value[path->len - 1];\n\tswitch (fid_h) {\n\tcase 0x29:\n\tcase 0x30:\n\tcase 0x31:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\t\tif (inc)\n\t\t\tfid_l = fid_l * FID_STEP;\n\t\telse\n\t\t\tfid_l = fid_l / FID_STEP;\n\t\tpath->value[path->len - 1] = fid_l;\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n        return(GC_generic_malloc((word)lb, k));\n    lg = ROUNDED_UP_GRANULES(lb);\n    lb_rounded = GRANULES_TO_BYTES(lg);\n    if (lb_rounded < lb)\n        return((*GC_get_oom_fn())(lb));\n    n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n    init = GC_obj_kinds[k].ok_init;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 0}
{"code": "dig_t bn_get_prime(int pos) {\n\tif (pos >= BASIC_TESTS) {\n\t\treturn 0;\n\t}\n\treturn primes[pos];\n}", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "wait_limit_netblock_findcreate(struct infra_cache* infra, char* str,\n\tint cookie)\n{\n\trbtree_type* tree;\n\tstruct sockaddr_storage addr;\n\tint net;\n\tsocklen_t addrlen;\n\tstruct wait_limit_netblock_info* d;\n\tif(!netblockstrtoaddr(str, 0, &addr, &addrlen, &net)) {\n\t\tlog_err(\"cannot parse wait limit netblock '%s'\", str);\n\t\treturn 0;\n\t}\n\tif(cookie)\n\t\ttree = &infra->wait_limits_cookie_netblock;\n\telse\n\t\ttree = &infra->wait_limits_netblock;\n\td = (struct wait_limit_netblock_info*)addr_tree_find(tree, &addr,\n\t\taddrlen, net);\n\tif(d)\n\t\treturn d;\n\td = (struct wait_limit_netblock_info*)calloc(1, sizeof(*d));\n\tif(!d)\n\t\treturn NULL;\n\td->limit = -1;\n\tif(!addr_tree_insert(tree, &d->node, &addr, addrlen, net)) {\n\t\tlog_err(\"duplicate element in domainlimit tree\");\n\t\tfree(d);\n\t\treturn NULL;\n\t}\n\treturn d;\n}", "target": 0}
{"code": "static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tif (sp->sa_protocol != PX_PROTO_PPTP)\n\t\treturn -EINVAL;\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\tlock_sock(sk);\n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk,\n\t\t\t\t   opt->dst_addr.sin_addr.s_addr,\n\t\t\t\t   opt->src_addr.sin_addr.s_addr,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tip_rt_put(rt);\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state = PPPOX_CONNECTED;\n end:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "static int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->active_mm;\n\tif (user_mode(regs))\n\t\t__do_user_fault(tsk, addr, esr, SIGSEGV, SEGV_MAPERR, regs);\n\telse\n\t\t__do_kernel_fault(mm, addr, esr, regs);\n}", "target": 0}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) {\n  if (t.shape() == TensorShape({})) {\n    if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) ||\n        (t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) {\n      *out = PartialTensorShape();\n      return OkStatus();\n    }\n    return errors::InvalidArgument(\n        \"The only valid scalar shape tensor is the fully unknown shape \"\n        \"specified as -1.\");\n  } else if (t.shape().dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be at most rank 1 but is rank \",\n                                   t.shape().dims());\n  }\n  if (t.dtype() == DT_INT32) {\n    return PartialTensorShape::MakePartialShape(t.vec<int32>().data(),\n                                                t.NumElements(), out);\n  } else if (t.dtype() == DT_INT64) {\n    return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(),\n                                                t.NumElements(), out);\n  }\n  return errors::InvalidArgument(\n      \"Expected an int32 or int64 shape tensor; found \",\n      DataTypeString(t.dtype()));\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static int cma_bind_loopback(struct rdma_id_private *id_priv)\n{\n\tstruct cma_device *cma_dev, *cur_dev;\n\tunion ib_gid gid;\n\tenum ib_port_state port_state;\n\tunsigned int p;\n\tu16 pkey;\n\tint ret;\n\tcma_dev = NULL;\n\tmutex_lock(&lock);\n\tlist_for_each_entry(cur_dev, &dev_list, list) {\n\t\tif (cma_family(id_priv) == AF_IB &&\n\t\t    !rdma_cap_ib_cm(cur_dev->device, 1))\n\t\t\tcontinue;\n\t\tif (!cma_dev)\n\t\t\tcma_dev = cur_dev;\n\t\trdma_for_each_port (cur_dev->device, p) {\n\t\t\tif (!ib_get_cached_port_state(cur_dev->device, p, &port_state) &&\n\t\t\t    port_state == IB_PORT_ACTIVE) {\n\t\t\t\tcma_dev = cur_dev;\n\t\t\t\tgoto port_found;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cma_dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tp = 1;\nport_found:\n\tret = rdma_query_gid(cma_dev->device, p, 0, &gid);\n\tif (ret)\n\t\tgoto out;\n\tret = ib_get_cached_pkey(cma_dev->device, p, 0, &pkey);\n\tif (ret)\n\t\tgoto out;\n\tid_priv->id.route.addr.dev_addr.dev_type =\n\t\t(rdma_protocol_ib(cma_dev->device, p)) ?\n\t\tARPHRD_INFINIBAND : ARPHRD_ETHER;\n\trdma_addr_set_sgid(&id_priv->id.route.addr.dev_addr, &gid);\n\tib_addr_set_pkey(&id_priv->id.route.addr.dev_addr, pkey);\n\tid_priv->id.port_num = p;\n\tcma_attach_to_dev(id_priv, cma_dev);\n\trdma_restrack_add(&id_priv->res);\n\tcma_set_loopback(cma_src_addr(id_priv));\nout:\n\tmutex_unlock(&lock);\n\treturn ret;\n}", "target": 0}
{"code": "int authRequired(client *c) {\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    return auth_required;\n}", "target": 0}
{"code": "static int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}", "target": 1}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "void ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  setUnderlying(NULL, 0);\n}", "target": 0}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn credssp;\n}", "target": 0}
{"code": "jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\tassert((buf && bufsize > 0) || (!buf));\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\tstream->ops_ = &jas_stream_memops;\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\tif (bufsize > 0 && buf) {\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\treturn stream;\n}", "target": 0}
{"code": "ldap_pvt_tls_check_hostname( LDAP *ld, void *s, const char *name_in )\n{\n\ttls_session *session = s;\n\tif (ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_NEVER &&\n\t    ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_ALLOW) {\n\t\tld->ld_errno = tls_imp->ti_session_chkhost( ld, session, name_in );\n\t\tif (ld->ld_errno != LDAP_SUCCESS) {\n\t\t\treturn ld->ld_errno;\n\t\t}\n\t}\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "GF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void http_req_handler(struct http_conn *conn,\n\t\t\t     const struct http_msg *msg, void *arg)\n{\n\tstruct mbuf *mb = mbuf_alloc(1024);\n\tint err = 0;\n\t(void)arg;\n\tinfo(\"restsrv: request %r %r%r from %J\\n\",\n\t     &msg->met, &msg->path, &msg->prm,\n\t     http_conn_peer(conn));\n\tif (0 == pl_strcasecmp(&msg->met, \"POST\") &&\n\t    0 == pl_strcasecmp(&msg->path, \"/create\")) {\n\t\thandle_post_create(conn, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_put_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_put_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_get_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_get_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse {\n\t\twarning(\"no such resource\\n\");\n\t\terr = ENOENT;\n\t\tgoto out;\n\t}\n out:\n\tif (err) {\n\t\thttp_ereply(conn, 400, \"Bad Request\");\n\t\twarning(\"restsrv: response 400 Bad Request (%m)\\n\", err);\n\t\thttp_conn_close(conn);\n\t}\n\tmem_deref(mb);\n}", "target": 0}
{"code": "void __init kvmclock_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn;\n\tif (kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\n\t\tmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\n\t\tmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\n\t} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))\n\t\treturn;\n\tprintk(KERN_INFO \"kvm-clock: Using msrs %x and %x\",\n\t\tmsr_kvm_system_time, msr_kvm_wall_clock);\n\tif (kvm_register_clock(\"boot clock\"))\n\t\treturn;\n\tpv_time_ops.sched_clock = kvm_clock_read;\n\tx86_platform.calibrate_tsc = kvm_get_tsc_khz;\n\tx86_platform.get_wallclock = kvm_get_wallclock;\n\tx86_platform.set_wallclock = kvm_set_wallclock;\n#ifdef CONFIG_X86_LOCAL_APIC\n\tx86_cpuinit.setup_percpu_clockev =\n\t\tkvm_setup_secondary_clock;\n#endif\n\tmachine_ops.shutdown  = kvm_shutdown;\n#ifdef CONFIG_KEXEC\n\tmachine_ops.crash_shutdown  = kvm_crash_shutdown;\n#endif\n\tkvm_get_preset_lpj();\n\tclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\n\tpv_info.paravirt_enabled = 1;\n\tpv_info.name = \"KVM\";\n\tif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\n\t\tpvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\n}", "target": 0}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return allowed_new_user_problem_entry(client_uid, key, value);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }", "target": 1}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n    if(drop_privileges(1))\n        return 1;\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}", "target": 1}
{"code": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}", "target": 1}
{"code": "int kvm_get_dirty_log(struct kvm *kvm,\n\t\t\tstruct kvm_dirty_log *log, int *is_dirty)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint r, i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\tr = -EINVAL;\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tr = -ENOENT;\n\tif (!memslot->dirty_bitmap)\n\t\tgoto out;\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = memslot->dirty_bitmap[i];\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, memslot->dirty_bitmap, n))\n\t\tgoto out;\n\tif (any)\n\t\t*is_dirty = 1;\n\tr = 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "nfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\tdprintk(\"--> %s\\n\", __func__);\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}", "target": 0}
{"code": "set_option_info(struct archive_string *info, int *opt, const char *key,\n    enum keytype type,  ...)\n{\n\tva_list ap;\n\tchar prefix;\n\tconst char *s;\n\tint d;\n\tprefix = (*opt==0)? ' ':',';\n\tva_start(ap, type);\n\tswitch (type) {\n\tcase KEY_FLG:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s%s\",\n\t\t    prefix, (d == 0)?\"!\":\"\", key);\n\t\tbreak;\n\tcase KEY_STR:\n\t\ts = va_arg(ap, const char *);\n\t\tarchive_string_sprintf(info, \"%c%s=%s\",\n\t\t    prefix, key, s);\n\t\tbreak;\n\tcase KEY_INT:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%d\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\tcase KEY_HEX:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%x\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\t}\n\tva_end(ap);\n\t*opt = 1;\n}", "target": 0}
{"code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\tmutex_lock(&key_session_mutex);\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tkey_put(keyring);\n\t\tret = 0;\n\t\tgoto error2;\n\t}\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 0}
{"code": "static void get_request(GDHCPClient *dhcp_client, struct dhcp_packet *packet,\n\t\tuint16_t packet_len)\n{\n\tGDHCPOptionType type;\n\tGList *list, *value_list;\n\tchar *option_value;\n\tuint8_t *option;\n\tuint8_t code;\n\tfor (list = dhcp_client->request_list; list; list = list->next) {\n\t\tcode = (uint8_t) GPOINTER_TO_INT(list->data);\n\t\toption = dhcp_get_option(packet, packet_len, code);\n\t\tif (!option) {\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\t\tcontinue;\n\t\t}\n\t\ttype =  dhcp_get_code_type(code);\n\t\toption_value = malloc_option_value_string(option, type);\n\t\tif (!option_value)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\tvalue_list = get_option_value_list(option_value, type);\n\t\tg_free(option_value);\n\t\tif (!value_list)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\telse\n\t\t\tg_hash_table_insert(dhcp_client->code_value_hash,\n\t\t\t\tGINT_TO_POINTER((int) code), value_list);\n\t}\n}", "target": 0}
{"code": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static void gen_vector_table16(TrueMotion1Context *s, const uint8_t *sel_vector_table)\n{\n    int len, i, j;\n    unsigned char delta_pair;\n    for (i = 0; i < 1024; i += 4)\n    {\n        len = *sel_vector_table++ / 2;\n        for (j = 0; j < len; j++)\n        {\n            delta_pair = *sel_vector_table++;\n            s->y_predictor_table[i+j] = 0xfffffffe &\n                make_ydt16_entry(delta_pair >> 4, delta_pair & 0xf, s->ydt);\n            s->c_predictor_table[i+j] = 0xfffffffe &\n                make_cdt16_entry(delta_pair >> 4, delta_pair & 0xf, s->cdt);\n        }\n        s->y_predictor_table[i+(j-1)] |= 1;\n        s->c_predictor_table[i+(j-1)] |= 1;\n    }\n}", "target": 0}
{"code": "Adaptation::Ecap::Host::Host()\n{\n    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);\n    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);\n    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);\n    libecap::headerVia.assignHostId(Http::HdrType::VIA);\n    libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);\n    libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);\n    libecap::protocolFtp.assignHostId(AnyP::PROTO_FTP);\n    libecap::protocolGopher.assignHostId(AnyP::PROTO_GOPHER);\n    libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);\n    libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);\n    libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);\n    protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);\n    protocolIcp.assignHostId(AnyP::PROTO_ICP);\n#if USE_HTCP\n    protocolHtcp.assignHostId(AnyP::PROTO_HTCP);\n#endif\n    protocolIcy.assignHostId(AnyP::PROTO_ICY);\n    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);\n    metaBypassable.assignHostId(1);\n}", "target": 1}
{"code": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}", "target": 0}
{"code": "int main(void) {\n    if (siphash_test() == 0) {\n        printf(\"SipHash test: OK\\n\");\n        return 0;\n    } else {\n        printf(\"SipHash test: FAILED\\n\");\n        return 1;\n    }\n}", "target": 0}
{"code": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\tif ( len <= 0 )\n\t\treturn 0;\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\t\tint c = data[0];\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t--offset; \n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\t\tlast_char = c;\n\t\t}\n\treturn data - data_start;\n\t}", "target": 0}
{"code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,\n\t\tunsigned int tag, struct request *rq)\n{\n\thctx->tags->rqs[tag] = rq;\n}", "target": 0}
{"code": "int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_tail = quicklist->tail;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {\n        quicklist->tail->zl =\n            ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(quicklist->tail);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);\n    }\n    quicklist->count++;\n    quicklist->tail->count++;\n    return (orig_tail != quicklist->tail);\n}", "target": 0}
{"code": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}", "target": 0}
{"code": "\tconsume_count(type)\n\t\tconst char **type;\n{\n\tint count = 0;\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\treturn (count);\n}", "target": 1}
{"code": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}", "target": 1}
{"code": "static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)\n{\n\tint gen_index, gen_count;\n\tgboolean matched = FALSE, has_dns_name = FALSE;\n\tconst char *cert_dns_name;\n\tchar *cert_subject_cn;\n\tconst GENERAL_NAME *gn;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\tgens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);\n\tif (gens) {\n\t\tgen_count = sk_GENERAL_NAME_num(gens);\n\t\tfor (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {\n\t\t\tgn = sk_GENERAL_NAME_value(gens, gen_index);\n\t\t\tif (gn->type != GEN_DNS)\n\t\t\t\tcontinue;\n\t\t\thas_dns_name = TRUE;\n\t\t\tcert_dns_name = tls_dns_name(gn);\n\t\t\tif (cert_dns_name && *cert_dns_name) {\n\t\t\t\tmatched = match_hostname(cert_dns_name, hostname);\n\t\t\t}\n    \t}\n\t    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\t}\n\tif (has_dns_name) {\n\t\tif (! matched) {\n\t\t\tg_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);\n\t\t}\n\t\treturn matched;\n\t} else { \n\t\tcert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);\n\t    if (cert_subject_cn && *cert_subject_cn) {\n\t    \tmatched = match_hostname(cert_subject_cn, hostname);\n\t    \tif (! matched) {\n\t\t\t\tg_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);\n\t    \t}\n\t    } else {\n\t    \tg_warning(\"No subjectAltNames and no valid common name in certificate\");\n\t    }\n\t    free(cert_subject_cn);\n\t}\n\treturn matched;\n}", "target": 0}
{"code": "static int io_files_update_with_index_alloc(struct io_kiocb *req,\n\t\t\t\t\t    unsigned int issue_flags)\n{\n\t__s32 __user *fds = u64_to_user_ptr(req->rsrc_update.arg);\n\tunsigned int done;\n\tstruct file *file;\n\tint ret, fd;\n\tif (!req->ctx->file_data)\n\t\treturn -ENXIO;\n\tfor (done = 0; done < req->rsrc_update.nr_args; done++) {\n\t\tif (copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t  IORING_FILE_INDEX_ALLOC);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(&fds[done], &ret, sizeof(ret))) {\n\t\t\t__io_close_fixed(req, issue_flags, ret);\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (done)\n\t\treturn done;\n\treturn ret;", "target": 0}
{"code": "ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            args.m_screenChangeScript = argv[++i];\n        }\n        else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) {\n  FromProto(proto);\n}", "target": 1}
{"code": "int smm_setup_relocation_handler(struct smm_loader_params *params)\n{\n\tvoid *smram = (void *)(SMM_DEFAULT_BASE);\n\tprintk(BIOS_SPEW, \"%s: enter\\n\", __func__);\n\tif (params->num_concurrent_save_states > 1)\n\t\treturn -1;\n\tif (params->handler == NULL)\n\t\treturn -1;\n\tif (params->num_concurrent_stacks == 0)\n\t\tparams->num_concurrent_stacks = CONFIG_MAX_CPUS;\n\tparams->smm_main_entry_offset = SMM_ENTRY_OFFSET;\n\tparams->smram_start = SMM_DEFAULT_BASE;\n\tparams->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;\n\treturn smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,\n\t\t\t\tparams, fxsave_area_relocation);\n\tprintk(BIOS_SPEW, \"%s: exit\\n\", __func__);\n}", "target": 0}
{"code": "_SSL_check_hostname (X509 *cert, const char *host)\n{\n\tint rv;\n\trv = _SSL_check_subject_altname (cert, host);\n\tif (rv == 0 || rv == -2)\n\t\treturn rv;\n\treturn _SSL_check_common_name (cert, host);\n}", "target": 0}
{"code": "    static CImg<T> get_load_camera(const unsigned int camera_index=0, const unsigned int skip_frames=0,\n                                   const bool release_camera=true,\n                                   const unsigned int capture_width=0, const unsigned int capture_height=0) {\n      return CImg<T>().load_camera(camera_index,skip_frames,release_camera,capture_width,capture_height);", "target": 0}
{"code": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void __pam_log(const pam_handle_t *pamh, int ctrl, int err, const char *format, ...)\n{\n\tva_list args;\n\tif (_pam_log_is_silent(ctrl)) {\n\t\treturn;\n\t}\n\tva_start(args, format);\n\t_pam_log_int(pamh, err, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}", "target": 0}
{"code": "fbFetchPixel_b1g2r1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = Fetch4(bits, offset);\n    CARD32  r,g,b;\n    b = ((pixel & 0x8) * 0xff) >> 3;\n    g = ((pixel & 0x6) * 0x55) << 7;\n    r = ((pixel & 0x1) * 0xff) << 16;\n    return 0xff000000|r|g|b;\n}", "target": 0}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)\n{\n  return (chunk->mem + chunk->memlen) - (chunk->data + chunk->datalen);\n}", "target": 0}
{"code": "CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n                                  X509 *signcert, EVP_PKEY *pkey,\n                                  STACK_OF(X509) *certs, unsigned int flags)\n{\n    CMS_SignerInfo *rct_si;\n    CMS_ContentInfo *cms = NULL;\n    ASN1_OCTET_STRING **pos, *os;\n    BIO *rct_cont = NULL;\n    int r = 0;\n    flags &= ~(CMS_STREAM | CMS_TEXT);\n    flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;\n    if (!pkey || !signcert) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);\n        return NULL;\n    }\n    cms = CMS_sign(NULL, NULL, certs, NULL, flags);\n    if (!cms)\n        goto err;\n    if (!CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_smime_ct_receipt)))\n        goto err;\n    rct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);\n    if (!rct_si) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);\n        goto err;\n    }\n    os = cms_encode_Receipt(si);\n    if (!os)\n        goto err;\n    rct_cont = BIO_new_mem_buf(os->data, os->length);\n    if (!rct_cont)\n        goto err;\n    if (!cms_msgSigDigest_add1(rct_si, si))\n        goto err;\n    if (!CMS_final(cms, rct_cont, NULL, flags))\n        goto err;\n    pos = CMS_get0_content(cms);\n    *pos = os;\n    r = 1;\n err:\n    if (rct_cont)\n        BIO_free(rct_cont);\n    if (r)\n        return cms;\n    CMS_ContentInfo_free(cms);\n    return NULL;\n}", "target": 0}
{"code": "void *safe_calloc(size_t size) {\n  void *addr;\n  if (!size)\n  {\n    ERR(\"Invalid allocation size.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  if (!(addr = calloc(1, size)))\n  {\n      ERR(\"Failed to allocate requested number of bytes, out of memory?\\n\");\n      exit(EXIT_FAILURE);\n  }\n  return addr;\n}", "target": 0}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}", "target": 0}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\tmutex_lock(&dev->lock);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 0}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                SpaceToBatchNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +\n                          paddings_data[dim * 2 + 1]);\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);\n    output_size->data[dim + 1] = final_dim_size / block_shape[dim];\n    output_batch_size *= block_shape[dim];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "int compat_sock_common_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t  char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tif (sk->sk_prot->compat_setsockopt != NULL)\n\t\treturn sk->sk_prot->compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t      optval, optlen);\n\treturn sk->sk_prot->setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Status TensorSlice::BuildTensorSlice(const TensorSliceProto& proto,\n                                     TensorSlice* output) {\n  output->Clear();\n  output->starts_.reserve(proto.extent_size());\n  output->lengths_.reserve(proto.extent_size());\n  for (const auto& e : proto.extent()) {\n    int64_t l = GetExtentLength(e);\n    if (e.start() != 0 || l != kFullExtent) {\n      if (e.start() < 0 || l <= 0) {\n        return errors::InvalidArgument(\n            \"Expected non-negative start and positive length but got start = \",\n            e.start(), \", length = \", l, \": extent = \", e.ShortDebugString());\n      }\n      if (static_cast<uint64_t>(e.start()) + static_cast<uint64_t>(e.length()) >\n          std::numeric_limits<int64_t>::max()) {\n        return errors::InvalidArgument(\n            \"Extent end exceeds the maximum possible size: extent = \",\n            e.ShortDebugString());\n      }\n    }\n    output->starts_.push_back(e.start());\n    output->lengths_.push_back(l);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\ts_idx = cb->args[0];\n\trcu_read_lock();\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "void RtmpProtocol::handle_C1_complex(const char *data){\n    const char *c1_start = data + 1;\n    const char *schema_start = c1_start + 8;\n    char *digest_start;\n    try {\n        auto digest = get_C1_digest((uint8_t *) schema_start + C1_SCHEMA_SIZE, &digest_start);\n        string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n        c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n        check_C1_Digest(digest, c1_joined);\n        send_complex_S0S1S2(0, digest);\n    } catch (std::exception &) {\n        try {\n            auto digest = get_C1_digest((uint8_t *) schema_start, &digest_start);\n            string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n            c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n            check_C1_Digest(digest, c1_joined);\n            send_complex_S0S1S2(1, digest);\n        } catch (std::exception &) {\n            handle_C1_simple(data);\n        }\n    }\n}", "target": 0}
{"code": "int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask,\n\t\tsector_t *error_sector)\n{\n\tstruct request_queue *q;\n\tstruct bio *bio;\n\tint ret = 0;\n\tif (bdev->bd_disk == NULL)\n\t\treturn -ENXIO;\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\tif (!q->make_request_fn)\n\t\treturn -ENXIO;\n\tbio = bio_alloc(gfp_mask, 0);\n\tbio->bi_bdev = bdev;\n\tret = submit_bio_wait(WRITE_FLUSH, bio);\n\tif (error_sector)\n\t\t*error_sector = bio->bi_iter.bi_sector;\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 0}
{"code": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n    lua_newtable(L);\n    luaL_checkstack(L, 1, \"in function mp_decode_to_lua_array\");\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}", "target": 0}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void *HTPStateGetTx(void *alstate, uint64_t tx_id)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL)\n        return htp_list_get(http_state->conn->transactions, tx_id);\n    else\n        return NULL;\n}", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "static int config_req_handler(void *arg)\n{\n\tprintf(\"requesing config\\n\");\n\treturn rest_request(NULL, engine_get_restcli(engine), 0,\n\t\t\t    \"GET\", cfg_resp_handler, NULL,\n\t\t\t    \"/calls/config/v2\", NULL);\n}", "target": 0}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "void Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n      generic_conn_pool_.reset();\n    }\n  }\n}", "target": 0}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}", "target": 1}
{"code": "\t\tGetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "  static ::tensorflow::Status ValidateInputs(\n      std::vector<ConstFlatSplits> rt_nested_splits,\n      const Tensor& rt_dense_values_in) {\n    for (int i = 0; i < rt_nested_splits.size(); ++i) {\n      if (rt_nested_splits[i].size() == 0) {\n        return InvalidArgument(\"ragged splits may not be empty.\");\n      }\n      if (rt_nested_splits[i](0) != 0) {\n        return InvalidArgument(\"First value of ragged splits must be 0.\");\n      }\n      for (int j = 1; j < rt_nested_splits[i].size(); ++j) {\n        if (rt_nested_splits[i](j) < rt_nested_splits[i](j - 1)) {\n          return InvalidArgument(\n              \"Ragged splits should be non decreasing, but we got \",\n              rt_nested_splits[i](j - 1), \" followed by \",\n              rt_nested_splits[i](j));\n        }\n      }\n      if (i > 0) {\n        SPLITS_TYPE last_split =\n            rt_nested_splits[i - 1](rt_nested_splits[i - 1].size() - 1);\n        if (rt_nested_splits[i].size() != last_split + 1) {\n          return InvalidArgument(\n              \"Final value of ragged splits must match the length \"\n              \"the corresponding ragged values.\");\n        }\n      }\n    }\n    if (rt_dense_values_in.dim_size(0) !=\n        rt_nested_splits.back()(rt_nested_splits.back().size() - 1)) {\n      return InvalidArgument(\n          \"Final value of ragged splits must match the length \"\n          \"the corresponding ragged values.\");\n    }\n    return ::tensorflow::Status::OK();\n  }", "target": 0}
{"code": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }", "target": 1}
{"code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}", "target": 1}
{"code": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "static int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!rc)\n\t\treturn 0;\n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\tmutex_lock(&priv->lock);\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 0}
{"code": "static int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tvma->vm_ops = &mon_bin_vm_ops;\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_private_data = filp->private_data;\n\tmon_bin_vma_open(vma);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || \n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && \n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); \n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static int sd_e_h(GWindow gw, GEvent *event) {\n    struct sd_data *sd = GDrawGetUserData(gw);\n    if ( sd==NULL )\nreturn( true );\n    if ( event->type==et_close ) {\n\tSD_DoCancel( sd );\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {\n    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {\n    sd->fv->script_unsaved = false;\n    } else if ( event->type==et_char ) {\n\tif ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {\n\t    help(\"scripting.html\");\nreturn( true );\n\t}\nreturn( false );\n    } else if ( event->type == et_map )\t\n\tGDrawRaise(gw);\n    else if ( event->type == et_resize )\n\tGDrawRequestExpose(gw,NULL,false);\nreturn( true );\n}", "target": 0}
{"code": "static int selinux_task_setnice(struct task_struct *p, int nice)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}", "target": 0}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\tsg_init_table(sgl->sg, npages);\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\tcexp(J, F, ref);\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\tif (end)\n\t\tlabel(J, F, end);\n}", "target": 0}
{"code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  BuildCommon();\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n      if (m_pLargestScale) {\n        class Frame *frame = m_pLargestScale->FrameOf();\n        while(frame) {\n          if (frame->ComponentOf(i)->SubXOf() != sx || frame->ComponentOf(i)->SubYOf() != sy)\n            JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::PrepareForDecoding\",\n                      \"component subsampling is inconsistent across hierarchical levels\");\n          frame = frame->NextOf();\n        }\n      }\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}", "target": 0}
{"code": "void MutateSavedTensorSlices(\n    const std::string& fname,\n    const std::function<std::string(SavedTensorSlices)>& mutator) {\n  table::Options options;\n  options.compression = table::kNoCompression;\n  std::vector<std::pair<std::string, std::string>> entries;\n  {\n    std::unique_ptr<RandomAccessFile> file;\n    TF_CHECK_OK(Env::Default()->NewRandomAccessFile(fname, &file));\n    uint64 file_size;\n    TF_CHECK_OK(Env::Default()->GetFileSize(fname, &file_size));\n    table::Table* t;\n    TF_CHECK_OK(table::Table::Open(options, file.get(), file_size, &t));\n    std::unique_ptr<table::Table> table(t);\n    std::unique_ptr<table::Iterator> it(table->NewIterator());\n    for (it->Seek(\"\"); it->Valid(); it->Next()) {\n      entries.emplace_back(it->key(), it->value());\n    }\n    TF_CHECK_OK(it->status());\n  }\n  {\n    std::unique_ptr<WritableFile> file;\n    TF_CHECK_OK(Env::Default()->NewWritableFile(fname, &file));\n    table::TableBuilder builder(options, file.get());\n    for (const auto& entry : entries) {\n      SavedTensorSlices sts;\n      CHECK(sts.ParseFromString(entry.second));\n      builder.Add(entry.first, mutator(std::move(sts)));\n    }\n    TF_CHECK_OK(builder.Finish());\n    TF_CHECK_OK(file->Close());\n  }\n}", "target": 0}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}", "target": 1}
{"code": "  Status ArgSortByRows(OpKernelContext* context, const GPUDevice& device,\n                       Tindex N, int rank, Tindex dense_rows,\n                       typename TTypes<Tindex>::ConstMatrix indices,\n                       Tensor* input_index_map_t) {\n    DataType index_type = DataTypeToEnum<Tindex>::value;\n    Tensor row_indices_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(index_type, TensorShape({N}), &row_indices_t));\n    auto row_indices = row_indices_t.flat<Tindex>();\n    TF_RETURN_IF_ERROR(wrap_kernel_call(CopyRowIndicesKernel<Tindex>,\n                                        device, N, rank,\n                                        indices, row_indices));\n    TF_RETURN_IF_ERROR(context->allocate_temp(index_type, TensorShape({N}),\n                                              input_index_map_t));\n    Tindex* input_index_map = input_index_map_t->flat<Tindex>().data();\n    return GpuRadixSort(context, N, row_indices.data(),\n                        static_cast<Tindex*>(nullptr),\n                        static_cast<Tindex*>(nullptr),\n                        input_index_map,\n                        Log2Ceiling64(dense_rows));\n  }", "target": 1}
{"code": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->symmetric_difference (*other);\n}", "target": 1}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}", "target": 0}
{"code": "static void lwp_write(FILE *fout, const std::string &buf) {\n  size_t len = buf.length();\n  fwrite(&len, sizeof(len), 1, fout);\n  fwrite(buf.c_str(), sizeof(buf[0]), len, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\treturn err;\n}", "target": 1}
{"code": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\tfuse_conn_put(&cc->fc);\n\trc = fuse_dev_release(inode, file);\t\n\treturn rc;\n}", "target": 0}
{"code": "void bio_advance(struct bio *bio, unsigned bytes)\n{\n\tif (bio_integrity(bio))\n\t\tbio_integrity_advance(bio, bytes);\n\tbio_advance_iter(bio, &bio->bi_iter, bytes);\n}", "target": 0}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "void slice_segment_header::set_defaults()\n{\n  slice_index = 0;\n  first_slice_segment_in_pic_flag = 1;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n  slice_type = SLICE_TYPE_I;\n  pic_output_flag = 1;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 1;\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics = 0;\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active=1; \n  num_ref_idx_l1_active=1; \n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n  luma_log2_weight_denom=0; \n  ChromaLog2WeightDenom=0;  \n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n  cu_chroma_qp_offset_enabled_flag = 0;\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset=0; \n  slice_tc_offset=0;   \n  slice_loop_filter_across_slices_enabled_flag = 0;\n  num_entry_point_offsets = 0;\n  slice_segment_header_extension_length = 0;\n  SliceAddrRS = slice_segment_address;\n}", "target": 0}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0f)\n    return(0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return(value);\n#endif\n}", "target": 1}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"Can't find debug filename\\n\");\n\t\treturn 1;\n\t}\n\tif (!is_valid_guid (info->guid)) {\n\t\teprintf (\"Invalid GUID for file\\n\");\n\t\treturn 1;\n\t}\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"Can't retrieve pdb configurations\\n\");\n\t\treturn 1;\n\t}\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"%s\\\"pdb\\\":{\\\"file\\\":\\\"%s\\\",\\\"download\\\":%s}\",\n\t\t        *actions_done ? \",\" : \"\", opt.dbg_file, ret ? \"true\" : \"false\");\n\t} else {\n\t\tprintf (\"PDB \\\"%s\\\" download %s\\n\",\n\t\t        opt.dbg_file, ret ? \"success\" : \"failed\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\treturn 0;\n}", "target": 0}
{"code": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}", "target": 1}
{"code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\tBUG_ON (!data || !frags);\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t\n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\treturn true;\n}", "target": 0}
{"code": "static void dp8393x_do_load_cam(dp8393xState *s)\n{\n    int width, size;\n    uint16_t index = 0;\n    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;\n    size = sizeof(uint16_t) * 4 * width;\n    while (s->regs[SONIC_CDC] & 0x1f) {\n        address_space_read(&s->as, dp8393x_cdp(s),\n                           MEMTXATTRS_UNSPECIFIED, s->data, size);\n        s->cam[index][0] = dp8393x_get(s, width, 1) & 0xff;\n        s->cam[index][1] = dp8393x_get(s, width, 1) >> 8;\n        s->cam[index][2] = dp8393x_get(s, width, 2) & 0xff;\n        s->cam[index][3] = dp8393x_get(s, width, 2) >> 8;\n        s->cam[index][4] = dp8393x_get(s, width, 3) & 0xff;\n        s->cam[index][5] = dp8393x_get(s, width, 3) >> 8;\n        DPRINTF(\"load cam[%d] with %02x%02x%02x%02x%02x%02x\\n\", index,\n            s->cam[index][0], s->cam[index][1], s->cam[index][2],\n            s->cam[index][3], s->cam[index][4], s->cam[index][5]);\n        s->regs[SONIC_CDC]--;\n        s->regs[SONIC_CDP] += size;\n        index++;\n    }\n    address_space_read(&s->as, dp8393x_cdp(s),\n                       MEMTXATTRS_UNSPECIFIED, s->data, size);\n    s->regs[SONIC_CE] = dp8393x_get(s, width, 0);\n    DPRINTF(\"load cam done. cam enable mask 0x%04x\\n\", s->regs[SONIC_CE]);\n    s->regs[SONIC_CR] &= ~SONIC_CR_LCAM;\n    s->regs[SONIC_ISR] |= SONIC_ISR_LCD;\n    dp8393x_update_irq(s);\n}", "target": 0}
{"code": "lib_contains_symbol(const char *path, const char *s)\n{\n\tstruct nlist nl[2];\n\tint ret = -1, r;\n\tmemset(nl, 0, sizeof(nl));\n\tnl[0].n_name = xstrdup(s);\n\tnl[1].n_name = NULL;\n\tif ((r = nlist(path, nl)) == -1) {\n\t\terror_f(\"nlist failed for %s\", path);\n\t\tgoto out;\n\t}\n\tif (r != 0 || nl[0].n_value == 0 || nl[0].n_type == 0) {\n\t\terror_f(\"library %s does not contain symbol %s\", path, s);\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\tfree(nl[0].n_name);\n\treturn ret;\n}", "target": 0}
{"code": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t\n\t\tanon_vma->parent = anon_vma;\n\t\tanon_vma->root = anon_vma;\n\t}\n\treturn anon_vma;\n}", "target": 1}
{"code": "bool neu_plugin_manager_schema_exist(neu_plugin_manager_t *mgr,\n                                     const char *          schema)\n{\n    bool             exist = false;\n    plugin_entity_t *el = NULL, *tmp = NULL;\n    HASH_ITER(hh, mgr->plugins, el, tmp)\n    {\n        if (strcmp(el->schema, schema) == 0) {\n            exist = true;\n            break;\n        }\n    }\n    return exist;\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "bool StringSanMatcher::match(const GENERAL_NAME* general_name) const {\n  if (general_name->type != general_name_type_) {\n    return false;\n  }\n  const std::string san = Utility::generalNameAsString(general_name);\n  return general_name->type == GEN_DNS &&\n                 matcher_.matcher().match_pattern_case() ==\n                     envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n             ? Utility::dnsNameMatch(matcher_.matcher().exact(), absl::string_view(san))\n             : matcher_.match(san);\n}", "target": 0}
{"code": "apply_intended_configuration (GsdXrandrManager *manager, const char *intended_filename, guint32 timestamp)\n{\n        GError *my_error;\n        my_error = NULL;\n        if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &my_error)) {\n                if (my_error) {\n                        if (!g_error_matches (my_error, G_FILE_ERROR, G_FILE_ERROR_NOENT))\n                                error_message (manager, _(\"Could not apply the stored configuration for monitors\"), my_error, NULL);\n                        g_error_free (my_error);\n                }\n        }\n}", "target": 0}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {\n    GROW;\n    if (CUR == '<') {\n        if (NXT(1) == '!') {\n\t    switch (NXT(2)) {\n\t        case 'E':\n\t\t    if (NXT(3) == 'L')\n\t\t\txmlParseElementDecl(ctxt);\n\t\t    else if (NXT(3) == 'N')\n\t\t\txmlParseEntityDecl(ctxt);\n\t\t    break;\n\t        case 'A':\n\t\t    xmlParseAttributeListDecl(ctxt);\n\t\t    break;\n\t        case 'N':\n\t\t    xmlParseNotationDecl(ctxt);\n\t\t    break;\n\t        case '-':\n\t\t    xmlParseComment(ctxt);\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t} else if (NXT(1) == '?') {\n\t    xmlParsePI(ctxt);\n\t}\n    }\n    if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n\txmlParsePEReference(ctxt);\n    if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {\n        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t    xmlParseConditionalSections(ctxt);\n\t}\n    }\n    ctxt->instate = XML_PARSER_DTD;\n}", "target": 0}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}", "target": 0}
{"code": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t}\n\treturn mnt;\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}", "target": 0}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  if (output_index >= src->num_outputs()) {\n    return errors::InvalidArgument(\n        \"Output \", output_index, \" of node \", src->name(),\n        \" does not exist. Node only has \", src->num_outputs(), \" outputs.\");\n  }\n  if (input_index >= dst->num_inputs()) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(),\n        \" does not exist. Node only has \", dst->num_inputs(), \" inputs.\");\n  }\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}", "target": 0}
{"code": "init_util(void)\n{\n\tfilegen_register(statsdir, \"peerstats\",\t  &peerstats);\n\tfilegen_register(statsdir, \"loopstats\",\t  &loopstats);\n\tfilegen_register(statsdir, \"clockstats\",  &clockstats);\n\tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n\tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n\tfilegen_register(statsdir, \"protostats\",  &protostats);\n#ifdef AUTOKEY\n\tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n#endif\t\n#ifdef DEBUG_TIMING\n\tfilegen_register(statsdir, \"timingstats\", &timingstats);\n#endif\t\n\tstep_callback = &ntpd_time_stepped;\n#ifdef DEBUG\n\tatexit(&uninit_util);\n#endif \n}", "target": 1}
{"code": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, \n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}", "target": 0}
{"code": "static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "int IniSection::Write (const YCPPath&p, const YCPValue&v, bool rewrite)\n{\n    if (ip->isFlat ())\n\treturn setValueFlat (p, v);\n    if (p->length() >= 1 && p->component_str (0) == \"all\")\n    {\n\treturn setAll (p, v, 1);\n    }\n    if (p->length() < 2)\n    {\n\ty2error (\"I do not know what to write to %s.\", p->toString().c_str());\n\treturn -1;\n    }\n    string s = p->component_str (0);\n    if (s == \"v\" || s == \"value\")\n\treturn setValue (p, v, 0, 1);\n    if (s == \"vc\" || s == \"value_comment\" || s == \"valuecomment\")\n      return setValue (p, v, 1, 1);\n    if (s == \"vt\" || s == \"value_type\" || s == \"valuetype\")\n      return setValue (p, v, 2, 1);\n    if (s == \"s\" || s == \"section\" || s == \"sc\" || s == \"section_comment\" || s == \"sectioncomment\")\n      return setSectionProp (p, v, 0, 1);\n    if (s == \"st\" || s == \"section_type\" || s == \"sectiontype\")\n      return setSectionProp (p, v, rewrite? 1:2, 1);\n    if (s == \"section_private\")\n      return setSectionProp (p, v, 3, 1);\n    return -1;\n}", "target": 0}
{"code": "static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n\tut8 *data = malloc (len);\n\tif (data) {\n\t\tr_buf_read_at (buf, addr, data, len);\n\t\tdata[len-1] = 0;\n\t\treturn data;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}", "target": 1}
{"code": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\text4_ext_mark_initialized(ex);\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        num_key_aliases++;\n    }\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 0}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "static int rtnl_bridge_notify(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\tif (!dev->netdev_ops->ndo_bridge_getlink)\n\t\treturn 0;\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\tif (!skb->len)\n\t\tgoto errout;\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\tif (err)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}", "target": 0}
{"code": "HIDDEN void log_cachehdr(const char *name, const char *contents,\n                         const char *raw, void *rock)\n{\n    struct buf *buf = (struct buf *) rock;\n    if (name[0] == ':') return;\n    if (!strcasecmp(name, \"authorization\")) {\n        const char *creds = strchr(contents, ' ') + 1;\n        buf_printf(buf, \"%c%s: %.*s%-*s\\r\\n\", toupper(name[0]), name+1,\n                   (int) (creds - contents), contents,\n                   (int) strlen(creds), \"...\");\n    }\n    else if (raw)\n        buf_appendcstr(buf, raw);\n    else\n        buf_printf(buf, \"%c%s: %s\\r\\n\", toupper(name[0]), name+1, contents);\n}", "target": 0}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\n\t\t\tstruct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint unit, err = -EFAULT;\n\tstruct ppp *ppp;\n\tstruct channel *chan;\n\tstruct ppp_net *pn;\n\tint __user *p = (int __user *)arg;\n\tmutex_lock(&ppp_mutex);\n\tswitch (cmd) {\n\tcase PPPIOCNEWUNIT:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\tppp = ppp_create_interface(net, unit, file, &err);\n\t\tif (!ppp)\n\t\t\tbreak;\n\t\tfile->private_data = &ppp->file;\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp->file.index, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCATTACH:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tmutex_lock(&pn->all_ppp_mutex);\n\t\tppp = ppp_find_unit(pn, unit);\n\t\tif (ppp) {\n\t\t\tatomic_inc(&ppp->file.refcnt);\n\t\t\tfile->private_data = &ppp->file;\n\t\t\terr = 0;\n\t\t}\n\t\tmutex_unlock(&pn->all_ppp_mutex);\n\t\tbreak;\n\tcase PPPIOCATTCHAN:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tspin_lock_bh(&pn->all_channels_lock);\n\t\tchan = ppp_find_channel(pn, unit);\n\t\tif (chan) {\n\t\t\tatomic_inc(&chan->file.refcnt);\n\t\t\tfile->private_data = &chan->file;\n\t\t\terr = 0;\n\t\t}\n\t\tspin_unlock_bh(&pn->all_channels_lock);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\tmutex_unlock(&ppp_mutex);\n\treturn err;\n}", "target": 0}
{"code": "void shut_down(int code)\n{\n    int i;\n    int bytes_in = 0;\n    int bytes_out = 0;\n    in_shutdown = 1;\n    if (allow_cors) free_wildmats(allow_cors);\n    for (i = 0; http_namespaces[i]; i++) {\n        if (http_namespaces[i]->enabled && http_namespaces[i]->shutdown)\n            http_namespaces[i]->shutdown();\n    }\n    xmlCleanupParser();\n    proc_cleanup();\n    i = 0;\n    while (backend_cached && backend_cached[i]) {\n        proxy_downserver(backend_cached[i]);\n        free(backend_cached[i]->context);\n        free(backend_cached[i]);\n        i++;\n    }\n    if (backend_cached) free(backend_cached);\n    index_text_extractor_destroy();\n    annotatemore_close();\n    if (httpd_in) {\n        prot_NONBLOCK(httpd_in);\n        prot_fill(httpd_in);\n        bytes_in = prot_bytes_in(httpd_in);\n        prot_free(httpd_in);\n    }\n    if (httpd_out) {\n        prot_flush(httpd_out);\n        bytes_out = prot_bytes_out(httpd_out);\n        prot_free(httpd_out);\n        prometheus_decrement(CYRUS_HTTP_ACTIVE_CONNECTIONS);\n    }\n    else {\n        prometheus_decrement(CYRUS_HTTP_READY_LISTENERS);\n    }\n    prometheus_increment(code ? CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_ERROR\n                              : CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_OK);\n    if (protin) protgroup_free(protin);\n    if (config_auditlog)\n        syslog(LOG_NOTICE,\n               \"auditlog: traffic sessionid=<%s> bytes_in=<%d> bytes_out=<%d>\",\n               session_id(), bytes_in, bytes_out);\n#ifdef HAVE_SSL\n    tls_shutdown_serverengine();\n#endif\n    saslprops_free(&saslprops);\n    http2_done();\n    cyrus_done();\n    exit(code);\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "countAllSwitchActions (union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n\tint i,j=1;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tfor(i=0; i < ((struct SWF_ACTIONIF*)actions)->numActions; i++)\n\t\t{\n\t\t\tj+=countAllSwitchActions(&((struct SWF_ACTIONIF*)actions)->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}                  \n\treturn j;\n}", "target": 0}
{"code": "static int mount_notrunc(const char *source, const char *target,\n\t\t\t const char *filesystemtype, unsigned long mountflags,\n\t\t\t const char *data) {\n\tif (strlen(data) > sysconf(_SC_PAGESIZE) - 1) {\n\t\tfprintf(stderr, \"%s: mount options too long\\n\", progname);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn mount(source, target, filesystemtype, mountflags, data);\n}", "target": 0}
{"code": "static int turn_dns_lookup(struct zapi_ice_server *turn,\n\t\t\t   struct stun_uri *uri)\n{\n\tstruct lookup_entry *lent;\n\tint err = 0;\n\tlent = mem_zalloc(sizeof(*lent), lent_destructor);\n\tif (!lent)\n\t\treturn ENOMEM;\n\tlent->turn = *turn;\n\tlent->ts = tmr_jiffies();\n\tlent->proto = uri->proto;\n\tlent->secure = uri->secure;\n\tlent->port = uri->port;\n\terr = str_dup(&lent->host, uri->host);\n\tif (err)\n\t\tgoto out;\n\tre_printf(\"dns_lookup for: %s:%d\\n\", lent->host, lent->port);\n\terr = dns_lookup(lent->host, dns_handler, lent);\n\tif (err) {\n\t\twarning(\"dns_lookup: failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n out:\n\tif (err)\n\t\tmem_deref(lent);\n\treturn err;\n}", "target": 0}
{"code": "checked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n    return xcalloc (num, size);\n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}", "target": 0}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "static int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t  const struct ebt_counter *oldcounters,\n\t\t\t\t  void __user *user, unsigned int num_counters,\n\t\t\t\t  unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\tif (num_counters == 0)\n\t\treturn 0;\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}", "target": 0}
{"code": "R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n\tint ret = 0;\n\tfor (ret = 0; ret < len; ) {\n\t\tint r = r_socket_read (s, buf + ret, len - ret);\n\t\tif (r == -1) {\n#if HAVE_LIB_SSL\n\t\t\tif (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {\n\t\t\t\tif (r_socket_ready (s, 1, 0) == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (r < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tret += r;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int do_set_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info,\n\t\t       int can_allocate)\n{\n\tstruct user_desc info;\n\tif (copy_from_user(&info, u_info, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (!tls_desc_okay(&info))\n\t\treturn -EINVAL;\n\tif (idx == -1)\n\t\tidx = info.entry_number;\n\tif (idx == -1 && can_allocate) {\n\t\tidx = get_free_idx();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tif (put_user(idx, &u_info->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\tset_tls_desc(p, idx, &info, 1);\n\treturn 0;\n}", "target": 0}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tif (op->ifindex) {\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; \n\t\t}\n\t}\n\treturn 0; \n}", "target": 0}
{"code": "void Context::onDelete() {\n  if (wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\tfulllen = strlen(target);\n\tif (prefix_skip) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\telse\n\t\t\t\tSYSERROR(\"Error examining %s in %s\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(dup);\n\treturn dirfd;\n}", "target": 0}
{"code": "find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    for (pl2 = plist; *pl2; pl2++);\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}", "target": 0}
{"code": "tsetcap(int cap, int flags)\n{\n    if (tccan(cap) && !isset(SINGLELINEZLE) &&\n        !(termflags & (TERM_NOUP|TERM_BAD|TERM_UNKNOWN))) {\n\tswitch (flags & TSC_OUTPUT_MASK) {\n\tcase TSC_RAW:\n\t    tputs(tcstr[cap], 1, putraw);\n\t    break;\n\tcase 0:\n\tdefault:\n\t    tputs(tcstr[cap], 1, putshout);\n\t    break;\n\tcase TSC_PROMPT:\n\t    if (!bv->dontcount) {\n\t\taddbufspc(1);\n\t\t*bv->bp++ = Inpar;\n\t    }\n\t    tputs(tcstr[cap], 1, putstr);\n\t    if (!bv->dontcount) {\n\t\tint glitch = 0;\n\t\tif (cap == TCSTANDOUTBEG || cap == TCSTANDOUTEND)\n\t\t    glitch = tgetnum(\"sg\");\n\t\telse if (cap == TCUNDERLINEBEG || cap == TCUNDERLINEEND)\n\t\t    glitch = tgetnum(\"ug\");\n\t\tif(glitch < 0)\n\t\t    glitch = 0;\n\t\taddbufspc(glitch + 1);\n\t\twhile(glitch--)\n\t\t    *bv->bp++ = Nularg;\n\t\t*bv->bp++ = Outpar;\n\t    }\n\t    break;\n\t}\n\tif (flags & TSC_DIRTY) {\n\t    flags &= ~TSC_DIRTY;\n\t    if (txtisset(TXTBOLDFACE) && cap != TCBOLDFACEBEG)\n\t\ttsetcap(TCBOLDFACEBEG, flags);\n\t    if (txtisset(TXTSTANDOUT))\n\t\ttsetcap(TCSTANDOUTBEG, flags);\n\t    if (txtisset(TXTUNDERLINE))\n\t\ttsetcap(TCUNDERLINEBEG, flags);\n\t    if (txtisset(TXTFGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_FG, TSC_PROMPT);\n\t    if (txtisset(TXTBGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_BG, TSC_PROMPT);\n\t}\n    }\n}", "target": 0}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm->vmacache_seqnum++;\n\tif (unlikely(mm->vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}", "target": 1}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "static int tipc_crypto_key_revoke(struct net *net, u8 tx_key)\n{\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx;\n\tstruct tipc_key key;\n\tspin_lock(&tx->lock);\n\tkey = tx->key;\n\tWARN_ON(!key.active || tx_key != key.active);\n\ttipc_crypto_key_set_state(tx, key.passive, 0, key.pending);\n\ttipc_crypto_key_detach(tx->aead[key.active], &tx->lock);\n\tspin_unlock(&tx->lock);\n\tpr_warn(\"%s: key is revoked\\n\", tx->name);\n\treturn -EKEYREVOKED;\n}", "target": 1}
{"code": "static void add_send_options(GDHCPClient *dhcp_client,\n\t\t\t\tstruct dhcp_packet *packet)\n{\n\tg_hash_table_foreach(dhcp_client->send_value_hash,\n\t\t\t\tadd_binary_option, packet);\n}", "target": 0}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\tmbochs_used_mbytes += type->mbytes;\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}", "target": 1}
{"code": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0) {\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}", "target": 1}
{"code": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n#ifdef CONFIG_NUMA\n\treturn s->node[node];\n#else\n\treturn &s->local_node;\n#endif\n}", "target": 0}
{"code": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  auto* output_data = GetTensorData<std::int64_t>(output_tensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  output_data[0] = lookup->Size();\n  return kTfLiteOk;\n}", "target": 1}
{"code": "int sldns_str2wire_nsap_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tconst char* s = str;\n\tsize_t slen;\n\tsize_t dlen = 0; \n\tif (s[0] != '0' || s[1] != 'x')\n\t\treturn LDNS_WIREPARSE_ERR_INVALID_STR;\n\ts += 2;\n\tslen = strlen(s);\n\tif(slen > LDNS_MAX_RDFLEN*2)\n\t\treturn LDNS_WIREPARSE_ERR_LABEL_OVERFLOW;\n\twhile(*s) {\n\t\tif(isspace((unsigned char)*s) || *s == '.') {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isxdigit((unsigned char)*s))\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t\tif(*len < dlen/2 + 1)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\ts-str);\n\t\tif((dlen&1)==0)\n\t\t\trd[dlen/2] = (uint8_t)sldns_hexdigit_to_int(*s++) * 16;\n\t\telse\trd[dlen/2] += sldns_hexdigit_to_int(*s++);\n\t\tdlen++;\n\t}\n\tif((dlen&1)!=0)\n\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t*len = dlen/2;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "  TestCertificateValidationContextConfig(\n      envoy::config::core::v3::TypedExtensionConfig config, bool allow_expired_certificate = false,\n      std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers = {})\n      : allow_expired_certificate_(allow_expired_certificate), api_(Api::createApiForTest()),\n        custom_validator_config_(config), san_matchers_(san_matchers){};", "target": 1}
{"code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\treturn 0;\n}", "target": 0}
{"code": "psf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\terror = psf_fclose (psf) ;\n\tpsf_close_rsrc (psf) ;\n\tfree (psf->header.ptr) ;\n\tfree (psf->container_data) ;\n\tfree (psf->codec_data) ;\n\tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\treturn error ;\n} ", "target": 0}
{"code": "void swallow_arg(int *argcp, char *argv[], char *which)\n{\n\tint i;\n\tfor (i = 1; argv[i]; i++) {\n\t\tif (strcmp(argv[i], which) != 0)\n\t\t\tcontinue;\n\t\tfor (; argv[i]; i++) {\n\t\t\targv[i] = argv[i+1];\n\t\t}\n\t\t(*argcp)--;\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "_pdfioFileConsume(pdfio_file_t *pdf,\t\n                  size_t       bytes)\t\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n  return (true);\n}", "target": 0}
{"code": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->subtract (*other);\n}", "target": 1}
{"code": "BOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\t\tnego_process_negotiation_request(nego, s);\n\t}\n\treturn tpkt_ensure_stream_consumed(s, length);\n}", "target": 1}
{"code": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n\t== NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\tfree(cd);\n\treturn NULL;\n    }\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n    return cd;\n}", "target": 0}
{"code": "mmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n    int length;\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n    char filename[256];\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n    if (mmsMsg_isFilenameSave(filename) == false)\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 0}
{"code": "subscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\tif (!subscription)\n\t\treturn;\n\tif (subscription->updateJob)\n\t\treturn;\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\t\tupdate_request_allow_commands (request, TRUE);\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}", "target": 0}
{"code": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}", "target": 1}
{"code": "static void php_array_merge_recursive(PointerSet &seen, bool check,\n                                      Array &arr1, const Array& arr2) {\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_merge_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key(iter.first());\n    const Variant& value(iter.secondRef());\n    if (key.isNumeric()) {\n      arr1.appendWithRef(value);\n    } else if (arr1.exists(key, true)) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      auto subarr1 = v.toArray().copy();\n      php_array_merge_recursive(seen,\n                                couldRecur(v, subarr1.get()),\n                                subarr1,\n                                value.toArray());\n      v.unset(); \n      v = subarr1;\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "nd_format_time(char *buf, size_t bufsize, const char *format,\n         const struct tm *timeptr)\n{\n\tif (timeptr != NULL) {\n\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n\t\t\treturn (buf);\n\t\telse\n\t\t\treturn (\"[nd_format_time() buffer is too small]\");\n\t} else\n\t\treturn (\"[localtime() or gmtime() couldn't convert the date and time]\");\n}", "target": 0}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "static void cma_id_get(struct rdma_id_private *id_priv)\n{\n\trefcount_inc(&id_priv->refcount);\n}", "target": 0}
{"code": "exit_ext2_xattr(void)\n{\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    Buffer* buf = nullptr;\n    OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n    core::ScopedUnref scope(buf);\n    Buffer::Tuple tuple;\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(ctx->input(0).shape()),\n                errors::InvalidArgument(\"index must be scalar\"));\n    std::size_t index = ctx->input(0).scalar<int>()();\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n    OP_REQUIRES(\n        ctx, tuple.size() == (size_t)ctx->num_outputs(),\n        errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                \" vs. \", ctx->num_outputs()));\n    for (size_t i = 0; i < tuple.size(); ++i) {\n      ctx->set_output(i, tuple[i]);\n    }\n  }", "target": 0}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "raptor_rss_parse_start(raptor_parser *rdf_parser) \n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rss_parser* rss_parser = (raptor_rss_parser*)rdf_parser->context;\n  int n;\n  if(!uri)\n    return 1;\n  for(n = 0; n < RAPTOR_RSS_NAMESPACES_SIZE; n++)\n    rss_parser->nspaces_seen[n] = 'N';\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rss_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rss_parser->sax2, uri);\n  return 0;\n}", "target": 0}
{"code": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}", "target": 0}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "parse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n  if (!rb_respond_to(io, id_read)) {\n    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n  }\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 0}
{"code": "int bind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    int listening_section;\n#ifdef USE_LIBWRAP\n    libwrap_init();\n#endif \n    s_poll_init(fds, 1);\n    for(opt=service_options.next; opt; opt=opt->next) {\n        unsigned i;\n        for(i=0; i<opt->local_addr.num; ++i)\n            opt->local_fd[i]=INVALID_SOCKET;\n    }\n    listening_section=0;\n    for(opt=service_options.next; opt; opt=opt->next) {\n        opt->bound_ports=0;\n        if(opt->local_addr.num) { \n            unsigned i;\n            s_log(LOG_DEBUG, \"Binding service [%s]\", opt->servname);\n            for(i=0; i<opt->local_addr.num; ++i) {\n                SOCKET fd;\n                fd=bind_port(opt, listening_section, i);\n                opt->local_fd[i]=fd;\n                if(fd!=INVALID_SOCKET) {\n                    s_poll_add(fds, fd, 1, 0);\n                    ++opt->bound_ports;\n                }\n            }\n            if(!opt->bound_ports) {\n                s_log(LOG_ERR, \"Binding service [%s] failed\", opt->servname);\n                return 1;\n            }\n            ++listening_section;\n        } else if(opt->exec_name && opt->connect_addr.names) {\n            s_log(LOG_DEBUG, \"Skipped exec+connect service [%s]\", opt->servname);\n#ifndef OPENSSL_NO_TLSEXT\n        } else if(!opt->option.client && opt->sni) {\n            s_log(LOG_DEBUG, \"Skipped SNI slave service [%s]\", opt->servname);\n#endif\n        } else { \n            s_log(LOG_ERR, \"Invalid service [%s]\", opt->servname);\n            return 1;\n        }\n    }\n    if(listening_section<systemd_fds) {\n        s_log(LOG_ERR,\n            \"Too many listening file descriptors received from systemd, got %d\",\n            systemd_fds);\n        return 1;\n    }\n    return 0; \n}", "target": 1}
{"code": "static struct sctp_auth_bytes *sctp_auth_make_key_vector(\n\t\t\tsctp_random_param_t *random,\n\t\t\tsctp_chunks_param_t *chunks,\n\t\t\tsctp_hmac_algo_param_t *hmacs,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_auth_bytes *new;\n\t__u32\tlen;\n\t__u32\toffset = 0;\n\tlen = ntohs(random->param_hdr.length) + ntohs(hmacs->param_hdr.length);\n        if (chunks)\n\t\tlen += ntohs(chunks->param_hdr.length);\n\tnew = kmalloc(sizeof(struct sctp_auth_bytes) + len, gfp);\n\tif (!new)\n\t\treturn NULL;\n\tnew->len = len;\n\tmemcpy(new->data, random, ntohs(random->param_hdr.length));\n\toffset += ntohs(random->param_hdr.length);\n\tif (chunks) {\n\t\tmemcpy(new->data + offset, chunks,\n\t\t\tntohs(chunks->param_hdr.length));\n\t\toffset += ntohs(chunks->param_hdr.length);\n\t}\n\tmemcpy(new->data + offset, hmacs, ntohs(hmacs->param_hdr.length));\n\treturn new;\n}", "target": 0}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "TEST_F(AutoParallelTest, SimpleParallelNoDequeue) {\n  tensorflow::Scope s = tensorflow::Scope::DisabledShapeInferenceScope();\n  Output constant_a = ops::Const(s.WithOpName(\"constant_a\"), 1.0f, {1});\n  Output constant_c = ops::Const(s.WithOpName(\"constant_c\"), 1.0f, {1});\n  Output constant_b = ops::Const(s.WithOpName(\"constant_b\"), 1, {1});\n  Output var = ops::Variable(s.WithOpName(\"var\"), {1}, DT_FLOAT);\n  Output assign = ops::Assign(s.WithOpName(\"assign\"), {var}, {constant_a});\n  Output add = ops::AddN(s.WithOpName(\"add\"), {constant_a, constant_c});\n  Output learning_rate = ops::Const(s.WithOpName(\"learning_rate\"), 0.01f, {1});\n  Output apply_gradient = ops::ApplyGradientDescent(\n      s.WithOpName(\"apply_gradient\"), {var}, {learning_rate}, {add});\n  GrapplerItem item;\n  item.init_ops.push_back(\"assign\");\n  item.fetch.push_back(\"apply_gradient\");\n  item.init_ops.push_back(\"assign\");\n  TF_CHECK_OK(s.ToGraphDef(&item.graph));\n  AutoParallel parallel(2);\n  GraphDef output;\n  Status status = parallel.Optimize(nullptr, item, &output);\n  TF_EXPECT_OK(status);\n}", "target": 0}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "gss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n    return status;\n}", "target": 0}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "option_env_fd_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autoptr(GBytes) env_block = NULL;\n  gsize remaining;\n  const char *p;\n  guint64 fd;\n  gchar *endptr;\n  fd = g_ascii_strtoull (value, &endptr, 10);\n  if (endptr == NULL || *endptr != '\\0' || fd > G_MAXINT)\n    return glnx_throw (error, \"Not a valid file descriptor: %s\", value);\n  env_block = glnx_fd_readall_bytes ((int) fd, NULL, error);\n  if (env_block == NULL)\n    return FALSE;\n  p = g_bytes_get_data (env_block, &remaining);\n  while (remaining > 0)\n    {\n      size_t len = strnlen (p, remaining);\n      const char *equals;\n      g_assert (len <= remaining);\n      equals = memchr (p, '=', len);\n      if (equals == NULL || equals == p)\n        return glnx_throw (error,\n                           \"Environment variable must be given in the form VARIABLE=VALUE, not %.*s\", (int) len, p);\n      flatpak_context_set_env_var (context,\n                                   g_strndup (p, equals - p),\n                                   g_strndup (equals + 1, len - (equals - p) - 1));\n      p += len;\n      remaining -= len;\n      if (remaining > 0)\n        {\n          g_assert (*p == '\\0');\n          p += 1;\n          remaining -= 1;\n        }\n    }\n  if (fd >= 3)\n    close (fd);\n  return TRUE;\n}", "target": 0}
{"code": "static inline bool sctp_peer_needs_update(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\tif ((asoc->rwnd > asoc->a_rwnd) &&\n\t\t    ((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\n\t\t\t   (asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\n\t\t\t   asoc->pathmtu)))\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_readdir_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(xdr, rqstp, res);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\t\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    const T max_as_quantized = FloatToQuantized<T>(6.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, max_as_quantized,\n                  output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>()\n              .cwiseMax(min_as_quantized)\n              .cwiseMin(max_as_quantized)\n              .template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 3));\n    if (tflite_node->inputs->size != 2) {\n      return absl::UnimplementedError(\"MUL requires two input tensors.\");\n    }\n    auto input0 = tflite::GetInput(context, tflite_node, 0);\n    auto input1 = tflite::GetInput(context, tflite_node, 1);\n    if (input0 == nullptr || input1 == nullptr) {\n      return absl::InvalidArgumentError(\"At least one input tensor is null\");\n    }\n    if (input0->dims->size == input1->dims->size) {\n      bool first_has_smaller_dim = false;\n      bool second_has_smaller_dim = false;\n      for (int i = 0; i < input0->dims->size; ++i) {\n        if (input0->dims->data[i] < input1->dims->data[i]) {\n          first_has_smaller_dim = true;\n        }\n        if (input1->dims->data[i] < input0->dims->data[i]) {\n          second_has_smaller_dim = true;\n        }\n      }\n      if (first_has_smaller_dim && second_has_smaller_dim) {\n        return absl::UnimplementedError(\n            \"MUL requires one tensor that not less than second in all \"\n            \"dimensions.\");\n      }\n    }\n    const TfLiteMulParams* tf_options;\n    RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n    return IsActivationSupported(tf_options->activation);\n  }", "target": 0}
{"code": "dirserv_add_multiple_descriptors(const char *desc, uint8_t purpose,\n                                 const char *source,\n                                 const char **msg)\n{\n  was_router_added_t r, r_tmp;\n  const char *msg_out;\n  smartlist_t *list;\n  const char *s;\n  int n_parsed = 0;\n  time_t now = time(NULL);\n  char annotation_buf[ROUTER_ANNOTATION_BUF_LEN];\n  char time_buf[ISO_TIME_LEN+1];\n  int general = purpose == ROUTER_PURPOSE_GENERAL;\n  tor_assert(msg);\n  r=ROUTER_ADDED_SUCCESSFULLY; \n  format_iso_time(time_buf, now);\n  if (tor_snprintf(annotation_buf, sizeof(annotation_buf),\n                   \"@uploaded-at %s\\n\"\n                   \"@source %s\\n\"\n                   \"%s%s%s\", time_buf, escaped(source),\n                   !general ? \"@purpose \" : \"\",\n                   !general ? router_purpose_to_string(purpose) : \"\",\n                   !general ? \"\\n\" : \"\")<0) {\n    *msg = \"Couldn't format annotations\";\n    return -1;\n  }\n  s = desc;\n  list = smartlist_create();\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 0, 0,\n                                     annotation_buf)) {\n    SMARTLIST_FOREACH(list, routerinfo_t *, ri, {\n        msg_out = NULL;\n        tor_assert(ri->purpose == purpose);\n        r_tmp = dirserv_add_descriptor(ri, &msg_out, source);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_clear(list);\n  s = desc;\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 1, 0,\n                                     NULL)) {\n    SMARTLIST_FOREACH(list, extrainfo_t *, ei, {\n        msg_out = NULL;\n        r_tmp = dirserv_add_extrainfo(ei, &msg_out);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_free(list);\n  if (! *msg) {\n    if (!n_parsed) {\n      *msg = \"No descriptors found in your POST.\";\n      if (WRA_WAS_ADDED(r))\n        r = ROUTER_WAS_NOT_NEW;\n    } else {\n      *msg = \"(no message)\";\n    }\n  }\n  return r;\n}", "target": 0}
{"code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\tax25->state = AX25_STATE_0;\n\tax25_link_failed(ax25, reason);\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}", "target": 1}
{"code": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n  while (true) {\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}", "target": 1}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "void SFS_Params(ScriptParser *parser)\n{\n\tu32 val;\n\tif (parser->codec->LastError) return;\n\tval = gf_bs_read_int(parser->bs, 1);\n\twhile (val) {\n\t\tSFS_Expression(parser);\n\t\tif (parser->codec->LastError) return;\n\t\tval = gf_bs_read_int(parser->bs, 1);\n\t\tif(val) SFS_AddString(parser, \",\");\n\t}\n}", "target": 0}
{"code": "QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n{\n    QString wrkMsg(message);\n    QList<QList<QByteArray>> msgsToSend;\n    do {\n        int splitPos = wrkMsg.size();\n        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n        if (initialOverrun) {\n            QString splitMsg(wrkMsg);\n            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n            QList<QByteArray> splitMsgEnc;\n            int overrun = initialOverrun;\n            while (overrun) {\n                splitPos = qtbf.toPreviousBoundary();\n                if (splitPos > 0) {\n                    splitMsg = splitMsg.left(splitPos);\n                    splitMsgEnc = cmdGenerator(splitMsg);\n                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n                }\n                else {\n                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n                        splitMsg = wrkMsg;\n                        splitPos = splitMsg.size();\n                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n                        qtbf = graphemeQtbf;\n                    }\n                    else {\n                        qWarning() << \"Unexpected failure to split message!\";\n                        return msgsToSend;\n                    }\n                }\n            }\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(splitMsgEnc);\n        }\n        else{\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(initialSplitMsgEnc);\n        }\n    } while (wrkMsg.size() > 0);\n    return msgsToSend;\n}", "target": 0}
{"code": "static noinline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr)\n{\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tvoid *object = head;\n\tint cnt = 0;\n\tunsigned long uninitialized_var(flags);\n\tint ret = 0;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tslab_lock(page);\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!check_slab(s, page))\n\t\t\tgoto out;\n\t}\nnext_object:\n\tcnt++;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!free_consistency_checks(s, page, object, addr))\n\t\t\tgoto out;\n\t}\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_FREE, addr);\n\ttrace(s, page, object, 0);\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tif (object != tail) {\n\t\tobject = get_freepointer(s, object);\n\t\tgoto next_object;\n\t}\n\tret = 1;\nout:\n\tif (cnt != bulk_cnt)\n\t\tslab_err(s, page, \"Bulk freelist count(%d) invalid(%d)\\n\",\n\t\t\t bulk_cnt, cnt);\n\tslab_unlock(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tif (!ret)\n\t\tslab_fix(s, \"Object at 0x%p not freed\", object);\n\treturn ret;\n}", "target": 0}
{"code": "static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}", "target": 1}
{"code": "static void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 0}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 0}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "u64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}", "target": 0}
{"code": "SWFInput_stream_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tint need = input->offset + count - input->length;\n\tif ( need > 0 )\n\t{\n\t\tint num;\n\t\tdata->buffer =\n\t\t\t(unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\tsizeof(unsigned char) * INPUTSTREAM_INCREMENT *\n\t\t\t\t\t\t\t(((input->offset + count) / INPUTSTREAM_INCREMENT) + 1));\n\t\tnum = fread(data->buffer + input->length,\n\t\t\t\t\t\t\t\tsizeof(unsigned char), need, data->file);\n\t\tinput->length += num;\n\t}\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\tmemcpy(buffer, data->buffer + input->offset, count);\n\treturn count;\n}", "target": 0}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\treturn n;\n}", "target": 0}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "static void read_buf(FILE *fin, char *buf) {\n  if (!fgets(buf, BUFFER_SIZE, fin)) {\n    buf[0] = '\\0';\n    return;\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}", "target": 1}
{"code": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "recv_fd (const int sock)\n{\n  struct msghdr msg = {0};\n  union\n    {\n      struct cmsghdr hdr;\n      char buf[CMSG_SPACE(sizeof(int))];\n    } cmsgbuf = {0};\n  struct cmsghdr *cmsg;\n  struct iovec vec;\n  ssize_t n;\n  char ch = '\\0';\n  int fd = -1;\n  vec.iov_base = &ch;\n  vec.iov_len = 1;\n  msg.msg_iov = &vec;\n  msg.msg_iovlen = 1;\n  msg.msg_control = &cmsgbuf.buf;\n  msg.msg_controllen = sizeof (cmsgbuf.buf);\n  while ((n = recvmsg (sock, &msg, 0)) == -1 && errno == EINTR);\n  if (n != 1 || ch != 'A')\n    return -1;\n  cmsg = CMSG_FIRSTHDR (&msg);\n  if (cmsg == NULL)\n    return -1;\n  if (cmsg->cmsg_type != SCM_RIGHTS)\n    return -1;\n  memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));\n  if (fd < 0)\n    return -1;\n  return fd;\n}", "target": 0}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "bool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        if (FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName)))\n          uiMsg(UIERROR_DIRNAMEEXISTS);\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n          MakeNameUsable(DestFileName,true);\n          if (!Cmd->AbsoluteLinks && UpLinkExtracted)\n            LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}", "target": 0}
{"code": "static inline void pipe_truncate(struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tif (pipe->nrbufs) {\n\t\tsize_t off = i->iov_offset;\n\t\tint idx = i->idx;\n\t\tint nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);\n\t\tif (off) {\n\t\t\tpipe->bufs[idx].len = off - pipe->bufs[idx].offset;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tnrbufs++;\n\t\t}\n\t\twhile (pipe->nrbufs > nrbufs) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}", "target": 1}
{"code": "bool f_libxml_disable_entity_loader(bool disable ) {\n  xmlParserInputBufferCreateFilenameFunc old;\n  if (disable) {\n    old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload);\n  } else {\n    old = xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }\n  return (old == hphp_libxml_input_buffer_noload);\n}", "target": 1}
{"code": "static void rose_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct rose_sock *rose = rose_sk(sk);\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\trose_destroy_socket(sk);\n\t\t\tsock_put(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase ROSE_STATE_3:\n\t\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\n\t\t    (rose->condition & ROSE_COND_OWN_RX_BUSY)) {\n\t\t\trose->condition &= ~ROSE_COND_OWN_RX_BUSY;\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose->vl         = rose->vr;\n\t\t\trose_write_internal(sk, ROSE_RR);\n\t\t\trose_stop_timer(sk);\t\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\trose_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "elg_get_nbits (int algo, gcry_mpi_t *pkey)\n{\n  (void)algo;\n  return mpi_get_nbits (pkey[0]);\n}", "target": 0}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}", "target": 0}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}", "target": 1}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}", "target": 0}
{"code": "int ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    if (stream->headers_) {\n      ASSERT(stream->headers_->byteSize().has_value() &&\n             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n    }\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n  return 0;\n}", "target": 0}
{"code": "static void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,\n\t\t\t\t\t   int needs_unthr)\n{\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tu64 now, period = TICK_NSEC;\n\ts64 delta;\n\tif (!(ctx->nr_freq || needs_unthr))\n\t\treturn;\n\traw_spin_lock(&ctx->lock);\n\tperf_pmu_disable(ctx->pmu);\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\thwc = &event->hw;\n\t\tif (needs_unthr && hwc->interrupts == MAX_INTERRUPTS) {\n\t\t\thwc->interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t\tevent->pmu->start(event, 0);\n\t\t}\n\t\tif (!event->attr.freq || !event->attr.sample_freq)\n\t\t\tcontinue;\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\t\tnow = local64_read(&event->count);\n\t\tdelta = now - hwc->freq_count_stamp;\n\t\thwc->freq_count_stamp = now;\n\t\tif (delta > 0)\n\t\t\tperf_adjust_period(event, period, delta, false);\n\t\tevent->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);\n\t}\n\tperf_pmu_enable(ctx->pmu);\n\traw_spin_unlock(&ctx->lock);\n}", "target": 0}
{"code": "static void spl_array_update_pos(spl_array_object* intern) \n{\n\tBucket *pos = intern->pos;\n\tif (pos != NULL) {\n\t\tintern->pos_h = pos->h;\n\t}\n} ", "target": 0}
{"code": "int ssl_init(void) { \n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        \"CLI pointer\", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        \"SERVICE_OPTIONS pointer\", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        \"session authenticated\", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        \"session connect address\", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli<0 || index_ssl_ctx_opt<0 ||\n            index_session_authenticated<0 ||\n            index_session_connect_address<0) {\n        s_log(LOG_ERR, \"Application specific data initialization failed\");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, \"Failed to get default DH parameters\");\n        return 1;\n    }\n#endif \n    return 0;\n}", "target": 1}
{"code": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}", "target": 1}
{"code": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}", "target": 1}
{"code": "spawn_child()\n{\n        pid_t pid;\n        sigset_t newset;\n        sigset_t oldset;\n        sigemptyset(&newset);\n        sigaddset(&newset, SIGCHLD);\n        sigaddset(&newset, SIGTERM);\n        sigprocmask(SIG_BLOCK, &newset, &oldset);\n        pid = fork();\n        if (pid < 0) {\n                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n                goto out;\n        }\n        if (pid > 0) { \n                pid_t *pidp;\n                pidp = g_malloc(sizeof(pid_t));\n                *pidp = pid;\n                g_hash_table_insert(children, pidp, pidp);\n                goto out;\n        }\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGTERM, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\nout:\n        sigprocmask(SIG_SETMASK, &oldset, NULL);\n        return pid;\n}", "target": 0}
{"code": "static uint32_t generate_seed() {\n    uint32_t seed;\n    int done = 0;\n#if !defined(_WIN32) && defined(USE_URANDOM)\n    if (!done && seed_from_urandom(&seed) == 0)\n        done = 1;\n#endif\n#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n        done = 1;\n#endif\n    if (!done) {\n        seed_from_timestamp_and_pid(&seed);\n    }\n    if (seed == 0)\n        seed = 1;\n    return seed;\n}", "target": 0}
{"code": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n    return 0;\n}", "target": 0}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/YourPhone.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "  pin(std::string pin, std::string name) {\n    pt::ptree tree;\n    if (map_id_sess.empty()) {\n      return false;\n    }\n    if (pin.size() != 4) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\n        \"root.<xmlattr>.status_message\", \"Pin must be 4 digits, \" + std::to_string(pin.size()) + \" provided\");\n      return false;\n    }\n    if (!std::all_of(pin.begin(), pin.end(), ::isdigit)) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Pin must be numeric\");\n      return false;\n    }\n    auto &sess = std::begin(map_id_sess)->second;\n    getservercert(sess, tree, pin);\n    sess.client.name = name;\n    std::ostringstream data;\n    pt::write_xml(data, tree);\n    auto &async_response = sess.async_insert_pin.response;\n    if (async_response.has_left() && async_response.left()) {\n      async_response.left()->write(data.str());\n    }\n    else if (async_response.has_right() && async_response.right()) {\n      async_response.right()->write(data.str());\n    }\n    else {\n      return false;\n    }\n    async_response = std::decay_t<decltype(async_response.left())>();\n    return true;\n  }", "target": 0}
{"code": "int rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n        assert(fd >= 0);\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n                if (is_physical_fs(&sfs)) {\n                        _cleanup_free_ char *path = NULL;\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n        return ret;\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\treturn -EACCES;\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}", "target": 0}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "fbFetch_r8g8b8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + 3*x;\n    const CARD8 *end = pixel + 3*width;\n    while (pixel < end) {\n        CARD32 b = Fetch24(pixel) | 0xff000000;\n        pixel += 3;\n        WRITE(buffer++, b);\n    }\n}", "target": 0}
{"code": "TEST_P(LocalJwksIntegrationTest, ConnectRequestWithRegExMatch) {\n  config_helper_.prependFilter(getAuthFilterConfig(ExampleConfigWithRegEx, true));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"CONNECT\"},\n      {\":authority\", \"host.com:80\"},\n      {\"authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  if (downstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"404\", response->headers().getStatusValue());\n  } else {\n    ASSERT_TRUE(response->waitForReset());\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  }\n}", "target": 0}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\t\t\"gpr\tpc\t.16 0 0\\n\" \n\t\t\"gpr\tsp\t.16 2 0\\n\" \n\t\t\"flg\tsr\t.16 4 0\\n\" \n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t} else {\n\t\tchar *buf = (char *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn 0;\n\t\twhile (off > 0) {\n\t\t\tunsigned long n = off;\n\t\t\tif (n > PAGE_SIZE)\n\t\t\t\tn = PAGE_SIZE;\n\t\t\tif (!dump_write(file, buf, n))\n\t\t\t\treturn 0;\n\t\t\toff -= n;\n\t\t}\n\t\tfree_page((unsigned long)buf);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\tpsf->file.mode = mode ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "register_disks_device (Device *device)\n{\n  DBusConnection *connection;\n  GError *error = NULL;\n  device->priv->system_bus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n  if (device->priv->system_bus_connection == NULL)\n    {\n      if (error != NULL)\n        {\n          g_critical (\"error getting system bus: %s\", error->message);\n          g_error_free (error);\n        }\n      goto error;\n    }\n  connection = dbus_g_connection_get_connection (device->priv->system_bus_connection);\n  device->priv->object_path = compute_object_path (device->priv->native_path);\n  if (dbus_g_connection_lookup_g_object (device->priv->system_bus_connection, device->priv->object_path) != NULL)\n    {\n      g_error (\"**** HACK: Wanting to register object at path `%s' but there is already an \"\n               \"object there. This is an internal error in the daemon. Aborting.\\n\", device->priv->object_path);\n    }\n  dbus_g_connection_register_g_object (device->priv->system_bus_connection,\n                                       device->priv->object_path,\n                                       G_OBJECT (device));\n  return TRUE;\n error:\n  return FALSE;\n}", "target": 0}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "static void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tif (!mdev->sysctl)\n\t\treturn;\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "    uint64_t Image::byteSwap(uint64_t value,bool bSwap) const\n    {\n        uint64_t result = 0;\n        byte* source_value = reinterpret_cast<byte *>(&value);\n        byte* destination_value = reinterpret_cast<byte *>(&result);\n        for (int i = 0; i < 8; i++)\n            destination_value[i] = source_value[8 - i - 1];\n        return bSwap ? result : value;\n    }", "target": 0}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int __init mb2cache_init(void)\n{\n\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tBUG_ON(!mb2_entry_cache);\n\treturn 0;\n}", "target": 0}
{"code": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\te->new_chunk = ps->next_free;\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}", "target": 1}
{"code": "int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  \n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  \n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  \n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  \n      for (i = 0; i < narg1; i++)  \n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  \n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  \n      ci->top = func + 1 + fsize;  \n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  \n      return -1;\n    }\n    default: {  \n      func = luaD_tryfuncTM(L, func);  \n      narg1++;\n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\tGifByteType *extension;\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\tcmd = zend_string_alloc(2 * l, 0);\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': \n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': \n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "static inline void write_desc(struct intel_engine_execlists *execlists, u64 desc, u32 port)\n{\n\tif (execlists->ctrl_reg) {\n\t\twritel(lower_32_bits(desc), execlists->submit_reg + port * 2);\n\t\twritel(upper_32_bits(desc), execlists->submit_reg + port * 2 + 1);\n\t} else {\n\t\twritel(upper_32_bits(desc), execlists->submit_reg);\n\t\twritel(lower_32_bits(desc), execlists->submit_reg);\n\t}\n}", "target": 0}
{"code": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}", "target": 0}
{"code": "void ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  OP_REQUIRES(ctx, dtype_ != DT_STRING,\n              errors::Unimplemented(\"Sorry, DT_STRING is not currently \"\n                                    \"supported for ImmutableConstOp.\"));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  allocator.release()->set_delete_on_deallocate();\n}", "target": 0}
{"code": "void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}", "target": 1}
{"code": "  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    setUpstreamCount(1);                         \n    setUpstreamProtocol(Http::CodecType::HTTP2); \n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    acceptXdsConnection();\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }", "target": 1}
{"code": "static int websocket_send(lua_State *L) {\n    lastCFunction = __func__;\n    std::string str = checkstring(L, 1);\n    if (config.http_max_websocket_message > 0 && str.size() > (unsigned)config.http_max_websocket_message) luaL_error(L, \"Message is too large\");\n    ws_handle * ws = *(ws_handle**)lua_touserdata(L, lua_upvalueindex(1));\n    if (ws == NULL) luaL_error(L, \"attempt to use a closed file\");\n    std::lock_guard<std::mutex> lock(ws->lock);\n    if (ws->ws == NULL) return luaL_error(L, \"attempt to use a closed file\");\n    if (ws->ws->sendFrame(str.c_str(), str.size(), (int)WebSocket::FRAME_FLAG_FIN | (int)(lua_toboolean(L, 2) ? WebSocket::FRAME_BINARY : WebSocket::FRAME_TEXT)) < 1) \n        websocket_close(L);\n    return 0;\n}", "target": 1}
{"code": "rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}", "target": 0}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "static SQLRETURN qt_string_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER attr, const QString &val)\n{\n    auto encoded = toSQLTCHAR(val);\n    return SQLSetConnectAttr(handle, attr,\n                             encoded.data(),\n                             SQLINTEGER(encoded.size() * sizeof(SQLTCHAR))); \n}", "target": 0}
{"code": "learn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    } else {\n        min_len += 2 * DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    }\n    return min_len;\n}", "target": 0}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "find_script_callback(char_u *fname, void *cookie)\n{\n    int sid;\n    int error = OK;\n    int *ret_sid = cookie;\n    sid = find_script_by_name(fname);\n    if (sid < 0)\n    {\n\tsid = get_new_scriptitem(&error);\n\tif (error == OK)\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(sid);\n\t    si->sn_name = vim_strsave(fname);\n\t    si->sn_state = SN_STATE_NOT_LOADED;\n\t}\n    }\n    *ret_sid = sid;\n}", "target": 0}
{"code": "noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n}", "target": 0}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {\n    zl = zrealloc(zl,len);\n    ZIPLIST_BYTES(zl) = intrev32ifbe(len);\n    zl[len-1] = ZIP_END;\n    return zl;\n}", "target": 1}
{"code": "client_data cql_server::connection::make_client_data() const {\n    client_data cd;\n    std::tie(cd.ip, cd.port, cd.ct) = make_client_key(_client_state);\n    cd.shard_id = this_shard_id();\n    cd.protocol_version = _version;\n    cd.driver_name = _client_state.get_driver_name();\n    cd.driver_version = _client_state.get_driver_version();\n    if (const auto user_ptr = _client_state.user(); user_ptr) {\n        cd.username = user_ptr->name;\n    }\n    if (_ready) {\n        cd.connection_stage = client_connection_stage::ready;\n    } else if (_authenticating) {\n        cd.connection_stage = client_connection_stage::authenticating;\n    }\n    return cd;\n}", "target": 0}
{"code": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\targs->ast = ast->parent;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = ast->parent;\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\tcil_tree_children_destroy(parse_current->parent);\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "\tCmdResult Handle (const std::vector<std::string>& parameters, User *user)\n\t{\n\t\tif (user->registered != REG_ALL)\n\t\t{\n\t\t\tif (!cap.ext.get(user))\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tif (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tSaslAuthenticator *sasl = authExt.get(user);\n\t\t\tif (!sasl)\n\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n\t\t\telse if (sasl->SendClientMessage(parameters) == false)\t\n\t\t\t{\n\t\t\t\tsasl->AnnounceState();\n\t\t\t\tauthExt.unset(user);\n\t\t\t}\n\t\t}\n\t\treturn CMD_FAILURE;\n\t}", "target": 0}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "R_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_ansi_strip (o);\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "static void vc_uniscr_insert(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemmove(&ln[x + nr], &ln[x], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[x], ' ', nr);\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    if (input.dims() > 0) {\n      OP_REQUIRES(\n          context, input.dim_size(0) != 0,\n          errors::InvalidArgument(\"Invalid input first dimension. Found 0.\"));\n    }\n    const Tensor& dims = context->input(1);\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                          dims.dims()));\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"'dims' must have the same number of values as 'input' has \"\n              \"dimensions. 'input' has \",\n              input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"reverse is not implemented for tensors of rank > 8.\"));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n#define HANDLE_REVERSE(NDIMS)                                               \\\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }", "target": 0}
{"code": "std::string Url::DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 0}
{"code": "flatpak_escape_string (const char        *s,\n                       FlatpakEscapeFlags flags)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  gboolean did_escape = FALSE;\n  while (*s)\n    {\n      gunichar c = g_utf8_get_char_validated (s, -1);\n      if (c == (gunichar)-2 || c == (gunichar)-1)\n        {\n          append_hex_escaped_character (res, (unsigned char)*s++);\n          did_escape = TRUE;\n          continue;\n        }\n      else if (should_hex_escape (c, flags))\n        {\n          append_hex_escaped_character (res, c);\n          did_escape = TRUE;\n        }\n      else if (c == '\\\\' || (!(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE) && c == '\\''))\n        {\n          g_string_append_printf (res, \"\\\\%c\", (char) c);\n          did_escape = TRUE;\n        }\n      else\n        g_string_append_unichar (res, c);\n      s = g_utf8_find_next_char (s, NULL);\n    }\n  if (did_escape && !(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE))\n    {\n      g_string_prepend_c (res, '\\'');\n      g_string_append_c (res, '\\'');\n    }\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "uint32_t sftp_parse_handle(struct sftpjob *job, struct handleid *id) {\n  uint32_t len, rc;\n  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK || len != 8 ||\n     (rc = sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n     (rc = sftp_parse_uint32(job, &id->tag) != SSH_FX_OK))\n    return rc;\n  return SSH_FX_OK;\n}", "target": 1}
{"code": "x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ZEND_API char* ZEND_FASTCALL zend_str_tolower_copy(char *dest, const char *source, size_t length) \n{\n\tregister unsigned char *str = (unsigned char*)source;\n\tregister unsigned char *result = (unsigned char*)dest;\n\tregister unsigned char *end = str + length;\n\twhile (str < end) {\n\t\t*result++ = zend_tolower_ascii(*str++);\n\t}\n\t*result = '\\0';\n\treturn dest;\n}", "target": 0}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\tmutex_lock(&pfkey_mutex);\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tmutex_unlock(&pfkey_mutex);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "static char *create_output_name(unsigned char *fname, unsigned char *dir,\n\t\t\t int lower, int isunix, int utf8)\n{\n  unsigned char *p, *name, c, *fe, sep, slash;\n  unsigned int x;\n  sep   = (isunix) ? '/'  : '\\\\'; \n  slash = (isunix) ? '\\\\' : '/';  \n  x = strlen((char *) fname);\n  if (utf8) x *= 3;\n  if (dir) x += strlen((char *) dir);\n  if (!(name = (unsigned char *) malloc(x + 2))) {\n    fprintf(stderr, \"out of memory!\\n\");\n    return NULL;\n  }\n  *name = '\\0';\n  if (dir) {\n    strcpy((char *) name, (char *) dir);\n    strcat((char *) name, \"/\");\n  }\n  while (*fname == sep) fname++;\n  p = &name[strlen((char *)name)];\n  fe = &fname[strlen((char *)fname)];\n  if (utf8) {\n    do {\n      if (fname >= fe) {\n\tfree(name);\n\treturn NULL;\n      }\n      if ((c = *fname++) < 0x80) x = c;\n      else {\n\tif ((c >= 0xC0) && (c < 0xE0)) {\n\t  x = (c & 0x1F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse if ((c >= 0xE0) && (c < 0xF0)) {\n\t  x = (c & 0xF) << 12;\n\t  x |= (*fname++ & 0x3F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse x = '?';\n      }\n      if      (x == sep)   x = '/';\n      else if (x == slash) x = '\\\\';\n      else if (lower)      x = (unsigned int) tolower((int) x);\n      if (x < 0x80) {\n\t*p++ = (unsigned char) x;\n      }\n      else if (x < 0x800) {\n\t*p++ = 0xC0 | (x >> 6);   \n\t*p++ = 0x80 | (x & 0x3F);\n      }\n      else {\n\t*p++ = 0xE0 | (x >> 12);\n\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n\t*p++ = 0x80 | (x & 0x3F);\n      }\n    } while (x);\n  }\n  else {\n    do {\n      c = *fname++;\n      if      (c == sep)   c = '/';\n      else if (c == slash) c = '\\\\';\n      else if (lower)      c = (unsigned char) tolower((int) c);\n    } while ((*p++ = c));\n  }\n  return (char *) name;\n}", "target": 1}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "int yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      0,\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}", "target": 0}
{"code": "static int efi_capsule_flush(struct file *file, fl_owner_t id)\n{\n\tint ret = 0;\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t\tret = -ECANCELED;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int del_balance_item(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_TEMPORARY_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}", "target": 0}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n\t\t\t\t\t\t  struct mb2_cache_entry *entry)\n{\n\treturn __entry_find(cache, entry, entry->e_key);\n}", "target": 0}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}", "target": 0}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "static void hog_exit(void)\n{\n\tif (suspend_supported)\n\t\tsuspend_exit();\n\tbtd_profile_unregister(&hog_profile);\n}", "target": 0}
{"code": "int infra_wait_limit_allowed(struct infra_cache* infra, struct comm_reply* rep,\n\tint cookie_valid, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn 1;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 0);\n\tif(entry) {\n\t\trbtree_type* tree;\n\t\tstruct wait_limit_netblock_info* w;\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tint mesh_wait = d->mesh_wait;\n\t\tlock_rw_unlock(&entry->lock);\n\t\tif(cookie_valid)\n\t\t\ttree = &infra->wait_limits_cookie_netblock;\n\t\telse\ttree = &infra->wait_limits_netblock;\n\t\tw = (struct wait_limit_netblock_info*)addr_tree_lookup(tree,\n\t\t\t&rep->client_addr, rep->client_addrlen);\n\t\tif(w) {\n\t\t\tif(w->limit != -1 && mesh_wait > w->limit)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif(mesh_wait > (cookie_valid?cfg->wait_limit_cookie:\n\t\t\t\tcfg->wait_limit))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ctx->ref_tkw == tkw) ctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static tjhandle _tjInitDecompress(tjinstance *this)\n{\n\tstatic unsigned char buffer[1];\n\tthis->dinfo.err=jpeg_std_error(&this->jerr.pub);\n\tthis->jerr.pub.error_exit=my_error_exit;\n\tthis->jerr.pub.output_message=my_output_message;\n\tthis->jerr.emit_message=this->jerr.pub.emit_message;\n\tthis->jerr.pub.emit_message=my_emit_message;\n\tif(setjmp(this->jerr.setjmp_buffer))\n\t{\n\t\tif(this) free(this);\n\t\treturn NULL;\n\t}\n\tjpeg_create_decompress(&this->dinfo);\n\tjpeg_mem_src_tj(&this->dinfo, buffer, 1);\n\tthis->init|=DECOMPRESS;\n\treturn (tjhandle)this;\n}", "target": 0}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "int CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n    if (script[0] == 0x1b)\n        abort();\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}", "target": 0}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "static inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tint totlen = NLA_ALIGN(nla->nla_len);\n\t*remaining -= totlen;\n\treturn (struct nlattr *) ((char *) nla + totlen);\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "backref_match_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int ignore_case, int case_fold_flag,\n                              int nest, int mem_num, MemNumType* memp,\n                              UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  StackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (IS_NOT_NULL(pend)) {\n            if (pend - pstart > send - *s) return 0; \n            p  = pstart;\n            ss = *s;\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; \n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; \n              }\n            }\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "void RtmpProtocol::reset() {\n    _chunk_size_in = DEFAULT_CHUNK_LEN;\n    _chunk_size_out = DEFAULT_CHUNK_LEN;\n    _bytes_sent = 0;\n    _bytes_sent_last = 0;\n    _windows_size = 0;\n    _bandwidth = 2500000;\n    _band_limit_type = 2;\n    _map_chunk_data.clear();\n    _now_stream_index = 0;\n    _now_chunk_id = 0;\n    _send_req_id = 0;\n    HttpRequestSplitter::reset();\n    _stream_index = STREAM_CONTROL;\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C0C1(data, len);\n    };\n}", "target": 0}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p)) {\n\t\t\t\twhile (last_dest->mnt_master != p) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tif (!peers(n, last_dest)) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn 0;\n}", "target": 1}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_readable();\n}", "target": 1}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "fu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}", "target": 1}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,\n\t                                     PathLength / sizeof(WCHAR), irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}", "target": 1}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n\tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        windowprocs.win_wait_synch = def_wait_synch;\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}", "target": 1}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "static int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\tBT_DBG(\"sk %p\", sk);\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\treturn ptr - data;\n}", "target": 1}
{"code": "int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,\n        sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 0}
{"code": "static void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\t\tif (!disk)\n\t\t\tcontinue;\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}", "target": 0}
{"code": "static void *CFRdbLoad(RedisModuleIO *io, int encver) {\n    if (encver > CF_MIN_EXPANSION_VERSION) {\n        return NULL;\n    }\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    cf->numFilters = RedisModule_LoadUnsigned(io);\n    cf->numBuckets = RedisModule_LoadUnsigned(io);\n    cf->numItems = RedisModule_LoadUnsigned(io);\n    if (encver < CF_MIN_EXPANSION_VERSION) { \n        cf->numDeletes = 0;                  \n        cf->bucketSize = CF_DEFAULT_BUCKETSIZE;\n        cf->maxIterations = CF_MAX_ITERATIONS;\n        cf->expansion = CF_DEFAULT_EXPANSION;\n    } else {\n        cf->numDeletes = RedisModule_LoadUnsigned(io);\n        cf->bucketSize = RedisModule_LoadUnsigned(io);\n        cf->maxIterations = RedisModule_LoadUnsigned(io);\n        cf->expansion = RedisModule_LoadUnsigned(io);\n    }\n    cf->filters = RedisModule_Calloc(cf->numFilters, sizeof(*cf->filters));\n    for (size_t ii = 0, exp = 1; ii < cf->numFilters; ++ii, exp *= cf->expansion) {\n        cf->filters[ii].bucketSize = cf->bucketSize;\n        if (encver < CF_MIN_EXPANSION_VERSION) {\n            cf->filters[ii].numBuckets = cf->numBuckets;\n        } else {\n            cf->filters[ii].numBuckets = RedisModule_LoadUnsigned(io);\n        }\n        size_t lenDummy = 0;\n        cf->filters[ii].data = (MyCuckooBucket *)RedisModule_LoadStringBuffer(io, &lenDummy);\n        assert(cf->filters[ii].data != NULL && lenDummy == cf->filters[ii].bucketSize *\n                                                               cf->filters[ii].numBuckets *\n                                                               sizeof(*cf->filters[ii].data));\n    }\n    return cf;\n}", "target": 1}
{"code": "void options_apply() { \n    unsigned num=0;\n    SERVICE_OPTIONS *section;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    memcpy(&global_options, &new_global_options, sizeof(GLOBAL_OPTIONS));\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    for(section=new_service_options.next; section; section=section->next)\n        section->section_number=num++;\n    memcpy(&service_options, &new_service_options, sizeof(SERVICE_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    number_of_sections=num;\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int sqfs_disk_read(__u32 block, __u32 nr_blocks, void *buf)\n{\n\tulong ret;\n\tif (!ctxt.cur_dev)\n\t\treturn -1;\n\tret = blk_dread(ctxt.cur_dev, ctxt.cur_part_info.start + block,\n\t\t\tnr_blocks, buf);\n\tif (ret != nr_blocks)\n\t\treturn -1;\n\treturn ret;\n}", "target": 0}
{"code": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}", "target": 1}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "  void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,\n                                      const int c, const int kx, const int ky,\n                                      const int sx, const int sy,\n                                      const string& data_format,\n                                      const string& padding) {\n    OpContext op_context;\n    int ho;\n    int wo;\n    if (data_format == \"NHWC\") {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, h, w, c}, {1, kx, ky, 1},\n                                     {1, sx, sy, 1}, \"NHWC\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(1).size();\n      wo = op_context.op_info.outputs(0).shape().dim(2).size();\n    } else {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, c, h, w}, {1, 1, kx, ky},\n                                     {1, 1, sx, sy}, \"NCHW\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(2).size();\n      wo = op_context.op_info.outputs(0).shape().dim(3).size();\n    }\n    bool found_unknown_shapes;\n    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n    Padding padding_enum;\n    if (padding == \"VALID\") {\n      padding_enum = Padding::VALID;\n    } else {\n      padding_enum = Padding::SAME;\n    }\n    EXPECT_EQ(n, dims.batch);\n    EXPECT_EQ(h, dims.ix);\n    EXPECT_EQ(w, dims.iy);\n    EXPECT_EQ(c, dims.iz);\n    EXPECT_EQ(kx, dims.kx);\n    EXPECT_EQ(ky, dims.ky);\n    EXPECT_EQ(sx, dims.sx);\n    EXPECT_EQ(sy, dims.sy);\n    EXPECT_EQ(ho, dims.ox);\n    EXPECT_EQ(wo, dims.oy);\n    EXPECT_EQ(c, dims.oz);\n    EXPECT_EQ(padding_enum, dims.padding);\n  }", "target": 1}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\tnego->state = NEGO_STATE_FAIL;\n}", "target": 1}
{"code": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "static int read_probe(const AVProbeData *p)\n{\n    int cnt = 0;\n    for (int i = 0; i < p->buf_size; i++)\n        cnt += !!isansicode(p->buf[i]);\n    return (cnt * 100LL / p->buf_size) * (cnt > 400) *\n        !!av_match_ext(p->filename, tty_extensions);\n}", "target": 0}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}", "target": 0}
{"code": "PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n    if ((sizeof(pj_off_t) > sizeof(long)) &&\n        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n    {\n        return PJ_ENOTSUP;\n    }\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "Network::FilterStatus Context::onNetworkNewConnection() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  if (!wasm_->onNewConnection_) {\n    return Network::FilterStatus::Continue;\n  }\n  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::StopIteration;\n}", "target": 0}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "ModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"XWD\",\"XWD\",\"X Windows system window dump (color)\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}", "target": 1}
{"code": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n    type = crm_element_value(update_msg, F_SUBTYPE);\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1}
{"code": "inline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }", "target": 0}
{"code": "start_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  upsample->spare_full = FALSE;\n  upsample->rows_to_go = cinfo->output_height;\n}", "target": 1}
{"code": "p_string(FILE* f, ptrdiff_t len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}", "target": 0}
{"code": "static __be16 cma_port(const struct sockaddr *addr)\n{\n\tstruct sockaddr_ib *sib;\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *) addr)->sin_port;\n\tcase AF_INET6:\n\t\treturn ((struct sockaddr_in6 *) addr)->sin6_port;\n\tcase AF_IB:\n\t\tsib = (struct sockaddr_ib *) addr;\n\t\treturn htons((u16) (be64_to_cpu(sib->sib_sid) &\n\t\t\t\t    be64_to_cpu(sib->sib_sid_mask)));\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "void j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){\n                fprintf(out_stream, \"Wrong flag\\n\");\n                return;\n        }\n        if (flag & OPJ_IMG_INFO){\n                if (p_j2k->m_private_image)\n                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n        if (flag & OPJ_J2K_MH_INFO){\n                opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TCH_INFO){\n          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n          OPJ_UINT32 i;\n          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n          for (i=0;i<l_nb_tiles;++i) {\n            opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n            ++l_tcp;\n          }\n        }\n        if (flag & OPJ_J2K_TH_INFO){\n        }\n        if (flag & OPJ_J2K_MH_IND){\n                opj_j2k_dump_MH_index(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TH_IND){\n        }\n}", "target": 0}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 0}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "uint64_t ldq_be_phys(AddressSpace *as, hwaddr addr)\n{\n    return address_space_ldq_be(as, addr, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n\t\t\t      int nsops)\n{\n\tint locknum;\n again:\n\tif (nsops == 1 && !sma->complex_count) {\n\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n\t\tspin_lock(&sem->lock);\n\t\tif (unlikely(sma->complex_count)) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tgoto lock_array;\n\t\t}\n\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n\t\t\tgoto again;\n\t\t}\n\t\tlocknum = sops->sem_num;\n\t} else {\n\t\tint i;\n lock_array:\n\t\tspin_lock(&sma->sem_perm.lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem *sem = sma->sem_base + i;\n\t\t\tspin_unlock_wait(&sem->lock);\n\t\t}\n\t\tlocknum = -1;\n\t}\n\treturn locknum;\n}", "target": 0}
{"code": "init_resources(X509 *x509, enum rpki_policy policy, enum cert_type type,\n    struct resources **_result)\n{\n\tstruct resources *result;\n\tint error;\n\tresult = resources_create(false);\n\tif (result == NULL)\n\t\treturn pr_enomem();\n\tresources_set_policy(result, policy);\n\terror = certificate_get_resources(x509, result, type);\n\tif (error)\n\t\tgoto fail;\n\tif (type == TA && resources_empty(result)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto fail;\n\t}\n\t*_result = result;\n\treturn 0;\nfail:\n\tresources_destroy(result);\n\treturn error;\n}", "target": 0}
{"code": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  \n  struct mg_str *cl;\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  \n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  return req_len;\n}", "target": 1}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    char buf[256];\n    int i;\n    int e;\n    int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n    char last;\n    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n        if (show_bits(gb, 23) == 0)\n            break;\n        buf[i] = get_bits(gb, 8);\n    }\n    buf[i] = 0;\n    e = sscanf(buf, \"DivX%dBuild%d%c\", &ver, &build, &last);\n    if (e < 2)\n        e = sscanf(buf, \"DivX%db%d%c\", &ver, &build, &last);\n    if (e >= 2) {\n        ctx->divx_version = ver;\n        ctx->divx_build   = build;\n        s->divx_packed  = e == 3 && last == 'p';\n        if (s->divx_packed && !ctx->showed_packed_warning) {\n            av_log(s->avctx, AV_LOG_INFO, \"Video uses a non-standard and \"\n                   \"wasteful way to store B-frames ('packed B-frames'). \"\n                   \"Consider using a tool like VirtualDub or avidemux to fix it.\\n\");\n            ctx->showed_packed_warning = 1;\n        }\n    }\n    e = sscanf(buf, \"FFmpe%*[^b]b%d\", &build) + 3;\n    if (e != 4)\n        e = sscanf(buf, \"FFmpeg v%d.%d.%d / libavcodec build: %d\", &ver, &ver2, &ver3, &build);\n    if (e != 4) {\n        e = sscanf(buf, \"Lavc%d.%d.%d\", &ver, &ver2, &ver3) + 1;\n        if (e > 1)\n            build = (ver << 16) + (ver2 << 8) + ver3;\n    }\n    if (e != 4) {\n        if (strcmp(buf, \"ffmpeg\") == 0)\n            ctx->lavc_build = 4600;\n    }\n    if (e == 4)\n        ctx->lavc_build = build;\n    e = sscanf(buf, \"XviD%d\", &build);\n    if (e == 1)\n        ctx->xvid_build = build;\n    return 0;\n}", "target": 0}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "static void ssh2_send_newkeys(PTInstVar pvar)\n{\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\n\tfinish_send_packet(pvar);\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\n\tssh2_set_newkeys(pvar, MODE_OUT);\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\n\t}\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\n\tenable_send_compression(pvar);\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.sender_sequence_number = 0;\n\t}\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn;\n}", "target": 0}
{"code": "static gg_action_t gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tchar *req, *auth;\n\tsize_t req_len;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tif (sess->connect_index > 1 || sess->connect_port[sess->connect_index] == 0) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_CONNECTING;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tauth = gg_proxy_auth();\n\treq = gg_saprintf(\"CONNECT %s:%d HTTP/1.0\\r\\n%s\\r\\n\", sess->connect_host, sess->connect_port[sess->connect_index], (auth) ? auth : \"\");\n\tfree(auth);\n\tsess->connect_index++;\n\tif (req == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\treq_len = strlen(req);\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tres = send(sess->fd, req, req_len, 0);\n\tfree(req);\n\tif (res == -1 && errno != EINTR && errno != EAGAIN) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tif ((size_t) res < req_len) {\n\t\tsess->state = alt_state;\n\t\tsess->check = GG_CHECK_WRITE;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t} else {\n\t\tsess->state = next_state;\n\t\tsess->check = GG_CHECK_READ;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t}\n\treturn GG_ACTION_WAIT;\n}", "target": 0}
{"code": "void dns_server_deinit(void)\n{\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n}", "target": 0}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "auth_line_is_begin (guint8 *line)\n{\n  guint8 next_char;\n  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n    return FALSE;\n  next_char = line[strlen (AUTH_BEGIN)];\n  return (next_char == 0 ||\n          next_char == ' ' ||\n          next_char == '\\t');\n}", "target": 0}
{"code": "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock->sk, *other;\n\tunsigned int mask, writable;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (sk->sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\tif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\twritable = unix_writable(sk);\n\tother = unix_peer_get(sk);\n\tif (other) {\n\t\tif (unix_peer(other) != sk) {\n\t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\n\t\t\tif (unix_recvq_full(other))\n\t\t\t\twritable = 0;\n\t\t}\n\t\tsock_put(other);\n\t}\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\treturn mask;\n}", "target": 1}
{"code": "static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    DH *dh_clnt = NULL;\n    const BIGNUM *pub_key;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    dh_clnt = EVP_PKEY_get0_DH(ckey);\n    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ckey);\n        return 0;\n    }\n    DH_get0_key(dh_clnt, &pub_key, NULL);\n    *len = BN_num_bytes(pub_key);\n    s2n(*len, *p);\n    BN_bn2bin(pub_key, *p);\n    *len += 2;\n    EVP_PKEY_free(ckey);\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "static int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)\n{\n\treturn usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t\tvalue, reg, NULL, 0);\n}", "target": 0}
{"code": "static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\tused = pvc_is_used(pvc);\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}", "target": 0}
{"code": "bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)\n{\n  bl = base_bl;\n  CephXAuthorize msg;\n  msg.nonce = nonce;\n  auto p = challenge.begin();\n  if (!p.end()) {\n    std::string error;\n    CephXAuthorizeChallenge ch;\n    decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);\n    if (!error.empty()) {\n      ldout(cct, 0) << \"failed to decrypt challenge (\" << challenge.length() << \" bytes): \"\n\t\t    << error << dendl;\n      return false;\n    }\n    msg.have_challenge = true;\n    msg.server_challenge_plus_one = ch.server_challenge + 1;\n  }\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, bl, error)) {\n    ldout(cct, 0) << __func__ << \" failed to encrypt authorizer: \" << error << dendl;\n    return false;\n  }\n  return true;\n}", "target": 0}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n    memset(&temp, 0u, sizeof(struct filter_node));\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}", "target": 1}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}", "target": 0}
{"code": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}", "target": 1}
{"code": "unset_nonblock(int fd)\n{\n\tint val;\n\tval = fcntl(fd, F_GETFL);\n\tif (val == -1) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_remove_all(&group->inotify_data.idr);\n\tidr_destroy(&group->inotify_data.idr);\n\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\tfree_uid(group->inotify_data.user);\n}", "target": 0}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1, t2, r;\n  unsigned int nbits = mpi_get_nbits (skey->p);\n  mpi_normalize (a);\n  mpi_normalize (b);\n  t1 = mpi_snew (nbits);\n#ifdef USE_BLINDING\n  t2 = mpi_snew (nbits);\n  r  = mpi_new (nbits);\n  _gcry_mpi_randomize (r, nbits, GCRY_WEAK_RANDOM);\n  mpi_powm (t1, r, skey->x, skey->p);\n  mpi_mulm (t2, a, r, skey->p);\n  mpi_powm (t2, t2, skey->x, skey->p);\n  mpi_invm (t2, t2, skey->p);\n  mpi_mulm (t1, t1, t2, skey->p);\n  mpi_free (r);\n  mpi_free (t2);\n#else \n  mpi_powm (t1, a, skey->x, skey->p);\n  mpi_invm (t1, t1, skey->p);\n#endif \n  mpi_mulm (output, b, t1, skey->p);\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free (t1);\n}", "target": 0}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\treturn sysfs_emit(buf, \"%lu\\n\", nr_huge_pages);\n}", "target": 0}
{"code": "const int& getActiveId(const void* object, const StructInfo& info) {\n  return *reinterpret_cast<const int*>(\n      static_cast<const char*>(object) + info.unionExt->unionTypeOffset);\n}", "target": 0}
{"code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)->type;\n  switch (output_type) {  \n    case kTfLiteFloat32:\n      EvalUnquantized<float>(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized<int32_t>(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized<int8_t>(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized<int64_t>(context, node);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Op Concatenation does not currently support Type '%s'.\",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static RBinWasmCustomNameEntry *parse_custom_name_entry(RBinWasmObj *bin, ut64 bound) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmCustomNameEntry *cust = R_NEW0 (RBinWasmCustomNameEntry);\n\tif (!cust) {\n\t\treturn NULL;\n\t}\n\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\tsize_t start = r_buf_tell (b);\n\tif (!consume_u7_r (b, bound, &cust->type)) {\n\t\tgoto beach;\n\t};\n\tif (!consume_u32_r (b, bound, &cust->size)) {\n\t\tgoto beach;\n\t};\n\tswitch (cust->type) {\n\tcase R_BIN_WASM_NAMETYPE_Module:\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &cust->mod_name)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Function:\n\t\tcust->func = R_NEW0 (RBinWasmCustomNameFunctionNames);\n\t\tif (!cust->func) {\n\t\t\tgoto beach;\n\t\t}\n\t\tcust->func->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!cust->func->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, cust->func->names, &cust->func->count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Local:\n\t\tcust->local = parse_custom_names_local (b, bound);\n\t\tif (!cust->local) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_WARN (\"[wasm] Halting custom name section parsing at unknown type 0x%x offset 0x%\" PFMTSZx \"\\n\", cust->type, start);\n\t\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\t\tgoto beach;\n\t}\n\treturn cust;\nbeach:\n\twasm_custom_name_free (cust);\n\treturn NULL;\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static void set_cpu_rq_start_time(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\trq->age_stamp = sched_clock_cpu(cpu);\n}", "target": 0}
{"code": "bool ArcMemory::Read(void *Data,size_t Size,size_t &Result)\n{\n  if (!Loaded)\n    return false;\n  Result=(size_t)Min(Size,ArcData.Size()-SeekPos);\n  memcpy(Data,&ArcData[(size_t)SeekPos],Result);\n  SeekPos+=Result;\n  return true;\n}", "target": 0}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, unsigned char *scbs,\n\t\t  int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb = scbs[IASECC_ACLS_CHV_VERIFY];\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,scb:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t       scb);\n\tif (scb & IASECC_SCB_METHOD_SM) {\n\t\trv = iasecc_sm_pin_verify(card, scb & IASECC_SCB_METHOD_MASK_REF, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "static uint16_t nvme_get_mgmt_zone_slba_idx(NvmeNamespace *ns, NvmeCmd *c,\n                                            uint64_t *slba, uint32_t *zone_idx)\n{\n    uint32_t dw10 = le32_to_cpu(c->cdw10);\n    uint32_t dw11 = le32_to_cpu(c->cdw11);\n    if (!ns->params.zoned) {\n        trace_pci_nvme_err_invalid_opc(c->opcode);\n        return NVME_INVALID_OPCODE | NVME_DNR;\n    }\n    *slba = ((uint64_t)dw11) << 32 | dw10;\n    if (unlikely(*slba >= ns->id_ns.nsze)) {\n        trace_pci_nvme_err_invalid_lba_range(*slba, 0, ns->id_ns.nsze);\n        *slba = 0;\n        return NVME_LBA_RANGE | NVME_DNR;\n    }\n    *zone_idx = nvme_zone_idx(ns, *slba);\n    assert(*zone_idx < ns->num_zones);\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "static void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls\" ) );\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n    sender = ( from == SSL_IS_CLIENT )\n             ? (char *) \"client finished\"\n             : (char *) \"server finished\";\n    md5_finish(  &md5, padbuf );\n    sha1_finish( &sha1, padbuf + 16 );\n    ssl->handshake->tls_prf( session->master, 48, sender,\n                             padbuf, 36, buf, len );\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}", "target": 0}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\tmsg->msg_namelen = sizeof(*sax);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "set_lenIV(const char* line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit((unsigned char) p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    PartialTensorShape element_shape;\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));\n    OP_REQUIRES(\n        c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"The num_elements to reserve must be a tensor size 1, but got \",\n            c->input(1).shape()));\n    int32_t num_elements = c->input(1).scalar<int32>()();\n    OP_REQUIRES(c, num_elements >= 0,\n                errors::InvalidArgument(\"The num_elements to reserve must be a \"\n                                        \"non negative number, but got \",\n                                        num_elements));\n    TensorList output;\n    output.element_shape = element_shape;\n    output.element_dtype = element_dtype_;\n    output.tensors().resize(num_elements, Tensor(DT_INVALID));\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    result->scalar<Variant>()() = std::move(output);\n  }", "target": 0}
{"code": "void WidgetUtils::openUrlByDesktop(const QUrl &p_url)\n{\n    const auto scheme = p_url.scheme();\n    if (scheme != \"http\" && scheme != \"https\") {\n        int ret = MessageBoxHelper::questionYesNo(MessageBoxHelper::Warning,\n                                                  MainWindow::tr(\"Are you sure to open link (%1)?\").arg(p_url.toString()),\n                                                  MainWindow::tr(\"Malicious link might do harm to your device.\"),\n                                                  QString(),\n                                                  nullptr);\n        if (ret == QMessageBox::No) {\n            return;\n        }\n    }\n    QDesktopServices::openUrl(p_url);\n}", "target": 0}
{"code": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}", "target": 0}
{"code": "int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif = NULL;\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\treturn SEPOL_OK;\nexit:\n\treturn rc;\n}", "target": 0}
{"code": "gss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n        return(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "assegment_dup_all (struct assegment *seg)\n{\n  struct assegment *new = NULL;\n  struct assegment *head = NULL;\n  while (seg)\n    {\n      if (head)\n        {\n          new->next = assegment_dup (seg);\n          new = new->next;\n        }\n      else\n        head = new = assegment_dup (seg);\n      seg = seg->next;\n    }\n  return head;\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "int create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    krb5_error_code ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    int i;\n    hist->key_data = k5calloc(n_key_data, sizeof(krb5_key_data), &ret);\n    if (hist->key_data == NULL)\n        return ret;\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n        krb5_free_keyblock_contents(context, &key);\n    }\n    hist->n_key_data = n_key_data;\n    return 0;\n}", "target": 0}
{"code": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n    return 0;\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n      return 0;\n    text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n      return 0;\n  }\n  *escaped_char = escaped_char_value(text);\n  return 1;", "target": 1}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    luaK_exp2anyregup(fs, var);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 0}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\",\", 1);\n  }\n  header.append(data.data(), data.size());\n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid);\n\tif (!r_sys_mkdirp (dir)) {\n\t\tfree (dir);\n\t\treturn false;\n\t}\n\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n\tint len;\n\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n\tfree (url);\n\tif (!len || R_STR_ISEMPTY (file_buf)) {\n\t\tfree (dir);\n\t\tfree (file_buf);\n\t\treturn false;\n\t}\n\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n\tFILE *f = fopen (path, \"wb\");\n\tif (f) {\n\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n\t\tfclose (f);\n\t}\n\tfree (dir);\n\tfree (path);\n\tfree (file_buf);\n\treturn true;\n}", "target": 0}
{"code": "hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n  if (wsctx->readlen > 0) {\n    if (wsctx->readlen > len) {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n  }\n  return nextState;\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "DLLIMPORT int cfg_parse(cfg_t *cfg, const char *filename)\n{\n\tint ret;\n\tchar *fn;\n\tFILE *fp;\n\tif (!cfg || !filename) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FILE_ERROR;\n\t}\n\tif (cfg->path)\n\t\tfn = cfg_searchpath(cfg->path, filename);\n\telse\n\t\tfn = cfg_tilde_expand(filename);\n\tif (!fn)\n\t\treturn CFG_FILE_ERROR;\n\tfree(cfg->filename);\n\tcfg->filename = fn;\n\tfp = fopen(cfg->filename, \"r\");\n\tif (!fp)\n\t\treturn CFG_FILE_ERROR;\n\tret = cfg_parse_fp(cfg, fp);\n\tfclose(fp);\n\treturn ret;\n}", "target": 0}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            if (cmd->pool == cmd->temp_pool) {\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 0}
{"code": "int main(int argc, char **argv) {\n  mlir::registerAsmPrinterCLOptions();\n  tensorflow::InitMlir y(&argc, &argv);\n  return failed(\n      mlir::mlirTranslateMain(argc, argv, \"Graph(Def)<->TFG Translation Tool\"));\n}", "target": 0}
{"code": "int nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\t__nfc_llcp_recv(local, skb);\n\tnfc_llcp_local_put(local);\n\treturn 0;\n}", "target": 0}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 0}
{"code": "static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n\t\t}", "target": 1}
{"code": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 0}
{"code": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tnew_ns->mounts++;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}", "target": 0}
{"code": "  SPLITS_TYPE RangeSize(T start, T limit, T delta) {\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      return 0;\n    }\n    return (std::is_integral<T>::value\n                ? ((std::abs(limit - start) + std::abs(delta) - 1) /\n                   std::abs(delta))\n                : std::ceil(std::abs((limit - start) / delta)));\n  }", "target": 1}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "static void print_vtable(vtableEntry* start, int len, outputStream* st) {\n  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n}", "target": 0}
{"code": "int options_cmdline(char *arg1, char *arg2) {\n    char *name;\n    CONF_TYPE type;\n#ifdef USE_WIN32\n    (void)arg2; \n#endif\n    if(!arg1) {\n        name=\n#ifdef CONFDIR\n            CONFDIR\n#ifdef USE_WIN32\n            \"\\\\\"\n#else\n            \"/\"\n#endif\n#endif\n            \"stunnel.conf\";\n        type=CONF_FILE;\n    } else if(!strcasecmp(arg1, \"-help\")) {\n        parse_global_option(CMD_PRINT_HELP, NULL, NULL);\n        parse_service_option(CMD_PRINT_HELP, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-version\")) {\n        parse_global_option(CMD_PRINT_DEFAULTS, NULL, NULL);\n        parse_service_option(CMD_PRINT_DEFAULTS, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-sockets\")) {\n        socket_options_print();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-options\")) {\n        print_ssl_options();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else\n#ifndef USE_WIN32\n    if(!strcasecmp(arg1, \"-fd\")) {\n        if(!arg2) {\n            s_log(LOG_ERR, \"No file descriptor specified\");\n            print_syntax();\n            return 1;\n        }\n        name=arg2;\n        type=CONF_FD;\n    } else\n#endif\n    {\n        name=arg1;\n        type=CONF_FILE;\n    }\n    if(type==CONF_FILE) {\n#ifdef HAVE_REALPATH\n        char *real_path=NULL;\n#ifdef MAXPATHLEN\n        real_path=malloc(MAXPATHLEN);\n#endif\n        real_path=realpath(name, real_path);\n        if(!real_path) {\n            s_log(LOG_ERR, \"Invalid configuration file name \\\"%s\\\"\", name);\n            ioerror(\"realpath\");\n            return 1;\n        }\n        configuration_file=str_dup(real_path);\n        free(real_path);\n#else\n        configuration_file=str_dup(name);\n#endif\n#ifndef USE_WIN32\n    } else if(type==CONF_FD) {\n        configuration_file=str_dup(name);\n#endif\n    }\n    return options_parse(type);\n}", "target": 1}
{"code": "static void bio_map_kern_endio(struct bio *bio)\n{\n\tbio_put(bio);\n}", "target": 0}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "static ssize_t compress(zckCtx *zck, zckComp *comp, const char *src,\n                        const size_t src_size, char **dst, size_t *dst_size,\n                        bool use_dict) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, dst);\n    ALLOCD_INT(zck, src);\n    ALLOCD_INT(zck, dst_size);\n    ALLOCD_INT(zck, comp);\n    if((comp->dc_data_size > comp->dc_data_size + src_size) ||\n       (src_size > comp->dc_data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading decompressed data\");\n        return false;\n    }\n    comp->dc_data = zrealloc(comp->dc_data, comp->dc_data_size + src_size);\n    if (!comp->dc_data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return -1;\n    }\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    *dst = NULL;\n    *dst_size = 0;\n    return 0;\n}", "target": 0}
{"code": "static int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\ttrack->index[i] = ind;\n}", "target": 1}
{"code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n    if (!s->current_req) {\n        return;\n    }\n    if (s->async_len == 0) {\n        return;\n    }\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "static u64 gen_hi_max(struct tnum var)\n{\n\treturn (var.value | var.mask) & ~0xffffffffULL;\n}", "target": 0}
{"code": "struct tcp_sock_t *tcp6_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv6: callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"Ipv6 socket open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_loopback;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv6 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv6 listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  if (!callable) {\n    return false;\n  }\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    cb->lazyCompile(runtime);\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n  return false;\n}", "target": 1}
{"code": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\tif(!context) return MOSQ_ERR_INVAL;\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\treturn;\n}", "target": 1}
{"code": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\t*s_ops = &ops;\n\tcomp = lookup_compressor(\"gzip\");\n\tif(sBlk_3->s_minor == 0)\n\t\tneeds_sorting = TRUE;\n\treturn TRUE;\n}", "target": 0}
{"code": "  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n    const TensorShape& perm_shape = permutation_indices.shape();\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n    }\n  }", "target": 1}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "static int CFScanDump_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx);\n    if (argc != 3) {\n        return RedisModule_WrongArity(ctx);\n    }\n    long long pos;\n    if (RedisModule_StringToLongLong(argv[2], &pos) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx, \"Invalid position\");\n    }\n    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);\n    CuckooFilter *cf;\n    int status = cfGetFilter(key, &cf);\n    if (status != SB_OK) {\n        return RedisModule_ReplyWithError(ctx, statusStrerror(status));\n    }\n    RedisModule_ReplyWithArray(ctx, 2);\n    if (!cf->numItems) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n        return REDISMODULE_OK;\n    }\n    if (pos == 0) {\n        CFHeader header;\n        fillCFHeader(&header, cf);\n        RedisModule_ReplyWithLongLong(ctx, 1);\n        RedisModule_ReplyWithStringBuffer(ctx, (const char *)&header, sizeof header);\n        return REDISMODULE_OK;\n    }\n    size_t chunkLen = 0;\n    const char *chunk = CF_GetEncodedChunk(cf, &pos, &chunkLen, MAX_SCANDUMP_SIZE);\n    if (chunk == NULL) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n    } else {\n        RedisModule_ReplyWithLongLong(ctx, pos);\n        RedisModule_ReplyWithStringBuffer(ctx, chunk, chunkLen);\n    }\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "        AuthenticationStatus get_auth_status() const\n        {\n            std::lock_guard<std::mutex> g(mtx_);\n            if (auth_.get() != nullptr)\n            {\n                return auth_->auth_status_;\n            }\n            else\n            {\n                return AUTHENTICATION_NOT_AVAILABLE;\n            }\n        }", "target": 0}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}", "target": 0}
{"code": "ansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc && ch == '\\\\')\n\t\t\treturn ANSI_END;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; \n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; \n\t}\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}", "target": 1}
{"code": "static void __net_exit sctp_defaults_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 0}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "same_url_p(ParsedURL *pu1, ParsedURL *pu2)\n{\n    return (pu1->scheme == pu2->scheme && pu1->port == pu2->port &&\n\t    (pu1->host ? pu2->host ? !strcasecmp(pu1->host, pu2->host) : 0 : 1)\n\t    && (pu1->file ? pu2->\n\t\tfile ? !strcmp(pu1->file, pu2->file) : 0 : 1));\n}", "target": 0}
{"code": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        ND_TCHECK2(p[0], 2);\n        extracted_ethertype = EXTRACT_16BITS(p);\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_pppoe_atm]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (axis.getNumElements() == 0) {\n    return false;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "alt_merge_opt_map_info(OnigEncoding enc, OptMapInfo* to, OptMapInfo* add)\n{\n  int i, val;\n  if (to->value == 0) return ;\n  if (add->value == 0 || to->mmd.max < add->mmd.min) {\n    clear_opt_map_info(to);\n    return ;\n  }\n  alt_merge_mml(&to->mmd, &add->mmd);\n  val = 0;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n    if (add->map[i])\n      to->map[i] = 1;\n    if (to->map[i])\n      val += map_position_value(enc, i);\n  }\n  to->value = val;\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n}", "target": 0}
{"code": "mark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}", "target": 1}
{"code": "static void InsertNode(CPpmd8 *p, void *node, unsigned indx)\n{\n  ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;\n  ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];\n  ((CPpmd8_Node *)node)->NU = I2U(indx);\n  p->FreeList[indx] = REF(node);\n  p->Stamps[indx]++;\n}", "target": 0}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}", "target": 1}
{"code": "SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) \n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}", "target": 0}
{"code": "auth_ice_connection (IceConn ice_conn)\n{\n        GIOChannel            *channel;\n        GsmIceConnectionWatch *data;\n        int                    fd;\n        g_debug (\"GsmXsmpServer: auth_ice_connection()\");\n        fd = IceConnectionNumber (ice_conn);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        data = g_new0 (GsmIceConnectionWatch, 1);\n        ice_conn->context = data;\n        data->protocol_timeout = g_timeout_add_seconds (5,\n                                                        (GSourceFunc)ice_protocol_timeout,\n                                                        ice_conn);\n        data->watch_id = g_io_add_watch (channel,\n                                         G_IO_IN | G_IO_ERR,\n                                         (GIOFunc)auth_iochannel_watch,\n                                         ice_conn);\n        g_io_channel_unref (channel);\n}", "target": 0}
{"code": "static int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tif (filler(buf, \"cpuinfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"meminfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"stat\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"uptime\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"diskstats\", NULL, 0) != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "static int expand_template(struct sss_certmap_ctx *ctx,\n                           struct parsed_template *parsed_template,\n                           struct sss_cert_content *cert_content,\n                           bool sanitize,\n                           char **expanded)\n{\n    int ret;\n    char *exp = NULL;\n    char *exp_sanitized = NULL;\n    if (strcmp(\"issuer_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->issuer_rdn_list, &exp);\n    } else if (strcmp(\"subject_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->subject_rdn_list, &exp);\n    } else if (strncmp(\"subject_\", parsed_template->name, 8) == 0) {\n        ret = expand_san(ctx, parsed_template, cert_content->san_list, &exp);\n    } else if (strcmp(\"cert\", parsed_template->name) == 0) {\n        sanitize = false;\n        ret = expand_cert(ctx, parsed_template, cert_content, &exp);\n    } else {\n        CM_DEBUG(ctx, \"Unsupported template name.\");\n        ret = EINVAL;\n        goto done;\n    }\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to expand [%s] template.\", parsed_template->name);\n        goto done;\n    }\n    if (exp == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    if (sanitize) {\n        ret = sss_filter_sanitize(ctx, exp, &exp_sanitized);\n        if (ret != EOK) {\n            CM_DEBUG(ctx, \"Failed to sanitize expanded template.\");\n            goto done;\n        }\n        talloc_free(exp);\n        exp = exp_sanitized;\n    }\n    ret = 0;\ndone:\n    if (ret == 0) {\n        *expanded = exp;\n    } else {\n        talloc_free(exp);\n    }\n    return ret;\n}", "target": 0}
{"code": "bool IsConvolutionOpSupported(const TfLiteRegistration* registration,\n                              const TfLiteNode* node, TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  TfLiteFusedActivation activation;\n  if (registration->builtin_code == kTfLiteBuiltinConv2d) {\n    const auto* conv_params =\n        reinterpret_cast<const TfLiteConvParams*>(node->builtin_data);\n    activation = conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinDepthwiseConv2d) {\n    const auto* depthwise_conv_params =\n        reinterpret_cast<const TfLiteDepthwiseConvParams*>(node->builtin_data);\n    activation = depthwise_conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    activation = kTfLiteActNone;\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context,\n        \"Invalid op: op must be Conv2D, DepthwiseConv2D or TransposeConv.\");\n    return false;\n  }\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  const int kOutputShapeTensor = 0;  \n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {\n      return false;\n    }\n  } else {\n    if (node->inputs->size >= kBiasTensor &&\n        !IsConstantTensor(GetInput(context, node, kBiasTensor))) {\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void atomic2gen (lua_State *L, global_State *g) {\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  g->reallyold = g->old = g->survival = g->allgc;\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n  sweep2old(L, &g->tobefnz);\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  \n  finishgencycle(L, g);\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "gss_krb5int_export_lucid_sec_context(\n    OM_uint32           *minor_status,\n    const gss_ctx_id_t  context_handle,\n    const gss_OID       desired_object,\n    gss_buffer_set_t    *data_set)\n{\n    krb5_error_code     kret = 0;\n    OM_uint32           retval;\n    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;\n    void                *lctx = NULL;\n    int                 version = 0;\n    gss_buffer_desc     rep;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    retval = generic_gss_oid_decompose(minor_status,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,\n                                       desired_object,\n                                       &version);\n    if (GSS_ERROR(retval))\n        return retval;\n    switch (version) {\n    case 1:\n        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,\n                                          version, &lctx);\n        break;\n    default:\n        kret = (OM_uint32) KG_LUCID_VERSION;\n        break;\n    }\n    if (kret)\n        goto error_out;\n    rep.value = &lctx;\n    rep.length = sizeof(lctx);\n    retval = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);\n    if (GSS_ERROR(retval))\n        goto error_out;\nerror_out:\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "x509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 0}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static int pgpVerifySelf(pgpDigParams key, pgpDigParams selfsig,\n\t\t\tconst struct pgpPkt *all, int i)\n{\n    int rc = -1;\n    DIGEST_CTX hash = NULL;\n    switch (selfsig->sigtype) {\n    case PGPSIGTYPE_SUBKEY_BINDING:\n\thash = rpmDigestInit(selfsig->hash_algo, 0);\n\tif (hash) {\n\t    rc = hashKey(hash, &all[0], PGPTAG_PUBLIC_KEY);\n\t    if (!rc)\n\t\trc = hashKey(hash, &all[i-1], PGPTAG_PUBLIC_SUBKEY);\n\t}\n\tbreak;\n    default:\n\trc = 0;\n\tbreak;\n    }\n    if (hash && rc == 0)\n\trc = pgpVerifySignature(key, selfsig, hash);\n    rpmDigestFinal(hash, NULL, NULL, 0);\n    return rc;\n}", "target": 0}
{"code": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (!dmn->uar) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_pd;\n\t}\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\treturn 0;\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\treturn ret;\n}", "target": 1}
{"code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "pdf_write_names(FILE *out)\t\t\n{\n  int\t\ti;\t\t\t\n  uchar\t\t*s;\t\t\t\n  link_t\t*link;\t\t\t\n  for (i = num_links, link = links; i > 0; i --, link ++)\n    for (s = link->name; *s != '\\0'; s ++)\n      *s = (uchar)tolower(*s);\n  names_object = pdf_start_object(out);\n  fprintf(out, \"/Dests %d 0 R\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fprintf(out, \"/Kids[%d 0 R]\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fputs(\"/Limits[\", out);\n  write_string(out, links[0].name, 0);\n  write_string(out, links[num_links - 1].name, 0);\n  fputs(\"]\", out);\n  fputs(\"/Names[\", out);\n  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)\n  {\n    write_string(out, link->name, 0);\n    fprintf(out, \"%d 0 R\", (int)num_objects + i);\n  }\n  fputs(\"]\", out);\n  pdf_end_object(out);\n  for (i = num_links, link = links; i > 0; i --, link ++)\n  {\n    pdf_start_object(out);\n    float x, y;\n    check_pages(link->page);\n    x = 0.0f;\n    y = link->top + pages[link->page].bottom;\n    pspdf_transform_coords(pages + link->page, x, y);\n    fprintf(out, \"/D[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[link->page].outpage + 1, x, y);\n    pdf_end_object(out);\n  }\n}", "target": 0}
{"code": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}", "target": 0}
{"code": "ins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\tif (State & LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    status_redraw_curbuf();\n#endif\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  val = val + c;\n  *bytes_read = *bytes_read + read;\n  return(htonl(val));\n}", "target": 0}
{"code": "static bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n\t\treturn true;\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}", "target": 0}
{"code": "static void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; \n    settings.maxconns = 1024;         \n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          \n    settings.evict_to_free = 1;       \n    settings.socketpath = NULL;       \n    settings.factor = 1.25;\n    settings.chunk_size = 48;         \n    settings.num_threads = 4;         \n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; \n    settings.slab_page_size = 1024 * 1024; \n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.inline_ascii_response = false;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; \n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = true;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}", "target": 1}
{"code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}", "target": 0}
{"code": "GopherStateData::iconUrl(const char gtype)\n{\n    switch (gtype) {\n    case GOPHER_DIRECTORY:\n        return mimeGetIconURL(\"internal-menu\");\n    case GOPHER_HTML:\n    case GOPHER_FILE:\n        return mimeGetIconURL(\"internal-text\");\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n        return mimeGetIconURL(\"internal-index\");\n    case GOPHER_IMAGE:\n    case GOPHER_GIF:\n    case GOPHER_PLUS_IMAGE:\n        return mimeGetIconURL(\"internal-image\");\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        return mimeGetIconURL(\"internal-sound\");\n    case GOPHER_PLUS_MOVIE:\n        return mimeGetIconURL(\"internal-movie\");\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        return mimeGetIconURL(\"internal-telnet\");\n    case GOPHER_BIN:\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n        return mimeGetIconURL(\"internal-binary\");\n    case GOPHER_INFO:\n        return nullptr;\n    case GOPHER_WWW:\n        return mimeGetIconURL(\"internal-link\");\n    default:\n        return mimeGetIconURL(\"internal-unknown\");\n    }\n}", "target": 1}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}", "target": 1}
{"code": "SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const Tensor& min = context->input(2);\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(min.shape()),\n        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max.shape()),\n        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape scalar_shape;\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, scalar_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, scalar_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsGradientFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), gradient.flat<float>(),\n            input.flat<float>(), min.scalar<float>(), max.scalar<float>(),\n            quant_min_, quant_max_, grad_wrt_input->flat<float>(),\n            grad_wrt_min->scalar<float>(), grad_wrt_max->scalar<float>());\n  }", "target": 0}
{"code": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  if (row_size == 0) {\n    return kTfLiteOk;\n  }\n  const int row_bytes = value->bytes / row_size;\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep)\n{\n\tupdate_curr(cfs_rq);\n\tupdate_stats_dequeue(cfs_rq, se);\n\tif (sleep) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tif (entity_is_task(se)) {\n\t\t\tstruct task_struct *tsk = task_of(se);\n\t\t\tif (tsk->state & TASK_INTERRUPTIBLE)\n\t\t\t\tse->sleep_start = rq_of(cfs_rq)->clock;\n\t\t\tif (tsk->state & TASK_UNINTERRUPTIBLE)\n\t\t\t\tse->block_start = rq_of(cfs_rq)->clock;\n\t\t}\n#endif\n\t}\n\tif (se != cfs_rq->curr)\n\t\t__dequeue_entity(cfs_rq, se);\n\taccount_entity_dequeue(cfs_rq, se);\n}", "target": 0}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }", "target": 1}
{"code": "TfLiteStatus EvalHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  const int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, value_tensor));\n  auto result = lookup->Import(context, key_tensor, value_tensor);\n  return result;\n}", "target": 1}
{"code": "TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}", "target": 0}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "static void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\n\tint ret=0;\n\tstruct dns_hdr *dns_rsp;\n\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n\tdns_rsp->flags1 |= 0x80; \n\tdns_rsp->flags2 = 0x05;  \n\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr, sender_port);\n\tudp_disconnect(udp_pcb);\n\tpbuf_free(udp_packet_buffer);\n}", "target": 0}
{"code": "request_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}", "target": 1}
{"code": "static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,\n\t\t\t\t      void *key)\n{\n\tstruct unix_sock *u;\n\twait_queue_head_t *u_sleep;\n\tu = container_of(q, struct unix_sock, peer_wake);\n\t__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,\n\t\t\t    q);\n\tu->peer_wake.private = NULL;\n\tu_sleep = sk_sleep(&u->sk);\n\tif (u_sleep)\n\t\twake_up_interruptible_poll(u_sleep, key);\n\treturn 0;\n}", "target": 0}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "OGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        poSRS_->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                char *pszWKT = nullptr;\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n    bClosedForWriting = !bWriterIn;\n}", "target": 0}
{"code": "static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\tint r;\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}", "target": 0}
{"code": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}", "target": 1}
{"code": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\treturn rc;\n}", "target": 0}
{"code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}", "target": 1}
{"code": "void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tgf_free(pidinst);\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "  Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {\n    if (group_size_t.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input group_size. \"\n          \"It shoulbe a scalar, got tensor with shape \",\n          group_size_t.shape().DebugString());\n    }\n    if (group_key_t.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key_t.shape().DebugString());\n    }\n    auto group_size = group_size_t.unaligned_flat<int32>()(0);\n    if (group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \", group_size);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "void ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t  bool allocated)\n{\n\tstruct extent_status newes;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\text4_es_insert_extent_check(inode, &newes);\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 != 0)\n\t\tgoto error;\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\n\tif (es1 && !es1->es_len)\n\t\t__es_free_extent(es1);\n\tif (es2 && !es2->es_len)\n\t\t__es_free_extent(es2);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\treturn;\n}", "target": 1}
{"code": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}", "target": 0}
{"code": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->iDoneUpTo = 0;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\nfinalize_it:\n\tRETiRet;\n}", "target": 0}
{"code": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    if (key == NULL) {\n        *key_len = 32;\n        return 1;\n    }\n    if (key != NULL && *key_len < 32) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n        return 0;\n    }\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: \n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}", "target": 0}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static const char *adpt_i2o_get_class_name(int class)\n{\n\tint idx = 16;\n\tstatic char *i2o_class_name[] = {\n\t\t\"Executive\",\n\t\t\"Device Driver Module\",\n\t\t\"Block Device\",\n\t\t\"Tape Device\",\n\t\t\"LAN Interface\",\n\t\t\"WAN Interface\",\n\t\t\"Fibre Channel Port\",\n\t\t\"Fibre Channel Device\",\n\t\t\"SCSI Device\",\n\t\t\"ATE Port\",\n\t\t\"ATE Device\",\n\t\t\"Floppy Controller\",\n\t\t\"Floppy Device\",\n\t\t\"Secondary Bus Port\",\n\t\t\"Peer Transport Agent\",\n\t\t\"Peer Transport\",\n\t\t\"Unknown\"\n\t};\n\tswitch(class&0xFFF) {\n\tcase I2O_CLASS_EXECUTIVE:\n\t\tidx = 0; break;\n\tcase I2O_CLASS_DDM:\n\t\tidx = 1; break;\n\tcase I2O_CLASS_RANDOM_BLOCK_STORAGE:\n\t\tidx = 2; break;\n\tcase I2O_CLASS_SEQUENTIAL_STORAGE:\n\t\tidx = 3; break;\n\tcase I2O_CLASS_LAN:\n\t\tidx = 4; break;\n\tcase I2O_CLASS_WAN:\n\t\tidx = 5; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PORT:\n\t\tidx = 6; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\n\t\tidx = 7; break;\n\tcase I2O_CLASS_SCSI_PERIPHERAL:\n\t\tidx = 8; break;\n\tcase I2O_CLASS_ATE_PORT:\n\t\tidx = 9; break;\n\tcase I2O_CLASS_ATE_PERIPHERAL:\n\t\tidx = 10; break;\n\tcase I2O_CLASS_FLOPPY_CONTROLLER:\n\t\tidx = 11; break;\n\tcase I2O_CLASS_FLOPPY_DEVICE:\n\t\tidx = 12; break;\n\tcase I2O_CLASS_BUS_ADAPTER_PORT:\n\t\tidx = 13; break;\n\tcase I2O_CLASS_PEER_TRANSPORT_AGENT:\n\t\tidx = 14; break;\n\tcase I2O_CLASS_PEER_TRANSPORT:\n\t\tidx = 15; break;\n\t}\n\treturn i2o_class_name[idx];\n}", "target": 1}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "NAN_METHOD(TxnWrap::putString) {\n    if (!info[2]->IsString())\n        return Nan::ThrowError(\"Value must be a string.\");\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);\n    }, [](MDB_val &data) -> void {\n        delete[] (uint16_t*)data.mv_data;\n    });\n}", "target": 0}
{"code": "int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const char *name, int name_len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tkey.objectid = dir;\n\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\tif (di) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}", "target": 0}
{"code": "on_response(void *data, krb5_error_code retval, otp_response response)\n{\n    struct request_state rs = *(struct request_state *)data;\n    free(data);\n    if (retval == 0 && response != otp_response_success)\n        retval = KRB5_PREAUTH_FAILED;\n    if (retval == 0)\n        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    rs.respond(rs.arg, retval, NULL, NULL, NULL);\n}", "target": 0}
{"code": "bounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n                                   const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                                   const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(w), err(Sirikata::JpegError::nil()) {\n    this->size_callback = size_callback;\n    buffer_position = 0;\n    byte_position = 0;\n    byte_bound = 0x7FFFFFFF;\n    num_bytes_attempted_to_write = 0;\n    set_bound(0);\n}", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)\n{\n\tssize_t ret;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(type,\n\t\t\t\t(struct compat_iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(type,\n\t\t\t\t(struct iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\tkiocb->ki_nr_segs = kiocb->ki_nbytes;\n\tkiocb->ki_cur_seg = 0;\n\tkiocb->ki_nbytes = ret;\n\tkiocb->ki_left = ret;\n\tret = 0;\nout:\n\treturn ret;\n}", "target": 0}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "static int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\n\t\t\t\t   struct tipc_nl_compat_msg *msg,\n\t\t\t\t   struct sk_buff *arg)\n{\n\tint len = 0;\n\tint err;\n\tstruct sk_buff *buf;\n\tstruct nlmsghdr *nlmsg;\n\tstruct netlink_callback cb;\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.nlh = (struct nlmsghdr *)arg->data;\n\tcb.skb = arg;\n\tbuf = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf->sk = msg->dst_sk;\n\tdo {\n\t\tint rem;\n\t\tlen = (*cmd->dumpit)(buf, &cb);\n\t\tnlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem) {\n\t\t\tstruct nlattr **attrs;\n\t\t\terr = tipc_nlmsg_parse(nlmsg, &attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\terr = (*cmd->format)(msg, attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tif (tipc_skb_tailroom(msg->rep) <= 1) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tskb_reset_tail_pointer(buf);\n\t\tbuf->len = 0;\n\t} while (len);\n\terr = 0;\nerr_out:\n\tkfree_skb(buf);\n\tif (err == -EMSGSIZE) {\n\t\tif ((TIPC_SKB_MAX - msg->rep->len) <= 1) {\n\t\t\tchar *tail = skb_tail_pointer(msg->rep);\n\t\t\tif (*tail != '\\0')\n\t\t\t\tsprintf(tail - sizeof(REPLY_TRUNCATED) - 1,\n\t\t\t\t\tREPLY_TRUNCATED);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_TX_INFO:\n\t\tif (len < sizeof(tfrc))\n\t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n\t\ttfrc.tfrctx_x\t   = hc->tx_x;\n\t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n\t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "std::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len,\n                                                             EC_Group_Source source)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n      if(p.bits() < 64 || p.is_negative() || !is_bailie_psw_probable_prime(p))\n         throw Decoding_Error(\"Invalid ECC p parameter\");\n      if(a.is_negative() || a >= p)\n         throw Decoding_Error(\"Invalid ECC a parameter\");\n      if(b <= 0 || b >= p)\n         throw Decoding_Error(\"Invalid ECC b parameter\");\n      if(order <= 0 || !is_bailie_psw_probable_prime(order))\n         throw Decoding_Error(\"Invalid ECC order parameter\");\n      if(cofactor <= 0 || cofactor >= 16)\n         throw Decoding_Error(\"Invalid ECC cofactor parameter\");\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second,\n                                              order, cofactor, OID(), source);\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }", "target": 1}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "static GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "int main(int argc, char *argv[]) {\n  try {\n    for (int i = 1; i < argc; i++) {\n      string arg = argv[i];\n      if (arg == \"--extract\" && i < argc - 1) {\n        TarFileReader reader(argv[++i]);\n        while (reader.hasMore())\n          cout << reader.extract() << endl;\n      } else THROWS(\"Invalid arg '\" << arg << \"'\");\n    }\n    return 0;\n  } catch (const Exception &e) {cerr << e.getMessage();}\n  return 1;\n}", "target": 0}
{"code": "makepol(QPRS_STATE *state)\n{\n\tint32\t\tval = 0,\n\t\t\t\ttype;\n\tint32\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tint32\t\tstack[STACKDEPTH];\n\tint32\t\tlenstack = 0;\n\tuint16\t\tflag = 0;\n\tcheck_stack_depth();\n\twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase VAL:\n\t\t\t\tpushval_asis(state, VAL, strval, lenval, flag);\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPR:\n\t\t\t\tif (lenstack && val == (int32) '|')\n\t\t\t\t\tpushquery(state, OPR, val, 0, 0, 0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (lenstack == STACKDEPTH)\n\t\t\t\t\t\telog(ERROR, \"stack too short\");\n\t\t\t\t\tstack[lenstack] = val;\n\t\t\t\t\tlenstack++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPEN:\n\t\t\t\tif (makepol(state) == ERR)\n\t\t\t\t\treturn ERR;\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\twhile (lenstack)\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t};\n\t\t\t\treturn END;\n\t\t\t\tbreak;\n\t\t\tcase ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error\")));\n\t\t\t\treturn ERR;\n\t\t}\n\t}\n\twhile (lenstack)\n\t{\n\t\tlenstack--;\n\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t};\n\treturn END;\n}", "target": 0}
{"code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 0}
{"code": "RecordConvertRangesToIntervals(SetInfoPtr psi,\n                               xRecordRange * pRanges,\n                               int nRanges,\n                               int byteoffset,\n                               SetInfoPtr pExtSetInfo, int *pnExtSetInfo)\n{\n    int i;\n    CARD8 *pCARD8;\n    int first, last;\n    int err;\n    for (i = 0; i < nRanges; i++, pRanges++) {\n        pCARD8 = ((CARD8 *) pRanges) + byteoffset;\n        first = pCARD8[0];\n        last = pCARD8[1];\n        if (first || last) {\n            if (!psi->intervals) {\n                err = RecordAllocIntervals(psi, 2 * (nRanges - i));\n                if (err != Success)\n                    return err;\n            }\n            psi->intervals[psi->nintervals].first = first;\n            psi->intervals[psi->nintervals].last = last;\n            psi->nintervals++;\n            assert(psi->nintervals <= psi->size);\n            if (pExtSetInfo) {\n                SetInfoPtr pesi = pExtSetInfo;\n                CARD16 *pCARD16 = (CARD16 *) (pCARD8 + 2);\n                int j;\n                for (j = 0; j < *pnExtSetInfo; j++, pesi++) {\n                    if ((first == pesi->first) && (last == pesi->last))\n                        break;\n                }\n                if (j == *pnExtSetInfo) {\n                    err = RecordAllocIntervals(pesi, 2 * (nRanges - i));\n                    if (err != Success)\n                        return err;\n                    pesi->first = first;\n                    pesi->last = last;\n                    (*pnExtSetInfo)++;\n                }\n                pesi->intervals[pesi->nintervals].first = pCARD16[0];\n                pesi->intervals[pesi->nintervals].last = pCARD16[1];\n                pesi->nintervals++;\n                assert(pesi->nintervals <= pesi->size);\n            }\n        }\n    }\n    return Success;\n}                               ", "target": 0}
{"code": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}", "target": 1}
{"code": "xfs_ip2xflags(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_icdinode\t*dic = &ip->i_d;\n\treturn _xfs_dic2xflags(dic->di_flags, dic->di_flags2, XFS_IFORK_Q(ip));\n}", "target": 0}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "std::wstring Utf8ToUtf16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static void freeInstParams (AFPVu *values, int fileFormat)\n{\n\tint\ti;\n\tint\tparameterCount = _af_units[fileFormat].instrumentParameterCount;\n\tfor (i=0; i<parameterCount; i++)\n\t{\n\t\tif (_af_units[fileFormat].instrumentParameters[i].type == AU_PVTYPE_PTR)\n\t\t\tif (values[i].v != NULL)\n\t\t\t\tfree(values[i].v);\n\t}\n\tfree(values);\n}", "target": 0}
{"code": "njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_resolve_element_functions;\n    on_fulfilled->args_count = 1;\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    arguments[1] = capability->reject;\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "static void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\t\tif (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n}", "target": 1}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withscores = 1;\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 1}
{"code": "static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n    if ((*idx + PICO_TCPOPTLEN_MSS) > len)\n        return;\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}", "target": 0}
{"code": "mmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n        switch(tag) {\n        case 0xa0: \n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n            hasFileName = true;\n            break;\n        case 0x81: \n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: \n            break;\n        default: \n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n    if (hasFileName) {\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n        if (frsm != NULL) {\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n            if (obtainFileCall) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n    return;\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 1}
{"code": "NOEXPORT void print_cipher(CLI *c) { \n    SSL_CIPHER *cipher;\n#ifndef OPENSSL_NO_COMP\n    const COMP_METHOD *compression, *expansion;\n#endif\n    if(c->opt->log_level<LOG_INFO) \n        return;\n    s_log(LOG_INFO, \"TLS %s: %s\",\n        c->opt->option.client ? \"connected\" : \"accepted\",\n        SSL_session_reused(c->ssl) && !c->flag.psk ?\n            \"previous session reused\" : \"new session negotiated\");\n    cipher=(SSL_CIPHER *)SSL_get_current_cipher(c->ssl);\n    s_log(LOG_INFO, \"%s ciphersuite: %s (%d-bit encryption)\",\n        SSL_get_version(c->ssl), SSL_CIPHER_get_name(cipher),\n        SSL_CIPHER_get_bits(cipher, NULL));\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n    print_tmp_key(c->ssl);\n#endif\n#ifndef OPENSSL_NO_COMP\n    compression=SSL_get_current_compression(c->ssl);\n    expansion=SSL_get_current_expansion(c->ssl);\n    s_log(compression||expansion ? LOG_INFO : LOG_DEBUG,\n        \"Compression: %s, expansion: %s\",\n        compression ? SSL_COMP_get_name(compression) : \"null\",\n        expansion ? SSL_COMP_get_name(expansion) : \"null\");\n#endif\n}", "target": 0}
{"code": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}", "target": 0}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void rds_rdma_drop_keys(struct rds_sock *rs)\n{\n\tstruct rds_mr *mr;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\twhile ((node = rb_first(&rs->rs_rdma_keys))) {\n\t\tmr = rb_entry(node, struct rds_mr, r_rb_node);\n\t\tif (mr->r_trans == rs->rs_transport)\n\t\t\tmr->r_invalidate = 0;\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\tif (rs->rs_transport && rs->rs_transport->flush_mrs)\n\t\trs->rs_transport->flush_mrs();\n}", "target": 0}
{"code": "static int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn 0;\n\t}\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "smb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tint rc;\n\trc = smb2_query_info_compound(xid, tcon, \"\",\n\t\t\t\t      FILE_READ_ATTRIBUTES,\n\t\t\t\t      FS_FULL_SIZE_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILESYSTEM,\n\t\t\t\t      sizeof(struct smb2_fs_full_size_info),\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc)\n\t\tgoto qfs_exit;\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\tbuf->f_type = SMB2_SUPER_MAGIC;\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, buf);\nqfs_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "ldns_str2rdf_str(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data, *dp, ch = 0;\n\tsize_t length;\n\tdp = data = LDNS_XMALLOC(uint8_t, strlen(str) > 255 ? 256 : (strlen(str) + 1));\n\tif (! data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\twhile (parse_char(&ch, &str)) {\n\t\tif (dp - data >= 255) {\n\t\t\tLDNS_FREE(data);\n\t\t\treturn LDNS_STATUS_INVALID_STR;\n\t\t}\n\t\t*++dp = ch;\n\t}\n\tif (! str) {\n\t\treturn LDNS_STATUS_SYNTAX_BAD_ESCAPE;\n\t}\n\tlength = (size_t)(dp - data);\n\tdata[0] = (uint8_t)length;\n\tdata = LDNS_XREALLOC(dp = data, uint8_t, length + 1);\n\tif (! data) {\n\t\tLDNS_FREE(dp);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_STR, length + 1, data);\n\tif (! *rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "  static void Launch(OpKernelContext* context, const Tensor& in_x,\n                     const Tensor& in_y, bool adjoint, bool lower,\n                     const MatMulBCast& bcast, Tensor* out) {\n    const int64 batch_size = bcast.output_batch_size();\n    const int64 cost_per_unit =\n        in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    using Matrix =\n        Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\n    using ConstMatrixMap = Eigen::Map<const Matrix>;\n    using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n    auto matrix = ConstMatrixMap(in_x.flat<Scalar>().data(), in_x.dim_size(1),\n                                 in_x.dim_size(2));\n    RealScalar min_abs_pivot;\n    if (lower) {\n      min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();\n    } else {\n      min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();\n    }\n    OP_REQUIRES(context, min_abs_pivot > RealScalar(0),\n                errors::InvalidArgument(\"Input matrix is not invertible.\"));\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          cost_per_unit,\n          [&in_x, &in_y, adjoint, lower, &bcast, out](int start, int limit) {\n            SequentialBandedTriangularSolveKernel<Scalar>::Run(\n                in_x, in_y, lower, adjoint, bcast, out, start, limit);\n          });\n  }", "target": 1}
{"code": "xsltVariableComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemVariablePtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemVariablePtr)\n\txsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    xsltGetQNameProperty(style, inst, BAD_CAST \"name\",\n\t1, &(comp->has_name), &(comp->ns), &(comp->name));\n    if (comp->ns)\n\tcomp->has_ns = 1;\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select != NULL) {\n#ifndef XSLT_REFACTORED\n        xmlNodePtr cur;\n#endif\n\tcomp->comp = xsltXPathCompile(style, comp->select);\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: Failed to compile the XPath expression '%s'.\\n\",\n\t\tcomp->select);\n\t    style->errors++;\n\t}\n#ifdef XSLT_REFACTORED\n\tif (inst->children != NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: There must be no child nodes, since the \"\n\t\t\"attribute 'select' was specified.\\n\");\n\t    style->errors++;\n\t}\n#else\n        for (cur = inst->children; cur != NULL; cur = cur->next) {\n            if (cur->type != XML_COMMENT_NODE &&\n                (cur->type != XML_TEXT_NODE || !xsltIsBlank(cur->content)))\n            {\n                xsltTransformError(NULL, style, inst,\n                    \"XSLT-variable: There must be no child nodes, since the \"\n                    \"attribute 'select' was specified.\\n\");\n                style->errors++;\n            }\n        }\n#endif\n    }\n}", "target": 0}
{"code": "decode_definite_short_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = fp_read_object(self, length);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}", "target": 1}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "int nfc_register_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\trc = device_add(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = nfc_llcp_register_device(dev);\n\tif (rc)\n\t\tpr_err(\"Could not register llcp device\\n\");\n\tdevice_lock(&dev->dev);\n\tdev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n\t\t\t\t   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n\tif (dev->rfkill) {\n\t\tif (rfkill_register(dev->rfkill) < 0) {\n\t\t\trfkill_destroy(dev->rfkill);\n\t\t\tdev->rfkill = NULL;\n\t\t}\n\t}\n\tdev->shutting_down = false;\n\tdevice_unlock(&dev->dev);\n\trc = nfc_genl_device_added(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n\t\t\t dev_name(&dev->dev));\n\treturn 0;\n}", "target": 0}
{"code": "static int append_session_tasks_max(pam_handle_t *handle, sd_bus_message *m, const char *limit) {\n        uint64_t val;\n        int r;\n        if (isempty(limit) || streq(limit, \"infinity\"))\n                return 0;\n        r = safe_atou64(limit, &val);\n        if (r >= 0) {\n                r = sd_bus_message_append(m, \"(sv)\", \"TasksMax\", \"t\", val);\n                if (r < 0) {\n                        pam_syslog(handle, LOG_ERR, \"Failed to append to bus message: %s\", strerror(-r));\n                        return r;\n                }\n        } else\n                pam_syslog(handle, LOG_WARNING, \"Failed to parse systemd.limit: %s, ignoring.\", limit);\n        return 0;\n}", "target": 0}
{"code": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\t\ttot_pages += nr_pages;\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "target": 0}
{"code": "print_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); \n\treturn len;\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}", "target": 1}
{"code": "ebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\tw->u.watcher = watcher;\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\t(*cnt)++;\n\treturn 0;\n}", "target": 0}
{"code": "void init_tls_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\tu_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n}", "target": 0}
{"code": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tsdb_free(sdb_version);\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\treturn sdb;\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n}", "target": 1}
{"code": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n      start++;\n    }\n  return modules;\n}", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}", "target": 0}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "static void wipe_keys()\n{\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n}", "target": 0}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "cdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}", "target": 0}
{"code": "inline void* aligned_malloc(size_t size, size_t alignment) {\n  return folly::detail::aligned_malloc(size, alignment);\n}", "target": 1}
{"code": "static int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL, *m2 = NULL;\n\tint ret = -ESTALE;\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!mutex_trylock(&alias->d_parent->d_inode->i_mutex))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_mutex;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tspin_unlock(&inode->i_lock);\n\tif (m2)\n\t\tmutex_unlock(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}", "target": 0}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR4, read_cr4());  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 1}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (seg == VCPU_SREG_SS && selector == 3 &&\n\t    ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}", "target": 0}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,\n\t       uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CR)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CR)));\n\treturn NULL;\n}", "target": 0}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "sshpam_cleanup(void *arg)\n{\n\t(void)arg;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_cred_established) {\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tif (sshpam_session_open) {\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tsshpam_authenticated = sshpam_new_authtok_reqd = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}", "target": 0}
{"code": "GF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TF_LITE_ENSURE_EQ(context, input->type, kTfLiteInt16);\n  output->type = kTfLiteInt32;\n  if (data->out_float) {\n    output->type = kTfLiteFloat32;\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(2);\n  int num_frames = 0;\n  if (input->dims->data[0] >= data->state->window.size) {\n    num_frames = (input->dims->data[0] - data->state->window.size) /\n                     data->state->window.step / data->frame_stride +\n                 1;\n  }\n  output_size->data[0] = num_frames;\n  output_size->data[1] = data->state->filterbank.num_channels *\n                         (1 + data->left_context + data->right_context);\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}", "target": 0}
{"code": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\tdeactivate_mm(tsk, mm);\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}", "target": 0}
{"code": "void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}", "target": 0}
{"code": "coolkey_get_attribute_bytes(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE type, u8 *data, size_t *data_len, size_t max_data_len)\n{\n\tconst u8 *val;\n\tsize_t val_len;\n\tint r;\n\tr = coolkey_get_attribute(card, obj, type, &val, &val_len, NULL);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tif (val_len > max_data_len) {\n\t\tval_len = max_data_len;\n\t}\n\tmemcpy(data, val, val_len);\n\t*data_len = val_len;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}", "target": 1}
{"code": "static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *list = (char *) malloc(size);\n        if (list == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_listxattr(f, req, ino, list, size);\n        if (res > 0)\n            fuse_reply_buf(req, list, res);\n        else\n            reply_err(req, res);\n        free(list);\n    } else {\n        res = common_listxattr(f, req, ino, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "static mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n    assert((MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(self_in, &mp_type_bytearray))\n        || (MICROPY_PY_ARRAY && mp_obj_is_type(self_in, &mp_type_array)));\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t arg_bufinfo;\n    mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n    size_t sz = mp_binary_get_size('@', self->typecode, NULL);\n    size_t len = arg_bufinfo.len / sz;\n    if (self->free < len) {\n        self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n        self->free = 0;\n        if (self_in == arg_in) {\n            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n        }\n    } else {\n        self->free -= len;\n    }\n    mp_seq_copy((byte *)self->items + self->len * sz, arg_bufinfo.buf, len * sz, byte);\n    self->len += len;\n    return mp_const_none;\n}", "target": 0}
{"code": "static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\treturn err;\n}", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst > addr_loaded[n].dest) &&\n\t\t     (dst <  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    (((dst < addr_loaded[n].dest) &&\n\t\t      (dst + len)) > addr_loaded[n].dest)) {\n\t\t\tERROR(\"BL2: image is inside a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\n\treturn result;\n}", "target": 1}
{"code": "void make_random_permutation(int start) {\n        int i, j;\n        permutation[0] = start;\t\n        for (i = 1; i < ARRAY_SIZE; i++) {\n                j = random() * (double)(i + 1) / RAND_MAX; \n                if (j != i) { \n                  permutation[i] = permutation[j];\n                }\n                permutation[j] = start + i;\n        }\n}", "target": 0}
{"code": "ring_buffer_read_finish(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_check_pages(cpu_buffer);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\tatomic_dec(&cpu_buffer->record_disabled);\n\tatomic_dec(&cpu_buffer->buffer->resize_disabled);\n\tkfree(iter);\n}", "target": 0}
{"code": "static void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}", "target": 0}
