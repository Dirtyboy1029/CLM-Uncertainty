{"code": "static int vidioc_try_fmt_out(struct file *file, void *priv, struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\t\tif (w > max_width)\n\t\t\tw = max_width;\n\t\tif (h > max_height)\n\t\t\th = max_height;\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n    conn = data;\n    ogs_assert(conn);\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n    return realsize;\n}", "target": 1}
{"code": "static apr_status_t lua_websocket_readbytes(conn_rec* c, char* buffer, \n        apr_off_t len) \n{\n    apr_bucket_brigade *brigade = apr_brigade_create(c->pool, c->bucket_alloc);\n    apr_status_t rv;\n    rv = ap_get_brigade(c->input_filters, brigade, AP_MODE_READBYTES, \n            APR_BLOCK_READ, len);\n    if (rv == APR_SUCCESS) {\n        if (!APR_BRIGADE_EMPTY(brigade)) {\n            apr_bucket* bucket = APR_BRIGADE_FIRST(brigade);\n            const char* data = NULL;\n            apr_size_t data_length = 0;\n            rv = apr_bucket_read(bucket, &data, &data_length, APR_BLOCK_READ);\n            if (rv == APR_SUCCESS) {\n                memcpy(buffer, data, len);\n            }\n            apr_bucket_delete(bucket);\n        }\n    }\n    apr_brigade_cleanup(brigade);\n    return rv;\n}", "target": 0}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "Bool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;", "target": 0}
{"code": "static inline bool mpOk(const QString &mp)\n{\n    return !mp.isEmpty() && mp.startsWith(\"/home/\"); \n}", "target": 1}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}", "target": 1}
{"code": "void ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\t\t\tServerAddress address(HostAddress(host), port);\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "unsigned int inet6_hash_frag(__be32 id, const struct in6_addr *saddr,\n\t\t\t     const struct in6_addr *daddr, u32 rnd)\n{\n\tu32 a, b, c;\n\ta = (__force u32)saddr->s6_addr32[0];\n\tb = (__force u32)saddr->s6_addr32[1];\n\tc = (__force u32)saddr->s6_addr32[2];\n\ta += JHASH_GOLDEN_RATIO;\n\tb += JHASH_GOLDEN_RATIO;\n\tc += rnd;\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)saddr->s6_addr32[3];\n\tb += (__force u32)daddr->s6_addr32[0];\n\tc += (__force u32)daddr->s6_addr32[1];\n\t__jhash_mix(a, b, c);\n\ta += (__force u32)daddr->s6_addr32[2];\n\tb += (__force u32)daddr->s6_addr32[3];\n\tc += (__force u32)id;\n\t__jhash_mix(a, b, c);\n\treturn c & (INETFRAGS_HASHSZ - 1);\n}", "target": 0}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "static void spl_heap_it_move_forward(zend_object_iterator *iter TSRMLS_DC) \n{\n\tzval                 *object   = (zval*)((zend_user_iterator *)iter)->it.data;\n\tspl_heap_it          *iterator = (spl_heap_it *)iter;\n\tspl_ptr_heap_element elem;\n\tif (iterator->object->heap->flags & SPL_HEAP_CORRUPTED) {\n\t\tzend_throw_exception(spl_ce_RuntimeException, \"Heap is corrupted, heap properties are no longer ensured.\", 0 TSRMLS_CC);\n\t\treturn;\n\t}\n\telem = spl_ptr_heap_delete_top(iterator->object->heap, object TSRMLS_CC);\n\tif (elem != NULL) {\n\t\tzval_ptr_dtor((zval **)&elem);\n\t}\n\tzend_user_it_invalidate_current(iter TSRMLS_CC);\n}", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "read_password(FILE *in, FILE *out, char *buf, size_t bufsz)\n{\n\tint infd = fileno(in);\n\tstruct termios tio;\n\tchar *ret;\n\tret = fgets(buf, bufsz, in);\n\tif (isatty(infd)) {\n\t\tfprintf(out, \"\\n\");\n\t\tfflush(out);\n\t\ttcgetattr(infd, &tio);\n\t\ttio.c_lflag |= ECHO;\n\t\ttcsetattr(infd, TCSAFLUSH, &tio);\n\t}\n\tif (ret == NULL)\n\t\treturn -1;\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "MATCHER_P(RepeatedProtoEq, expected, \"\") {\n  const bool equal = TestUtility::repeatedPtrFieldEqual(arg, expected);\n  if (!equal) {\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected repeated:\") << \"\\n\"\n                     << RepeatedPtrUtil::debugString(expected) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"is not equal to actual repeated:\")\n                     << \"\\n\"\n                     << RepeatedPtrUtil::debugString(arg) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "static void hardware_enable_nolock(void *junk)\n{\n\tint cpu = raw_smp_processor_id();\n\tint r;\n\tif (cpumask_test_cpu(cpu, cpus_hardware_enabled))\n\t\treturn;\n\tcpumask_set_cpu(cpu, cpus_hardware_enabled);\n\tr = kvm_arch_hardware_enable(NULL);\n\tif (r) {\n\t\tcpumask_clear_cpu(cpu, cpus_hardware_enabled);\n\t\tatomic_inc(&hardware_enable_failed);\n\t\tprintk(KERN_INFO \"kvm: enabling virtualization on \"\n\t\t\t\t \"CPU%d failed\\n\", cpu);\n\t}\n}", "target": 0}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\trq_qos_exit(q);\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tblk_put_queue(q);\n}", "target": 1}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "generate_spc_string(cms_context *cms, SECItem *ssp, char *str, int len)\n{\n\tSpcString ss;\n\tmemset(&ss, '\\0', sizeof (ss));\n\tSECITEM_AllocItem(cms->arena, &ss.unicode, len);\n\tif (len != 0) {\n\t\tif (!ss.unicode.data)\n\t\t\tcmsreterr(-1, cms, \"could not allocate memory\");\n\t\tmemcpy(ss.unicode.data, str, len);\n\t}\n\tss.unicode.type = siBMPString;\n\tif (SEC_ASN1EncodeItem(cms->arena, ssp, &ss, SpcStringTemplate) == NULL)\n\t\tcmsreterr(-1, cms, \"could not encode SpcString\");\n\treturn 0;\n}", "target": 0}
{"code": "void jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    strncpy(str, \"ID:\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n  } else if (lex->tk == LEX_STR) {\n    strncpy(str, \"String:'\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n    strncat(str, \"'\", len);\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}", "target": 1}
{"code": "static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)\n{\n\tint err  = 0, reg;\n\tint val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};\n\tfor (reg = 0; reg < ARRAY_SIZE(val); reg++) {\n\t\terr = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 1}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "perf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = NULL, *old_rb = NULL;\n\tint ret = -EINVAL;\n\tif (!output_event)\n\t\tgoto set;\n\tif (event == output_event)\n\t\tgoto out;\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\nset:\n\tmutex_lock(&event->mmap_mutex);\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\tif (output_event) {\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\told_rb = event->rb;\n\trcu_assign_pointer(event->rb, rb);\n\tif (old_rb)\n\t\tring_buffer_detach(event, old_rb);\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\tif (old_rb)\n\t\tring_buffer_put(old_rb);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static int lua_websocket_peek(lua_State *L) \n{\n    apr_status_t rv;\n    apr_bucket_brigade *brigade;\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    brigade = apr_brigade_create(r->connection->pool, \n            r->connection->bucket_alloc);\n    rv = ap_get_brigade(r->connection->input_filters, brigade, \n            AP_MODE_READBYTES, APR_NONBLOCK_READ, 1);\n    if (rv == APR_SUCCESS) {\n        lua_pushboolean(L, 1);\n    }\n    else {\n        lua_pushboolean(L, 0);\n    }\n    apr_brigade_cleanup(brigade);\n    return 1;\n}", "target": 0}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "void read_user_name(char *name)\n{\n  char *str=getenv(\"USER\");\t\t\n  strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}", "target": 0}
{"code": "static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\n {\n     const unsigned char *p;\n     int plen;\n    if (alg == NULL)\n         return NULL;\n     if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\n         return NULL;\n    if (alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    return d2i_X509_ALGOR(NULL, &p, plen);\n}", "target": 1}
{"code": "alloc_downsampled_buffers(TIFF* tif, jpeg_component_info* comp_info,\n\t\t\t  int num_components)\n{\n\tJPEGState* sp = JState(tif);\n\tint ci;\n\tjpeg_component_info* compptr;\n\tJSAMPARRAY buf;\n\tint samples_per_clump = 0;\n\tfor (ci = 0, compptr = comp_info; ci < num_components;\n\t     ci++, compptr++) {\n\t\tsamples_per_clump += compptr->h_samp_factor *\n\t\t\tcompptr->v_samp_factor;\n\t\tbuf = TIFFjpeg_alloc_sarray(sp, JPOOL_IMAGE,\n\t\t\t\tcompptr->width_in_blocks * DCTSIZE,\n\t\t\t\t(JDIMENSION) (compptr->v_samp_factor*DCTSIZE));\n\t\tif (buf == NULL)\n\t\t\treturn (0);\n\t\tsp->ds_buffer[ci] = buf;\n\t}\n\tsp->samplesperclump = samples_per_clump;\n\treturn (1);\n}", "target": 0}
{"code": "void WebContentsImpl::DidFailProvisionalLoadWithError(\n    RenderViewHost* render_view_host,\n    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {\n  VLOG(1) << \"Failed Provisional Load: \" << params.url.possibly_invalid_spec()\n          << \", error_code: \" << params.error_code\n          << \", error_description: \" << params.error_description\n          << \", is_main_frame: \" << params.is_main_frame\n          << \", showing_repost_interstitial: \" <<\n            params.showing_repost_interstitial\n          << \", frame_id: \" << params.frame_id;\n  GURL validated_url(params.url);\n  RenderProcessHost* render_process_host =\n      render_view_host->GetProcess();\n  RenderViewHost::FilterURL(render_process_host, false, &validated_url);\n  if (net::ERR_ABORTED == params.error_code) {\n    if (ShowingInterstitialPage()) {\n      LOG(WARNING) << \"Discarding message during interstitial.\";\n      return;\n    }\n    render_manager_.RendererAbortedProvisionalLoad(render_view_host);\n  }\n  if (controller_.GetPendingEntry() != controller_.GetVisibleEntry())\n    controller_.DiscardPendingEntry();\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    DidFailProvisionalLoad(params.frame_id,\n                                           params.is_main_frame,\n                                           validated_url,\n                                           params.error_code,\n                                           params.error_description,\n                                           render_view_host));\n}", "target": 0}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static void ldapsrv_process_call_trigger(struct tevent_req *req,\n\t\t\t\t\t void *private_data)\n{\n\tstruct ldapsrv_process_call_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct ldapsrv_process_call_state);\n\tstruct ldapsrv_connection *conn = state->call->conn;\n\tNTSTATUS status;\n\tif (conn->deferred_expire_disconnect != NULL) {\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tstatus = ldapsrv_do_call(state->call);\n\tif (NT_STATUS_EQUAL(status, NT_STATUS_NETWORK_SESSION_EXPIRED)) {\n\t\tint defer_msec = lpcfg_parm_int(\n\t\t\tconn->lp_ctx,\n\t\t\tNULL,\n\t\t\t\"ldap_server\",\n\t\t\t\"delay_expire_disconnect\",\n\t\t\t0);\n\t\tconn->deferred_expire_disconnect = tevent_wakeup_send(\n\t\t\tconn,\n\t\t\tconn->connection->event.ctx,\n\t\t\ttimeval_current_ofs_msec(defer_msec));\n\t\tif (tevent_req_nomem(conn->deferred_expire_disconnect, req)) {\n\t\t\treturn;\n\t\t}\n\t\ttevent_req_set_callback(\n\t\t\tconn->deferred_expire_disconnect,\n\t\t\tldapsrv_disconnect_ticket_expired,\n\t\t\tconn);\n\t\ttevent_req_done(req);\n\t\treturn;\n\t}\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\ttevent_req_done(req);\n}", "target": 0}
{"code": "    CiffComponent* CiffComponent::doFindComponent(uint16_t crwTagId,\n                                                  uint16_t crwDir) const\n    {\n        if (tagId() == crwTagId && dir() == crwDir) {\n            return const_cast<CiffComponent*>(this);\n        }\n        return 0;\n    } ", "target": 0}
{"code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_lo_write)\n{\n  \tzval *pgsql_id;\n  \tchar *str;\n  \tlong z_len;\n\tint str_len, nbytes;\n\tint len;\n\tpgLofp *pgsql;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"rs|l\", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc > 2) {\n\t\tif (z_len > str_len) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot write more than buffer size %d. Tried to write %ld\", str_len, z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (z_len < 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Buffer size must be larger than 0, but %ld was specified\", z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tlen = z_len;\n\t}\n\telse {\n\t\tlen = str_len;\n\t}\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, &pgsql_id, -1, \"PostgreSQL large object\", le_lofp);\n\tif ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(nbytes);\n}", "target": 0}
{"code": "int register_power_pmu(struct power_pmu *pmu)\n{\n\tif (ppmu)\n\t\treturn -EBUSY;\t\t\n\tppmu = pmu;\n\tpr_info(\"%s performance monitor hardware support registered\\n\",\n\t\tpmu->name);\n#ifdef MSR_HV\n\tif (mfmsr() & MSR_HV)\n\t\tfreeze_events_kernel = MMCR0_FCHV;\n#endif \n\tperf_pmu_register(&power_pmu, \"cpu\", PERF_TYPE_RAW);\n\tperf_cpu_notifier(power_pmu_notifier);\n\treturn 0;\n}", "target": 0}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "     **/\n    CImg<T>& min(const T& val) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=65536))\n      cimg_rof(*this,ptrd,T) *ptrd = std::min(*ptrd,val);\n      return *this;", "target": 0}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n \tint err;\n\terr = crypto_ahash_export(req, state);\n \tif (err)\n \t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = 1;\n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "void OverlayWindowViews::OnGestureEvent(ui::GestureEvent* event) {\n  if (event->type() != ui::ET_GESTURE_TAP)\n    return;\n  hide_controls_timer_.Reset();\n  if (!GetControlsScrimLayer()->visible()) {\n    UpdateControlsVisibility(true);\n    return;\n  }\n  if (GetCloseControlsBounds().Contains(event->location())) {\n    controller_->Close(true ,\n                       true );\n    event->SetHandled();\n  } else if (GetPlayPauseControlsBounds().Contains(event->location())) {\n     TogglePlayPause();\n     event->SetHandled();\n   }\n }", "target": 0}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "bool red_stream_write_all(RedStream *stream, const void *in_buf, size_t n)\n{\n    const uint8_t *buf = (uint8_t *)in_buf;\n    while (n) {\n        int now = red_stream_write(stream, buf, n);\n        if (now <= 0) {\n            if (now == -1 && (errno == EINTR || errno == EAGAIN)) {\n                continue;\n            }\n            return false;\n        }\n        n -= now;\n        buf += now;\n    }\n    return true;\n}", "target": 0}
{"code": "void limit_output_verbosity(int level)\n{\n\tshort info_limits[COUNT_INFO], debug_limits[COUNT_DEBUG];\n\tint j;\n\tif (level > MAX_VERBOSITY)\n\t\treturn;\n\tmemset(info_limits, 0, sizeof info_limits);\n\tmemset(debug_limits, 0, sizeof debug_limits);\n\tfor (j = 1; j <= level; j++) {\n\t\tparse_output_words(info_words, info_limits, info_verbosity[j], LIMIT_PRIORITY);\n\t\tparse_output_words(debug_words, debug_limits, debug_verbosity[j], LIMIT_PRIORITY);\n\t}\n\tfor (j = 0; j < COUNT_INFO; j++) {\n\t\tif (info_levels[j] > info_limits[j])\n\t\t\tinfo_levels[j] = info_limits[j];\n\t}\n\tfor (j = 0; j < COUNT_DEBUG; j++) {\n\t\tif (debug_levels[j] > debug_limits[j])\n\t\t\tdebug_levels[j] = debug_limits[j];\n\t}\n}", "target": 0}
{"code": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (!fio_old_sig_int.sa_handler)\n    return;\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static void kvm_mmu_notifier_invalidate_page(struct mmu_notifier *mn,\n\t\t\t\t\t     struct mm_struct *mm,\n\t\t\t\t\t     unsigned long address)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint need_tlb_flush, idx;\n\tidx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\tkvm->mmu_notifier_seq++;\n\tneed_tlb_flush = kvm_unmap_hva(kvm, address) | kvm->tlbs_dirty;\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tif (need_tlb_flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}", "target": 0}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}", "target": 0}
{"code": "int ssh_scp_close(ssh_scp scp)\n{\n    char buffer[128] = {0};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->channel != NULL) {\n        if (ssh_channel_send_eof(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        while (!ssh_channel_is_eof(scp->channel)) {\n            rc = ssh_channel_read(scp->channel, buffer, sizeof(buffer), 0);\n            if (rc == SSH_ERROR || rc == 0) {\n                break;\n            }\n        }\n        if (ssh_channel_close(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        ssh_channel_free(scp->channel);\n        scp->channel = NULL;\n    }\n    scp->state = SSH_SCP_NEW;\n    return SSH_OK;\n}", "target": 0}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tint len;\n\tint new_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + ppp->dev->hard_header_len;\n\tint compressor_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + PPP_HDRLEN;\n\tnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"PPP: no memory (comp pkt)\\n\");\n\t\treturn NULL;\n\t}\n\tif (ppp->dev->hard_header_len > PPP_HDRLEN)\n\t\tskb_reserve(new_skb,\n\t\t\t    ppp->dev->hard_header_len - PPP_HDRLEN);\n\tlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\n\t\t\t\t   new_skb->data, skb->len + 2,\n\t\t\t\t   compressor_skb_size);\n\tif (len > 0 && (ppp->flags & SC_CCP_UP)) {\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t\n\t} else if (len == 0) {\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = skb;\n\t} else {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"ppp: compressor dropped pkt\\n\");\n\t\tkfree_skb(skb);\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = NULL;\n\t}\n\treturn new_skb;\n}", "target": 0}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}", "target": 1}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "ppp_input(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct channel *pch = chan->ppp;\n\tint proto;\n\tif (!pch || skb->len == 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = PPP_PROTO(skb);\n\tread_lock_bh(&pch->upl);\n\tif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\n\t\tskb_queue_tail(&pch->file.rq, skb);\n\t\twhile (pch->file.rq.qlen > PPP_MAX_RQLEN\n\t\t       && (skb = skb_dequeue(&pch->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\twake_up_interruptible(&pch->file.rwait);\n\t} else {\n\t\tppp_do_recv(pch->ppp, skb, pch);\n\t}\n\tread_unlock_bh(&pch->upl);\n}", "target": 0}
{"code": "  Declaration_Obj Parser::parse_declaration() {\n    String_Obj prop;\n    bool is_custom_property = false;\n    if (lex< sequence< optional< exactly<'*'> >, identifier_schema > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = parse_identifier_schema();\n    }\n    else if (lex< sequence< optional< exactly<'*'> >, identifier, zero_plus< block_comment > > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    else {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"}\\\", was \");\n    }\n    bool is_indented = true;\n    const std::string property(lexed);\n    if (!lex_css< one_plus< exactly<':'> > >()) error(\"property \\\"\" + escape_string(property)  + \"\\\" must be followed by a ':'\");\n    if (!is_custom_property && match< sequence< optional_css_comments, exactly<';'> > >()) error(\"style declaration must contain a value\");\n    if (match< sequence< optional_css_comments, exactly<'{'> > >()) is_indented = false; \n    if (is_custom_property) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_css_variable_value(), false, true);\n    }\n    lex < css_comments >(false);\n    if (peek_css< static_value >()) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_static_value());\n    }\n    else {\n      Expression_Obj value;\n      Lookahead lookahead = lookahead_for_value(position);\n      if (lookahead.found) {\n        if (lookahead.has_interpolants) {\n          value = parse_value_schema(lookahead.found);\n        } else {\n          value = parse_list(DELAYED);\n        }\n      }\n      else {\n        value = parse_list(DELAYED);\n        if (List* list = Cast<List>(value)) {\n          if (!list->is_bracketed() && list->length() == 0 && !peek< exactly <'{'> >()) {\n            css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n          }\n        }\n      }\n      lex < css_comments >(false);\n      Declaration_Obj decl = SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, value);\n      decl->is_indented(is_indented);\n      decl->update_pstate(pstate);\n      return decl;\n    }\n  }", "target": 0}
{"code": "static int iommu_no_mapping(struct device *dev)\n{\n\tint found;\n\tif (iommu_dummy(dev))\n\t\treturn 1;\n\tif (!iommu_identity_mapping)\n\t\treturn 0;\n\tfound = identity_mapping(dev);\n\tif (found) {\n\t\tif (iommu_should_identity_map(dev, 0))\n\t\t\treturn 1;\n\t\telse {\n\t\t\tdmar_remove_one_dev_info(si_domain, dev);\n\t\t\tpr_info(\"32bit %s uses non-identity mapping\\n\",\n\t\t\t\tdev_name(dev));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (iommu_should_identity_map(dev, 0)) {\n\t\t\tint ret;\n\t\t\tret = domain_add_dev_info(si_domain, dev);\n\t\t\tif (!ret) {\n\t\t\t\tpr_info(\"64bit %s uses identity mapping\\n\",\n\t\t\t\t\tdev_name(dev));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "GF_Err prhd_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProjectionHeaderBox *ptr = (GF_ProjectionHeaderBox *)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->yaw);\n\tgf_bs_write_u32(bs, ptr->pitch);\n\tgf_bs_write_u32(bs, ptr->roll);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock_bh(hdev);\n\terr = -ENOMEM;\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\tbacpy(src, conn->src);\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}", "target": 0}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  \n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  \n    }\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, uint32_t samples, FLAC__bool is_last_block)\n{\n\tconst FLAC__byte *buffer;\n\tsize_t bytes;\n\tFLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));\n\tif(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;\n\t\treturn false;\n\t}\n\tif(encoder->protected_->verify) {\n\t\tencoder->private_->verify.output.data = buffer;\n\t\tencoder->private_->verify.output.bytes = bytes;\n\t\tif(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {\n\t\t\tencoder->private_->verify.needs_magic_hack = true;\n\t\t}\n\t\telse {\n\t\t\tif(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {\n\t\t\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\t\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\t\t\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)\n\t\t\t\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {\n\t\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\t\tFLAC__bitwriter_clear(encoder->private_->frame);\n\t\tencoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;\n\t\treturn false;\n\t}\n\tFLAC__bitwriter_release_buffer(encoder->private_->frame);\n\tFLAC__bitwriter_clear(encoder->private_->frame);\n\tif(samples > 0) {\n\t\tencoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);\n\t\tencoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "bool SetExtendedFileAttribute(const char* path,\n                              const char* name,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \"Could not set extended attribute \" << name << \" on file \"\n                  << path;\n     return false;\n   }\n   return true;\n }", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "static int kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_cpuid2 *cpuid,\n\t\t\t\t     struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(&vcpu->arch.cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tupdate_cpuid(vcpu);\n\treturn 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n {\n \tint ret = 0;\n\tchar buf[65];\n \tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n \t\tint ndots = 0;\n \t\tunsigned v;\n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n \t}\n \treturn ret;\n }", "target": 1}
{"code": "    template<typename tp, typename tf, typename tc, typename to, typename tz>\n    CImg<T>& draw_object3d(LibBoard::Board& board,\n                           const float x0, const float y0, const float z0,\n                           const CImg<tp>& vertices, const CImgList<tf>& primitives,\n                           const CImgList<tc>& colors, const CImg<to>& opacities,\n                           const unsigned int render_type,\n                           const bool is_double_sided, const float focale,\n                           const float lightx, const float lighty, const float lightz,\n                           const float specular_lightness, const float specular_shininess,\n                           CImg<tz>& zbuffer) {\n      return _draw_object3d((void*)&board,zbuffer,x0,y0,z0,vertices,primitives,colors,opacities,\n                            render_type,is_double_sided,focale,lightx,lighty,lightz,\n                            specular_lightness,specular_shininess,1);", "target": 0}
{"code": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag, len;\n   uchar data[0x10000];\n   const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "static int dsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *public_key = NULL;\n    DSA *dsa = NULL;\n    if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\n        return 0;\n    X509_ALGOR_get0(NULL, &ptype, &pval, palg);\n    if (ptype == V_ASN1_SEQUENCE) {\n        pstr = pval;\n        pm = pstr->data;\n        pmlen = pstr->length;\n        if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen))) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n            goto err;\n        }\n    } else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {\n        if (!(dsa = DSA_new())) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);\n        goto err;\n    }\n    if (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n        goto err;\n    }\n    if (!(dsa->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);\n        goto err;\n    }\n    ASN1_INTEGER_free(public_key);\n    EVP_PKEY_assign_DSA(pkey, dsa);\n    return 1;\n err:\n    if (public_key)\n        ASN1_INTEGER_free(public_key);\n    if (dsa)\n        DSA_free(dsa);\n    return 0;\n}", "target": 0}
{"code": "read_yin_subnode(struct ly_ctx *ctx, struct lyxml_elem *node, const char *name)\n{\n    int len;\n    if (!node->child || !node->child->name || strcmp(node->child->name, name)) {\n        LOGERR(ctx, LY_EVALID, \"Expected \\\"%s\\\" element in \\\"%s\\\" element.\", name, node->name);\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, node->name);\n        return NULL;\n    } else if (node->child->content) {\n        len = strlen(node->child->content);\n        return lydict_insert(ctx, node->child->content, len);\n    } else {\n        return lydict_insert(ctx, \"\", 0);\n    }\n}", "target": 0}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "rb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}", "target": 0}
{"code": "void RenderView::willSubmitForm(WebFrame* frame, const WebFormElement& form) {\n  NavigationState* navigation_state =\n      NavigationState::FromDataSource(frame->provisionalDataSource());\n  if (navigation_state->transition_type() == PageTransition::LINK)\n    navigation_state->set_transition_type(PageTransition::FORM_SUBMIT);\n  WebSearchableFormData web_searchable_form_data(form);\n  navigation_state->set_searchable_form_url(web_searchable_form_data.url());\n  navigation_state->set_searchable_form_encoding(\n      web_searchable_form_data.encoding().utf8());\n  PasswordForm* password_form_data =\n      PasswordFormDomManager::CreatePasswordForm(form);\n  navigation_state->set_password_form_data(password_form_data);\n  if (password_form_data && password_form_data->password_value.empty()) {\n    NavigationState* old_navigation_state =\n        NavigationState::FromDataSource(frame->dataSource());\n    if (old_navigation_state) {\n      PasswordForm* old_form_data = old_navigation_state->password_form_data();\n      if (old_form_data && old_form_data->action == password_form_data->action)\n        password_form_data->password_value = old_form_data->password_value;\n    }\n  }\n  FormData form_data;\n  if (FormManager::WebFormElementToFormData(\n          form, FormManager::REQUIRE_AUTOCOMPLETE, true, &form_data))\n    Send(new ViewHostMsg_FormSubmitted(routing_id_, form_data));\n}", "target": 0}
{"code": "test_gui_mouse_event(dict_T *args)\n{\n    int\t\tbutton;\n    int\t\trow;\n    int\t\tcol;\n    int\t\trepeated_click;\n    int_u\tmods;\n    int\t\tmove;\n    if (!dict_has_key(args, \"row\")\n\t    || !dict_has_key(args, \"col\"))\n\treturn FALSE;\n    move = (int)dict_get_bool(args, \"move\", FALSE);\n    if (!move && (!dict_has_key(args, \"button\")\n\t    || !dict_has_key(args, \"multiclick\")\n\t    || !dict_has_key(args, \"modifiers\")))\n\treturn FALSE;\n    row = (int)dict_get_number(args, \"row\");\n    col = (int)dict_get_number(args, \"col\");\n    if (move)\n    {\n\tif (dict_get_bool(args, \"cell\", FALSE))\n\t{\n\t    row = row * gui.char_height + gui.char_height / 2;\n\t    col = col * gui.char_width + gui.char_width / 2;\n\t}\n\tgui_mouse_moved(col, row);\n    }\n    else\n    {\n\tbutton = (int)dict_get_number(args, \"button\");\n\trepeated_click = (int)dict_get_number(args, \"multiclick\");\n\tmods = (int)dict_get_number(args, \"modifiers\");\n\tmouse_set_hor_scroll_step(6);\n\tmouse_set_vert_scroll_step(3);\n\tgui_send_mouse_event(button, TEXT_X(col - 1), TEXT_Y(row - 1),\n\t\t\t\t\t\t\trepeated_click, mods);\n    }\n    return TRUE;\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "static int decode_transform_skip_flag(thread_context* tctx, int cIdx)\n{\n  const int context = (cIdx==0) ? 0 : 1;\n  logtrace(LogSlice,\"# transform_skip_flag (context=%d)\\n\",context);\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_TRANSFORM_SKIP_FLAG+context]);\n  logtrace(LogSymbols,\"$1 transform_skip_flag=%d\\n\",bit);\n  return bit;\n}", "target": 0}
{"code": "xmlCreateMemoryParserCtxt(const char *buffer, int size) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr input;\n    xmlParserInputBufferPtr buf;\n    if (buffer == NULL)\n\treturn(NULL);\n    if (size <= 0)\n\treturn(NULL);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt == NULL)\n\treturn(NULL);\n    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (buf == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input = xmlNewInputStream(ctxt);\n    if (input == NULL) {\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input->filename = NULL;\n    input->buf = buf;\n    xmlBufResetInput(input->buf->buffer, input);\n    inputPush(ctxt, input);\n    return(ctxt);\n}", "target": 0}
{"code": "static void TIFFErrors(const char *module,const char *format,va_list error)\n{\n  char\n    message[MagickPathExtent];\n  ExceptionInfo\n    *exception;\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  (void) vsnprintf(message,MagickPathExtent,format,error);\n#else\n  (void) vsprintf(message,format,error);\n#endif\n  (void) ConcatenateMagickString(message,\".\",MagickPathExtent);\n  exception=(ExceptionInfo *) GetMagickThreadValue(tiff_exception);\n  if (exception != (ExceptionInfo *) NULL)\n    (void) ThrowMagickException(exception,GetMagickModule(),CoderError,message,\n      \"`%s'\",module);\n}", "target": 0}
{"code": "u32 gf_fs_get_http_rate(GF_FilterSession *fs)\n{\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return 0;\n\t}\n\treturn gf_dm_get_global_rate(fs->download_manager);\n}", "target": 0}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "snmp_process_data(void)\n{\n  static unsigned char packet[SNMP_MAX_PACKET_SIZE];\n  unsigned char *packet_end;\n  static uint32_t packet_len;\n  packet_end = packet + sizeof(packet) - 1;\n  packet_len = 0;\n  LOG_DBG(\"receiving UDP datagram from [\");\n  LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_DBG_(\"]:%u\", uip_ntohs(UIP_UDP_BUF->srcport));\n  LOG_DBG_(\" Length: %u\\n\", uip_datalen());\n  if((packet_end = snmp_engine(uip_appdata, uip_datalen(), packet_end, &packet_len)) == NULL) {\n    LOG_DBG(\"Error while handling the request\\n\");\n  } else {\n    LOG_DBG(\"Sending response\\n\");\n    uip_udp_packet_sendto(snmp_udp_conn, packet_end, packet_len, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);\n  }\n}", "target": 1}
{"code": "void HTMLSelectElement::recalcListItems(bool updateSelectedStates) const\n{\n    m_listItems.clear();\n    m_shouldRecalcListItems = false;\n    HTMLOptionElement* foundSelected = 0;\n    HTMLOptionElement* firstOption = 0;\n    for (Element* currentElement = ElementTraversal::firstWithin(*this); currentElement; ) {\n        if (!currentElement->isHTMLElement()) {\n            currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);\n            continue;\n        }\n        HTMLElement& current = toHTMLElement(*currentElement);\n        if (current.hasTagName(optgroupTag)) {\n            m_listItems.append(&current);\n            if (Element* nextElement = ElementTraversal::firstWithin(current)) {\n                currentElement = nextElement;\n                continue;\n            }\n        }\n        if (current.hasTagName(optionTag)) {\n            m_listItems.append(&current);\n            if (updateSelectedStates && !m_multiple) {\n                HTMLOptionElement& option = toHTMLOptionElement(current);\n                if (!firstOption)\n                    firstOption = &option;\n                if (option.selected()) {\n                    if (foundSelected)\n                        foundSelected->setSelectedState(false);\n                    foundSelected = &option;\n                } else if (m_size <= 1 && !foundSelected && !option.isDisabledFormControl()) {\n                    foundSelected = &option;\n                    foundSelected->setSelectedState(true);\n                }\n            }\n        }\n        if (current.hasTagName(hrTag))\n            m_listItems.append(&current);\n        currentElement = ElementTraversal::nextSkippingChildren(*currentElement, this);\n    }\n    if (!foundSelected && m_size <= 1 && firstOption && !firstOption->selected())\n        firstOption->setSelectedState(true);\n}", "target": 0}
{"code": "static ha_rows get_quick_record_count(THD *thd, SQL_SELECT *select,\n\t\t\t\t      TABLE *table,\n\t\t\t\t      const key_map *keys,ha_rows limit)\n{\n  int error;\n  DBUG_ENTER(\"get_quick_record_count\");\n  uchar buff[STACK_BUFF_ALLOC];\n  if (check_stack_overrun(thd, STACK_MIN_SIZE, buff))\n    DBUG_RETURN(0);                           \n  if (select)\n  {\n    select->head=table;\n    table->reginfo.impossible_range=0;\n    if ((error= select->test_quick_select(thd, *(key_map *)keys,(table_map) 0,\n                                          limit, 0, FALSE, \n                                          TRUE )) == 1)\n      DBUG_RETURN(select->quick->records);\n    if (error == -1)\n    {\n      table->reginfo.impossible_range=1;\n      DBUG_RETURN(0);\n    }\n    DBUG_PRINT(\"warning\",(\"Couldn't use record count on const keypart\"));\n  }\n  DBUG_RETURN(HA_POS_ERROR);\t\t\t\n}", "target": 0}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static int check_reg_arg(struct bpf_verifier_env *env, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_func_state *state = vstate->frame[vstate->curframe];\n\tstruct bpf_insn *insn = env->prog->insnsi + env->insn_idx;\n\tstruct bpf_reg_state *reg, *regs = state->regs;\n\tbool rw64;\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(env, \"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\tmark_reg_scratched(env, regno);\n\treg = &regs[regno];\n\trw64 = is_reg64(env, insn, regno, reg, t);\n\tif (t == SRC_OP) {\n\t\tif (reg->type == NOT_INIT) {\n\t\t\tverbose(env, \"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (regno == BPF_REG_FP)\n\t\t\treturn 0;\n\t\tif (rw64)\n\t\t\tmark_insn_zext(env, reg);\n\t\treturn mark_reg_read(env, reg, reg->parent,\n\t\t\t\t     rw64 ? REG_LIVE_READ64 : REG_LIVE_READ32);\n\t} else {\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(env, \"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\treg->live |= REG_LIVE_WRITTEN;\n\t\treg->subreg_def = rw64 ? DEF_NOT_SUBREG : env->insn_idx + 1;\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown(env, regs, regno);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1}
{"code": "static int madvise_need_mmap_write(int behavior)\n{\n\tswitch (behavior) {\n\tcase MADV_REMOVE:\n\tcase MADV_WILLNEED:\n\tcase MADV_DONTNEED:\n\tcase MADV_COLD:\n\tcase MADV_PAGEOUT:\n\tcase MADV_FREE:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 0}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}", "target": 1}
{"code": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\tif(d_len<8) return;\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}", "target": 1}
{"code": "dcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n}", "target": 0}
{"code": "static int parse_line(char *str)\n{\n\tuint8_t array[256];\n\tuint16_t value, pskey, length = 0;\n\tchar *off, *end;\n\tpskey = strtol(str + 1, NULL, 16);\n\toff = strstr(str, \"=\");\n\tif (!off)\n\t\treturn -EIO;\n\toff++;\n\twhile (1) {\n\t\tvalue = strtol(off, &end, 16);\n\t\tif (value == 0 && off == end)\n\t\t\tbreak;\n\t\tarray[length++] = value & 0xff;\n\t\tarray[length++] = value >> 8;\n\t\tif (*end == '\\0')\n\t\t\tbreak;\n\t\toff = end + 1;\n\t}\n\treturn psr_put(pskey, array, length);\n}", "target": 1}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, output_tensor));\n  auto result =\n      lookup->Lookup(context, key_tensor, output_tensor, default_value_tensor);\n  return result;\n}", "target": 1}
{"code": "std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 1}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n   EF_GBL->lineno = 1;\n   parse_options(argc, argv);\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n   load_tables();\n   load_constants();\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n   ef_debug(1, \"\\n\");\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}", "target": 1}
{"code": "const char *who_am_i(void)\n{\n\tif (am_starting_up)\n\t\treturn am_server ? \"server\" : \"client\";\n\treturn am_sender ? \"sender\"\n\t     : am_generator ? \"generator\"\n\t     : am_receiver ? \"receiver\"\n\t     : \"Receiver\"; \n}", "target": 0}
{"code": "static int cmd_noop(struct imap_client *client,\n\t\t    const struct imap_arg *args ATTR_UNUSED)\n{\n\tclient_send_reply(&client->common, IMAP_CMD_REPLY_OK,\n\t\t\t  \"NOOP completed.\");\n\treturn 1;\n}", "target": 0}
{"code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n    return has_optional || !has_any_optional;\n}", "target": 1}
{"code": "static void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}", "target": 0}
{"code": "xsltCompileLocationPathPattern(xsltParserContextPtr ctxt, int novar) {\n    SKIP_BLANKS;\n    if ((CUR == '/') && (NXT(1) == '/')) {\n\tNEXT;\n\tNEXT;\n\tctxt->comp->priority = 0.5;\t\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '/') {\n\tNEXT;\n\tSKIP_BLANKS;\n\tPUSH(XSLT_OP_ROOT, NULL, NULL, novar);\n\tif ((CUR != 0) && (CUR != '|')) {\n\t    PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t}\n    } else if (CUR == '*') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '@') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else {\n\txmlChar *name;\n\tname = xsltScanNCName(ctxt);\n\tif (name == NULL) {\n\t    xsltTransformError(NULL, NULL, NULL,\n\t\t    \"xsltCompileLocationPathPattern : Name expected\\n\");\n\t    ctxt->error = 1;\n\t    return;\n\t}\n \tSKIP_BLANKS;\n \tif ((CUR == '(') && !xmlXPathIsNodeType(name)) {\n \t    xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);\n \t    if ((CUR == '/') && (NXT(1) == '/')) {\n \t\tPUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n \t\tNEXT;\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    } else if (CUR == '/') {\n\t\tPUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    }\n\t    return;\n\t}\n\txsltCompileRelativePathPattern(ctxt, name, novar);\n    }\nerror:\n    return;\n}", "target": 1}
{"code": "static int memory_access_ok(struct vhost_dev *d, struct vhost_memory *mem,\n\t\t\t    int log_all)\n{\n\tint i;\n\tfor (i = 0; i < d->nvqs; ++i) {\n\t\tint ok;\n\t\tmutex_lock(&d->vqs[i].mutex);\n\t\tif (d->vqs[i].private_data)\n\t\t\tok = vq_memory_access_ok(d->vqs[i].log_base, mem,\n\t\t\t\t\t\t log_all);\n\t\telse\n\t\t\tok = 1;\n\t\tmutex_unlock(&d->vqs[i].mutex);\n\t\tif (!ok)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "acpi_status acpi_os_delete_cache(acpi_cache_t * cache)\n{\n\tkmem_cache_destroy(cache);\n\treturn (AE_OK);\n}", "target": 0}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "void SetLineWidth(double w) {\n    outpos +=\n    sprintf(outpos,\" %12.3f w\",w);\n}", "target": 1}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "int ip6_dst_hoplimit(struct dst_entry *dst)\n{\n\tint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\n\tif (hoplimit == 0) {\n\t\tstruct net_device *dev = dst->dev;\n\t\tstruct inet6_dev *idev;\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev)\n\t\t\thoplimit = idev->cnf.hop_limit;\n\t\telse\n\t\t\thoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\n\t\trcu_read_unlock();\n\t}\n\treturn hoplimit;\n}", "target": 0}
{"code": "static u32 *gen9_init_indirectctx_bb(struct intel_engine_cs *engine, u32 *batch)\n{\n\tstatic const struct lri lri[] = {\n\t\t{\n\t\t\tCOMMON_SLICE_CHICKEN2,\n\t\t\t__MASKED_FIELD(GEN9_DISABLE_GATHER_AT_SET_SHADER_COMMON_SLICE,\n\t\t\t\t       0),\n\t\t},\n\t\t{\n\t\t\tFF_SLICE_CHICKEN,\n\t\t\t__MASKED_FIELD(FF_SLICE_CHICKEN_CL_PROVOKING_VERTEX_FIX,\n\t\t\t\t       FF_SLICE_CHICKEN_CL_PROVOKING_VERTEX_FIX),\n\t\t},\n\t\t{\n\t\t\t_3D_CHICKEN3,\n\t\t\t__MASKED_FIELD(_3D_CHICKEN_SF_PROVOKING_VERTEX_FIX,\n\t\t\t\t       _3D_CHICKEN_SF_PROVOKING_VERTEX_FIX),\n\t\t}\n\t};\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_DISABLE;\n\tbatch = gen8_emit_flush_coherentl3_wa(engine, batch);\n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_FLUSH_L3 |\n\t\t\t\t       PIPE_CONTROL_STORE_DATA_INDEX |\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_QW_WRITE,\n\t\t\t\t       LRC_PPHWSP_SCRATCH_ADDR);\n\tbatch = emit_lri(batch, lri, ARRAY_SIZE(lri));\n\tif (HAS_POOLED_EU(engine->i915)) {\n\t\t*batch++ = GEN9_MEDIA_POOL_STATE;\n\t\t*batch++ = GEN9_MEDIA_POOL_ENABLE;\n\t\t*batch++ = 0x00777000;\n\t\t*batch++ = 0;\n\t\t*batch++ = 0;\n\t\t*batch++ = 0;\n\t}\n\t*batch++ = MI_ARB_ON_OFF | MI_ARB_ENABLE;\n\twhile ((unsigned long)batch % CACHELINE_BYTES)\n\t\t*batch++ = MI_NOOP;\n\treturn batch;\n}", "target": 0}
{"code": "uint32_t sftp_parse_handle(struct sftpjob *job, struct handleid *id) {\n  uint32_t len, rc;\n  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK || len != 8 ||\n     (rc = sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n     (rc = sftp_parse_uint32(job, &id->tag) != SSH_FX_OK))\n    return rc;\n  return SSH_FX_OK;\n}", "target": 1}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !strcasecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 0}
{"code": "bool DownloadItemImpl::CanOpenDownload() {\n   const bool is_complete = GetState() == DownloadItem::COMPLETE;\n   return (!IsDone() || is_complete) && !IsTemporary() &&\n         !file_externally_removed_;\n }", "target": 1}
{"code": "PHP_FUNCTION(abs) \n{\n\tzval **value;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &value) == FAILURE) {\n\t\treturn;\n\t}\n\tconvert_scalar_to_number_ex(value);\n\tif (Z_TYPE_PP(value) == IS_DOUBLE) {\n\t\tRETURN_DOUBLE(fabs(Z_DVAL_PP(value)));\n\t} else if (Z_TYPE_PP(value) == IS_LONG) {\n\t\tif (Z_LVAL_PP(value) == LONG_MIN) {\n\t\t\tRETURN_DOUBLE(-(double)LONG_MIN);\n\t\t} else {\n\t\t\tRETURN_LONG(Z_LVAL_PP(value) < 0 ? -Z_LVAL_PP(value) : Z_LVAL_PP(value));\n\t\t}\n\t}\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "void WebUIExtension::Send(gin::Arguments* args) {\n  blink::WebLocalFrame* frame;\n  RenderFrame* render_frame;\n  if (!ShouldRespondToRequest(&frame, &render_frame))\n    return;\n  std::string message;\n  if (!args->GetNext(&message)) {\n    args->ThrowError();\n    return;\n  }\n  if (base::EndsWith(message, \"RequiringGesture\",\n                     base::CompareCase::SENSITIVE) &&\n      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {\n    NOTREACHED();\n    return;\n  }\n  std::unique_ptr<base::ListValue> content;\n  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {\n    content.reset(new base::ListValue());\n  } else {\n    v8::Local<v8::Object> obj;\n    if (!args->GetNext(&obj)) {\n      args->ThrowError();\n      return;\n    }\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n   }\n  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),\n                                                frame->GetDocument().Url(),\n                                                message, *content));\n}", "target": 1}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "CLOSE_BRACKET_WITHOUT_ESC_WARN(ScanEnv* env, UChar* c)\n{\n  if (onig_warn == onig_null_warn) return ;\n  if (IS_SYNTAX_BV((env)->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED)) {\n      onig_syntax_warn(env, \"regular expression has '%s' without escape\", c);\n  }\n}", "target": 0}
{"code": "void HTMLMediaElement::SelectMediaResource() {\n  BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this << \")\";\n  enum Mode { kObject, kAttribute, kChildren, kNothing };\n  Mode mode = kNothing;\n  if (src_object_) {\n    mode = kObject;\n  } else if (FastHasAttribute(kSrcAttr)) {\n    mode = kAttribute;\n  } else if (HTMLSourceElement* element =\n                 Traversal<HTMLSourceElement>::FirstChild(*this)) {\n    mode = kChildren;\n    next_child_node_to_consider_ = element;\n    current_source_node_ = nullptr;\n  } else {\n    load_state_ = kWaitingForSource;\n    SetShouldDelayLoadEvent(false);\n    if (!GetWebMediaPlayer() || (ready_state_ < kHaveFutureData &&\n                                 ready_state_maximum_ < kHaveFutureData)) {\n      SetNetworkState(kNetworkEmpty);\n    } else {\n      UseCounter::Count(GetDocument(),\n                        WebFeature::kHTMLMediaElementEmptyLoadWithFutureData);\n    }\n    UpdateDisplayState();\n    BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                    << \"), nothing to load\";\n    return;\n  }\n  SetNetworkState(kNetworkLoading);\n  ScheduleEvent(event_type_names::kLoadstart);\n  switch (mode) {\n    case kObject:\n      LoadSourceFromObject();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \", using 'srcObject' attribute\";\n      break;\n    case kAttribute:\n      LoadSourceFromAttribute();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \"), using 'src' attribute url\";\n      break;\n    case kChildren:\n      LoadNextSourceChild();\n      BLINK_MEDIA_LOG << \"selectMediaResource(\" << (void*)this\n                      << \"), using source element\";\n      break;\n    default:\n      NOTREACHED();\n  }\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static inline struct sctp_ulpevent *sctp_ulpq_retrieve_partial(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos, *last_frag, *first_frag;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 ctsn, next_tsn;\n\tint is_last;\n\tstruct sctp_ulpevent *retval;\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn NULL;\n\tlast_frag = first_frag = NULL;\n\tretval = NULL;\n\tnext_tsn = 0;\n\tis_last = 0;\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tnext_tsn = ctsn + 1;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else if (next_tsn == ctsn)\n\t\t\t\tnext_tsn++;\n\t\t\telse\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tfirst_frag = pos;\n\t\t\telse if (ctsn != next_tsn)\n\t\t\t\tgoto done;\n\t\t\tlast_frag = pos;\n\t\t\tis_last = 1;\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t};\n\t}\ndone:\n\tretval = sctp_make_reassembled_event(&ulpq->reasm, first_frag, last_frag);\n\tif (retval && is_last)\n\t\tretval->msg_flags |= MSG_EOR;\n\treturn retval;\n}", "target": 0}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "coolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n{\n    gx_device *dev_old = gs_currentdevice(pgs_old);\n    gx_device *dev_new;\n    gx_device *dev_t1;\n    gx_device *dev_t2;\n    bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice,\n        &gs_int_gstate(pgs_new)->pagedevice);\n    bool LockSafetyParams = dev_old->LockSafetyParams;\n    if ((dev_t1 = (*dev_proc(dev_old, get_page_device)) (dev_old)) == 0)\n        return 0;\n    if (!samepagedevice)\n        dev_old->LockSafetyParams = false;\n    dev_new = gs_currentdevice(pgs_new);\n    if (dev_old != dev_new) {\n        if ((dev_t2 = (*dev_proc(dev_new, get_page_device)) (dev_new)) == 0)\n            samepagedevice = true;\n        else if (dev_t1 != dev_t2)\n            samepagedevice = false;\n    }\n    if (LockSafetyParams) {\n        const int required_ops = 512;\n        const int required_es = 32;\n        if (required_ops + ref_stack_count(&o_stack) >= ref_stack_max_count(&o_stack)) {\n           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n           return_error(gs_error_stackoverflow);\n        }\n        if (required_es + ref_stack_count(&e_stack) >= ref_stack_max_count(&e_stack)) {\n           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n           return_error(gs_error_execstackoverflow);\n        }\n    }\n    return samepagedevice ? 0 : 1;\n}", "target": 0}
{"code": "struct page *vm_normal_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\tpte_t pte)\n{\n\tunsigned long pfn;\n\tif (HAVE_PTE_SPECIAL) {\n\t\tif (likely(!pte_special(pte))) {\n\t\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\t\treturn pte_page(pte);\n\t\t}\n\t\tVM_BUG_ON(!(vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP)));\n\t\treturn NULL;\n\t}\n\tpfn = pte_pfn(pte);\n\tif (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {\n\t\tif (vma->vm_flags & VM_MIXEDMAP) {\n\t\t\tif (!pfn_valid(pfn))\n\t\t\t\treturn NULL;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tunsigned long off;\n\t\t\toff = (addr - vma->vm_start) >> PAGE_SHIFT;\n\t\t\tif (pfn == vma->vm_pgoff + off)\n\t\t\t\treturn NULL;\n\t\t\tif (!is_cow_mapping(vma->vm_flags))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\tVM_BUG_ON(!pfn_valid(pfn));\nout:\n\treturn pfn_to_page(pfn);\n}", "target": 0}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n    {\n      FT_Byte*  p;\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n      if ( decoder->strike_index_array > face->sbit_table_size             ||\n           decoder->strike_index_array + 8 * decoder->strike_index_count >\n             face->sbit_table_size                                         )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }", "target": 1}
{"code": "const FunctionDef* FunctionLibraryDefinition::Find(const string& func) const {\n  tf_shared_lock l(mu_);\n  auto result = FindHelper(func);\n  if (result) {\n    return &result->fdef;\n  } else {\n    return nullptr;\n  }\n}", "target": 0}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "  int libraw_versionNumber() { return LibRaw::versionNumber(); }", "target": 0}
{"code": "PpapiPluginProcessHost* PpapiPluginProcessHost::CreateBrokerHost(\n    const content::PepperPluginInfo& info) {\n  PpapiPluginProcessHost* plugin_host =\n      new PpapiPluginProcessHost();\n  if (plugin_host->Init(info))\n    return plugin_host;\n  NOTREACHED();  \n  return NULL;\n}", "target": 0}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "static int page_outside_zone_boundaries(struct zone *zone, struct page *page)\n{\n\tint ret = 0;\n\tunsigned seq;\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long sp, start_pfn;\n\tdo {\n\t\tseq = zone_span_seqbegin(zone);\n\t\tstart_pfn = zone->zone_start_pfn;\n\t\tsp = zone->spanned_pages;\n\t\tif (!zone_spans_pfn(zone, pfn))\n\t\t\tret = 1;\n\t} while (zone_span_seqretry(zone, seq));\n\tif (ret)\n\t\tpr_err(\"page 0x%lx outside node %d zone %s [ 0x%lx - 0x%lx ]\\n\",\n\t\t\tpfn, zone_to_nid(zone), zone->name,\n\t\t\tstart_pfn, start_pfn + sp);\n\treturn ret;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImagePngCtxEx (im, out, -1);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\treturn rv;\n}", "target": 1}
{"code": "cdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\tsize_t name_len = strlen(name) + 1;\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == CDF_DIR_TYPE_USER_STREAM &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, name_len)\n\t\t    == 0)\n\t\t\tbreak;\n\tif (i == 0) {\n\t\tDPRINTF((\"Cannot find user stream `%s'\\n\", name));\n\t\terrno = ESRCH;\n\t\treturn -1;\n\t}\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}", "target": 0}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "Bool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}", "target": 0}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": " MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "int nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "gif_main_loop (GifContext *context)\n{\n\tgint retval = 0;\n\tdo {\n\t\tswitch (context->state) {\n\t\tcase GIF_START:\n                        LOG(\"start\\n\");\n\t\t\tretval = gif_init (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP:\n                        LOG(\"get_colormap\\n\");\n\t\t\tretval = gif_get_colormap (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_NEXT_STEP:\n                        LOG(\"next_step\\n\");\n\t\t\tretval = gif_get_next_step (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_FRAME_INFO:\n                        LOG(\"frame_info\\n\");\n\t\t\tretval = gif_get_frame_info (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_EXTENSION:\n                        LOG(\"get_extension\\n\");\n\t\t\tretval = gif_get_extension (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP2:\n                        LOG(\"get_colormap2\\n\");\n\t\t\tretval = gif_get_colormap2 (context);\n\t\t\tif (retval == 0)\n\t\t\t\tgif_set_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_PREPARE_LZW:\n                        LOG(\"prepare_lzw\\n\");\n\t\t\tretval = gif_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_FILL_BUFFER:\n                        LOG(\"fill_buffer\\n\");\n\t\t\tretval = gif_lzw_fill_buffer (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_CLEAR_CODE:\n                        LOG(\"clear_code\\n\");\n\t\t\tretval = gif_lzw_clear_code (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_LZW:\n                        LOG(\"get_lzw\\n\");\n\t\t\tretval = gif_get_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_DONE:\n                        LOG(\"done\\n\");\n\t\tdefault:\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t};\n\t} while ((retval == 0) || (retval == -3));\n done:\n\treturn retval;\n}", "target": 0}
{"code": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}", "target": 1}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "push_partial_as_tag (GMarkupParseContext *context)\n{\n  GString *str = context->partial_chunk;\n  context->tag_stack = g_slist_concat (get_list_node (context, str->str), context->tag_stack);\n  context->tag_stack_gstr = g_slist_concat (get_list_node (context, str), context->tag_stack_gstr);\n  context->partial_chunk = NULL;\n}", "target": 0}
{"code": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\tdev->arg = dummy;\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\treturn 0;\n}", "target": 1}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n {\n     char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n     return 1;\n }", "target": 1}
{"code": "static void FNAME_DECL(compress_row0)(const PIXEL *cur_row, unsigned int width)\n{\n    DECLARE_STATE_VARIABLES;\n    const unsigned int bpc_mask = BPC_MASK;\n    int pos = 0;\n    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {\n        if (state->wmileft) {\n            FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + state->wmileft,\n                                          bppmask[state->wmidx], bpc_mask);\n            width -= state->wmileft;\n            pos += state->wmileft;\n        }\n        state->wmidx++;\n        set_wm_trigger(state);\n        state->wmileft = DEFwminext;\n    }\n    if (width) {\n        FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + width,\n                                      bppmask[state->wmidx], bpc_mask);\n        if (DEFwmimax > (int)state->wmidx) {\n            state->wmileft -= width;\n        }\n    }\n    spice_assert((int)state->wmidx <= DEFwmimax);\n    spice_assert(state->wmidx <= 32);\n    spice_assert(DEFwminext > 0);\n}", "target": 0}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "void in6_dev_finish_destroy(struct inet6_dev *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\tWARN_ON(!list_empty(&idev->addr_list));\n\tWARN_ON(idev->mc_list != NULL);\n\tWARN_ON(timer_pending(&idev->rs_timer));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %s\\n\", __func__, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead) {\n\t\tpr_warn(\"Freeing alive inet6 device %p\\n\", idev);\n\t\treturn;\n\t}\n\tsnmp6_free_dev(idev);\n\tkfree_rcu(idev, rcu);\n}", "target": 0}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, ContainedOrPathLevelMultikeyCannotCombineTrailingFields) {\n    MultikeyPaths multikeyPaths{{}, {0U}};\n    addIndex(BSON(\"b\" << 1 << \"a\" << 1), multikeyPaths);\n    addIndex(BSON(\"c\" << 1));\n    runQuery(\n        fromjson(\"{$and: [{a: {$gte: 0}}, {$or: [{$and: [{a: {$lte: 10}}, {b: 6}]}, {c: 7}]}]}\"));\n    assertNumSolutions(2);\n    std::vector<std::string> alternates;\n    alternates.push_back(\n        \"{fetch: {filter: {a: {$gte: 0}}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[-Infinity, 10, \"\n        \"true, true]]}}},\"\n        \"{ixscan: {pattern: {c: 1}, bounds: {c: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    alternates.push_back(\n        \"{fetch: {filter: {a: {$gte: 0}}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[0, Infinity, \"\n        \"true, true]]}}},\"\n        \"{ixscan: {pattern: {c: 1}, bounds: {c: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    assertHasOneSolutionOf(alternates);\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "yang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr *length;\n    if (is_ext_instance) {\n        length = (struct lys_restr *)stype;\n    } else {\n        if (stype->base == 0 || stype->base == LY_TYPE_STRING) {\n            stype->base = LY_TYPE_STRING;\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected length statement.\");\n            goto error;\n        }\n        if (stype->type->info.str.length) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"length\", \"type\");\n            goto error;\n        }\n        length = calloc(1, sizeof *length);\n        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);\n        stype->type->info.str.length = length;\n    }\n    length->expr = lydict_insert_zc(ctx, value);\n    return length;\nerror:\n    free(value);\n    return NULL;\n}", "target": 0}
{"code": "static void fts3EvalStartReaders(\n  Fts3Cursor *pCsr,               \n  Fts3Expr *pExpr,                \n  int *pRc                        \n){\n  if( pExpr && SQLITE_OK==*pRc ){\n    if( pExpr->eType==FTSQUERY_PHRASE ){\n      int i;\n      int nToken = pExpr->pPhrase->nToken;\n      for(i=0; i<nToken; i++){\n        if( pExpr->pPhrase->aToken[i].pDeferred==0 ) break;\n      }\n      pExpr->bDeferred = (i==nToken);\n      *pRc = fts3EvalPhraseStart(pCsr, 1, pExpr->pPhrase);\n    }else{\n      fts3EvalStartReaders(pCsr, pExpr->pLeft, pRc);\n      fts3EvalStartReaders(pCsr, pExpr->pRight, pRc);\n      pExpr->bDeferred = (pExpr->pLeft->bDeferred && pExpr->pRight->bDeferred);\n    }\n  }\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "GF_Err srpp_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->info = (GF_SchemeInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tif (ptr->scheme_type) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->scheme_type = (GF_SchemeTypeBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_ablkcipher *skcipher;\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tskcipher = crypto_alloc_ablkcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\ttfm->skcipher = skcipher;\n\treturn tfm;\n}", "target": 0}
{"code": "int phar_is_tar(char *buf, char *fname) \n{\n\ttar_header *header = (tar_header *) buf;\n\tphp_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tphp_uint32 ret;\n\tchar save[sizeof(header->checksum)], *bname;\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif ((bname = strrchr(fname, PHP_DIR_SEPARATOR))) {\n\t\tfname = bname;\n\t}\n\tif (!ret && (bname = strstr(fname, \".tar\")) && (bname[4] == '\\0' || bname[4] == '.')) {\n\t\treturn 1;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "void PDPServer::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    static_cast<void>(pdata);\n#if HAVE_SECURITY\n    match_reliable_pdp_endpoints(pdata);\n#endif \n}", "target": 1}
{"code": "c_valid_gregorian_p(int y, int m, int d, int *rm, int *rd)\n{\n    int last;\n    if (m < 0)\n\tm += 13;\n    if (m < 1 || m > 12)\n\treturn 0;\n    last = c_gregorian_last_day_of_month(y, m);\n    if (d < 0)\n\td = last + d + 1;\n    if (d < 1 || d > last)\n\treturn 0;\n    *rm = m;\n    *rd = d;\n    return 1;\n}", "target": 0}
{"code": "cql_server::unadvertise_connection(shared_ptr<generic_server::connection> raw_conn) {\n    --_stats.connections;\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising disconnection of CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}", "target": 0}
{"code": "FILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "std::string TestURLLoader::TestUntendedLoad() {\n  pp::URLRequestInfo request(instance_);\n  request.SetURL(\"test_url_loader_data/hello.txt\");\n  request.SetRecordDownloadProgress(true);\n  TestCompletionCallback callback(instance_->pp_instance(), callback_type());\n  pp::URLLoader loader(instance_);\n  callback.WaitForResult(loader.Open(request, callback.GetCallback()));\n  CHECK_CALLBACK_BEHAVIOR(callback);\n  ASSERT_EQ(PP_OK, callback.result());\n  int64_t bytes_received = 0;\n  int64_t total_bytes_to_be_received = 0;\n  while (true) {\n     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);\n     if (total_bytes_to_be_received <= 0)\n       return ReportError(\"URLLoader::GetDownloadProgress total size\",\n          total_bytes_to_be_received);\n     if (bytes_received == total_bytes_to_be_received)\n       break;\n    if (pp::Module::Get()->core()->IsMainThread()) {\n      NestedEvent event(instance_->pp_instance());\n      event.PostSignal(10);\n      event.Wait();\n    }\n  }\n  std::string body;\n  std::string error = ReadEntireResponseBody(&loader, &body);\n  if (!error.empty())\n    return error;\n  if (body != \"hello\\n\")\n    return ReportError(\"Couldn't read data\", callback.result());\n  PASS();\n}", "target": 1}
{"code": "BOOL CSoundFile::GetPatternName(UINT nPat, LPSTR lpszName, UINT cbSize) const\n{\n\tif ((!lpszName) || (!cbSize)) return FALSE;\n\tlpszName[0] = 0;\n\tif (cbSize > MAX_PATTERNNAME) cbSize = MAX_PATTERNNAME;\n\tif ((m_lpszPatternNames) && (nPat < m_nPatternNames))\n\t{\n\t\tmemcpy(lpszName, m_lpszPatternNames + nPat * MAX_PATTERNNAME, cbSize);\n\t\tlpszName[cbSize-1] = 0;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_zoom_weak_set(Evas_Object* ewkView, float zoom, Evas_Coord centerX, Evas_Coord centerY)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET(smartData, priv);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->zoom_weak_set, false);\n    if (!priv->settings.zoomRange.userScalable) {\n        WRN(\"userScalable is false\");\n        return false;\n    }\n    if (zoom < priv->settings.zoomRange.minScale) {\n        WRN(\"zoom level is < %f : %f\", priv->settings.zoomRange.minScale, zoom);\n        return false;\n    }\n    if (zoom > priv->settings.zoomRange.maxScale) {\n        WRN(\"zoom level is > %f : %f\", priv->settings.zoomRange.maxScale, zoom);\n        return false;\n    }\n    smartData->animated_zoom.zoom.start = ewk_frame_page_zoom_get(smartData->main_frame);\n    smartData->animated_zoom.zoom.end = zoom;\n    smartData->animated_zoom.zoom.current = zoom;\n    return smartData->api->zoom_weak_set(smartData, zoom, centerX, centerY);\n}", "target": 0}
{"code": "    void TiffImage::printStructure(std::ostream& out, Exiv2::PrintStructureOption option,int depth)\n    {\n        if (io_->open() != 0) throw Error(9, io_->path(), strError());\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(14);\n            throw Error(15);\n        }\n        io_->seek(0,BasicIo::beg);\n        printTiffStructure(io(),out,option,depth-1);\n    }", "target": 0}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "change_refs_to_tmp_fields(THD *thd, Ref_ptr_array ref_pointer_array,\n\t\t\t  List<Item> &res_selected_fields,\n\t\t\t  List<Item> &res_all_fields, uint elements,\n\t\t\t  List<Item> &all_fields)\n{\n  List_iterator_fast<Item> it(all_fields);\n  Item *item, *new_item;\n  res_selected_fields.empty();\n  res_all_fields.empty();\n  uint i, border= all_fields.elements - elements;\n  for (i= 0; (item= it++); i++)\n  {\n    if (item->type() == Item::SUM_FUNC_ITEM && item->const_item())\n      new_item= item;\n    else\n    {\n      if (!(new_item= item->get_tmp_table_item(thd)))\n        return 1;\n    }\n    if (res_all_fields.push_back(new_item, thd->mem_root))\n      return 1;\n    ref_pointer_array[((i < border)? all_fields.elements-i-1 : i-border)]=\n      new_item;\n  }\n  List_iterator_fast<Item> itr(res_all_fields);\n  for (i= 0; i < border; i++)\n    itr++;\n  itr.sublist(res_selected_fields, elements);\n  return thd->is_fatal_error;\n}", "target": 0}
{"code": "static GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\tif (!nl_size) return GF_OK;\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void _gnutls_handshake_internal_state_init(gnutls_session_t session)\n{\n\tsession->internals.adv_version_major = 0;\n\tsession->internals.adv_version_minor = 0;\n\tsession->internals.direction = 0;\n\tsession->internals.last_handshake_in = -1;\n\tsession->internals.last_handshake_out = -1;\n\tsession->internals.resumable = RESUME_TRUE;\n\tsession->internals.handshake_large_loops = 0;\n\tsession->internals.dtls.hsk_read_seq = 0;\n\tsession->internals.dtls.hsk_write_seq = 0;\n}", "target": 1}
{"code": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n   Process();\n   if (link_)\n    link_->OwnerInserted();\n  return kInsertionDone;\n}", "target": 1}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static spl_ptr_heap_element spl_ptr_heap_delete_top(spl_ptr_heap *heap, void *cmp_userdata TSRMLS_DC) { \n\tint i, j;\n\tconst int limit = (heap->count-1)/2;\n\tspl_ptr_heap_element top;\n\tspl_ptr_heap_element bottom;\n\tif (heap->count == 0) {\n\t\treturn NULL;\n\t}\n\ttop    = heap->elements[0];\n\tbottom = heap->elements[--heap->count];\n\tfor( i = 0; i < limit; i = j)\n\t{\n\t\tj = i*2+1;\n\t\tif(j != heap->count && heap->cmp(heap->elements[j+1], heap->elements[j], cmp_userdata TSRMLS_CC) > 0) {\n\t\t\tj++; \n\t\t}\n\t\tif(heap->cmp(bottom, heap->elements[j], cmp_userdata TSRMLS_CC) < 0) {\n\t\t\theap->elements[i] = heap->elements[j];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (EG(exception)) {\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\theap->elements[i] = bottom;\n\theap->dtor(top TSRMLS_CC);\n\treturn top;\n}", "target": 0}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}", "target": 1}
{"code": "onig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  ptrdiff_t addlen = end - s;\n  if (addlen > 0) {\n    ptrdiff_t len  = NSTR(node)->end - NSTR(node)->s;\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      ptrdiff_t capa = len + addlen + NODE_STR_MARGIN;\n      if (capa <= NSTR(node)->capa) {\n\tonig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n\tif (NSTR(node)->s == NSTR(node)->buf)\n\t  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n\t\t\t\t      s, end, capa);\n\telse\n\t  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\tNSTR(node)->s    = p;\n\tNSTR(node)->capa = (int )capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n  return 0;\n}", "target": 0}
{"code": "get_pw_flags (NMSettingVpn *s_vpn, const char *secret_name, const char *type_name)\n{\n\tconst char *val;\n\tNMSettingSecretFlags flags = NM_SETTING_SECRET_FLAG_NONE;\n\tif (nm_setting_get_secret_flags (NM_SETTING (s_vpn), secret_name, &flags, NULL))\n\t\treturn flags;\n\tval = nm_setting_vpn_get_data_item (s_vpn, type_name);\n\tif (val) {\n\t\tif (g_strcmp0 (val, NM_VPNC_PW_TYPE_ASK) == 0)\n\t\t\treturn NM_SETTING_SECRET_FLAG_NOT_SAVED;\n\t\telse if (g_strcmp0 (val, NM_VPNC_PW_TYPE_UNUSED) == 0)\n\t\t\treturn NM_SETTING_SECRET_FLAG_NOT_REQUIRED;\n\t}\n\treturn NM_SETTING_SECRET_FLAG_NONE;\n}", "target": 0}
{"code": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}", "target": 1}
{"code": "static int cma_addr_cmp(const struct sockaddr *src, const struct sockaddr *dst)\n{\n\tif (src->sa_family != dst->sa_family)\n\t\treturn -1;\n\tswitch (src->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *)src)->sin_addr.s_addr !=\n\t\t       ((struct sockaddr_in *)dst)->sin_addr.s_addr;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *)src;\n\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *)dst;\n\t\tbool link_local;\n\t\tif (ipv6_addr_cmp(&src_addr6->sin6_addr,\n\t\t\t\t\t  &dst_addr6->sin6_addr))\n\t\t\treturn 1;\n\t\tlink_local = ipv6_addr_type(&dst_addr6->sin6_addr) &\n\t\t\t     IPV6_ADDR_LINKLOCAL;\n\t\treturn link_local ? (src_addr6->sin6_scope_id !=\n\t\t\t\t     dst_addr6->sin6_scope_id) :\n\t\t\t\t    0;\n\t}\n\tdefault:\n\t\treturn ib_addr_cmp(&((struct sockaddr_ib *) src)->sib_addr,\n\t\t\t\t   &((struct sockaddr_ib *) dst)->sib_addr);\n\t}\n}", "target": 0}
{"code": "static __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\treturn err_code;\n}", "target": 0}
{"code": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "std::string utf16ToUtf8(const StringPiece16& utf16) {\n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());\n if (utf8Length <= 0) {\n return {};\n     }\n     std::string utf8;\n     utf8.resize(utf8Length);\n    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());\n     return utf8;\n }", "target": 1}
{"code": "static MOVFragmentStreamInfo *get_frag_stream_info_from_pkt(MOVFragmentIndex *frag_index, AVPacket *pkt, int id)\n{\n    int current = frag_index->current;\n    if (!frag_index->nb_items)\n        return NULL;\n    if (current >= 0 && current < frag_index->nb_items) {\n        if (frag_index->item[current].moof_offset < pkt->pos &&\n            (current + 1 == frag_index->nb_items ||\n             frag_index->item[current + 1].moof_offset > pkt->pos))\n            return get_frag_stream_info(frag_index, current, id);\n    }\n    for (int i = 0; i < frag_index->nb_items; i++) {\n        if (frag_index->item[i].moof_offset > pkt->pos)\n            break;\n        current = i;\n    }\n    frag_index->current = current;\n    return get_frag_stream_info(frag_index, current, id);\n}", "target": 0}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tpid_t wait_pid;\n\tint wstatus = 0;\n\tif (!fp)\n\t\treturn -1;\n\tdo {\n\t\twait_pid = waitpid(fp->child_pid, &wstatus, 0);\n\t} while (wait_pid < 0 && errno == EINTR);\n\tfclose(fp->f);\n\tfree(fp);\n\tif (wait_pid < 0)\n\t\treturn -1;\n\treturn wstatus;\n}", "target": 0}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n     }\n     case SEEK_CUR:\n     {\n       if ((profile->offset+offset) < 0)\n         return(-1);\n       profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n  return(profile->offset);\n}", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "void nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "void ScriptLoader::executeScript(const ScriptSourceCode& sourceCode)\n{\n    ASSERT(m_alreadyStarted);\n    if (sourceCode.isEmpty())\n        return;\n    RefPtr<Document> elementDocument(m_element->document());\n    RefPtr<Document> contextDocument = elementDocument->contextDocument().get();\n    if (!contextDocument)\n        return;\n    LocalFrame* frame = contextDocument->frame();\n    bool shouldBypassMainWorldContentSecurityPolicy = (frame && frame->script().shouldBypassMainWorldContentSecurityPolicy()) || elementDocument->contentSecurityPolicy()->allowScriptNonce(m_element->fastGetAttribute(HTMLNames::nonceAttr)) || elementDocument->contentSecurityPolicy()->allowScriptHash(sourceCode.source());\n     if (!m_isExternalScript && (!shouldBypassMainWorldContentSecurityPolicy && !elementDocument->contentSecurityPolicy()->allowInlineScript(elementDocument->url(), m_startLineNumber)))\n         return;\n    if (m_isExternalScript && m_resource && !m_resource->mimeTypeAllowedByNosniff()) {\n        contextDocument->addConsoleMessage(SecurityMessageSource, ErrorMessageLevel, \"Refused to execute script from '\" + m_resource->url().elidedString() + \"' because its MIME type ('\" + m_resource->mimeType() + \"') is not executable, and strict MIME type checking is enabled.\");\n        return;\n     }\n     if (frame) {\n        const bool isImportedScript = contextDocument != elementDocument;\n        IgnoreDestructiveWriteCountIncrementer ignoreDestructiveWriteCountIncrementer(m_isExternalScript || isImportedScript ? contextDocument.get() : 0);\n        if (isHTMLScriptLoader(m_element))\n            contextDocument->pushCurrentScript(toHTMLScriptElement(m_element));\n        AccessControlStatus corsCheck = NotSharableCrossOrigin;\n        if (sourceCode.resource() && sourceCode.resource()->passesAccessControlCheck(m_element->document().securityOrigin()))\n            corsCheck = SharableCrossOrigin;\n        frame->script().executeScriptInMainWorld(sourceCode, corsCheck);\n        if (isHTMLScriptLoader(m_element)) {\n            ASSERT(contextDocument->currentScript() == m_element);\n            contextDocument->popCurrentScript();\n        }\n    }\n}", "target": 1}
{"code": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n        if (conn->mandatory_signing) {\n                security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n        }\n        return security_mode;\n }", "target": 1}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "static int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint i, len, status = 0;\n\trpc_authflavor_t flav_array[NFS_MAX_SECFLAVORS];\n\tlen = rpcauth_list_flavors(flav_array, ARRAY_SIZE(flav_array));\n\tBUG_ON(len < 0);\n\tfor (i = 0; i < len; i++) {\n\t\tif (flav_array[i] == RPC_AUTH_UNIX)\n\t\t\tcontinue;\n\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info, flav_array[i]);\n\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}", "target": 0}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "static int adpt_close(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 0;\n\treturn 0;\n}", "target": 1}
{"code": "ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_nullfunc(hdr->frame_control))\n\t\treturn TX_DROP;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\treturn TX_CONTINUE;\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {\n\t\treturn TX_DROP;\n\t}\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CantUseHashedIndexToProvideSort) {\n    addIndex(BSON(\"x\"\n                  << \"hashed\"));\n    runQuerySortProj(BSONObj(), BSON(\"x\" << 1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen:\"\n        \"{node: {cscan: {dir: 1, filter: {}}}}}}}\");\n}", "target": 0}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "AudioFlinger::EffectChain::EffectChain(ThreadBase *thread,\n int sessionId)\n : mThread(thread), mSessionId(sessionId), mActiveTrackCnt(0), mTrackCnt(0), mTailBufferCount(0),\n      mOwnInBuffer(false), mVolumeCtrlIdx(-1), mLeftVolume(UINT_MAX), mRightVolume(UINT_MAX),\n      mNewLeftVolume(UINT_MAX), mNewRightVolume(UINT_MAX), mForceVolume(false)\n{\n    mStrategy = AudioSystem::getStrategyForStream(AUDIO_STREAM_MUSIC);\n if (thread == NULL) {\n return;\n }\n    mMaxTailBuffers = ((kProcessTailDurationMs * thread->sampleRate()) / 1000) /\n                                    thread->frameCount();\n}", "target": 0}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "static void cleanup_async_copy(struct nfsd4_copy *copy)\n{\n\tnfs4_free_cp_state(copy);\n\tfput(copy->file_dst);\n\tfput(copy->file_src);\n\tspin_lock(&copy->cp_clp->async_lock);\n\tlist_del(&copy->copies);\n\tspin_unlock(&copy->cp_clp->async_lock);\n\tnfs4_put_copy(copy);\n}", "target": 0}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": "set_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n    if (action == 't')\t\t    \n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t\n\t    tagstack_clear(wp);\n\ttagstack_push_items(wp, l);\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n    return OK;\n}", "target": 0}
{"code": "check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tret = check_entry((struct arpt_entry *)e);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}", "target": 1}
{"code": " static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "gtime2generalTime(time_t gtime, char *str_time, size_t str_time_size)\n{\n\tsize_t ret;\n\tstruct tm _tm;\n\tif (gtime == (time_t)-1\n#if SIZEOF_LONG == 8\n\t\t|| gtime >= 253402210800\n#endif\n\t ) {\n        \tsnprintf(str_time, str_time_size, \"99991231235959Z\");\n        \treturn 0;\n\t}\n\tif (!gmtime_r(&gtime, &_tm)) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\tret = strftime(str_time, str_time_size, \"%Y%m%d%H%M%SZ\", &_tm);\n\tif (!ret) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_SHORT_MEMORY_BUFFER;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\tulong2bebytes(&params.object_id[0], object_id);\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\treturn out_len;\nfail:\n\treturn r;\n}", "target": 0}
{"code": "int sldns_str2wire_eui48_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tunsigned int a, b, c, d, e, f;\n\tint l;\n\tif(*len < 6)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif (sscanf(str, \"%2x-%2x-%2x-%2x-%2x-%2x%n\",\n\t\t\t&a, &b, &c, &d, &e, &f, &l) != 6 ||\n\t\t\tl != (int)strlen(str))\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_EUI48;\n\trd[0] = a;\n\trd[1] = b;\n\trd[2] = c;\n\trd[3] = d;\n\trd[4] = e;\n\trd[5] = f;\n\t*len = 6;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "bool kvm_check_and_clear_guest_paused(void)\n{\n\tbool ret = false;\n\tstruct pvclock_vcpu_time_info *src;\n\tint cpu = smp_processor_id();\n\tif (!hv_clock)\n\t\treturn ret;\n\tsrc = &hv_clock[cpu].pvti;\n\tif ((src->flags & PVCLOCK_GUEST_STOPPED) != 0) {\n\t\tsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\n\t\tpvclock_touch_watchdogs();\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "decompileGOTOFRAME(int n, SWF_ACTION *actions,int maxn,int islabel)\n{\n\tint i=0;\n\tstruct SWF_ACTIONGOTOLABEL *sactv2;\n\tOUT_BEGIN2(SWF_ACTIONGOTOFRAME);\n\tsactv2 = (struct SWF_ACTIONGOTOLABEL*)sact;\n\tINDENT\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY)\n\t{\n\t\ti=1;\n\t\tputs(\"gotoAndPlay(\");\n\t}\n\telse\n\t{\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\ti=1;\n\t\tputs(\"gotoAndStop(\");\n\t}\n\tif (islabel)\n\t\tprintln(\"'%s');\", sactv2->FrameLabel);\n\telse\n\t\tprintln(\"%d);\", sact->Frame+1); \n\treturn i;\n}", "target": 0}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}", "target": 1}
{"code": "int RGWPutCORS_ObjStore_S3::get_params()\n{\n  int r;\n  char *data = nullptr;\n  int len = 0;\n  RGWCORSXMLParser_S3 parser(s->cct);\n  RGWCORSConfiguration_S3 *cors_config;\n  const auto max_size = s->cct->_conf->rgw_max_put_param_size;\n  r = rgw_rest_read_all_input(s, &data, &len, max_size, false);\n  if (r < 0) {\n    return r;\n  }\n  auto data_deleter = std::unique_ptr<char, decltype(free)*>{data, free};\n  r = do_aws4_auth_completion();\n  if (r < 0) {\n    return r;\n  }\n  if (!parser.init()) {\n    return -EINVAL;\n  }\n  if (!data || !parser.parse(data, len, 1)) {\n    return -EINVAL;\n  }\n  cors_config =\n    static_cast<RGWCORSConfiguration_S3 *>(parser.find_first(\n\t\t\t\t\t     \"CORSConfiguration\"));\n  if (!cors_config) {\n    return -EINVAL;\n  }\n#define CORS_RULES_MAX_NUM      100\n  int max_num = s->cct->_conf->rgw_cors_rules_max_num;\n  if (max_num < 0) {\n    max_num = CORS_RULES_MAX_NUM;\n  }\n  int cors_rules_num = cors_config->get_rules().size();\n  if (cors_rules_num > max_num) {\n    ldout(s->cct, 4) << \"An cors config can have up to \"\n                     << max_num\n                     << \" rules, request cors rules num: \"\n                     << cors_rules_num << dendl;\n    op_ret = -ERR_INVALID_CORS_RULES_ERROR;\n    s->err.message = \"The number of CORS rules should not exceed allowed limit of \"\n                     + std::to_string(max_num) + \" rules.\";\n    return -ERR_INVALID_REQUEST;\n  }\n  if (!store->is_meta_master()) {\n    in_data.append(data, len);\n  }\n  if (s->cct->_conf->subsys.should_gather<ceph_subsys_rgw, 15>()) {\n    ldout(s->cct, 15) << \"CORSConfiguration\";\n    cors_config->to_xml(*_dout);\n    *_dout << dendl;\n  }\n  cors_config->encode(cors_bl);\n  return 0;\n}", "target": 0}
{"code": "void PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n  d_startrecordpos=d_pos; \n  d_recordlen=ah.d_clen;\n}", "target": 0}
{"code": "QPDF::resolve(int objid, int generation)\n{\n    QPDFObjGen og(objid, generation);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    return new QPDF_Null;\n\t}\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n    return this->obj_cache[og].object;\n}", "target": 1}
{"code": "TEST(HeaderMapImplTest, TestAppendHeader) {\n  {\n    TestRequestHeaderMapImpl headers;\n    LowerCaseString foo(\"key1\");\n    headers.addCopy(foo, \"some;\");\n    headers.appendCopy(foo, \"test\");\n    EXPECT_EQ(headers.get(foo)->value().getStringView(), \"some;,test\");\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    LowerCaseString key2(\"key2\");\n    headers.appendCopy(key2, \"my tag data\");\n    EXPECT_EQ(headers.get(key2)->value().getStringView(), \"my tag data\");\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    LowerCaseString key3(\"key3\");\n    headers.addCopy(key3, \"empty\");\n    headers.appendCopy(key3, \"\");\n    EXPECT_EQ(headers.get(key3)->value().getStringView(), \"empty\");\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    const std::string empty;\n    headers.setPath(empty);\n    headers.appendPath(\" \", \",\");\n    headers.setPath(0);\n    EXPECT_EQ(\"0\", headers.getPathValue());\n    EXPECT_EQ(1U, headers.Path()->value().size());\n  }\n  {\n    TestRequestHeaderMapImpl headers;\n    headers.addCopy(Headers::get().Via, \"1.0 fred\");\n    EXPECT_EQ(headers.getViaValue(), \"1.0 fred\");\n    headers.appendCopy(Headers::get().Via, \"1.1 p.example.net\");\n    EXPECT_EQ(headers.getViaValue(), \"1.0 fred,1.1 p.example.net\");\n    headers.appendVia(\"1.1 new.example.net\", \",\");\n    EXPECT_EQ(headers.getViaValue(), \"1.0 fred,1.1 p.example.net,1.1 new.example.net\");\n  }\n}", "target": 0}
{"code": "void ttm_unmap_and_unpopulate_pages(struct device *dev, struct ttm_dma_tt *tt)\n{\n\tunsigned i, j;\n\tfor (i = 0; i < tt->ttm.num_pages;) {\n\t\tstruct page *p = tt->ttm.pages[i];\n\t\tsize_t num_pages = 1;\n\t\tif (!tt->dma_address[i] || !tt->ttm.pages[i]) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = i + 1; j < tt->ttm.num_pages; ++j) {\n\t\t\tif (++p != tt->ttm.pages[j])\n\t\t\t\tbreak;\n\t\t\t++num_pages;\n\t\t}\n\t\tdma_unmap_page(dev, tt->dma_address[i], num_pages * PAGE_SIZE,\n\t\t\t       DMA_BIDIRECTIONAL);\n\t\ti += num_pages;\n\t}\n\tttm_pool_unpopulate(&tt->ttm);\n}", "target": 0}
{"code": "void rdma_unlock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_unlock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "std::unique_ptr<cql_server::response> cql_server::connection::make_ready(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    return std::make_unique<cql_server::response>(stream, cql_binary_opcode::READY, tr_state);\n}", "target": 0}
{"code": "static int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start(msg, attr);\n\tint i;\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}", "target": 0}
{"code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "aspath_show_all_iterator (struct hash_backet *backet, struct vty *vty)\n{\n  struct aspath *as;\n  as = (struct aspath *) backet->data;\n  vty_out (vty, \"[%p:%u] (%ld) \", (void *)backet, backet->key, as->refcnt);\n  vty_out (vty, \"%s%s\", as->str, VTY_NEWLINE);\n}", "target": 0}
{"code": "void AddVersionKeyWorkItems(HKEY root,\n                            BrowserDistribution* dist,\n                            const Version& new_version,\n                            WorkItemList* list) {\n  std::wstring version_key(dist->GetVersionKey());\n  list->AddCreateRegKeyWorkItem(root, version_key);\n  std::wstring product_name(dist->GetAppShortCutName());\n  list->AddSetRegValueWorkItem(root, version_key, google_update::kRegNameField,\n                               product_name, true);  \n  list->AddSetRegValueWorkItem(root, version_key,\n                               google_update::kRegOopcrashesField,\n                               static_cast<DWORD>(1),\n                               false);  \n  list->AddSetRegValueWorkItem(root, version_key,\n                               google_update::kRegVersionField,\n                               UTF8ToWide(new_version.GetString()),\n                               true);  \n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static void load_creator_from_buf(\n    FILE       *fp,\n    xref_t     *xref,\n    const char *buf,\n    size_t      buf_size)\n{\n    int   is_xml;\n    char *c;\n    if (!buf)\n      return;\n    if ((c = strstr(buf, \"/Type\")))\n      while (*c && !isspace(*c))\n        ++c;\n    is_xml = 0;\n    if (c && (*c == 'M'))\n      is_xml = 1;\n    if (is_xml)\n      load_creator_from_xml(xref, buf);\n    else\n      load_creator_from_old_format(fp, xref, buf, buf_size);\n}", "target": 0}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "static long sock_wait_for_wmem(struct sock * sk, long timeo)\n{\n\tDEFINE_WAIT(wait);\n\tclear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\tfor (;;) {\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_INTERRUPTIBLE);\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf)\n\t\t\tbreak;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err)\n\t\t\tbreak;\n\t\ttimeo = schedule_timeout(timeo);\n\t}\n\tfinish_wait(sk->sk_sleep, &wait);\n\treturn timeo;\n}", "target": 0}
{"code": "p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                               size_t *offset,\n                               const unsigned char **data,\n                               size_t *length)\n{\n\tsize_t off = *offset;\n\tuint32_t len;\n\tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n\t\treturn false;\n\tif (len == 0xffffffff) {\n\t\t*offset = off;\n\t\tif (data)\n\t\t\t*data = NULL;\n\t\tif (length)\n\t\t\t*length = 0;\n\t\treturn true;\n\t} else if (len >= 0x7fffffff) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (buf->len < len || *offset > buf->len - len) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (data)\n\t\t*data = (unsigned char *)buf->data + off;\n\tif (length)\n\t\t*length = len;\n\t*offset = off + len;\n\treturn true;\n}", "target": 1}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "EXPORTED int meth_trace(struct transaction_t *txn, void *params)\n{\n    parse_path_t parse_path = (parse_path_t) params;\n    const char **hdr;\n    unsigned long max_fwd = -1;\n    struct buf *msg = &txn->resp_body.payload;\n    txn->flags.cc |= CC_NOCACHE;\n    if (!(txn->req_tgt.allow & ALLOW_TRACE)) return HTTP_NOT_ALLOWED;\n    if ((hdr = spool_getheader(txn->req_hdrs, \"Max-Forwards\"))) {\n        max_fwd = strtoul(hdr[0], NULL, 10);\n    }\n    if (max_fwd && parse_path) {\n        int r;\n        if ((r = parse_path(txn->req_uri->path,\n                            &txn->req_tgt, &txn->error.desc))) return r;\n        if (txn->req_tgt.mbentry && txn->req_tgt.mbentry->server) {\n            struct backend *be;\n            be = proxy_findserver(txn->req_tgt.mbentry->server,\n                                  &http_protocol, httpd_userid,\n                                  &backend_cached, NULL, NULL, httpd_in);\n            if (!be) return HTTP_UNAVAILABLE;\n            return http_pipe_req_resp(be, txn);\n        }\n    }\n    buf_reset(msg);\n    buf_printf(msg, \"TRACE %s %s\\r\\n\", txn->req_line.uri, txn->req_line.ver);\n    spool_enum_hdrcache(txn->req_hdrs, &trace_cachehdr, msg);\n    buf_appendcstr(msg, \"\\r\\n\");\n    txn->resp_body.type = \"message/http\";\n    txn->resp_body.len = buf_len(msg);\n    write_body(HTTP_OK, txn, buf_cstring(msg), buf_len(msg));\n    return 0;\n}", "target": 0}
{"code": "    uint32_t PsdImage::writeExifData(const ExifData& exifData, BasicIo& out)\n    {\n        uint32_t resLength = 0;\n        byte buf[8];\n        if (exifData.count() > 0) {\n            Blob blob;\n            ByteOrder bo = byteOrder();\n            if (bo == invalidByteOrder) {\n                bo = littleEndian;\n                setByteOrder(bo);\n            }\n            ExifParser::encode(blob, bo, exifData);\n            if (blob.size() > 0) {\n#ifdef DEBUG\n                std::cerr << std::hex << \"write: resourceId: \" << kPhotoshopResourceID_ExifInfo << \"\\n\";\n                std::cerr << std::dec << \"Writing ExifInfo: size: \" << blob.size() << \"\\n\";\n#endif\n                if (out.write(reinterpret_cast<const byte*>(Photoshop::irbId_[0]), 4) != 4) throw Error(kerImageWriteFailed);\n                us2Data(buf, kPhotoshopResourceID_ExifInfo, bigEndian);\n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                us2Data(buf, 0, bigEndian);                      \n                if (out.write(buf, 2) != 2) throw Error(kerImageWriteFailed);\n                ul2Data(buf, static_cast<uint32_t>(blob.size()), bigEndian);\n                if (out.write(buf, 4) != 4) throw Error(kerImageWriteFailed);\n                if (out.write(&blob[0], static_cast<long>(blob.size())) != static_cast<long>(blob.size())) throw Error(kerImageWriteFailed);\n                resLength += static_cast<long>(blob.size()) + 12;\n                if (blob.size() & 1)    \n                {\n                    buf[0] = 0;\n                    if (out.write(buf, 1) != 1) throw Error(kerImageWriteFailed);\n                    resLength++;\n                }\n            }\n        }\n        return resLength;\n    } ", "target": 0}
{"code": "static void get_socket_name( char* buf, int len )\n{\n    char* dpy = g_strdup(g_getenv(\"DISPLAY\"));\n    if(dpy && *dpy)\n    {\n        char* p = strchr(dpy, ':');\n        for(++p; *p && *p != '.' && *p != '\\n';)\n            ++p;\n         if(*p)\n             *p = '\\0';\n     }\n     g_snprintf( buf, len, \"%s/.menu-cached-%s-%s\", g_get_tmp_dir(),\n                 dpy ? dpy : \":0\", g_get_user_name() );\n     g_free(dpy);\n }", "target": 1}
{"code": "struct SWF_ACTIONPUSHPARAM * peek()\n{\n#ifdef DEBUG\n\tprintf(\"*peek*\\n\");\n#endif\n#ifdef DEBUGSTACK\t\t\n\tif( Stack == NULL ) push(newVar(\"\n#else\n\tif( Stack == NULL ) SWF_error(\"Stack blown!! - peek\");\n#endif\n\treturn Stack->val;\n}", "target": 0}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 1}
{"code": "compile_length_string_node(Node* node, regex_t* reg)\n{\n  int rlen, r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p, sn->end);\n  p += prev_len;\n  slen = 1;\n  rlen = 0;\n  for (; p < sn->end; ) {\n    len = enclen(enc, p, sn->end);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n      rlen += r;\n      prev = p;\n      slen = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n  rlen += r;\n  return rlen;\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n \tmsr.data = data;\n \tmsr.index = ecx;\n \tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(vcpu, 0);\n \t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)\n{\n    attributes->usage = (audio_usage_t) parcel.readInt32();\n    attributes->content_type = (audio_content_type_t) parcel.readInt32();\n    attributes->source = (audio_source_t) parcel.readInt32();\n    attributes->flags = (audio_flags_mask_t) parcel.readInt32();\n const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);\n if (hasFlattenedTag) {\n String16 tags = parcel.readString16();\n ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());\n if (realTagSize <= 0) {\n            strcpy(attributes->tags, \"\");\n } else {\n             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?\n                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;\n            utf16_to_utf8(tags.string(), tagSize, attributes->tags);\n         }\n     } else {\n         ALOGE(\"unmarshallAudioAttributes() received unflattened tags, ignoring tag values\");\n        strcpy(attributes->tags, \"\");\n }\n}", "target": 1}
{"code": "bool Capability::ChangeUnixUser(uid_t uid) {\n  if (setInitialCapabilities()) {\n    struct passwd *pw;\n    if ((pw = getpwuid(uid)) == nullptr) {\n      Logger::Error(\"unable to getpwuid(%d): %s\", uid,\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (pw->pw_gid == 0 || setgid(pw->pw_gid) < 0) {\n      Logger::Error(\"unable to drop gid privs: %s\",\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (uid == 0 || setuid(uid) < 0) {\n      Logger::Error(\"unable to drop uid privs: %s\",\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (!setMinimalCapabilities()) {\n      Logger::Error(\"unable to set minimal server capabiltiies\");\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "int db__open(struct mosquitto__config *config)\n{\n\tstruct mosquitto__subhier *subhier;\n\tif(!config) return MOSQ_ERR_INVAL;\n\tdb.last_db_id = 0;\n\tdb.contexts_by_id = NULL;\n\tdb.contexts_by_sock = NULL;\n\tdb.contexts_for_free = NULL;\n#ifdef WITH_BRIDGE\n\tdb.bridges = NULL;\n\tdb.bridge_count = 0;\n#endif\n\tdb.clientid_index_hash = NULL;\n\tdb.subs = NULL;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"\", 0);\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"$SYS\", (uint16_t)strlen(\"$SYS\"));\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tretain__init();\n\tdb.config->security_options.unpwd = NULL;\n#ifdef WITH_PERSISTENCE\n\tif(persist__restore()) return 1;\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct ifaddrmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\tif (!(ifa->flags&IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put(skb, IFA_LOCAL, 16, &ifa->addr) < 0 ||\n\t\t    nla_put(skb, IFA_ADDRESS, 16, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put(skb, IFA_ADDRESS, 16, &ifa->addr) < 0)\n\t\t\tgoto error;\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\treturn nlmsg_end(skb, nlh);\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void do_pclose(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  int64_t fptr = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  FILE *f = (FILE *)fptr;\n  int ret = ::pclose(f);\n  fprintf(fout, \"%d\\n\", ret);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "void device_init()\n{\n    hw_init(LOW_FREQUENCY);\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n    device_migrate();\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n}", "target": 1}
{"code": "static int snd_timer_stop1(struct snd_timer_instance *timeri, bool stop)\n{\n\tstruct snd_timer *timer;\n\tint result = 0;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (!(timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t       SNDRV_TIMER_IFLG_START))) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif (timer->card && timer->card->shutdown)\n\t\tgoto unlock;\n\tif (stop) {\n\t\ttimeri->cticks = timeri->ticks;\n\t\ttimeri->pticks = 0;\n\t}\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\ttimeri->flags &= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tsnd_timer_notify1(timeri, stop ? SNDRV_TIMER_EVENT_STOP :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "GF_Err sbgp_box_size(GF_Box *s)\n{\n\tGF_SampleGroupBox *p = (GF_SampleGroupBox*)s;\n\tp->size += 8;\n\tif (p->grouping_type_parameter) p->version=1;\n\tif (p->version==1) p->size += 4;\n\tp->size += 8*p->entry_count;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\tper_cpu(svm_data, cpu) = sd;\n\treturn 0;\nerr_1:\n\tkfree(sd);\n\treturn r;\n}", "target": 1}
{"code": "pci_msix_table_init(struct pci_vdev *dev, int table_entries)\n{\n\tint i, table_size;\n\tassert(table_entries > 0);\n\tassert(table_entries <= MAX_MSIX_TABLE_ENTRIES);\n\ttable_size = table_entries * MSIX_TABLE_ENTRY_SIZE;\n\tdev->msix.table = calloc(1, table_size);\n\tassert(dev->msix.table != NULL);\n\tfor (i = 0; i < table_entries; i++)\n\t\tdev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;\n}", "target": 1}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type = NULL;\n\tunsigned char *buf_in=NULL;\n\tint ret= -1,inl;\n        int mdnid, pknid;\n        EVP_MD_CTX_init(&ctx);\n\tif (type == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\n\t\tgoto err;\n\t\t}\n\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);\n\t\tgoto err;\n\t\t}\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}", "target": 1}
{"code": "init_line_list(line_list *ll, gs_memory_t * mem)\n{\n    ll->memory = mem;\n    ll->active_area = 0;\n    ll->next_active = ll->local_active;\n    ll->limit = ll->next_active + MAX_LOCAL_ACTIVE;\n    ll->close_count = 0;\n    ll->y_list = 0;\n    ll->y_line = 0;\n    ll->h_list0 = ll->h_list1 = 0;\n    ll->x_head.prev = NULL;\n    ll->x_head.start.x = 0;\n    ll->x_head.start.y = 0;\n    ll->x_head.end.x = 0;\n    ll->x_head.end.y = 0;\n    INCR(fill);\n}", "target": 0}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "Value ExpressionDateToString::evaluate(const Document& root, Variables* variables) const {\n    const Value date = _date->evaluate(root, variables);\n    Value formatValue;\n    if (_format) {\n        formatValue = _format->evaluate(root, variables);\n        if (!formatValue.nullish()) {\n            uassert(18533,\n                    str::stream() << \"$dateToString requires that 'format' be a string, found: \"\n                                  << typeName(formatValue.getType()) << \" with value \"\n                                  << formatValue.toString(),\n                    formatValue.getType() == BSONType::String);\n            TimeZone::validateToStringFormat(formatValue.getStringData());\n        }\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (date.nullish()) {\n        return _onNull ? _onNull->evaluate(root, variables) : Value(BSONNULL);\n    }\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_format) {\n        if (formatValue.nullish()) {\n            return Value(BSONNULL);\n        }\n        return Value(uassertStatusOK(\n            timeZone->formatDate(formatValue.getStringData(), date.coerceToDate())));\n    }\n    return Value(\n        uassertStatusOK(timeZone->formatDate(Value::kISOFormatString, date.coerceToDate())));\n}", "target": 0}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "static unsigned long __init init_range_memory_mapping(\n\t\t\t\t\t   unsigned long r_start,\n\t\t\t\t\t   unsigned long r_end)\n{\n\tunsigned long start_pfn, end_pfn;\n\tunsigned long mapped_ram_size = 0;\n\tint i;\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {\n\t\tu64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);\n\t\tu64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);\n\t\tif (start >= end)\n\t\t\tcontinue;\n\t\tcan_use_brk_pgt = max(start, (u64)pgt_buf_end<<PAGE_SHIFT) >=\n\t\t\t\t    min(end, (u64)pgt_buf_top<<PAGE_SHIFT);\n\t\tinit_memory_mapping(start, end);\n\t\tmapped_ram_size += end - start;\n\t\tcan_use_brk_pgt = true;\n\t}\n\treturn mapped_ram_size;\n}", "target": 0}
{"code": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\treturn 0;\n}", "target": 1}
{"code": "bool HHVM_FUNCTION(array_key_exists,\n                   const Variant& key,\n                   const Variant& search) {\n  const ArrayData *ad;\n  auto const searchCell = search.asCell();\n  if (LIKELY(isArrayType(searchCell->m_type))) {\n    ad = searchCell->m_data.parr;\n  } else if (searchCell->m_type == KindOfObject) {\n    ObjectData* obj = searchCell->m_data.pobj;\n    if (obj->isCollection()) {\n      return collections::contains(obj, key);\n    }\n    return HHVM_FN(array_key_exists)(key, toArray(search));\n  } else {\n    throw_bad_type_exception(\"array_key_exists expects an array or an object; \"\n                             \"false returned.\");\n    return false;\n  }\n  auto const cell = key.asCell();\n  switch (cell->m_type) {\n    case KindOfUninit:\n    case KindOfNull:\n      return ad->useWeakKeys() && ad->exists(staticEmptyString());\n    case KindOfBoolean:\n    case KindOfDouble:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfObject:\n    case KindOfResource:\n      if (!ad->useWeakKeys()) throwInvalidArrayKeyException(cell, ad);\n      raise_warning(\"Array key should be either a string or an integer\");\n      return false;\n    case KindOfPersistentString:\n    case KindOfString: {\n      int64_t n = 0;\n      if (ad->convertKey(cell->m_data.pstr, n)) {\n        return ad->exists(n);\n      }\n      return ad->exists(StrNR(cell->m_data.pstr));\n    }\n    case KindOfInt64:\n      return ad->exists(cell->m_data.num);\n    case KindOfRef:\n    case KindOfClass:\n      break;\n  }\n  not_reached();\n}", "target": 0}
{"code": "nfsd4_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_copy *copy)\n{\n\tstruct file *src, *dst;\n\t__be32 status;\n\tssize_t bytes;\n\tstatus = nfsd4_verify_copy(rqstp, cstate, &copy->cp_src_stateid, &src,\n\t\t\t\t   &copy->cp_dst_stateid, &dst);\n\tif (status)\n\t\tgoto out;\n\tbytes = nfsd_copy_file_range(src, copy->cp_src_pos,\n\t\t\tdst, copy->cp_dst_pos, copy->cp_count);\n\tif (bytes < 0)\n\t\tstatus = nfserrno(bytes);\n\telse {\n\t\tcopy->cp_res.wr_bytes_written = bytes;\n\t\tcopy->cp_res.wr_stable_how = NFS_UNSTABLE;\n\t\tcopy->cp_consecutive = 1;\n\t\tcopy->cp_synchronous = 1;\n\t\tgen_boot_verifier(&copy->cp_res.wr_verifier, SVC_NET(rqstp));\n\t\tstatus = nfs_ok;\n\t}\n\tfput(src);\n\tfput(dst);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static void blk_mq_add_queue_tag_set(struct blk_mq_tag_set *set,\n\t\t\t\t     struct request_queue *q)\n{\n\tq->tag_set = set;\n\tmutex_lock(&set->tag_list_lock);\n\tlist_add_tail(&q->tag_set_list, &set->tag_list);\n\tblk_mq_update_tag_set_depth(set);\n\tmutex_unlock(&set->tag_list_lock);\n}", "target": 0}
{"code": "find_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n \tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n \t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n \t\treturn -EINVAL;\n \tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "static int nf_tables_table_notify(const struct nft_ctx *ctx, int event)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_table_info(skb, ctx->net, ctx->portid, ctx->seq,\n\t\t\t\t\tevent, 0, ctx->afi->family, ctx->table);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, GFP_KERNEL);\nerr:\n\tif (err < 0) {\n\t\tnfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES,\n\t\t\t\t  err);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "int set_binfmt(struct linux_binfmt *new)\n{\n\tstruct linux_binfmt *old = current->binfmt;\n\tif (new) {\n\t\tif (!try_module_get(new->module))\n\t\t\treturn -1;\n\t}\n\tcurrent->binfmt = new;\n\tif (old)\n\t\tmodule_put(old->module);\n\treturn 0;\n}", "target": 0}
{"code": "update_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}", "target": 0}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "void slice_segment_header::compute_derived_values(const pic_parameter_set* pps)\n{\n  SliceQPY = pps->pic_init_qp + slice_qp_delta;\n  switch (slice_type)\n    {\n    case SLICE_TYPE_I: initType = 0; break;\n    case SLICE_TYPE_P: initType = cabac_init_flag + 1; break;\n    case SLICE_TYPE_B: initType = 2 - cabac_init_flag; break;\n    }\n  MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n}", "target": 0}
{"code": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n     Mutex::Autolock autoLock(mLock);\n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = rangeLength;\n     header->nOffset = rangeOffset;\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}", "target": 1}
{"code": "static const char *escape_identifier(const char *identifier)\n{\n\tsize_t pos = strcspn(identifier, \"./%\");\n\tif (pos < strlen(identifier)) {\n\t\tstring_t *new_id = t_str_new(strlen(identifier));\n\t\tstr_append_data(new_id, identifier, pos);\n\t\tfor (const char *c = identifier+pos; *c != '\\0'; c++) {\n\t\t\tswitch (*c) {\n\t\t\tcase '.':\n\t\t\t\tstr_append(new_id, \"%2e\");\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tstr_append(new_id, \"%2f\");\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tstr_append(new_id, \"%25\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr_append_c(new_id, *c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str_c(new_id);\n\t}\n\treturn identifier;\n}", "target": 1}
{"code": "SPL_METHOD(SplObjectStorage, count)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(zend_hash_num_elements(&intern->storage));\n} ", "target": 0}
{"code": "bool HTMLMediaElement::HasNativeControls() {\n  return ShouldShowControls(RecordMetricsBehavior::kDoRecord);\n}", "target": 0}
{"code": "get_text_rgb_cmyk_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE g = read_pbm_integer(cinfo, infile, maxval);\n      JSAMPLE b = read_pbm_integer(cinfo, infile, maxval);\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  } else {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE r = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE g = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      JSAMPLE b = rescale[read_pbm_integer(cinfo, infile, maxval)];\n      rgb_to_cmyk(r, g, b, ptr, ptr + 1, ptr + 2, ptr + 3);\n      ptr += 4;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n     if (!ndo->ndo_eflag)\n         ND_PRINT((ndo, \"MLPPP, \"));\n     ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n            (EXTRACT_16BITS(p))&0x0fff, \n            bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}", "target": 1}
{"code": "mrb_prev_pc(codegen_scope *s, const mrb_code *pc)\n{\n  const mrb_code *prev_pc = NULL;\n  const mrb_code *i = s->iseq;\n  while (i<pc) {\n    uint8_t insn = i[0];\n    prev_pc = i;\n    switch (insn) {\n    case OP_EXT1:\n      i += mrb_insn_size1[i[1]] + 1;\n      break;\n    case OP_EXT2:\n      i += mrb_insn_size2[i[1]] + 1;\n      break;\n    case OP_EXT3:\n      i += mrb_insn_size3[i[1]] + 1;\n      break;\n    default:\n      i += mrb_insn_size[insn];\n      break;\n    }\n  }\n  return prev_pc;\n}", "target": 0}
{"code": "static int find_uid(struct posix_acl_state *state, struct posix_ace_state_array *a, uid_t uid)\n{\n\tint i;\n\tfor (i = 0; i < a->n; i++)\n\t\tif (a->aces[i].uid == uid)\n\t\t\treturn i;\n\ta->n++;\n\ta->aces[i].uid = uid;\n\ta->aces[i].perms.allow = state->everyone.allow;\n\ta->aces[i].perms.deny  = state->everyone.deny;\n\treturn i;\n}", "target": 0}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortFlags = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}", "target": 0}
{"code": "int LibRaw::is_phaseone_compressed() \n{ \n  return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw); \n}", "target": 0}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": " PHP_FUNCTION(linkinfo)\n {\n \tchar *link;\n \tsize_t link_len;\n \tzend_stat_t sb;\n \tint ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n \t\treturn;\n \t}\n \tret = VCWD_STAT(link, &sb);\n \tif (ret == -1) {\n \t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n \t\tRETURN_LONG(Z_L(-1));\n \t}\n \tRETURN_LONG((zend_long) sb.st_dev);\n }", "target": 1}
{"code": "static inline void *packet_previous_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status)\n{\n\tunsigned int previous = rb->head ? rb->head - 1 : rb->frame_max;\n\treturn packet_lookup_frame(po, rb, previous, status);\n}", "target": 0}
{"code": "irc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n    return rc;\n}", "target": 0}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static inline void *packet_current_rx_frame(struct packet_sock *po,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    int status, unsigned int len)\n{\n\tchar *curr = NULL;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\tcurr = packet_lookup_frame(po, &po->rx_ring,\n\t\t\t\t\tpo->rx_ring.head, status);\n\t\treturn curr;\n\tcase TPACKET_V3:\n\t\treturn __packet_lookup_frame_in_block(po, skb, status, len);\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "NTSTATUS get_ea_value_fsp(TALLOC_CTX *mem_ctx,\n\t\t\t  files_struct *fsp,\n\t\t\t  const char *ea_name,\n\t\t\t  struct ea_struct *pea)\n{\n\tsize_t attr_size = 256;\n\tchar *val = NULL;\n\tssize_t sizeret;\n\tsize_t max_xattr_size = 0;\n\tif (fsp == NULL) {\n\t\treturn NT_STATUS_INVALID_HANDLE;\n\t}\n\tmax_xattr_size = lp_smbd_max_xattr_size(SNUM(fsp->conn));\n again:\n\tval = talloc_realloc(mem_ctx, val, char, attr_size);\n\tif (!val) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tsizeret = SMB_VFS_FGETXATTR(fsp, ea_name, val, attr_size);\n\tif (sizeret == -1 && errno == ERANGE && attr_size < max_xattr_size) {\n\t\tattr_size = max_xattr_size;\n\t\tgoto again;\n\t}\n\tif (sizeret == -1) {\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tDEBUG(10,(\"get_ea_value: EA %s is of length %u\\n\", ea_name, (unsigned int)sizeret));\n\tdump_data(10, (uint8_t *)val, sizeret);\n\tpea->flags = 0;\n\tif (strnequal(ea_name, \"user.\", 5)) {\n\t\tpea->name = talloc_strdup(mem_ctx, &ea_name[5]);\n\t} else {\n\t\tpea->name = talloc_strdup(mem_ctx, ea_name);\n\t}\n\tif (pea->name == NULL) {\n\t\tTALLOC_FREE(val);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tpea->value.data = (unsigned char *)val;\n\tpea->value.length = (size_t)sizeret;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "check_supported(item *new)\n{\nint c = -1;\nint bot = 0;\nint top = supported_elements_count;\nint mid;\ntree_node *tn;\nparamstr *param;\nwhile (top > bot)\n  {\n  mid = (top + bot)/2;\n  c = Ustrcmp(new->name, supported_elements[mid].name);\n  if (c == 0) break;\n  if (c < 0) top = mid; else bot = mid + 1;\n  }\nif (c != 0)\n  {\n  tn = tree_search(unknown_element_tree, new->name);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(new->name));\n    Ustrcpy(tn->name, new->name);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  return;\n  }\nfor (param = new->p.param; param != NULL; param = param->next)\n  {\n  uschar buffer[256];\n  uschar **aptr;\n  if (param->name[0] == '#') continue;\n  if (Ustrcmp(param->name, \"revisionflag\") == 0)\n    {\n    if (Ustrcmp(param->value, \"changed\") == 0) continue;\n    (void)sprintf(CS buffer, \"+%s=%s:%s\", param->name, param->value,\n      new->name);\n    }\n  else\n    {\n    aptr = supported_elements[mid].attrs;\n    if (aptr != NULL)\n      {\n      if (Ustrcmp(*aptr, \"*\") == 0) continue;\n      for (; *aptr != NULL; aptr++)\n        if (Ustrcmp(*aptr, param->name) == 0) break;\n      if (*aptr != NULL) continue;\n      }\n    (void)sprintf(CS buffer, \"+%s:%s\", param->name, new->name);\n    }\n  tn = tree_search(unknown_element_tree, buffer);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(buffer));\n    Ustrcpy(tn->name, buffer);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  }\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL convert_to_object(zval *op) \n{\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_ARRAY:\n\t\t\t{\n\t\t\t\tHashTable *ht = zend_symtable_to_proptable(Z_ARR_P(op));\n\t\t\t\tzend_object *obj;\n\t\t\t\tif (GC_FLAGS(ht) & IS_ARRAY_IMMUTABLE) {\n\t\t\t\t\tht = zend_array_dup(ht);\n\t\t\t\t} else if (ht != Z_ARR_P(op)) {\n\t\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\t} else {\n\t\t\t\t\tGC_DELREF(ht);\n\t\t\t\t}\n\t\t\t\tobj = zend_objects_new(zend_standard_class_def);\n\t\t\t\tobj->properties = ht;\n\t\t\t\tZVAL_OBJ(op, obj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IS_OBJECT:\n\t\t\tbreak;\n\t\tcase IS_NULL:\n\t\t\tobject_init(op);\n\t\t\tbreak;\n\t\tcase IS_REFERENCE:\n\t\t\tzend_unwrap_reference(op);\n\t\t\tgoto try_again;\n\t\tdefault: {\n\t\t\tzval tmp;\n\t\t\tZVAL_COPY_VALUE(&tmp, op);\n\t\t\tobject_init(op);\n\t\t\tzend_hash_add_new(Z_OBJPROP_P(op), ZSTR_KNOWN(ZEND_STR_SCALAR), &tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "ldap_pvt_tls_get_peer_dn( void *s, struct berval *dn,\n\tLDAPDN_rewrite_dummy *func, unsigned flags )\n{\n\ttls_session *session = s;\n\tstruct berval bvdn;\n\tint rc;\n\trc = tls_imp->ti_session_peer_dn( session, &bvdn );\n\tif ( rc ) return rc;\n\trc = ldap_X509dn2bv( &bvdn, dn, \n\t\t\t    (LDAPDN_rewrite_func *)func, flags);\n\treturn rc;\n}", "target": 0}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "int main(int argc, char **argv)\n{\n    int fd;\n    int ret;\n    fd = mkstemp(test_image);\n    g_assert(fd >= 0);\n    ret = ftruncate(fd, TEST_IMAGE_SIZE);\n    g_assert(ret == 0);\n    close(fd);\n    g_test_init(&argc, &argv, NULL);\n    qtest_start(\"-machine pc -device floppy,id=floppy0\");\n    qtest_irq_intercept_in(global_qtest, \"ioapic\");\n    qtest_add_func(\"/fdc/cmos\", test_cmos);\n    qtest_add_func(\"/fdc/no_media_on_start\", test_no_media_on_start);\n    qtest_add_func(\"/fdc/read_without_media\", test_read_without_media);\n    qtest_add_func(\"/fdc/media_change\", test_media_change);\n    qtest_add_func(\"/fdc/sense_interrupt\", test_sense_interrupt);\n    qtest_add_func(\"/fdc/relative_seek\", test_relative_seek);\n    qtest_add_func(\"/fdc/read_id\", test_read_id);\n    qtest_add_func(\"/fdc/verify\", test_verify);\n    qtest_add_func(\"/fdc/media_insert\", test_media_insert);\n    qtest_add_func(\"/fdc/read_no_dma_1\", test_read_no_dma_1);\n    qtest_add_func(\"/fdc/read_no_dma_18\", test_read_no_dma_18);\n    qtest_add_func(\"/fdc/read_no_dma_19\", test_read_no_dma_19);\n    qtest_add_func(\"/fdc/fuzz-registers\", fuzz_registers);\n    qtest_add_func(\"/fdc/fuzz/cve_2021_20196\", test_cve_2021_20196);\n    ret = g_test_run();\n    qtest_end();\n    unlink(test_image);\n    return ret;\n}", "target": 1}
{"code": "PyImaging_MapBuffer(PyObject* self, PyObject* args)\n{\n    Py_ssize_t y, size;\n    Imaging im;\n    PyObject* target;\n    Py_buffer view;\n    char* mode;\n    char* codec;\n    PyObject* bbox;\n    Py_ssize_t offset;\n    int xsize, ysize;\n    int stride;\n    int ystep;\n    if (!PyArg_ParseTuple(args, \"O(ii)sOn(sii)\", &target, &xsize, &ysize,\n                          &codec, &bbox, &offset, &mode, &stride, &ystep))\n        return NULL;\n    if (!PyImaging_CheckBuffer(target)) {\n        PyErr_SetString(PyExc_TypeError, \"expected string or buffer\");\n        return NULL;\n    }\n    if (stride <= 0) {\n        if (!strcmp(mode, \"L\") || !strcmp(mode, \"P\"))\n            stride = xsize;\n        else if (!strncmp(mode, \"I;16\", 4))\n            stride = xsize * 2;\n        else\n            stride = xsize * 4;\n    }\n    size = (Py_ssize_t) ysize * stride;\n    if (PyImaging_GetBuffer(target, &view) < 0)\n        return NULL;\n    if (view.len < 0) {\n        PyErr_SetString(PyExc_ValueError, \"buffer has negative size\");\n        return NULL;\n    }\n    if (offset + size > view.len) {\n        PyErr_SetString(PyExc_ValueError, \"buffer is not large enough\");\n        return NULL;\n    }\n    im = ImagingNewPrologueSubtype(\n        mode, xsize, ysize, sizeof(ImagingBufferInstance)\n        );\n    if (!im)\n        return NULL;\n    if (ystep > 0)\n        for (y = 0; y < ysize; y++)\n            im->image[y] = (char*)view.buf + offset + y * stride;\n    else\n        for (y = 0; y < ysize; y++)\n            im->image[ysize-y-1] = (char*)view.buf + offset + y * stride;\n    im->destroy = mapping_destroy_buffer;\n    Py_INCREF(target);\n    ((ImagingBufferInstance*) im)->target = target;\n    ((ImagingBufferInstance*) im)->view = view;\n    if (!ImagingNewEpilogue(im))\n        return NULL;\n    return PyImagingNew(im);\n}", "target": 1}
{"code": "static void mctp_serial_uninit(struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tcancel_work_sync(&dev->tx_work);\n}", "target": 0}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+(PrimitiveExtentPad+1)*quantum;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) (extent+1),quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i <= (ssize_t) extent; i++)\n          {\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n            (*mvg_info->primitive_info)[i].text=(char *) NULL;\n          }\n          return(MagickTrue);\n        }\n    }\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  *mvg_info->primitive_info=(PrimitiveInfo *) AcquireCriticalMemory((size_t) (\n    (PrimitiveExtentPad+1)*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t) ((PrimitiveExtentPad+1)*\n    quantum));\n  *mvg_info->extent=1;\n  mvg_info->offset=0;\n  return(MagickFalse);\n}", "target": 0}
{"code": "static struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto);\n\tif (!sk)\n\t\treturn NULL;\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}", "target": 0}
{"code": "static MagickPixelPacket **DestroyPixelThreadSet(const Image *images,\n  MagickPixelPacket **pixels)\n{\n  ssize_t\n    i;\n  size_t\n    rows;\n  assert(pixels != (MagickPixelPacket **) NULL);\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (MagickPixelPacket *) NULL)\n      pixels[i]=(MagickPixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(MagickPixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}", "target": 0}
{"code": "win_free_lsize(win_T *wp)\n{\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}", "target": 0}
{"code": "static void mce_report_event(struct pt_regs *regs)\n{\n\tif (regs->flags & (X86_VM_MASK|X86_EFLAGS_IF)) {\n\t\tmce_notify_irq();\n\t\tmce_schedule_work();\n\t\treturn;\n\t}\n\tirq_work_queue(&mce_irq_work);\n}", "target": 0}
{"code": "currentLn(Buffer *buf)\n{\n    if (buf->currentLine)\n\treturn buf->currentLine->linenumber + 1;\n    else\n\treturn 1;\n}", "target": 0}
{"code": "assegment_append_asns (struct assegment *seg, as_t *asnos, int num)\n{\n  as_t *newas;\n  newas = XREALLOC (MTYPE_AS_SEG_DATA, seg->as,\n\t\t      ASSEGMENT_DATA_SIZE (seg->length + num, 1));\n  if (newas)\n    {\n      seg->as = newas;\n      memcpy (seg->as + seg->length, asnos, ASSEGMENT_DATA_SIZE(num, 1));\n      seg->length += num;\n      return seg;\n    }\n  assegment_free_all (seg);\n  return NULL;\n}", "target": 0}
{"code": "static unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}", "target": 0}
{"code": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\tif (length < 0)\n\t\treturn -EINVAL;\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1}
{"code": "static void vcc_sock_destruct(struct sock *sk)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: rmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_rmem_alloc));\n\tif (atomic_read(&sk->sk_wmem_alloc))\n\t\tprintk(KERN_DEBUG \"%s: wmem leakage (%d bytes) detected.\\n\",\n\t\t       __func__, atomic_read(&sk->sk_wmem_alloc));\n}", "target": 0}
{"code": "static int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static bool setup_natural_join_row_types(THD *thd,\n                                         List<TABLE_LIST> *from_clause,\n                                         Name_resolution_context *context)\n{\n  DBUG_ENTER(\"setup_natural_join_row_types\");\n  thd->where= \"from clause\";\n  if (from_clause->elements == 0)\n    DBUG_RETURN(false); \n  if (!context->select_lex->first_natural_join_processing)\n  {\n    context->first_name_resolution_table= context->natural_join_first_table;\n    DBUG_PRINT(\"info\", (\"using cached setup_natural_join_row_types\"));\n    DBUG_RETURN(false);\n  }\n  List_iterator_fast<TABLE_LIST> table_ref_it(*from_clause);\n  TABLE_LIST *table_ref; \n  TABLE_LIST *left_neighbor;\n  TABLE_LIST *right_neighbor= NULL;\n  for (left_neighbor= table_ref_it++; left_neighbor ; )\n  {\n    table_ref= left_neighbor;\n    do\n    {\n      left_neighbor= table_ref_it++;\n    }\n    while (left_neighbor && left_neighbor->sj_subq_pred);\n    if (store_top_level_join_columns(thd, table_ref,\n                                     left_neighbor, right_neighbor))\n      DBUG_RETURN(true);\n    if (left_neighbor)\n    {\n      TABLE_LIST *first_leaf_on_the_right;\n      first_leaf_on_the_right= table_ref->first_leaf_for_name_resolution();\n      left_neighbor->next_name_resolution_table= first_leaf_on_the_right;\n    }\n    right_neighbor= table_ref;\n  }\n  DBUG_ASSERT(right_neighbor);\n  context->first_name_resolution_table=\n    right_neighbor->first_leaf_for_name_resolution();\n  context->natural_join_first_table= context->first_name_resolution_table;\n  context->select_lex->first_natural_join_processing= false;\n  DBUG_RETURN (false);\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "    template<typename t1, typename t2>\n    CImg<intT> get_patchmatch(const CImg<T>& patch_image,\n                              const unsigned int patch_width,\n                              const unsigned int patch_height,\n                              const unsigned int patch_depth,\n                              const unsigned int nb_iterations,\n                              const unsigned int nb_randoms,\n                              const CImg<t1> &guide,\n                              CImg<t2> &matching_score) const {\n      return _patchmatch(patch_image,patch_width,patch_height,patch_depth,\n                         nb_iterations,nb_randoms,\n                         guide,true,matching_score);", "target": 0}
{"code": "static int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; \n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 1}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "void __init kvm_guest_init(void)\n{\n\tint i;\n\tif (!kvm_para_available())\n\t\treturn;\n\tparavirt_ops_setup();\n\tregister_reboot_notifier(&kvm_pv_reboot_nb);\n\tfor (i = 0; i < KVM_TASK_SLEEP_HASHSIZE; i++)\n\t\tspin_lock_init(&async_pf_sleepers[i].lock);\n\tif (kvm_para_has_feature(KVM_FEATURE_ASYNC_PF))\n\t\tx86_init.irqs.trap_init = kvm_apf_trap_init;\n\tif (kvm_para_has_feature(KVM_FEATURE_STEAL_TIME)) {\n\t\thas_steal_clock = 1;\n\t\tpv_time_ops.steal_clock = kvm_steal_clock;\n\t}\n\tif (kvm_para_has_feature(KVM_FEATURE_PV_EOI))\n\t\tapic_set_eoi_write(kvm_guest_apic_eoi_write);\n\tif (kvmclock_vsyscall)\n\t\tkvm_setup_vsyscall_timeinfo();\n#ifdef CONFIG_SMP\n\tsmp_ops.smp_prepare_boot_cpu = kvm_smp_prepare_boot_cpu;\n\tregister_cpu_notifier(&kvm_cpu_notifier);\n#else\n\tkvm_guest_cpu_init();\n#endif\n\twatchdog_enable_hardlockup_detector(false);\n}", "target": 0}
{"code": "static uint16_t nvme_get_feature_timestamp(NvmeCtrl *n, NvmeRequest *req)\n{\n    uint64_t timestamp = nvme_get_timestamp(n);\n    return nvme_c2h(n, (uint8_t *)&timestamp, sizeof(timestamp), req);\n}", "target": 0}
{"code": "static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen)\n\t\t\t\tjs_rangeerror(J, \"array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto readonly;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref && ref->setter) {\n\t\tjs_pushobject(J, ref->setter);\n\t\tjs_pushobject(J, obj);\n\t\tjs_pushvalue(J, *value);\n\t\tjs_call(J, 1);\n\t\tjs_pop(J, 1);\n\t\treturn;\n\t}\n\tif (!ref || !own)\n\t\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\treturn;\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}", "target": 0}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "inline void GatherNd(const RuntimeShape& params_shape,\n                     const ParamsT* params_data,\n                     const RuntimeShape& indices_shape,\n                     const IndicesT* indices_data,\n                     const RuntimeShape& output_shape, ParamsT* output_data) {\n  ruy::profiler::ScopeLabel label(\"GatherNd\");\n  const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n  for (int i = 0; i < res.n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < res.indices_nd; ++j) {\n      from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n    }\n    std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                sizeof(ParamsT) * res.slice_size);\n  }\n}", "target": 1}
{"code": "static int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static av_always_inline void snow_horizontal_compose_lift_lead_out(int i, IDWTELEM * dst, IDWTELEM * src, IDWTELEM * ref, int width, int w, int lift_high, int mul, int add, int shift){\n    for(; i<w; i++){\n        dst[i] = src[i] - ((mul * (ref[i] + ref[i + 1]) + add) >> shift);\n    }\n    if((width^lift_high)&1){\n        dst[w] = src[w] - ((mul * 2 * ref[w] + add) >> shift);\n    }\n}", "target": 0}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "    uint32_t TiffBinaryElement::doWrite(IoWrapper& ioWrapper,\n                                        ByteOrder byteOrder,\n                                        int32_t   ,\n                                        uint32_t  ,\n                                        uint32_t  ,\n                                        uint32_t& )\n    {\n        Value const* pv = pValue();\n        if (!pv || pv->count() == 0) return 0;\n        DataBuf buf(pv->size());\n        pv->copy(buf.pData_, byteOrder);\n        ioWrapper.write(buf.pData_, buf.size_);\n        return (uint32_t)buf.size_;\n    } ", "target": 0}
{"code": "zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n\t\treturn err;\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tIRDA_DEBUG(2, \"%s(), Received truncated frame (%zd < %zd)!\\n\",\n\t\t\t   __func__, copied, size);\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\treturn copied;\n}", "target": 1}
{"code": "static bool ok_inflater_literal_tree(ok_inflater *inflater) {\n    bool done = ok_inflater_inflate_huffman_tree(inflater, inflater->literal_huffman,\n                                                 inflater->code_length_huffman,\n                                                 inflater->num_literal_codes);\n    if (done) {\n        inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE_TREE;\n        inflater->huffman_code = -1;\n        inflater->state_count = 0;\n        return true;\n    } else {\n        return false;\n    }\n}", "target": 0}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "int snd_ctl_remove(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tif (snd_BUG_ON(!card || !kcontrol))\n\t\treturn -EINVAL;\n\tlist_del(&kcontrol->list);\n\tcard->controls_count -= kcontrol->count;\n\tid = kcontrol->id;\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_REMOVE, &id);\n\tsnd_ctl_free_one(kcontrol);\n\treturn 0;\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "  static Config::DecodedResourcesWrapper decodeResources(\n      const Protobuf::RepeatedPtrField<envoy::service::discovery::v3::Resource>& resources,\n      const std::string& name_field = \"name\") {\n    Config::DecodedResourcesWrapper decoded_resources;\n    TestOpaqueResourceDecoderImpl<MessageType> resource_decoder(name_field);\n    for (const auto& resource : resources) {\n      decoded_resources.owned_resources_.emplace_back(\n          new Config::DecodedResourceImpl(resource_decoder, resource));\n      decoded_resources.refvec_.emplace_back(*decoded_resources.owned_resources_.back());\n    }\n    return decoded_resources;\n  }", "target": 0}
{"code": "void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->local_i_key &= p_cb->peer_i_key;\n  p_cb->local_r_key &= p_cb->peer_r_key;\n if (smp_send_cmd(SMP_OPCODE_PAIRING_RSP, p_cb)) {\n if (p_cb->selected_association_model == SMP_MODEL_SEC_CONN_OOB)\n      smp_use_oob_private_key(p_cb, NULL);\n else\n      smp_decide_association_model(p_cb, NULL);\n }\n}", "target": 0}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "     res1 = cimg::eval(\"cos(x)^2 + sin(y)^2\",2,2),  \n     res2 = cimg::eval(0,1,1);                    \n     \\endcode\n  **/", "target": 0}
{"code": "void LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input) \n    {\n      if (libraw_internal_data.internal_data.input->eof())\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),-1);\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        }\n      else\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),\n                                                    libraw_internal_data.internal_data.input->tell());\n        }\n    }\n  libraw_internal_data.unpacker_data.data_error++;\n}", "target": 0}
{"code": "_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n{\n  mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n  mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n  if (nlimbs > 2*m->size)\n    {\n      mp_limb_t hi = rp[2*m->size];\n      assert (nlimbs == 2*m->size + 1);\n      hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n      assert (hi <= 1);\n      hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n      assert (hi == 0);\n    }\n  m->mod (m, rp, rp);\n}", "target": 1}
{"code": "static ssize_t show_constraint_name(struct device *dev,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tchar *buf)\n{\n\tconst char *name;\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\tint id;\n\tssize_t len = -ENODATA;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id))\n\t\treturn -EINVAL;\n\tif (id >= power_zone->const_id_cnt)\n\t\treturn -EINVAL;\n\tpconst = &power_zone->constraints[id];\n\tif (pconst && pconst->ops && pconst->ops->get_name) {\n\t\tname = pconst->ops->get_name(power_zone, id);\n\t\tif (name) {\n\t\t\tsnprintf(buf, POWERCAP_CONSTRAINT_NAME_LEN,\n\t\t\t\t\t\t\t\t\"%s\\n\", name);\n\t\t\tbuf[POWERCAP_CONSTRAINT_NAME_LEN] = '\\0';\n\t\t\tlen = strlen(buf);\n\t\t}\n\t}\n\treturn len;\n}", "target": 0}
{"code": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\tif (p > end)\n\t\treturn 0;\n\tlen = *p++;\n\tif (p + len > end)\n\t\treturn 0;\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\t*data += 1 + len;\n\treturn len;\n}", "target": 1}
{"code": "seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n \tpkglen = s->end - s->p;\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\txfree(buf);\n}", "target": 1}
{"code": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n \t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n \t}\n \ttm_reclaim(thr, thr->regs->msr, cause);\n\tthr->regs->msr |= msr_diff;\n}", "target": 1}
{"code": "static int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n = ctx->major;\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: \n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: \n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: \n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: \n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: \n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {\n  if (find_local_field(name, sig, fd)) {\n    if (fd->is_static() == is_static) return const_cast<InstanceKlass*>(this);\n  }\n  if (is_static) {\n    Klass* intf = find_interface_field(name, sig, fd);\n    if (intf != NULL) return intf;\n  }\n  { Klass* supr = super();\n    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n  }\n  return NULL;\n}", "target": 0}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "time_to_df(int h, int min, int s)\n{\n    return h * HOUR_IN_SECONDS + min * MINUTE_IN_SECONDS + s;\n}", "target": 0}
{"code": "void PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n}", "target": 1}
{"code": "list_ne_name_resources (WinLibrary *fi, WinResource *typeres, int *count)\n{\n    int c, rescnt;\n    WinResource *wr;\n    Win16NETypeInfo *typeinfo = (Win16NETypeInfo *) typeres->this;\n    Win16NENameInfo *nameinfo = (Win16NENameInfo *) typeres->children;\n    RETURN_IF_BAD_POINTER(NULL, typeinfo->count);\n    *count = rescnt = typeinfo->count;\n    if (rescnt == 0) return NULL;\n    wr = xmalloc(sizeof(WinResource) * rescnt);\n    for (c = 0 ; c < rescnt ; c++) {\n        RETURN_IF_BAD_POINTER(NULL, nameinfo[c]);\n        wr[c].this = nameinfo+c;\n        wr[c].is_directory = false;\n        wr[c].children = nameinfo+c;\n        wr[c].level = 1;\n        if (!decode_ne_resource_id (fi, wr + c, (nameinfo+c)->id)) {\n            free(wr);\n            return NULL;\n        }\n    }\n    return wr;\n}", "target": 0}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "relax_ng_parse(const char *path, xml_read_cb cb, void *arg)\n{\n\txmlTextReaderPtr reader;\n\txmlRelaxNGValidCtxtPtr rngvalidctx;\n\tint read;\n\tint error;\n\treader = xmlNewTextReaderFilename(path);\n\tif (reader == NULL)\n\t\treturn pr_val_err(\"Couldn't get XML '%s' file.\", path);\n\terror = xmlTextReaderRelaxNGSetSchema(reader, schema);\n\tif (error) {\n\t\terror = pr_val_err(\"Couldn't set Relax NG schema.\");\n\t\tgoto free_reader;\n\t}\n\trngvalidctx = xmlRelaxNGNewValidCtxt(schema);\n\tif (rngvalidctx == NULL) {\n\t\terror = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");\n\t\tgoto free_reader;\n\t}\n\txmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,\n\t    relax_ng_log_warn, NULL);\n\terror = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);\n\tif (error) {\n\t\terror = pr_val_err(\"Invalid XML document\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,\n\t    NULL);\n\twhile ((read = xmlTextReaderRead(reader)) == 1) {\n\t\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\t\tgoto free_valid_ctx;\n\t\t}\n\t\terror = cb(reader, arg);\n\t\tif (error)\n\t\t\tgoto free_valid_ctx;\n\t}\n\tif (read < 0) {\n\t\terror = pr_val_err(\"Error parsing XML document.\");\n\t\tgoto free_valid_ctx;\n\t}\n\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\n\txmlFreeTextReader(reader);\n\treturn 0;\nfree_valid_ctx:\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\nfree_reader:\n\txmlFreeTextReader(reader);\n\treturn error;\n}", "target": 1}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "and_code_range_buf(BBuf* bbuf1, int not1, BBuf* bbuf2, int not2, BBuf** pbuf, ScanEnv* env)\n{\n  int r;\n  OnigCodePoint i, j, n1, n2, *data1, *data2;\n  OnigCodePoint from, to, from1, to1, from2, to2;\n  *pbuf = (BBuf* )NULL;\n  if (IS_NULL(bbuf1)) {\n    if (not1 != 0 && IS_NOT_NULL(bbuf2)) \n      return bbuf_clone(pbuf, bbuf2);\n    return 0;\n  }\n  else if (IS_NULL(bbuf2)) {\n    if (not2 != 0)\n      return bbuf_clone(pbuf, bbuf1);\n    return 0;\n  }\n  if (not1 != 0)\n    SWAP_BBUF_NOT(bbuf1, not1, bbuf2, not2);\n  data1 = (OnigCodePoint* )(bbuf1->p);\n  data2 = (OnigCodePoint* )(bbuf2->p);\n  GET_CODE_POINT(n1, data1);\n  GET_CODE_POINT(n2, data2);\n  data1++;\n  data2++;\n  if (not2 == 0 && not1 == 0) { \n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      for (j = 0; j < n2; j++) {\n\tfrom2 = data2[j*2];\n\tto2   = data2[j*2+1];\n\tif (from2 > to1) break;\n\tif (to2 < from1) continue;\n\tfrom = MAX(from1, from2);\n\tto   = MIN(to1, to2);\n\tr = add_code_range_to_buf(pbuf, env, from, to);\n\tif (r != 0) return r;\n      }\n    }\n  }\n  else if (not1 == 0) { \n    for (i = 0; i < n1; i++) {\n      from1 = data1[i*2];\n      to1   = data1[i*2+1];\n      r = and_code_range1(pbuf, env, from1, to1, data2, n2);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "int sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "static int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tpgprot_t prot = vma->vm_page_prot;\n\tif (vma->vm_pgoff + vma_pages(vma) > lpc_ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tprot = pgprot_noncached(prot);\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 0}
{"code": "void SetBuildInfoAnnotations(std::map<std::string, std::string>* annotations) {\n  base::android::BuildInfo* info = base::android::BuildInfo::GetInstance();\n   (*annotations)[\"android_build_id\"] = info->android_build_id();\n   (*annotations)[\"android_build_fp\"] = info->android_build_fp();\n   (*annotations)[\"device\"] = info->device();\n   (*annotations)[\"model\"] = info->model();\n   (*annotations)[\"brand\"] = info->brand();\n  (*annotations)[\"board\"] = info->board();\n  (*annotations)[\"installer_package_name\"] = info->installer_package_name();\n  (*annotations)[\"abi_name\"] = info->abi_name();\n  (*annotations)[\"custom_themes\"] = info->custom_themes();\n  (*annotations)[\"resources_verison\"] = info->resources_version();\n  (*annotations)[\"gms_core_version\"] = info->gms_version_code();\n  if (info->firebase_app_id()[0] != '\\0') {\n    (*annotations)[\"package\"] = std::string(info->firebase_app_id()) + \" v\" +\n                                info->package_version_code() + \" (\" +\n                                info->package_version_name() + \")\";\n  }\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "static int get_lower_vlan_dev_tc(struct net_device *dev,\n\t\t\t\t struct netdev_nested_priv *priv)\n{\n\tstruct iboe_prio_tc_map *map = (struct iboe_prio_tc_map *)priv->data;\n\tif (is_vlan_dev(dev))\n\t\tmap->output_tc = get_vlan_ndev_tc(dev, map->input_prio);\n\telse if (dev->num_tc)\n\t\tmap->output_tc = netdev_get_prio_tc_map(dev, map->input_prio);\n\telse\n\t\tmap->output_tc = 0;\n\tmap->found = true;\n\treturn 1;\n}", "target": 0}
{"code": "static inline void GetMaximumPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n  size_t\n    color,\n    maximum;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  maximum=p->nodes[color].next[0];\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (color > maximum)\n      maximum=color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) maximum);\n}", "target": 0}
{"code": "static int __init si_domain_init(int hw)\n{\n\tint nid, ret;\n\tsi_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);\n\tif (!si_domain)\n\t\treturn -EFAULT;\n\tif (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) {\n\t\tdomain_exit(si_domain);\n\t\treturn -EFAULT;\n\t}\n\tpr_debug(\"Identity mapping domain allocated\\n\");\n\tif (hw)\n\t\treturn 0;\n\tfor_each_online_node(nid) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tint i;\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tret = iommu_domain_identity_map(si_domain,\n\t\t\t\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteRawTile\";\n\tif (!WRITECHECKTILES(tif, module))\n\t\treturn ((tmsize_t)(-1));\n\tif (tile >= tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Tile %lu out of range, max %lu\",\n\t\t    (unsigned long) tile,\n\t\t    (unsigned long) tif->tif_dir.td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\treturn (TIFFAppendToStrip(tif, tile, (uint8*) data, cc) ?\n\t    cc : (tmsize_t)(-1));\n}", "target": 0}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "void GpuDataManager::UpdateGpuInfo(const GPUInfo& gpu_info) {\n  {\n     base::AutoLock auto_lock(gpu_info_lock_);\n     if (!gpu_info_.Merge(gpu_info))\n       return;\n    RunGpuInfoUpdateCallbacks();\n     content::GetContentClient()->SetGpuInfo(gpu_info_);\n   }\n  UpdateGpuFeatureFlags();\n}", "target": 1}
{"code": "TypedValue HHVM_FUNCTION(array_pad,\n                         const Variant& input,\n                         int pad_size,\n                         const Variant& pad_value) {\n  getCheckedArray(input);\n  if (pad_size > 0) {\n    return tvReturn(ArrayUtil::Pad(arr_input, pad_value, pad_size, true));\n  }\n  return tvReturn(ArrayUtil::Pad(arr_input, pad_value, -pad_size, false));\n}", "target": 0}
{"code": "void ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\tqsUsername = si->qsUsername;\n\tg.s.qsLastServer = si->qsName;\n\tQDialog::accept();\n}", "target": 0}
{"code": "static inline bool ieee80211_rx_reorder_ready(struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t      int index)\n{\n\tstruct sk_buff_head *frames = &tid_agg_rx->reorder_buf[index];\n\tstruct sk_buff *tail = skb_peek_tail(frames);\n\tstruct ieee80211_rx_status *status;\n\tif (tid_agg_rx->reorder_buf_filtered & BIT_ULL(index))\n\t\treturn true;\n\tif (!tail)\n\t\treturn false;\n\tstatus = IEEE80211_SKB_RXCB(tail);\n\tif (status->flag & RX_FLAG_AMSDU_MORE)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "        bool operator()(const Exiv2::Xmpdatum& xmpdatum) const\n            { return key_ == xmpdatum.key(); }", "target": 0}
{"code": "static RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tsz = r_buf_size (bf->buf);\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\tr_list_append (ret, sect);\n\treturn ret;\n}", "target": 1}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void Shell::DeleteInstance() {\n  delete instance_;\n  instance_ = nullptr;\n}", "target": 0}
{"code": "void Browser::ExitFullscreenModeForTab(WebContents* web_contents) {\n  exclusive_access_manager_->fullscreen_controller()->ExitFullscreenModeForTab(\n      web_contents);\n}", "target": 0}
{"code": "bool Curl_meets_timecondition(struct Curl_easy *data, time_t timeofdoc)\n{\n  if((timeofdoc == 0) || (data->set.timevalue == 0))\n    return TRUE;\n  switch(data->set.timecondition) {\n  case CURL_TIMECOND_IFMODSINCE:\n  default:\n    if(timeofdoc <= data->set.timevalue) {\n      infof(data,\n            \"The requested document is not new enough\");\n      data->info.timecond = TRUE;\n      return FALSE;\n    }\n    break;\n  case CURL_TIMECOND_IFUNMODSINCE:\n    if(timeofdoc >= data->set.timevalue) {\n      infof(data,\n            \"The requested document is not old enough\");\n      data->info.timecond = TRUE;\n      return FALSE;\n    }\n    break;\n  }\n  return TRUE;\n}", "target": 0}
{"code": "static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p;\n    int16_t *sample[4][2];\n    int lbd    = s->avctx->bits_per_raw_sample <= 8;\n    int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n    for (x = 0; x < 4; x++) {\n        sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;\n        sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;\n    }\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int16_t *temp = sample[p][0]; \n            sample[p][0] = sample[p][1];\n            sample[p][1] = temp;\n            sample[p][1][-1]= sample[p][0][0  ];\n            sample[p][0][ w]= sample[p][0][w-1];\n            if (lbd && s->slice_coding_mode == 0)\n                decode_line(s, w, sample[p], (p + 1)/2, 9);\n            else\n                decode_line(s, w, sample[p], (p + 1)/2, bits + (s->slice_coding_mode != 1));\n        }\n        for (x = 0; x < w; x++) {\n            int g = sample[0][1][x];\n            int b = sample[1][1][x];\n            int r = sample[2][1][x];\n            int a = sample[3][1][x];\n            if (s->slice_coding_mode != 1) {\n                b -= offset;\n                r -= offset;\n                g -= (b * s->slice_rct_by_coef + r * s->slice_rct_ry_coef) >> 2;\n                b += g;\n                r += g;\n            }\n            if (lbd)\n                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24);\n            else {\n                *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = b;\n                *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = g;\n                *((uint16_t*)(src[2] + x*2 + stride[2]*y)) = r;\n            }\n        }\n    }\n}", "target": 0}
{"code": " void OmniboxEditModel::RestoreState(const State* state) {\n   controller_->GetToolbarModel()->set_url_replacement_enabled(\n      !state || state->url_replacement_enabled);\n   permanent_text_ = controller_->GetToolbarModel()->GetText();\n  view_->RevertWithoutResettingSearchTermReplacement();\n  input_ = state ? state->autocomplete_input : AutocompleteInput();\n  if (!state)\n    return;\n  SetFocusState(state->focus_state, OMNIBOX_FOCUS_CHANGE_TAB_SWITCH);\n  focus_source_ = state->focus_source;\n  if (state->user_input_in_progress) {\n    keyword_ = state->keyword;\n    is_keyword_hint_ = state->is_keyword_hint;\n    view_->SetUserText(state->user_text,\n        DisplayTextFromUserText(state->user_text), false);\n    view_->SetGrayTextAutocompletion(state->gray_text);\n  }\n}", "target": 1}
{"code": "xsltNewKeyDef(const xmlChar *name, const xmlChar *nameURI) {\n    xsltKeyDefPtr cur;\n    cur = (xsltKeyDefPtr) xmlMalloc(sizeof(xsltKeyDef));\n    if (cur == NULL) {\n\txsltTransformError(NULL, NULL, NULL,\n\t\t\"xsltNewKeyDef : malloc failed\\n\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xsltKeyDef));\n    if (name != NULL)\n\tcur->name = xmlStrdup(name);\n    if (nameURI != NULL)\n\tcur->nameURI = xmlStrdup(nameURI);\n    cur->nsList = NULL;\n    return(cur);\n}", "target": 0}
{"code": "xfs_iunlink_insert_backref(\n\tstruct xfs_perag\t*pag,\n\tstruct xfs_iunlink\t*iu)\n{\n\tint\t\t\terror;\n\terror = rhashtable_insert_fast(&pag->pagi_unlinked_hash,\n\t\t\t&iu->iu_rhash_head, xfs_iunlink_hash_params);\n\tif (error) {\n\t\tWARN(error != -ENOMEM, \"iunlink cache insert error %d\", error);\n\t\tkmem_free(iu);\n\t}\n\tif (error != 0 && error != -EEXIST)\n\t\terror = 0;\n\treturn error;\n}", "target": 0}
{"code": "ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    ptr = buf;\n    for (;;) {\n\tif (bytes < 1)\n\t    return ptr - buf;\n\tif ((*ptr & 0xC0) == 0xC0) {\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\t    n = ptr[0] & 0x3F;\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\t    ptr += 2; bytes -= 2;\n\t} else {\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\t}\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  \n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\t    state->x = 0;\n\t    if (++state->y >= state->ysize) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "static int sr9700_get_eeprom_len(struct net_device *netdev)\n{\n\treturn SR_EEPROM_LEN;\n}", "target": 0}
{"code": "static void kvm_gen_update_masterclock(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_arch *ka = &kvm->arch;\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tkvm_make_mclock_inprogress_request(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tclear_bit(KVM_REQ_MCLOCK_INPROGRESS, &vcpu->requests);\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n#endif\n}", "target": 0}
{"code": "dict_param_enumerate(iparam_list * plist, gs_param_enumerator_t * penum,\n                     gs_param_key_t * key, ref_type * type)\n{\n    ref elt[2];\n    int code;\n    dict_param_list *const pdlist = (dict_param_list *) plist;\n    int index =\n    (penum->intval != 0 ? penum->intval : dict_first(&pdlist->dict));\n    index = dict_next(&pdlist->dict, index, elt);\n    if (index < 0)\n        return 1;\n    *type = r_type(&elt[1]);\n    code = ref_to_key(&elt[0], key, plist);\n    penum->intval = index;\n    return code;\n}", "target": 0}
{"code": " void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }", "target": 1}
{"code": "static int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv,\n\t\t\t      int depth)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\tmutex_lock_nested(&ep->mtx, depth);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\terror = (*sproc)(ep, &txlist, priv);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\tif (!ep_is_linked(&epi->rdllink))\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t}\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tlist_splice(&txlist, &ep->rdllist);\n\tif (!list_empty(&ep->rdllist)) {\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tmutex_unlock(&ep->mtx);\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\treturn error;\n}", "target": 0}
{"code": "void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)\n{\n\tvoid *buf = n->nm_nlh;\n        size_t nlmsg_len = n->nm_nlh->nlmsg_len;\n        size_t tlen;\n        tlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;\n        if ((tlen + nlmsg_len) > n->nm_size)\n\tn->nm_nlh->nlmsg_len += tlen;\n\tif (tlen > len)\n\t\tmemset(buf + len, 0, tlen - len);\n\tNL_DBG(2, \"msg %p: Reserved %zu (%zu) bytes, pad=%d, nlmsg_len=%d\\n\",\n\t\t  n, tlen, len, pad, n->nm_nlh->nlmsg_len);\n\treturn buf;\n}", "target": 1}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "static int32_t virtio_net_rsc_coalesce4(VirtioNetRscChain *chain,\n                                        VirtioNetRscSeg *seg,\n                                        const uint8_t *buf, size_t size,\n                                        VirtioNetRscUnit *unit)\n{\n    struct ip_header *ip1, *ip2;\n    ip1 = (struct ip_header *)(unit->ip);\n    ip2 = (struct ip_header *)(seg->unit.ip);\n    if ((ip1->ip_src ^ ip2->ip_src) || (ip1->ip_dst ^ ip2->ip_dst)\n        || (unit->tcp->th_sport ^ seg->unit.tcp->th_sport)\n        || (unit->tcp->th_dport ^ seg->unit.tcp->th_dport)) {\n        chain->stat.no_match++;\n        return RSC_NO_MATCH;\n    }\n    return virtio_net_rsc_coalesce_data(chain, seg, buf, unit);\n}", "target": 0}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 0}
{"code": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\treturn err;\n}", "target": 1}
{"code": "ldns_fget_keyword_data(FILE *f, const char *keyword, const char *k_del, char *data,\n               const char *d_del, size_t data_limit)\n{\n       return ldns_fget_keyword_data_l(f, keyword, k_del, data, d_del,\n\t\t       data_limit, NULL);\n}", "target": 0}
{"code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n  LOG_DEBUG(5, \"Extracting: \" << path);\n  return extract(*SystemUtilities::oopen(path));\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_put_line)\n{\n\tchar *query;\n\tzval *pgsql_link = NULL;\n\tint query_len, id = -1;\n\tPGconn *pgsql;\n\tint result = 0, argc = ZEND_NUM_ARGS();\n\tif (argc == 1) {\n\t\tif (zend_parse_parameters(argc TSRMLS_CC, \"s\", &query, &query_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tid = PGG(default_link);\n\t\tCHECK_DEFAULT_LINK(id);\n\t} else {\n\t\tif (zend_parse_parameters(argc TSRMLS_CC, \"rs\", &pgsql_link, &query, &query_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\t\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tresult = PQputline(pgsql, query);\n\tif (result==EOF) {\n\t\tPHP_PQ_ERROR(\"Query failed: %s\", pgsql);\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "monitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    memcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}", "target": 0}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "ebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n                const struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\tint verdict, i;\n\tif (vlan_tx_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (FWINV2(ntohs(ethproto) >= 1536, EBT_IPROTO))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t   FWINV2(e->ethproto != ethproto, EBT_IPROTO))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\n\t\treturn 1;\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\n\t\treturn 1;\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\n\t\t\t   e->sourcemsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_ISOURCE) )\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_dest[i] ^ e->destmac[i]) &\n\t\t\t   e->destmsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_IDEST) )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void __init taa_select_mitigation(void)\n{\n\tu64 ia32_cap;\n\tif (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\ttaa_mitigation = TAA_MITIGATION_TSX_DISABLED;\n\t\tgoto out;\n\t}\n\tif (cpu_mitigations_off()) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (taa_mitigation == TAA_MITIGATION_OFF &&\n\t    mds_mitigation == MDS_MITIGATION_OFF)\n\t\tgoto out;\n\tif (boot_cpu_has(X86_FEATURE_MD_CLEAR))\n\t\ttaa_mitigation = TAA_MITIGATION_VERW;\n\telse\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tia32_cap = x86_read_arch_cap_msr();\n\tif ( (ia32_cap & ARCH_CAP_MDS_NO) &&\n\t    !(ia32_cap & ARCH_CAP_TSX_CTRL_MSR))\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tstatic_branch_enable(&mds_user_clear);\n\tif (taa_nosmt || cpu_mitigations_auto_nosmt())\n\t\tcpu_smt_disable(false);\n\tif (mds_mitigation == MDS_MITIGATION_OFF &&\n\t    boot_cpu_has_bug(X86_BUG_MDS)) {\n\t\tmds_mitigation = MDS_MITIGATION_FULL;\n\t\tmds_select_mitigation();\n\t}\nout:\n\tpr_info(\"%s\\n\", taa_strings[taa_mitigation]);\n}", "target": 0}
{"code": "sg_vma_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tSg_fd *sfp;\n\tunsigned long offset, len, sa;\n\tSg_scatter_hold *rsv_schp;\n\tint k, length;\n\tif ((NULL == vma) || (!(sfp = (Sg_fd *) vma->vm_private_data)))\n\t\treturn VM_FAULT_SIGBUS;\n\trsv_schp = &sfp->reserve;\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= rsv_schp->bufflen)\n\t\treturn VM_FAULT_SIGBUS;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_vma_fault: offset=%lu, scatg=%d\\n\",\n\t\t\t\t      offset, rsv_schp->k_use_sg));\n\tsa = vma->vm_start;\n\tlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\n\tfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\n\t\tlen = vma->vm_end - sa;\n\t\tlen = (len < length) ? len : length;\n\t\tif (offset < len) {\n\t\t\tstruct page *page = nth_page(rsv_schp->pages[k],\n\t\t\t\t\t\t     offset >> PAGE_SHIFT);\n\t\t\tget_page(page);\t\n\t\t\tvmf->page = page;\n\t\t\treturn 0; \n\t\t}\n\t\tsa += len;\n\t\toffset -= len;\n\t}\n\treturn VM_FAULT_SIGBUS;\n}", "target": 0}
{"code": "static int mxf_read_pulldown_component(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFPulldownComponent *mxf_pulldown = arg;\n    switch(tag) {\n    case 0x0d01:\n        avio_read(pb, mxf_pulldown->input_segment_ref, 16);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "static const char *set_enable_sendfile(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_sendfile = ENABLE_SENDFILE_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "PingStats::~PingStats() {\n\tdelete asQuantile;\n}", "target": 0}
{"code": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\n{\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\n  RawData->Assign(Data);\n  if (RawData->FSProtocol != fsSFTPonly)\n  {\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\n  }\n  RawData->HostName = FactoryDefaults->HostName;\n  RawData->PortNumber = FactoryDefaults->PortNumber;\n  RawData->UserName = FactoryDefaults->UserName;\n  RawData->Password = FactoryDefaults->Password;\n  RawData->Ftps = FactoryDefaults->Ftps;\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\n  SettingsMemo->Lines = Options.get();\n  bool Result = TCustomDialog::Execute();\n  if (Result)\n  {\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\n    BackupData->Assign(Data);\n    Data->DefaultSettings();\n    Data->FSProtocol = BackupData->FSProtocol;\n    Data->HostName = BackupData->HostName;\n    Data->PortNumber = BackupData->PortNumber;\n    Data->UserName = BackupData->UserName;\n    Data->Password = BackupData->Password;\n    Data->Ftps = BackupData->Ftps;\n    Data->ApplyRawSettings(SettingsMemo->Lines);\n  }\n  return Result;\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\tarea->bitmap = kzalloc(BITS_TO_LONGS(UINSNS_PER_PAGE) * sizeof(long), GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}", "target": 0}
{"code": "int _gnutls_x509_verify_signature(const gnutls_datum_t * tbs,\n\t\t\t\t  const gnutls_datum_t * signature,\n\t\t\t\t  gnutls_x509_crt_t issuer)\n{\n    mpi_t issuer_params[MAX_PUBLIC_PARAMS_SIZE];\n    int ret, issuer_params_size, i;\n    issuer_params_size = MAX_PUBLIC_PARAMS_SIZE;\n    ret =\n\t_gnutls_x509_crt_get_mpis(issuer, issuer_params,\n\t\t\t\t  &issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    ret =\n\tverify_sig(tbs, signature,\n\t\t   gnutls_x509_crt_get_pk_algorithm(issuer, NULL),\n\t\t   issuer_params, issuer_params_size);\n    if (ret < 0) {\n\tgnutls_assert();\n    }\n    for (i = 0; i < issuer_params_size; i++) {\n\t_gnutls_mpi_release(&issuer_params[i]);\n    }\n    return ret;\n}", "target": 0}
{"code": "static void fill_model_structures(SPICE_GNUC_UNUSED Encoder *encoder, FamilyStat *family_stat,\n                                  unsigned int rep_first, unsigned int first_size,\n                                  unsigned int rep_next, unsigned int mul_size,\n                                  unsigned int levels, unsigned int ncounters,\n                                  unsigned int nbuckets, unsigned int n_buckets_ptrs)\n{\n    unsigned int\n    bsize,\n    bstart,\n    bend = 0,\n    repcntr,\n    bnumber;\n    COUNTER * free_counter = family_stat->counters;\n    bnumber = 0;\n    repcntr = rep_first + 1;    \n    bsize = first_size;\n    do { \n        if (bnumber) {\n            bstart = bend + 1;\n        } else {\n            bstart = 0;\n        }\n        if (!--repcntr) {\n            repcntr = rep_next;\n            bsize *= mul_size;\n        }\n        bend = bstart + bsize - 1;\n        if (bend + bsize >= levels) {\n            bend = levels - 1;\n        }\n        family_stat->buckets_buf[bnumber].pcounters = free_counter;\n        free_counter += ncounters;\n        spice_assert(bstart < n_buckets_ptrs);\n        {\n            unsigned int i;\n            spice_assert(bend < n_buckets_ptrs);\n            for (i = bstart; i <= bend; i++) {\n                family_stat->buckets_ptrs[i] = family_stat->buckets_buf + bnumber;\n            }\n        }\n        bnumber++;\n    } while (bend < levels - 1);\n    spice_assert(free_counter - family_stat->counters == (ptrdiff_t)(nbuckets * ncounters));\n}", "target": 0}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\treturn 0;\n}", "target": 1}
{"code": "static int unlock_full_stripe(struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t      bool locked)\n{\n\tstruct btrfs_block_group_cache *bg_cache;\n\tstruct btrfs_full_stripe_locks_tree *locks_root;\n\tstruct full_stripe_lock *fstripe_lock;\n\tu64 fstripe_start;\n\tbool freeit = false;\n\tint ret = 0;\n\tif (!locked)\n\t\treturn 0;\n\tbg_cache = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!bg_cache) {\n\t\tASSERT(0);\n\t\treturn -ENOENT;\n\t}\n\tif (!(bg_cache->flags & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\tgoto out;\n\tlocks_root = &bg_cache->full_stripe_locks_root;\n\tfstripe_start = get_full_stripe_logical(bg_cache, bytenr);\n\tmutex_lock(&locks_root->lock);\n\tfstripe_lock = search_full_stripe_lock(locks_root, fstripe_start);\n\tif (!fstripe_lock) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t\tmutex_unlock(&locks_root->lock);\n\t\tgoto out;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\tWARN_ON(1);\n\t\tbtrfs_warn(fs_info, \"full stripe lock at %llu refcount underflow\",\n\t\t\tfstripe_lock->logical);\n\t} else {\n\t\tfstripe_lock->refs--;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\trb_erase(&fstripe_lock->node, &locks_root->root);\n\t\tfreeit = true;\n\t}\n\tmutex_unlock(&locks_root->lock);\n\tmutex_unlock(&fstripe_lock->mutex);\n\tif (freeit)\n\t\tkfree(fstripe_lock);\nout:\n\tbtrfs_put_block_group(bg_cache);\n\treturn ret;\n}", "target": 0}
{"code": "int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\tif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "static void carray(JF, js_Ast *list)\n{\n\tint i = 0;\n\twhile (list) {\n\t\tif (list->a->type != EXP_UNDEF) {\n\t\t\temitnumber(J, F, i++);\n\t\t\tcexp(J, F, list->a);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t\tlist = list->b;\n\t}\n}", "target": 0}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "ram_addr_t qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n                                   void (*resized)(const char*,\n                                                   uint64_t length,\n                                                   void *host),\n                                   void *host, bool resizeable,\n                                   MemoryRegion *mr, Error **errp)\n{\n    RAMBlock *new_block;\n    ram_addr_t addr;\n    Error *local_err = NULL;\n    size = TARGET_PAGE_ALIGN(size);\n    max_size = TARGET_PAGE_ALIGN(max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    new_block->mr = mr;\n    new_block->resized = resized;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->fd = -1;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    if (resizeable) {\n        new_block->flags |= RAM_RESIZEABLE;\n    }\n    addr = ram_block_add(new_block, &local_err);\n    if (local_err) {\n        g_free(new_block);\n        error_propagate(errp, local_err);\n        return -1;\n    }\n    return addr;\n}", "target": 0}
{"code": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\t*minor_status = 0;\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\treturn (ret);\n}", "target": 1}
{"code": "void _WM_do_meta_instrumentname(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_SDEBUG(__FUNCTION__, ch, data->data.string);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "target": 0}
{"code": "SSLNetVConnection::select_next_protocol(SSL *ssl, const unsigned char **out, unsigned char *outlen,\n                                        const unsigned char *in ATS_UNUSED, unsigned inlen ATS_UNUSED, void *)\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  const unsigned char *npn = nullptr;\n  unsigned npnsz           = 0;\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(&npn, &npnsz)) {\n#if HAVE_SSL_SELECT_NEXT_PROTO\n    if (SSL_select_next_proto((unsigned char **)out, outlen, npn, npnsz, in, inlen) == OPENSSL_NPN_NEGOTIATED) {\n      Debug(\"ssl\", \"selected ALPN protocol %.*s\", (int)(*outlen), *out);\n      return SSL_TLSEXT_ERR_OK;\n    }\n#endif \n  }\n  *out    = nullptr;\n  *outlen = 0;\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "static int __tipc_nl_add_monitor_prop(struct net *net, struct tipc_nl_msg *msg)\n{\n\tstruct nlattr *attrs;\n\tvoid *hdr;\n\tu32 val;\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  0, TIPC_NL_MON_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_MON);\n\tif (!attrs)\n\t\tgoto msg_full;\n\tval = tipc_nl_monitor_get_threshold(net);\n\tif (nla_put_u32(msg->skb, TIPC_NLA_MON_ACTIVATION_THRESHOLD, val))\n\t\tgoto attr_msg_full;\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\treturn 0;\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "    bool Nikon3MnHeader::read(const byte* pData,\n                              uint32_t    size,\n                              ByteOrder   )\n    {\n        if (!pData || size < sizeOfSignature()) return false;\n        if (0 != memcmp(pData, signature_, 6)) return false;\n        buf_.alloc(sizeOfSignature());\n        std::memcpy(buf_.pData_, pData, buf_.size_);\n        TiffHeader th;\n        if (!th.read(buf_.pData_ + 10, 8)) return false;\n        byteOrder_ = th.byteOrder();\n        start_ = 10 + th.offset();\n        return true;\n    } ", "target": 0}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_uint_32 max_palette_length;\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n   if (num_palette < 0 || num_palette > max_palette_length)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "jio_snprintf(char * str, int n, const char * format, ...)\n{\n\tva_list args;\n\tint result;\n\tTrc_SC_snprintf_Entry();\n\tva_start(args, format);\n#if defined(WIN32) && !defined(WIN32_IBMC)\n\tresult = _vsnprintf( str, n, format, args );\n#else\n\tresult = vsprintf( str, format, args );\n#endif\n\tva_end(args);\n\tTrc_SC_snprintf_Exit(result);\n\treturn result;\n}", "target": 1}
{"code": "int vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\tif (error)\n\t\treturn error;\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": " void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }", "target": 1}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "get_auth_param(struct auth_param *auth, char *name)\n{\n    struct auth_param *ap;\n    for (ap = auth; ap->name != NULL; ap++) {\n\tif (strcasecmp(name, ap->name) == 0)\n\t    return ap->val;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "static CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (location) {\n    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n    return StringPrimitive::createEfficient(\n        runtime, debugInfo->getFilenameByID(location->filenameId));\n  } else {\n    llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n    if (!sourceURL.empty()) {\n      return StringPrimitive::createEfficient(runtime, sourceURL);\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}", "target": 1}
{"code": "static int check_client_redirect_uri_valid(struct _oidc_config * config,\n                                           const char * client_id,\n                                           const char * redirect_uri,\n                                           const char * ip_source) {\n  json_t * j_client = config->glewlwyd_config->glewlwyd_plugin_callback_get_client(config->glewlwyd_config, client_id);\n  int uri_found = 0, ret;\n  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n    if (!o_strnullempty(redirect_uri)) {\n      if (json_array_has_string(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), redirect_uri)) {\n        uri_found = 1;\n      } else {\n        uri_found = 0;\n      }\n    } else {\n      uri_found = 1;\n    }\n    if (!uri_found) {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_redirect_uri_valid - oidc - Error, redirect_uri '%s' is invalid for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      ret = G_OK;\n    }\n  } else {\n    ret = G_ERROR_UNAUTHORIZED;\n  }\n  json_decref(j_client);\n  return ret;\n}", "target": 1}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "_XimEncodeStatusValue(\n    Xic\t\t\t ic,\n    XIMResourceList\t res,\n    XIMArg\t\t*p)\n{\n    if (res->xrm_name == XrmStringToQuark(XNStdColormap)) {\n\tXStandardColormap\t*colormap_ret = NULL;\n\tint\t\t\t count;\n\tif (!(XGetRGBColormaps(ic->core.im->core.display,\n\t\t\t\tic->core.focus_window, &colormap_ret,\n\t\t\t\t&count, (Atom)p->value)))\n\t    return False;\n\tXFree(colormap_ret);\n    } else if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tint\t\t  list_ret;\n\tXFontStruct\t**struct_list;\n\tchar\t\t**name_list;\n\tchar\t\t *tmp;\n\tint\t\t  len;\n\tregister int\t  i;\n\tif (!p->value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)p->value,\n\t\t\t\t\t\t &struct_list, &name_list);\n\tfor (i = 0, len = 0; i < list_ret; i++) {\n\t     len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif (!(tmp = Xmalloc(len+1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "nfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_readlink *readlink)\n{\n\treadlink->rl_rqstp = rqstp;\n\treadlink->rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}", "target": 0}
{"code": "base::string16 GetRelyingPartyIdString(\n    AuthenticatorRequestDialogModel* dialog_model) {\n  static constexpr char kRpIdUrlPrefix[] = \"https:\n  static constexpr int kDialogWidth = 300;\n   const auto& rp_id = dialog_model->relying_party_id();\n   DCHECK(!rp_id.empty());\n   GURL rp_id_url(kRpIdUrlPrefix + rp_id);\n  auto max_static_string_length = gfx::GetStringWidthF(\n      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),\n      gfx::Typesetter::DEFAULT);\n  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),\n                                  kDialogWidth - max_static_string_length);\n }", "target": 1}
{"code": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}", "target": 1}
{"code": "bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *failing_dev)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tu64 next_start = 0;\n\tbool ret = true;\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, 0, (u64)-1);\n\tread_unlock(&map_tree->map_tree.lock);\n\tif (!em) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\twhile (em) {\n\t\tstruct map_lookup *map;\n\t\tint missing = 0;\n\t\tint max_tolerated;\n\t\tint i;\n\t\tmap = em->map_lookup;\n\t\tmax_tolerated =\n\t\t\tbtrfs_get_num_tolerated_disk_barrier_failures(\n\t\t\t\t\tmap->type);\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tstruct btrfs_device *dev = map->stripes[i].dev;\n\t\t\tif (!dev || !dev->bdev ||\n\t\t\t    test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) ||\n\t\t\t    dev->last_flush_error)\n\t\t\t\tmissing++;\n\t\t\telse if (failing_dev && failing_dev == dev)\n\t\t\t\tmissing++;\n\t\t}\n\t\tif (missing > max_tolerated) {\n\t\t\tif (!failing_dev)\n\t\t\t\tbtrfs_warn(fs_info,\n\t\"chunk %llu missing %d devices, max tolerance is %d for writable mount\",\n\t\t\t\t   em->start, missing, max_tolerated);\n\t\t\tfree_extent_map(em);\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\tnext_start = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tread_lock(&map_tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&map_tree->map_tree, next_start,\n\t\t\t\t\t   (u64)(-1) - next_start);\n\t\tread_unlock(&map_tree->map_tree.lock);\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "static int nfs4_proc_rename_done(struct rpc_task *task, struct inode *old_dir,\n\t\t\t\t struct inode *new_dir)\n{\n\tstruct nfs_renameres *res = task->tk_msg.rpc_resp;\n\tif (!nfs4_sequence_done(task, &res->seq_res))\n\t\treturn 0;\n\tif (nfs4_async_handle_error(task, res->server, NULL) == -EAGAIN)\n\t\treturn 0;\n\tupdate_changeattr(old_dir, &res->old_cinfo);\n\tupdate_changeattr(new_dir, &res->new_cinfo);\n\treturn 1;\n}", "target": 0}
{"code": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"%p\\n\", sock);\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      break;\n  }\n  _Data[j] = 0;\n}", "target": 1}
{"code": "isdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\tif (p) {\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void FNAME_DECL(uncompress_row0_seg)(int i,\n                                            PIXEL * const cur_row,\n                                            const int end,\n                                            const unsigned int waitmask,\n                                            const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    int stopidx;\n    spice_assert(end - i > 0);\n    if (i == 0) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    while (stopidx < end) {\n        for (; i <= stopidx; i++) {\n            unsigned int codewordlen;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n        }\n        UPDATE_MODEL(stopidx);\n        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n    }\n    for (; i < end; i++) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n    }\n    state->waitcnt = stopidx - end;\n}", "target": 0}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "onig_set_default_case_fold_flag(OnigCaseFoldType case_fold_flag)\n{\n  OnigDefaultCaseFoldFlag = case_fold_flag;\n  return 0;\n}", "target": 0}
{"code": "static int __execlists_context_alloc(struct intel_context *ce,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *ctx_obj;\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\tu32 context_size;\n\tint ret;\n\tGEM_BUG_ON(ce->state);\n\tcontext_size = round_up(engine->context_size, I915_GTT_PAGE_SIZE);\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tcontext_size += I915_GTT_PAGE_SIZE; \n\tctx_obj = i915_gem_object_create_shmem(engine->i915, context_size);\n\tif (IS_ERR(ctx_obj))\n\t\treturn PTR_ERR(ctx_obj);\n\tvma = i915_vma_instance(ctx_obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto error_deref_obj;\n\t}\n\tif (!ce->timeline) {\n\t\tstruct intel_timeline *tl;\n\t\ttl = intel_timeline_create(engine->gt, NULL);\n\t\tif (IS_ERR(tl)) {\n\t\t\tret = PTR_ERR(tl);\n\t\t\tgoto error_deref_obj;\n\t\t}\n\t\tce->timeline = tl;\n\t}\n\tring = intel_engine_create_ring(engine, (unsigned long)ce->ring);\n\tif (IS_ERR(ring)) {\n\t\tret = PTR_ERR(ring);\n\t\tgoto error_deref_obj;\n\t}\n\tret = populate_lr_context(ce, ctx_obj, engine, ring);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to populate LRC: %d\\n\", ret);\n\t\tgoto error_ring_free;\n\t}\n\tce->ring = ring;\n\tce->state = vma;\n\treturn 0;\nerror_ring_free:\n\tintel_ring_put(ring);\nerror_deref_obj:\n\ti915_gem_object_put(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "gx_edgebuffer_print(gx_edgebuffer * edgebuffer)\n{\n    int i;\n    dlprintf1(\"Edgebuffer %x\\n\", edgebuffer);\n    dlprintf4(\"xmin=%d xmax=%d base=%d height=%d\\n\",\n              edgebuffer->xmin, edgebuffer->xmax, edgebuffer->base, edgebuffer->height);\n    for (i=0; i < edgebuffer->height; i++) {\n        int  offset = edgebuffer->index[i];\n        int *row    = &edgebuffer->table[offset];\n        int count   = *row++;\n        dlprintf3(\"%d @ %d: %d =\", i, offset, count);\n        while (count-- > 0) {\n            int v = *row++;\n            dlprintf2(\" %d:%d\", v&~1, v&1);\n        }\n        dlprintf(\"\\n\");\n    }\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "const GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) return NULL;\n\treturn &mdcvb->mdcv;\n}", "target": 0}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": " ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n  auto params = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n  io_buffer_size_ = params->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n  socket->Send(io_buffer_,\n               io_buffer_size_,\n               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),\n               base::Bind(&BluetoothSocketSendFunction::OnError, this));\n  return did_respond() ? AlreadyResponded() : RespondLater();\n}", "target": 1}
{"code": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}", "target": 1}
{"code": "datetime_to_date(VALUE self)\n{\n    get_d1a(self);\n    if (simple_dat_p(adat)) {\n\tVALUE new = d_lite_s_alloc_simple(cDate);\n\t{\n\t    get_d1b(new);\n\t    bdat->s = adat->s;\n\t    bdat->s.jd = m_local_jd(adat);\n\t    return new;\n\t}\n    }\n    else {\n\tVALUE new = d_lite_s_alloc_simple(cDate);\n\t{\n\t    get_d1b(new);\n\t    copy_complex_to_simple(new, &bdat->s, &adat->c);\n\t    bdat->s.jd = m_local_jd(adat);\n\t    bdat->s.flags &= ~(HAVE_DF | HAVE_TIME | COMPLEX_DAT);\n\t    return new;\n\t}\n    }\n}", "target": 0}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for(list<string>::iterator it = exposable_hdrs.begin();\n      it != exposable_hdrs.end(); ++it) {\n      if (s.length() > 0)\n        s.append(\",\");\n      s.append((*it));\n  }\n}", "target": 1}
{"code": "png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,\n        png_bytep output, png_size_t output_size)\n{\n   png_size_t count = 0;\n   png_ptr->zstream.next_in = (png_bytep)data; \n   png_ptr->zstream.avail_in = size;\n   while (1)\n   {\n      int ret, avail;\n      png_ptr->zstream.next_out = png_ptr->zbuf;\n      png_ptr->zstream.avail_out = png_ptr->zbuf_size;\n      ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);\n      avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;\n      if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)\n       {\n          if (output != 0 && output_size > count)\n          {\n            int copy = output_size - count;\n            if (avail < copy) copy = avail;\n             png_memcpy(output + count, png_ptr->zbuf, copy);\n          }\n          count += avail;\n      }\n      if (ret == Z_OK)\n         continue;\n      png_ptr->zstream.avail_in = 0;\n      inflateReset(&png_ptr->zstream);\n      if (ret == Z_STREAM_END)\n         return count; \n      {\n         PNG_CONST char *msg;\n         if (png_ptr->zstream.msg != 0)\n            msg = png_ptr->zstream.msg;\n         else\n         {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n            char umsg[52];\n            switch (ret)\n            {\n               case Z_BUF_ERROR:\n                  msg = \"Buffer error in compressed datastream in %s chunk\";\n                  break;\n               case Z_DATA_ERROR:\n                  msg = \"Data error in compressed datastream in %s chunk\";\n                  break;\n               default:\n                  msg = \"Incomplete compressed datastream in %s chunk\";\n                  break;\n            }\n            png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);\n            msg = umsg;\n#else\n            msg = \"Damaged compressed datastream in chunk other than IDAT\";\n#endif\n         }\n         png_warning(png_ptr, msg);\n      }\n      return 0;\n   }\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "aspath_filter_exclude (struct aspath * source, struct aspath * exclude_list)\n{\n  struct assegment * srcseg, * exclseg, * lastseg;\n  struct aspath * newpath;\n  newpath = aspath_new();\n  lastseg = NULL;\n  for (srcseg = source->segments; srcseg; srcseg = srcseg->next)\n  {\n    unsigned i, y, newlen = 0, done = 0, skip_as;\n    struct assegment * newseg;\n    for (i = 0; i < srcseg->length; i++)\n    {\n      skip_as = 0;\n      for (exclseg = exclude_list->segments; exclseg && !skip_as; exclseg = exclseg->next)\n        for (y = 0; y < exclseg->length; y++)\n          if (srcseg->as[i] == exclseg->as[y])\n          {\n            skip_as = 1;\n            break;\n          }\n      if (!skip_as)\n        newlen++;\n    }\n    if (!newlen)\n      continue;\n    newseg = assegment_new (srcseg->type, newlen);\n    for (i = 0; i < srcseg->length; i++)\n    {\n      skip_as = 0;\n      for (exclseg = exclude_list->segments; exclseg && !skip_as; exclseg = exclseg->next)\n        for (y = 0; y < exclseg->length; y++)\n          if (srcseg->as[i] == exclseg->as[y])\n          {\n            skip_as = 1;\n            break;\n          }\n      if (skip_as)\n        continue;\n      newseg->as[done++] = srcseg->as[i];\n    }\n    if (!lastseg)\n      newpath->segments = newseg;\n    else\n      lastseg->next = newseg;\n    lastseg = newseg;\n  }\n  aspath_str_update (newpath);\n  aspath_free (source);\n  return newpath;\n}", "target": 0}
{"code": "xfs_iolock_two_inodes_and_break_layout(\n\tstruct inode\t\t*src,\n\tstruct inode\t\t*dest)\n{\n\tint\t\t\terror;\n\tif (src > dest)\n\t\tswap(src, dest);\nretry:\n\terror = break_layout(src, true);\n\tif (error)\n\t\treturn error;\n\tif (src != dest) {\n\t\terror = break_layout(dest, true);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tinode_lock(src);\n\terror = break_layout(src, false);\n\tif (error) {\n\t\tinode_unlock(src);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\tgoto retry;\n\t\treturn error;\n\t}\n\tif (src == dest)\n\t\treturn 0;\n\tinode_lock_nested(dest, I_MUTEX_NONDIR2);\n\terror = break_layout(dest, false);\n\tif (error) {\n\t\tinode_unlock(src);\n\t\tinode_unlock(dest);\n\t\tif (error == -EWOULDBLOCK)\n\t\t\tgoto retry;\n\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n \terr  = get_user(palp, &up->palette);\n \terr |= get_user(length, &up->length);\n \tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n \terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\treturn err;\n}", "target": 1}
{"code": "static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n{\n\tdown_read(&mm->mmap_sem);\n\tfor ( ; pm->node != MAX_NUMNODES; pm++) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct page *page;\n\t\tint err;\n\t\terr = -EFAULT;\n\t\tvma = find_vma(mm, pm->addr);\n\t\tif (!vma)\n\t\t\tgoto set_status;\n\t\tpage = follow_page(vma, pm->addr, 0);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto set_status;\n\t\terr = -ENOENT;\n\t\tif (!page || PageReserved(page))\n\t\t\tgoto set_status;\n\t\terr = page_to_nid(page);\nset_status:\n\t\tpm->status = err;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn 0;\n}", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n{\n    ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n    if (file) \n    {\n\tchar buffer[1024]; int len;\n\twhile ((len = zzip_file_read (file, buffer, 1024))) \n\t{\n\t    fwrite (buffer, 1, len, out);\n\t}\n\tzzip_file_close (file);\n    }\n}", "target": 1}
{"code": "Document DocumentSourceGroup::makeDocument(const Value& id,\n                                           const Accumulators& accums,\n                                           bool mergeableOutput) {\n    const size_t n = _accumulatedFields.size();\n    MutableDocument out(1 + n);\n    out.addField(\"_id\", expandId(id));\n    for (size_t i = 0; i < n; ++i) {\n        Value val = accums[i]->getValue(mergeableOutput);\n        if (val.missing()) {\n            out.addField(_accumulatedFields[i].fieldName, Value(BSONNULL));\n        } else {\n            out.addField(_accumulatedFields[i].fieldName, std::move(val));\n        }\n    }\n    _stats.totalOutputDataSizeBytes += out.getApproximateSize();\n    return out.freeze();\n}", "target": 0}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "put16(unsigned char *cp, unsigned short x)\n{\n\t*cp++ = x >> 8;\n\t*cp++ = x;\n\treturn cp;\n}", "target": 0}
{"code": "GF_Err gitn_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tptr->size += 2;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->entries[i].name) ptr->size += strlen(ptr->entries[i].name);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "RunTerminationHelper(HANDLE console_token, DWORD pid) {\n  WCHAR module_path[MAX_PATH];\n  GetModuleFileNameW(NULL, module_path, _countof(module_path));\n  std::wstring command { module_path };\n  command += L\" --terminate \" + std::to_wstring(pid);\n  STARTUPINFOW startup_info = {};\n  startup_info.cb = sizeof(startup_info);\n  startup_info.lpDesktop = (LPWSTR) L\"winsta0\\\\default\";\n  PROCESS_INFORMATION process_info;\n  if (!CreateProcessAsUserW(console_token,\n        NULL,\n        (LPWSTR) command.c_str(),\n        NULL,\n        NULL,\n        FALSE,\n        CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,\n        NULL,\n        NULL,\n        &startup_info,\n        &process_info)) {\n    return false;\n  }\n  WaitForSingleObject(process_info.hProcess, INFINITE);\n  DWORD exit_code;\n  GetExitCodeProcess(process_info.hProcess, &exit_code);\n  CloseHandle(process_info.hProcess);\n  CloseHandle(process_info.hThread);\n  return exit_code == 0;\n}", "target": 1}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "bool Virtual_tmp_table::open()\n{\n  DBUG_ASSERT(s->fields == m_alloced_field_count);\n  field[s->fields]= NULL;            \n  s->blob_field[s->blob_fields]= 0;  \n  uint null_pack_length= (s->null_fields + 7) / 8; \n  s->reclength+= null_pack_length;\n  s->rec_buff_length= ALIGN_SIZE(s->reclength + 1);\n  if (!(record[0]= (uchar*) in_use->alloc(s->rec_buff_length)))\n    return true;\n  if (null_pack_length)\n  {\n    null_flags= (uchar*) record[0];\n    s->null_bytes= s->null_bytes_for_compare= null_pack_length;\n  }\n  setup_field_pointers();\n  return false;\n}", "target": 0}
{"code": "static int nbd_receive_option_reply(QIOChannel *ioc, uint32_t opt,\n                                    nbd_opt_reply *reply, Error **errp)\n{\n    QEMU_BUILD_BUG_ON(sizeof(*reply) != 20);\n    if (read_sync(ioc, reply, sizeof(*reply)) != sizeof(*reply)) {\n        error_setg(errp, \"failed to read option reply\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    be64_to_cpus(&reply->magic);\n    be32_to_cpus(&reply->option);\n    be32_to_cpus(&reply->type);\n    be32_to_cpus(&reply->length);\n    TRACE(\"Received option reply %\" PRIx32\", type %\" PRIx32\", len %\" PRIu32,\n          reply->option, reply->type, reply->length);\n    if (reply->magic != NBD_REP_MAGIC) {\n        error_setg(errp, \"Unexpected option reply magic\");\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    if (reply->option != opt) {\n        error_setg(errp, \"Unexpected option type %x expected %x\",\n                   reply->option, opt);\n        nbd_send_opt_abort(ioc);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void radix_count(const RCCMPEntry *data, int size, int buckets[RADIX_PASSES][NBUCKETS])\n{\n    int i, j;\n    memset(buckets, 0, sizeof(buckets[0][0]) * RADIX_PASSES * NBUCKETS);\n    for (i = 0; i < size; i++) {\n        int v = data[i].value;\n        for (j = 0; j < RADIX_PASSES; j++) {\n            buckets[j][get_bucket(v, 0)]++;\n            v >>= BUCKET_BITS;\n        }\n        av_assert1(!v);\n    }\n    for (j = 0; j < RADIX_PASSES; j++) {\n        int offset = size;\n        for (i = NBUCKETS - 1; i >= 0; i--)\n            buckets[j][i] = offset -= buckets[j][i];\n        av_assert1(!buckets[j][0]);\n    }\n}", "target": 0}
{"code": "static uint16_t nvme_tx(NvmeCtrl *n, NvmeSg *sg, uint8_t *ptr, uint32_t len,\n                        NvmeTxDirection dir)\n{\n    assert(sg->flags & NVME_SG_ALLOC);\n    if (sg->flags & NVME_SG_DMA) {\n        const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n        dma_addr_t residual;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            dma_buf_write(ptr, len, &residual, &sg->qsg, attrs);\n        } else {\n            dma_buf_read(ptr, len, &residual, &sg->qsg, attrs);\n        }\n        if (unlikely(residual)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    } else {\n        size_t bytes;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            bytes = qemu_iovec_to_buf(&sg->iov, 0, ptr, len);\n        } else {\n            bytes = qemu_iovec_from_buf(&sg->iov, 0, ptr, len);\n        }\n        if (unlikely(bytes != len)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    }\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}", "target": 1}
{"code": "static int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\t\tsize += bv.bv_len;\n\t}\n\treturn size >> 9;\n}", "target": 0}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n  PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "concat_opt_exact_info_str(OptExactInfo* to, UChar* s, UChar* end,\n\t\t\t  int raw ARG_UNUSED, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p, end);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n}", "target": 0}
{"code": "nfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_access *access)\n{\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}", "target": 0}
{"code": "  int libraw_get_decoder_info(libraw_data_t *lr, libraw_decoder_info_t *d)\n  {\n    if (!lr || !d)\n      return EINVAL;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    return ip->get_decoder_info(d);\n  }", "target": 0}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n\t\tcb->done(cb);\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "void fill_luma_motion_vector_predictors(base_context* ctx,\n                                        const slice_segment_header* shdr,\n                                        de265_image* img,\n                                        int xC,int yC,int nCS,int xP,int yP,\n                                        int nPbW,int nPbH, int l,\n                                        int refIdx, int partIdx,\n                                        MotionVector out_mvpList[2])\n{\n  uint8_t availableFlagLXN[2];\n  MotionVector mvLXN[2];\n  derive_spatial_luma_vector_prediction(ctx, img, shdr, xC,yC, nCS, xP,yP,\n                                        nPbW,nPbH, l, refIdx, partIdx,\n                                        availableFlagLXN, mvLXN);\n  uint8_t availableFlagLXCol;\n  MotionVector mvLXCol;\n  if (availableFlagLXN[0] &&\n      availableFlagLXN[1] &&\n      (mvLXN[0].x != mvLXN[1].x || mvLXN[0].y != mvLXN[1].y)) {\n    availableFlagLXCol = 0;\n  }\n  else {\n    derive_temporal_luma_vector_prediction(ctx, img, shdr,\n                                           xP,yP, nPbW,nPbH, refIdx,l,\n                                           &mvLXCol, &availableFlagLXCol);\n  }\n  int numMVPCandLX=0;\n  if (availableFlagLXN[0])\n    {\n      out_mvpList[numMVPCandLX++] = mvLXN[0];\n    }\n  if (availableFlagLXN[1] &&\n      (!availableFlagLXN[0] || \n       (mvLXN[0].x != mvLXN[1].x || mvLXN[0].y != mvLXN[1].y)))\n    {\n      out_mvpList[numMVPCandLX++] = mvLXN[1];\n    }\n  if (availableFlagLXCol)\n    {\n      out_mvpList[numMVPCandLX++] = mvLXCol;\n    }\n  while (numMVPCandLX<2) {\n    out_mvpList[numMVPCandLX].x = 0;\n    out_mvpList[numMVPCandLX].y = 0;\n    numMVPCandLX++;\n  }\n  assert(numMVPCandLX==2);\n}", "target": 0}
{"code": "static void override_ssh_variant(enum ssh_variant *ssh_variant)\n{\n\tconst char *variant = getenv(\"GIT_SSH_VARIANT\");\n\tif (!variant && git_config_get_string_const(\"ssh.variant\", &variant))\n\t\treturn;\n\tif (!strcmp(variant, \"auto\"))\n\t\t*ssh_variant = VARIANT_AUTO;\n\telse if (!strcmp(variant, \"plink\"))\n\t\t*ssh_variant = VARIANT_PLINK;\n\telse if (!strcmp(variant, \"putty\"))\n\t\t*ssh_variant = VARIANT_PUTTY;\n\telse if (!strcmp(variant, \"tortoiseplink\"))\n\t\t*ssh_variant = VARIANT_TORTOISEPLINK;\n\telse if (!strcmp(variant, \"simple\"))\n\t\t*ssh_variant = VARIANT_SIMPLE;\n\telse\n\t\t*ssh_variant = VARIANT_SSH;\n}", "target": 0}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){\n  ZipfileCDS *pCds = &pEntry->cds;\n  u8 *a = aBuf;\n  pCds->nExtra = 9;\n  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);\n  zipfileWrite16(a, pCds->iVersionExtract);\n  zipfileWrite16(a, pCds->flags);\n  zipfileWrite16(a, pCds->iCompression);\n  zipfileWrite16(a, pCds->mTime);\n  zipfileWrite16(a, pCds->mDate);\n  zipfileWrite32(a, pCds->crc32);\n  zipfileWrite32(a, pCds->szCompressed);\n  zipfileWrite32(a, pCds->szUncompressed);\n  zipfileWrite16(a, (u16)pCds->nFile);\n  zipfileWrite16(a, pCds->nExtra);\n  assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );\n  memcpy(a, pCds->zFile, (int)pCds->nFile);\n  a += (int)pCds->nFile;\n  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);\n  zipfileWrite16(a, 5);\n  *a++ = 0x01;\n  zipfileWrite32(a, pEntry->mUnixTime);\n  return a-aBuf;\n}", "target": 0}
{"code": "  explicit BoostedTreesMakeStatsSummaryOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }", "target": 0}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "options_transports(void)\n{\nstruct transport_info * ti;\nuschar buf[64];\noptions_from_list(optionlist_transports, nelem(optionlist_transports), US\"TRANSPORTS\", NULL);\nfor (ti = transports_available; ti->driver_name[0]; ti++)\n  {\n  spf(buf, sizeof(buf), US\"_DRIVER_TRANSPORT_%T\", ti->driver_name);\n  builtin_macro_create(buf);\n  options_from_list(ti->options, (unsigned)*ti->options_count, US\"TRANSPORT\", ti->driver_name);\n  }\n}", "target": 0}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "static void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}", "target": 0}
{"code": "static void naludmx_update_nalu_maxsize(GF_NALUDmxCtx *ctx, u32 size)\n{\n\tif (ctx->max_nalu_size < size) {\n\t\tctx->max_nalu_size = size;\n\t\tif (size > ctx->max_nalu_size_allowed) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[%s] nal size %d larger than max allowed size %d - change import settings\\n\", ctx->log_name, size, ctx->max_nalu_size_allowed ));\n\t\t}\n\t}\n}", "target": 0}
{"code": "wb_write_padding_to_temp(struct archive_write *a, int64_t csize)\n{\n\tsize_t ns;\n\tint ret;\n\tns = (size_t)(csize % LOGICAL_BLOCK_SIZE);\n\tif (ns != 0)\n\t\tret = write_null(a, LOGICAL_BLOCK_SIZE - ns);\n\telse\n\t\tret = ARCHIVE_OK;\n\treturn (ret);\n}", "target": 0}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n \t    !(mnt_flags & MNT_READONLY)) {\n \t\treturn -EPERM;\n \t}\n \terr = security_sb_remount(sb, data);\n \tif (err)\n \t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "DNS::DNS()\n{\n\tServerInstance->Logs->Log(\"RESOLVER\",DEBUG,\"DNS::DNS\");\n\tmemset(Classes,0,sizeof(Classes));\n\tmemset(requests,0,sizeof(requests));\n\tcurrid = 0;\n\tthis->cache = NULL;\n\tthis->SetFd(-1);\n\tthis->Rehash();\n\tthis->PruneTimer = new CacheTimer(this);\n\tServerInstance->Timers->AddTimer(this->PruneTimer);\n}", "target": 0}
{"code": "static int __init cpia2_init(void)\n{\n\tLOG(\"%s v%s\\n\",\n\t    ABOUT, CPIA_VERSION);\n\tcheck_parameters();\n\tcpia2_usb_init();\n\treturn 0;\n}", "target": 1}
{"code": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "static bool reds_send_link_error(RedLinkInfo *link, uint32_t error)\n{\n    struct {\n        SpiceLinkHeader header;\n        SpiceLinkReply reply;\n    } msg;\n    SPICE_VERIFY(sizeof(msg) == sizeof(SpiceLinkHeader) + sizeof(SpiceLinkReply));\n    msg.header.magic = SPICE_MAGIC;\n    msg.header.size = GUINT32_TO_LE(sizeof(msg.reply));\n    msg.header.major_version = GUINT32_TO_LE(SPICE_VERSION_MAJOR);\n    msg.header.minor_version = GUINT32_TO_LE(SPICE_VERSION_MINOR);\n    memset(&msg.reply, 0, sizeof(msg.reply));\n    msg.reply.error = GUINT32_TO_LE(error);\n    return red_stream_write_all(link->stream, &msg, sizeof(msg));\n}", "target": 0}
{"code": "static bool ok_jpg_decode_restart_if_needed(ok_jpg_decoder *decoder) {\n    if (decoder->restart_intervals_remaining > 0) {\n        decoder->restart_intervals_remaining--;\n        if (decoder->restart_intervals_remaining == 0) {\n            ok_jpg_dump_bits(decoder);\n            if (decoder->next_marker != 0) {\n                if (decoder->next_marker == 0xD0 + decoder->next_restart) {\n                    decoder->next_marker = 0;\n                } else {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (1)\");\n                    return false;\n                }\n            } else {\n                uint8_t buffer[2];\n                if (!ok_read(decoder, buffer, 2)) {\n                    return false;\n                }\n                if (!(buffer[0] == 0xff && buffer[1] == 0xD0 + decoder->next_restart)) {\n                    ok_jpg_error(decoder->jpg, OK_JPG_ERROR_INVALID, \"Invalid restart marker (2)\");\n                    return false;\n                }\n            }\n            decoder->next_restart = (decoder->next_restart + 1) & 7;\n            ok_jpg_decode_restart(decoder);\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "static int read_file(const char *path, char *buf, size_t size,\n\t\t     struct file_info *d)\n{\n\tsize_t linelen = 0, total_len = 0, rv = 0;\n\tchar *line = NULL;\n\tchar *cache = d->buf;\n\tsize_t cache_size = d->buflen;\n\tFILE *f = fopen(path, \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsize_t l = snprintf(cache, cache_size, \"%s\", line);\n\t\tif (l < 0) {\n\t\t\tperror(\"Error writing to cache\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l >= cache_size) {\n\t\t\tfprintf(stderr, \"Internal error: truncated write to cache\\n\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l < cache_size) {\n\t\t\tcache += l;\n\t\t\tcache_size -= l;\n\t\t\ttotal_len += l;\n\t\t} else {\n\t\t\tcache += cache_size;\n\t\t\ttotal_len += cache_size;\n\t\t\tcache_size = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\td->size = total_len;\n\tif (total_len > size ) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\trv = total_len;\n  err:\n\tfclose(f);\n\tfree(line);\n\treturn rv;\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static bool dir_is_in_dump_location(const char *dump_dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0\n     && dump_dir_name[len] == '/'\n     && !strstr(dump_dir_name + len, \"/.\")\n    ) {\n        return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}", "target": 1}
{"code": "void mark_progress(struct st_command* command __attribute__((unused)),\n                   int line)\n{\n  static ulonglong progress_start= 0; \n  DYNAMIC_STRING ds_progress;\n  char buf[32], *end;\n  ulonglong timer= timer_now();\n  if (!progress_start)\n    progress_start= timer;\n  timer-= progress_start;\n  if (init_dynamic_string(&ds_progress, \"\", 256, 256))\n    die(\"Out of memory\");\n  end= longlong10_to_str(timer, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  end= int10_to_str(line, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  dynstr_append(&ds_progress, cur_file->file_name);\n  dynstr_append_mem(&ds_progress, \":\", 1);\n  end= int10_to_str(cur_file->lineno, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\n\", 1);\n  progress_file.write(&ds_progress);\n  dynstr_free(&ds_progress);\n}", "target": 0}
{"code": "static int sg_proc_seq_show_debug(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tunsigned long iflags;\n\tif (it && (0 == it->index))\n\t\tseq_printf(s, \"max_active_device=%d  def_reserved_size=%d\\n\",\n\t\t\t   (int)it->max, sg_big_buff);\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tif (NULL == sdp)\n\t\tgoto skip;\n\tread_lock(&sdp->sfd_lock);\n\tif (!list_empty(&sdp->sfds)) {\n\t\tseq_printf(s, \" >>> device=%s \", sdp->disk->disk_name);\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\tseq_puts(s, \"detaching pending close \");\n\t\telse if (sdp->device) {\n\t\t\tstruct scsi_device *scsidp = sdp->device;\n\t\t\tseq_printf(s, \"%d:%d:%d:%llu   em=%d\",\n\t\t\t\t   scsidp->host->host_no,\n\t\t\t\t   scsidp->channel, scsidp->id,\n\t\t\t\t   scsidp->lun,\n\t\t\t\t   scsidp->host->hostt->emulated);\n\t\t}\n\t\tseq_printf(s, \" sg_tablesize=%d excl=%d open_cnt=%d\\n\",\n\t\t\t   sdp->sg_tablesize, sdp->exclude, sdp->open_cnt);\n\t\tsg_proc_debug_helper(s, sdp);\n\t}\n\tread_unlock(&sdp->sfd_lock);\nskip:\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\ttest_two_locks();\n\tfprintf(stderr, \"all tests passed\\n\");\n\texit(ret);\n}", "target": 1}
{"code": "filesystem_list_open_files_completed_cb (DBusGMethodInvocation *context,\n                                         Device *device,\n                                         gboolean job_was_cancelled,\n                                         int status,\n                                         const char *stderr,\n                                         const char *stdout,\n                                         gpointer user_data)\n{\n  if ((WEXITSTATUS (status) == 0 || WEXITSTATUS (status) == 1) && !job_was_cancelled)\n    {\n      GPtrArray *processes;\n      processes = g_ptr_array_new ();\n      lsof_parse (stdout, processes);\n      dbus_g_method_return (context, processes);\n      g_ptr_array_foreach (processes, (GFunc) g_value_array_free, NULL);\n      g_ptr_array_free (processes, TRUE);\n    }\n  else\n    {\n      throw_error (context,\n                   ERROR_FAILED,\n                   \"Error listing open files: lsof exited with exit code %d: %s\",\n                   WEXITSTATUS (status),\n                   stderr);\n    }\n}", "target": 0}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}", "target": 1}
{"code": "int RGWHandler_REST_S3::init(RGWRados *store, struct req_state *s,\n                             rgw::io::BasicClient *cio)\n{\n  int ret;\n  s->dialect = \"s3\";\n  ret = rgw_validate_tenant_name(s->bucket_tenant);\n  if (ret)\n    return ret;\n  bool relaxed_names = s->cct->_conf->rgw_relaxed_s3_bucket_names;\n  if (!s->bucket_name.empty()) {\n    ret = valid_s3_bucket_name(s->bucket_name, relaxed_names);\n    if (ret)\n      return ret;\n    ret = validate_object_name(s->object.name);\n    if (ret)\n      return ret;\n  }\n  const char *cacl = s->info.env->get(\"HTTP_X_AMZ_ACL\");\n  if (cacl)\n    s->canned_acl = cacl;\n  s->has_acl_header = s->info.env->exists_prefix(\"HTTP_X_AMZ_GRANT\");\n  const char *copy_source = s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE\");\n  if (copy_source &&\n      (! s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE_RANGE\")) &&\n      (! s->info.args.exists(\"uploadId\"))) {\n    ret = RGWCopyObj::parse_copy_location(copy_source,\n                                          s->init_state.src_bucket,\n                                          s->src_object);\n    if (!ret) {\n      ldout(s->cct, 0) << \"failed to parse copy location\" << dendl;\n      return -EINVAL; \n    }\n  }\n  return RGWHandler_REST::init(store, s, cio);\n}", "target": 0}
{"code": "get_clone_size (GnomeRRScreen *screen, int *width, int *height)\n{\n        GnomeRRMode **modes = gnome_rr_screen_list_clone_modes (screen);\n        int best_w, best_h;\n        int i;\n        best_w = 0;\n        best_h = 0;\n        for (i = 0; modes[i] != NULL; ++i) {\n                GnomeRRMode *mode = modes[i];\n                int w, h;\n                w = gnome_rr_mode_get_width (mode);\n                h = gnome_rr_mode_get_height (mode);\n                if (w * h > best_w * best_h) {\n                        best_w = w;\n                        best_h = h;\n                }\n        }\n        if (best_w > 0 && best_h > 0) {\n                if (width)\n                        *width = best_w;\n                if (height)\n                        *height = best_h;\n                return TRUE;\n        }\n        return FALSE;\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "bool setup_tables_and_check_access(THD *thd, Name_resolution_context *context,\n                                   List<TABLE_LIST> *from_clause,\n                                   TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                                   bool select_insert, ulong want_access_first,\n                                   ulong want_access, bool full_table_list)\n{\n  DBUG_ENTER(\"setup_tables_and_check_access\");\n  if (setup_tables(thd, context, from_clause, tables,\n                   leaves, select_insert, full_table_list))\n    DBUG_RETURN(TRUE);\n  List_iterator<TABLE_LIST> ti(leaves);\n  TABLE_LIST *table_list;\n  ulong access= want_access_first;\n  while ((table_list= ti++))\n  {\n    if (table_list->belong_to_view && !table_list->view && \n        check_single_table_access(thd, access, table_list, FALSE))\n    {\n      tables->hide_view_error(thd);\n      DBUG_RETURN(TRUE);\n    }\n    access= want_access;\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "static int kvp_process_ip_address(void *addrp,\n\t\t\t\tint family, char *buffer,\n\t\t\t\tint length,  int *offset)\n{\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tint addr_length;\n\tchar tmp[50];\n\tconst char *str;\n\tif (family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)addrp;\n\t\tstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\n\t\taddr_length = INET_ADDRSTRLEN;\n\t} else {\n\t\taddr6 = (struct sockaddr_in6 *)addrp;\n\t\tstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\n\t\taddr_length = INET6_ADDRSTRLEN;\n\t}\n\tif ((length - *offset) < addr_length + 2)\n\t\treturn HV_E_FAIL;\n\tif (str == NULL) {\n\t\tstrcpy(buffer, \"inet_ntop failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\tif (*offset == 0)\n\t\tstrcpy(buffer, tmp);\n\telse {\n\t\tstrcat(buffer, \";\");\n\t\tstrcat(buffer, tmp);\n\t}\n\t*offset += strlen(str) + 1;\n\treturn 0;\n}", "target": 0}
{"code": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n         avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n         return AVERROR_PATCHWELCOME;\n     }\n    if (item_num > 65536) {\n         av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n         return AVERROR_INVALIDDATA;\n     }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static void ahci_irq_lower(AHCIState *s, AHCIDevice *dev)\n{\n    DeviceState *dev_state = s->container;\n    PCIDevice *pci_dev = (PCIDevice *) object_dynamic_cast(OBJECT(dev_state),\n                                                           TYPE_PCI_DEVICE);\n    DPRINTF(0, \"lower irq\\n\");\n    if (!pci_dev || !msi_enabled(pci_dev)) {\n        qemu_irq_lower(s->irq);\n    }\n}", "target": 0}
{"code": "static int skcipher_check_key(struct socket *sock)\n{\n\tint err = 0;\n\tstruct sock *psk;\n\tstruct alg_sock *pask;\n\tstruct skcipher_tfm *tfm;\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tlock_sock(sk);\n\tif (ask->refcnt)\n\t\tgoto unlock_child;\n\tpsk = ask->parent;\n\tpask = alg_sk(ask->parent);\n\ttfm = pask->private;\n\terr = -ENOKEY;\n\tlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\n\tif (!tfm->has_key)\n\t\tgoto unlock;\n\tif (!pask->refcnt++)\n\t\tsock_hold(psk);\n\task->refcnt = 1;\n\tsock_put(psk);\n\terr = 0;\nunlock:\n\trelease_sock(psk);\nunlock_child:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": " DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)\n    : AbstractMetadataProvider(e),\n       m_validate(XMLHelper::getAttrBool(e, false, validate)),\n         m_id(XMLHelper::getAttrString(e, \"Dynamic\", id)),\n         m_lock(RWLock::create()),\n        m_refreshDelayFactor(0.75),\n        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),\n        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),\n        m_shutdown(false),\n        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),\n        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),\n         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)\n {\n     if (m_minCacheDuration > m_maxCacheDuration) {\n        Category::getInstance(SAML_LOGCAT \".MetadataProvider.Dynamic\").error(\n             \"minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it\"\n             );\n         m_minCacheDuration = m_maxCacheDuration;\n    }\n    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;\n    if (delay && *delay) {\n        auto_ptr_char temp(delay);\n        m_refreshDelayFactor = atof(temp.get());\n        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {\n            Category::getInstance(SAML_LOGCAT \".MetadataProvider.Dynamic\").error(\n                \"invalid refreshDelayFactor setting, using default\"\n                );\n            m_refreshDelayFactor = 0.75;\n        }\n    }\n    if (m_cleanupInterval > 0) {\n        if (m_cleanupTimeout < 0)\n            m_cleanupTimeout = 0;\n        m_cleanup_wait = CondWait::create();\n        m_cleanup_thread = Thread::create(&cleanup_fn, this);\n    }\n}", "target": 1}
{"code": "new_msg_lsa_change_notify (u_char msgtype,\n\t\t\t   u_int32_t seqnum,\n\t\t\t   struct in_addr ifaddr,\n\t\t\t   struct in_addr area_id,\n\t\t\t   u_char is_self_originated, struct lsa_header *data)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_lsa_change_notify *nmsg;\n  int len;\n  assert (data);\n  nmsg = (struct msg_lsa_change_notify *) buf;\n  len = ntohs (data->length) + sizeof (struct msg_lsa_change_notify)\n    - sizeof (struct lsa_header);\n  nmsg->ifaddr = ifaddr;\n  nmsg->area_id = area_id;\n  nmsg->is_self_originated = is_self_originated;\n  memset (&nmsg->pad, 0, sizeof (nmsg->pad));\n  memcpy (&nmsg->data, data, ntohs (data->length));\n  return msg_new (msgtype, nmsg, seqnum, len);\n}", "target": 1}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "static CURLcode imap_state_fetch_resp(struct connectdata *conn, int imapcode,\n                                      imapstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct pingpong *pp = &imapc->pp;\n  const char *ptr = data->state.buffer;\n  bool parsed = FALSE;\n  curl_off_t size = 0;\n  (void)instate; \n  if(imapcode != '*') {\n    Curl_pgrsSetDownloadSize(data, -1);\n    state(conn, IMAP_STOP);\n    return CURLE_REMOTE_FILE_NOT_FOUND; \n  }\n  while(*ptr && (*ptr != '{'))\n    ptr++;\n  if(*ptr == '{') {\n    char *endptr;\n    if(!curlx_strtoofft(ptr + 1, &endptr, 10, &size)) {\n      if(endptr - ptr > 1 && endptr[0] == '}' &&\n         endptr[1] == '\\r' && endptr[2] == '\\0')\n        parsed = TRUE;\n    }\n  }\n  if(parsed) {\n    infof(data, \"Found %\" CURL_FORMAT_CURL_OFF_TU \" bytes to download\\n\",\n          size);\n    Curl_pgrsSetDownloadSize(data, size);\n    if(pp->cache) {\n      size_t chunk = pp->cache_size;\n      if(chunk > (size_t)size)\n        chunk = (size_t)size;\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, pp->cache, chunk);\n      if(result)\n        return result;\n      data->req.bytecount += chunk;\n      infof(data, \"Written %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes, %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes are left for transfer\\n\", (curl_off_t)chunk,\n            size - chunk);\n      if(pp->cache_size > chunk) {\n        memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);\n        pp->cache_size -= chunk;\n      }\n      else {\n        Curl_safefree(pp->cache);\n        pp->cache_size = 0;\n      }\n    }\n    if(data->req.bytecount == size)\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n    else {\n      data->req.maxdownload = size;\n      Curl_setup_transfer(conn, FIRSTSOCKET, size, FALSE, NULL, -1, NULL);\n    }\n  }\n  else {\n    failf(pp->conn->data, \"Failed to parse FETCH response.\");\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  state(conn, IMAP_STOP);\n  return result;\n}", "target": 1}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "static inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n#if 1\n    level += 256;\n    if (n < 4) {\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n#else\n    int size, v;\n    size = 0;\n    v    = abs(level);\n    while (v) {\n        v >>= 1;\n        size++;\n    }\n    if (n < 4) {\n        put_bits(s, ff_mpeg4_DCtab_lum[size][1], ff_mpeg4_DCtab_lum[size][0]);\n    } else {\n        put_bits(s, ff_mpeg4_DCtab_chrom[size][1], ff_mpeg4_DCtab_chrom[size][0]);\n    }\n    if (size > 0) {\n        if (level < 0)\n            level = (-level) ^ ((1 << size) - 1);\n        put_bits(s, size, level);\n        if (size > 8)\n            put_bits(s, 1, 1);\n    }\n#endif\n}", "target": 0}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "struct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = NULL;\n\tint idx;\n\tint ret;\n\tidx = srcu_read_lock(&pmus_srcu);\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (ret)\n\t\t\tpmu = ERR_PTR(ret);\n\t\tgoto unlock;\n\t}\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tevent->pmu = pmu;\n\t\tret = pmu->event_init(event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\t\tif (ret != -ENOENT) {\n\t\t\tpmu = ERR_PTR(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = ERR_PTR(-ENOENT);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\treturn pmu;\n}", "target": 0}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "php_apache_server_startup(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n\tvoid *data = NULL;\n\tconst char *userdata_key = \"apache2hook_post_config\";\n\tapr_pool_userdata_get(&data, userdata_key, s->process->pool);\n\tif (data == NULL) {\n\t\tapr_pool_userdata_set((const void *)1, userdata_key, apr_pool_cleanup_null, s->process->pool);\n\t\treturn OK;\n\t}\n\tif (apache2_php_ini_path_override) {\n\t\tapache2_sapi_module.php_ini_path_override = apache2_php_ini_path_override;\n\t}\n#ifdef ZTS\n\ttsrm_startup(1, 1, 0, NULL);\n#endif\n\tsapi_startup(&apache2_sapi_module);\n\tapache2_sapi_module.startup(&apache2_sapi_module);\n\tapr_pool_cleanup_register(pconf, NULL, php_apache_server_shutdown, apr_pool_cleanup_null);\n\tphp_apache_add_version(pconf);\n\treturn OK;\n}", "target": 0}
{"code": "int tipc_node_get_mtu(struct net *net, u32 addr, u32 sel, bool connected)\n{\n\tstruct tipc_node *n;\n\tint bearer_id;\n\tunsigned int mtu = MAX_MSG_SIZE;\n\tn = tipc_node_find(net, addr);\n\tif (unlikely(!n))\n\t\treturn mtu;\n\tif (n->peer_net && connected) {\n\t\ttipc_node_put(n);\n\t\treturn mtu;\n\t}\n\tbearer_id = n->active_links[sel & 1];\n\tif (likely(bearer_id != INVALID_BEARER_ID))\n\t\tmtu = n->links[bearer_id].mtu;\n\ttipc_node_put(n);\n\treturn mtu;\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, RouteOverride) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) {\n        envoy::extensions::filters::http::rbac::v3::RBACPerRoute per_route_config;\n        TestUtility::loadFromJson(\"{}\", per_route_config);\n        auto* config = cfg.mutable_route_config()\n                           ->mutable_virtual_hosts()\n                           ->Mutable(0)\n                           ->mutable_typed_per_filter_config();\n        (*config)[Extensions::HttpFilters::HttpFilterNames::get().Rbac].PackFrom(per_route_config);\n      });\n  config_helper_.addFilter(RBAC_CONFIG);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "cmsToneCurve* CMSEXPORT cmsDupToneCurve(const cmsToneCurve* In)\n{\n    if (In == NULL) return NULL;\n    return  AllocateToneCurveStruct(In ->InterpParams ->ContextID, In ->nEntries, In ->nSegments, In ->Segments, In ->Table16);\n}", "target": 0}
{"code": "nwfilterConnectNumOfNWFilters(virConnectPtr conn)\n{\n    if (virConnectNumOfNWFiltersEnsureACL(conn) < 0)\n        return -1;\n    return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn,\n                                        virConnectNumOfNWFiltersCheckACL);\n}", "target": 1}
{"code": "static void OneLineTransp(struct ico_progressive_state *context)\n{\n\tgint X;\n\tguchar *Pixels;\n\tif (context->Header.depth == 32)\n\t\treturn;\n\tX = 0;\n\tif (context->Header.Negative == 0)\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (2*context->Header.height - context->Lines - 1));\n\telse\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (context->Lines-context->Header.height));\n\twhile (X < context->Header.width) {\n\t\tint Bit;\n\t\tBit = (context->LineBuf[X / 8]) >> (7 - (X & 7));\n\t\tBit = Bit & 1;\n\t\tPixels[X * 4 + 3] = 255-Bit*255;\n#if 0\n\t\tif (Bit){\n\t\t  Pixels[X*4+0] = 255;\n\t\t  Pixels[X*4+1] = 255;\n\t\t} else {\n\t\t  Pixels[X*4+0] = 0;\n\t\t  Pixels[X*4+1] = 0;\n\t\t}\n#endif\t\t\n\t\tX++;\n\t}\n}", "target": 0}
{"code": "static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n static int asn1_template_ex_d2i(ASN1_VALUE **pval,\n                                 const unsigned char **in, long len,\n                                 const ASN1_TEMPLATE *tt, char opt,\n                                ASN1_TLC *ctx);\n static int asn1_template_noexp_d2i(ASN1_VALUE **val,\n                                    const unsigned char **in, long len,\n                                    const ASN1_TEMPLATE *tt, char opt,\n                                   ASN1_TLC *ctx);\n static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n                                  const unsigned char **in, long len,\n                                  const ASN1_ITEM *it,\n    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,\n    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,\n    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,\n    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,\n    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,\n    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,\n};\nunsigned long ASN1_tag2bit(int tag)\n{", "target": 1}
{"code": "mm_answer_sign(int socket, Buffer *m)\n{\n\tKey *key;\n\tu_char *p;\n\tu_char *signature;\n\tu_int siglen, datlen;\n\tint keyid;\n\tdebug3(\"%s\", __func__);\n\tkeyid = buffer_get_int(m);\n\tp = buffer_get_string(m, &datlen);\n\tif (datlen != 20)\n\t\tfatal(\"%s: data length incorrect: %u\", __func__, datlen);\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\tif ((key = get_hostkey_by_index(keyid)) == NULL)\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\tif (key_sign(key, &signature, &siglen, p, datlen) < 0)\n\t\tfatal(\"%s: key_sign failed\", __func__);\n\tdebug3(\"%s: signature %p(%u)\", __func__, signature, siglen);\n\tbuffer_clear(m);\n\tbuffer_put_string(m, signature, siglen);\n\txfree(p);\n\txfree(signature);\n\tmm_request_send(socket, MONITOR_ANS_SIGN, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}", "target": 1}
{"code": "windows_icon_typefind (GstTypeFind * find, gpointer user_data)\n{\n  const guint8 *data;\n  gint64 datalen;\n  guint16 type, nimages;\n  gint32 size, offset;\n  datalen = gst_type_find_get_length (find);\n  if ((data = gst_type_find_peek (find, 0, 6)) == NULL)\n    return;\n  if (GST_READ_UINT16_LE (data) != 0)\n    return;\n  type = GST_READ_UINT16_LE (data + 2);\n  if (type != 1 && type != 2)\n    return;\n  nimages = GST_READ_UINT16_LE (data + 4);\n  if (nimages == 0)             \n    return;\n  if (data[6 + 3] != 0)\n    return;\n  if (type == 1) {\n    guint16 planes = GST_READ_UINT16_LE (data + 6 + 4);\n    if (planes > 1)\n      return;\n  }\n  size = GST_READ_UINT32_LE (data + 6 + 8);\n  offset = GST_READ_UINT32_LE (data + 6 + 12);\n  if (offset < 0 || size <= 0 || size >= datalen || offset >= datalen\n      || size + offset > datalen)\n    return;\n  gst_type_find_suggest_simple (find, GST_TYPE_FIND_NEARLY_CERTAIN,\n      \"image/x-icon\", NULL);\n}", "target": 1}
{"code": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "static ssize_t ifalias_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst struct net_device *netdev = to_net_dev(dev);\n\tchar tmp[IFALIASZ];\n\tssize_t ret = 0;\n\tret = dev_get_alias(netdev, tmp, sizeof(tmp));\n\tif (ret > 0)\n\t\tret = sprintf(buf, \"%s\\n\", tmp);\n\treturn ret;", "target": 0}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tif (sk->sk_family == AF_INET6)\n\t\tsk->sk_ipv6only = 1;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes)\n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\tif (Stream_GetRemainingCapacity(s) < 12 * NumberOfPipes)\n\t\treturn NULL;\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\tif (!MsPipes)\n\t\treturn NULL;\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\treturn MsPipes;\nout_error:\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\tfree(MsPipes);\n\treturn NULL;\n}", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "static int sctp_setsockopt_partial_delivery_point(struct sock *sk,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int optlen)\n{\n\tu32 val;\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tsctp_sk(sk)->pd_point = val;\n\treturn 0; \n}", "target": 0}
{"code": "void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n        fprintf(out_stream, \"Codestream info from main header: {\\n\");\n        fprintf(out_stream, \"\\t tx0=%d, ty0=%d\\n\", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);\n        fprintf(out_stream, \"\\t tdx=%d, tdy=%d\\n\", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);\n        fprintf(out_stream, \"\\t tw=%d, th=%d\\n\", p_j2k->m_cp.tw, p_j2k->m_cp.th);\n        opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n        fprintf(out_stream, \"}\\n\");\n}", "target": 0}
{"code": "static bool ok_inflater_init_fixed_huffman(ok_inflater *inflater) {\n    if (!inflater->fixed_literal_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t code_length[288];\n            int i;\n            for (i = 0; i < 144; i++) {\n                code_length[i] = 8;\n            }\n            for (i = 144; i < 256; i++) {\n                code_length[i] = 9;\n            }\n            for (i = 256; i < 280; i++) {\n                code_length[i] = 7;\n            }\n            for (i = 280; i < 288; i++) {\n                code_length[i] = 8;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, code_length,\n                                                     sizeof(code_length) / sizeof(code_length[0]));\n            inflater->fixed_literal_huffman = tree;\n        }\n    }\n    if (!inflater->fixed_distance_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t distance_code_length[32];\n            for (int i = 0; i < 32; i++) {\n                distance_code_length[i] = 5;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, distance_code_length, 32);\n            inflater->fixed_distance_huffman = tree;\n        }\n    }\n    return inflater->fixed_literal_huffman && inflater->fixed_distance_huffman;\n}", "target": 0}
{"code": "static int prepare_func_exit(struct bpf_verifier_env *env, int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tstruct bpf_reg_state *r0;\n\tint err;\n\tcallee = state->frame[state->curframe];\n\tr0 = &callee->regs[BPF_REG_0];\n\tif (r0->type == PTR_TO_STACK) {\n\t\tverbose(env, \"cannot return stack pointer to the caller\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstate->curframe--;\n\tcaller = state->frame[state->curframe];\n\tif (callee->in_callback_fn) {\n\t\tstruct tnum range = tnum_range(0, 1);\n\t\tif (r0->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"R0 not a scalar value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_in(range, r0->var_off)) {\n\t\t\tverbose_invalid_scalar(env, r0, &range, \"callback return\", \"R0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcaller->regs[BPF_REG_0] = *r0;\n\t}\n\terr = copy_reference_state(caller, callee);\n\tif (err)\n\t\treturn err;\n\t*insn_idx = callee->callsite + 1;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"returning from callee:\\n\");\n\t\tprint_verifier_state(env, callee);\n\t\tverbose(env, \"to caller at %d:\\n\", *insn_idx);\n\t\tprint_verifier_state(env, caller);\n\t}\n\tfree_func_state(callee);\n\tstate->frame[state->curframe + 1] = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "int tipc_nl_node_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tint done = cb->args[0];\n\tint last_addr = cb->args[1];\n\tstruct tipc_node *node;\n\tstruct tipc_nl_msg msg;\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trcu_read_lock();\n\tif (last_addr) {\n\t\tnode = tipc_node_find(net, last_addr);\n\t\tif (!node) {\n\t\t\trcu_read_unlock();\n\t\t\tcb->prev_seq = 1;\n\t\t\treturn -EPIPE;\n\t\t}\n\t\ttipc_node_put(node);\n\t}\n\tlist_for_each_entry_rcu(node, &tn->node_list, list) {\n\t\tif (node->preliminary)\n\t\t\tcontinue;\n\t\tif (last_addr) {\n\t\t\tif (node->addr == last_addr)\n\t\t\t\tlast_addr = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\ttipc_node_read_lock(node);\n\t\terr = __tipc_nl_add_node(&msg, node);\n\t\tif (err) {\n\t\t\tlast_addr = node->addr;\n\t\t\ttipc_node_read_unlock(node);\n\t\t\tgoto out;\n\t\t}\n\t\ttipc_node_read_unlock(node);\n\t}\n\tdone = 1;\nout:\n\tcb->args[0] = done;\n\tcb->args[1] = last_addr;\n\trcu_read_unlock();\n\treturn skb->len;\n}", "target": 0}
{"code": "static int __vhost_add_used_n(struct vhost_virtqueue *vq,\n\t\t\t    struct vring_used_elem *heads,\n\t\t\t    unsigned count)\n{\n\tstruct vring_used_elem __user *used;\n\tu16 old, new;\n\tint start;\n\tstart = vq->last_used_idx % vq->num;\n\tused = vq->used->ring + start;\n\tif (__copy_to_user(used, heads, count * sizeof *used)) {\n\t\tvq_err(vq, \"Failed to write used\");\n\t\treturn -EFAULT;\n\t}\n\tif (unlikely(vq->log_used)) {\n\t\tsmp_wmb();\n\t\tlog_write(vq->log_base,\n\t\t\t  vq->log_addr +\n\t\t\t   ((void __user *)used - (void __user *)vq->used),\n\t\t\t  count * sizeof *used);\n\t}\n\told = vq->last_used_idx;\n\tnew = (vq->last_used_idx += count);\n\tif (unlikely((u16)(new - vq->signalled_used) < (u16)(new - old)))\n\t\tvq->signalled_used_valid = false;\n\treturn 0;\n}", "target": 0}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "nfsd4_check_open_attributes(struct svc_rqst *rqstp,\n\tstruct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\t__be32 status = nfs_ok;\n\tif (open->op_create == NFS4_OPEN_CREATE) {\n\t\tif (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd_attrmask);\n\t\telse if (open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1)\n\t\t\tstatus = check_attr_support(rqstp, cstate,\n\t\t\t\t\topen->op_bmval, nfsd41_ex_attrmask);\n\t}\n\treturn status;\n}", "target": 0}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "static int lua_ap_set_document_root(lua_State *L)\n{\n    request_rec    *r;\n    const char     *root;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    luaL_checktype(L, 2, LUA_TSTRING);\n    r = ap_lua_check_request_rec(L, 1);\n    root = lua_tostring(L, 2);\n    ap_set_document_root(r, root);\n    return 0;\n}", "target": 0}
{"code": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n        return TRUE;\n}", "target": 1}
{"code": "remove_waiting_conn(conn c)\n{\n    tube t;\n    size_t i;\n    if (!conn_waiting(c)) return NULL;\n    c->type &= ~CONN_TYPE_WAITING;\n    global_stat.waiting_ct--;\n    for (i = 0; i < c->watch.used; i++) {\n        t = c->watch.items[i];\n        t->stat.waiting_ct--;\n        ms_remove(&t->waiting, c);\n    }\n    return c;\n}", "target": 0}
{"code": "RGWOp *RGWHandler_REST_Bucket_S3::op_put()\n{\n  if (s->info.args.sub_resource_exists(\"logging\"))\n    return NULL;\n  if (s->info.args.sub_resource_exists(\"versioning\"))\n    return new RGWSetBucketVersioning_ObjStore_S3;\n  if (s->info.args.sub_resource_exists(\"website\")) {\n    if (!s->cct->_conf->rgw_enable_static_website) {\n      return NULL;\n    }\n    return new RGWSetBucketWebsite_ObjStore_S3;\n  }\n  if (is_acl_op()) {\n    return new RGWPutACLs_ObjStore_S3;\n  } else if (is_cors_op()) {\n    return new RGWPutCORS_ObjStore_S3;\n  } else if (is_request_payment_op()) {\n    return new RGWSetRequestPayment_ObjStore_S3;\n  } else if(is_lc_op()) {\n    return new RGWPutLC_ObjStore_S3;\n  } else if(is_policy_op()) {\n    return new RGWPutBucketPolicy;\n  } else if (is_object_lock_op()) {\n    return new RGWPutBucketObjectLock_ObjStore_S3;\n  } else if (is_notification_op()) {\n    return RGWHandler_REST_PSNotifs_S3::create_put_op();\n  }\n  return new RGWCreateBucket_ObjStore_S3;\n}", "target": 0}
{"code": "int hugetlb_report_node_meminfo(char *buf, int len, int nid)\n{\n\tstruct hstate *h = &default_hstate;\n\tif (!hugepages_supported())\n\t\treturn 0;\n\treturn sysfs_emit_at(buf, len,\n\t\t\t     \"Node %d HugePages_Total: %5u\\n\"\n\t\t\t     \"Node %d HugePages_Free:  %5u\\n\"\n\t\t\t     \"Node %d HugePages_Surp:  %5u\\n\",\n\t\t\t     nid, h->nr_huge_pages_node[nid],\n\t\t\t     nid, h->free_huge_pages_node[nid],\n\t\t\t     nid, h->surplus_huge_pages_node[nid]);\n}", "target": 0}
{"code": "static void _ewk_frame_smart_del(Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET(ewkFrame, smartData);\n    if (smartData) {\n         if (smartData->frame) {\n             WebCore::FrameLoaderClientEfl* flc = _ewk_frame_loader_efl_get(smartData->frame);\n             flc->setWebFrame(0);\n            smartData->frame->loader()->detachFromParent();\n            smartData->frame->loader()->cancelAndClear();\n             smartData->frame = 0;\n         }\n        eina_stringshare_del(smartData->title);\n        eina_stringshare_del(smartData->uri);\n        eina_stringshare_del(smartData->name);\n    }\n    _parent_sc.del(ewkFrame);\n}", "target": 1}
{"code": "static int pit_get_out(struct kvm *kvm, int channel)\n{\n\tstruct kvm_kpit_channel_state *c =\n\t\t&kvm->arch.vpit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\tt = kpit_elapsed(kvm, c, channel);\n\td = muldiv64(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\treturn out;\n}", "target": 0}
{"code": "  bool AddCallback(GetUsageAndQuotaCallback* callback, bool unlimited) {\n    if (unlimited)\n      unlimited_callbacks_.push_back(callback);\n    else\n      callbacks_.push_back(callback);\n    return (callbacks_.size() + unlimited_callbacks_.size() == 1);\n  }", "target": 0}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tunsigned long gran;\n\tif (unlikely(rt_prio(p->prio))) {\n\t\tupdate_rq_clock(rq);\n\t\tupdate_curr(cfs_rq);\n\t\tresched_task(curr);\n\t\treturn;\n\t}\n\tcfs_rq_of(pse)->next = pse;\n\tif (unlikely(p->policy == SCHED_BATCH))\n\t\treturn;\n\tif (!sched_feat(WAKEUP_PREEMPT))\n\t\treturn;\n\twhile (!is_same_group(se, pse)) {\n\t\tse = parent_entity(se);\n\t\tpse = parent_entity(pse);\n\t}\n\tgran = sysctl_sched_wakeup_granularity;\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\tif (pse->vruntime + gran < se->vruntime)\n\t\tresched_task(curr);\n}", "target": 0}
{"code": "test_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}", "target": 1}
{"code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t\n  bool it_is_update= (select_lex == &thd->lex->select_lex) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n  if (derived && derived->merged)\n    DBUG_RETURN(0);\n  select_lex->is_item_list_lookup= 0;\n  thd->mark_used_columns= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->mark_used_columns: %d\", thd->mark_used_columns));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == &thd->lex->select_lex &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((!(*conds)->fixed && (*conds)->fix_fields(thd, conds)) ||\n\t(*conds)->check_cols(1))\n      goto err_no_arena;\n  }\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n  if (!thd->stmt_arena->is_conventional())\n  {\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(MY_TEST(thd->is_error()));\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}", "target": 0}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CacheDataFromTaggedTreeFailsOnBadInput) {\n    std::vector<IndexEntry> relevantIndices;\n    auto swIndexTree = QueryPlanner::cacheDataFromTaggedTree(NULL, relevantIndices);\n    ASSERT_NOT_OK(swIndexTree.getStatus());\n    relevantIndices.push_back(IndexEntry(BSON(\"a\" << 1)));\n    auto qr = stdx::make_unique<QueryRequest>(NamespaceString(\"test.collection\"));\n    qr->setFilter(BSON(\"a\" << 3));\n    auto statusWithCQ = CanonicalQuery::canonicalize(opCtx.get(), std::move(qr));\n    ASSERT_OK(statusWithCQ.getStatus());\n    std::unique_ptr<CanonicalQuery> scopedCq = std::move(statusWithCQ.getValue());\n    scopedCq->root()->setTag(new IndexTag(1));\n    swIndexTree = QueryPlanner::cacheDataFromTaggedTree(scopedCq->root(), relevantIndices);\n    ASSERT_NOT_OK(swIndexTree.getStatus());\n}", "target": 0}
{"code": "size_t Parcel::getOpenAshmemSize() const\n{\n return mOpenAshmemSize;\n}", "target": 0}
{"code": "encode_algorithm_id(cms_context *cms, SECItem *der, SECOidTag tag)\n{\n\tSECAlgorithmID id;\n\tint rc = generate_algorithm_id(cms, &id, tag);\n\tif (rc < 0)\n\t\treturn rc;\n\tvoid *ret;\n\tret = SEC_ASN1EncodeItem(cms->arena, der, &id,\n\t\t\t\t\t\tSECOID_AlgorithmIDTemplate);\n\tif (ret == NULL)\n\t\tcmsreterr(-1, cms, \"could not encode Algorithm ID\");\n\treturn 0;\n}", "target": 0}
{"code": "static void OneLine(struct bmp_progressive_state *context)\n{\n\tcontext->BufferDone = 0;\n\tif (context->Lines >= context->Header.height)\n\t\treturn;\n\tif (context->Type == 32)\n\t\tOneLine32(context);\n\telse if (context->Type == 24)\n\t\tOneLine24(context);\n\telse if (context->Type == 16)\n\t\tOneLine16(context);\n\telse if (context->Type == 8)\n\t\tOneLine8(context);\n\telse if (context->Type == 4)\n\t\tOneLine4(context);\n\telse if (context->Type == 1)\n\t\tOneLine1(context);\n\telse\n\t\tg_assert_not_reached ();\n\tcontext->Lines++;\n\tif (context->updated_func != NULL) {\n\t\t(*context->updated_func) (context->pixbuf,\n\t\t\t\t\t  0,\n\t\t\t\t\t  (context->Header.Negative ?\n\t\t\t\t\t   (context->Lines - 1) :\n\t\t\t\t\t   (context->Header.height - context->Lines)),\n\t\t\t\t\t  context->Header.width,\n\t\t\t\t\t  1,\n\t\t\t\t\t  context->user_data);\n\t}\n}", "target": 0}
{"code": "static int open_fuse_device(char **devp)\n{\n\tint fd = try_open_fuse_device(devp);\n\tif (fd >= -1)\n\t\treturn fd;\n\tfprintf(stderr,\n\t\t\"%s: fuse device not found, try 'modprobe fuse' first\\n\",\n\t\tprogname);\n\treturn -1;\n}", "target": 0}
{"code": "elg_encrypt (int algo, gcry_mpi_t *resarr,\n             gcry_mpi_t data, gcry_mpi_t *pkey, int flags)\n{\n  gcry_err_code_t err = GPG_ERR_NO_ERROR;\n  ELG_public_key pk;\n  (void)algo;\n  (void)flags;\n  if ((! data) || (! pkey[0]) || (! pkey[1]) || (! pkey[2]))\n    err = GPG_ERR_BAD_MPI;\n  else\n    {\n      pk.p = pkey[0];\n      pk.g = pkey[1];\n      pk.y = pkey[2];\n      resarr[0] = mpi_alloc (mpi_get_nlimbs (pk.p));\n      resarr[1] = mpi_alloc (mpi_get_nlimbs (pk.p));\n      do_encrypt (resarr[0], resarr[1], data, &pk);\n    }\n  return err;\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static int packet_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tif (po->tx_ring.pg_vec)\n\t\treturn tpacket_snd(po, msg);\n\telse\n\t\treturn packet_snd(sock, msg, len);\n}", "target": 0}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "PHPAPI char *php_get_current_user(void)\n{\n\tzend_stat_t *pstat;\n\tif (SG(request_info).current_user) {\n\t\treturn SG(request_info).current_user;\n\t}\n\tpstat = sapi_get_stat();\n\tif (!pstat) {\n\t\treturn \"\";\n\t} else {\n#ifdef PHP_WIN32\n\t\tchar name[256];\n\t\tDWORD len = sizeof(name)-1;\n\t\tif (!GetUserName(name, &len)) {\n\t\t\treturn \"\";\n\t\t}\n\t\tname[len] = '\\0';\n\t\tSG(request_info).current_user_length = len;\n\t\tSG(request_info).current_user = estrndup(name, len);\n\t\treturn SG(request_info).current_user;\n#else\n\t\tstruct passwd *pwd;\n#if defined(ZTS) && defined(HAVE_GETPWUID_R) && defined(_SC_GETPW_R_SIZE_MAX)\n\t\tstruct passwd _pw;\n\t\tstruct passwd *retpwptr = NULL;\n\t\tint pwbuflen = sysconf(_SC_GETPW_R_SIZE_MAX);\n\t\tchar *pwbuf;\n\t\tif (pwbuflen < 1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tpwbuf = emalloc(pwbuflen);\n\t\tif (getpwuid_r(pstat->st_uid, &_pw, pwbuf, pwbuflen, &retpwptr) != 0) {\n\t\t\tefree(pwbuf);\n\t\t\treturn \"\";\n\t\t}\n\t\tif (retpwptr == NULL) {\n\t\t\tefree(pwbuf);\n\t\t\treturn \"\";\n\t\t}\n\t\tpwd = &_pw;\n#else\n\t\tif ((pwd=getpwuid(pstat->st_uid))==NULL) {\n\t\t\treturn \"\";\n\t\t}\n#endif\n\t\tSG(request_info).current_user_length = strlen(pwd->pw_name);\n\t\tSG(request_info).current_user = estrndup(pwd->pw_name, SG(request_info).current_user_length);\n#if defined(ZTS) && defined(HAVE_GETPWUID_R) && defined(_SC_GETPW_R_SIZE_MAX)\n\t\tefree(pwbuf);\n#endif\n\t\treturn SG(request_info).current_user;\n#endif\n\t}\n}", "target": 0}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "bool HHVM_FUNCTION(uksort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      ArraySortTmp ast(arr_array, SORTFUNC_UKSORT);\n      return ast->uksort(cmp_function);\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        return hc->uksort(cmp_function);\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(\"uksort\");\n  return false;\n}", "target": 0}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\tgeneric_fillattr(inode, stat);\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\troot_tmp = gf_strdup(szPath);\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\tstrcat(szPath, \"gpac_cache\");\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}", "target": 0}
{"code": "    void ExifThumb::setJpegThumbnail(\n        const std::string& path,\n              URational    xres,\n              URational    yres,\n              uint16_t     unit\n    )\n    {\n        DataBuf thumb = readFile(path); \n        setJpegThumbnail(thumb.pData_, thumb.size_, xres, yres, unit);\n    }", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "void AddRegisterComDllWorkItems(const FilePath& dll_folder,\n                                const std::vector<FilePath>& dll_list,\n                                bool system_level,\n                                bool do_register,\n                                bool ignore_failures,\n                                WorkItemList* work_item_list) {\n  DCHECK(work_item_list);\n  if (dll_list.empty()) {\n    VLOG(1) << \"No COM DLLs to register\";\n  } else {\n    std::vector<FilePath>::const_iterator dll_iter(dll_list.begin());\n    for (; dll_iter != dll_list.end(); ++dll_iter) {\n      FilePath dll_path = dll_folder.Append(*dll_iter);\n      WorkItem* work_item = work_item_list->AddSelfRegWorkItem(\n          dll_path.value(), do_register, !system_level);\n      DCHECK(work_item);\n      work_item->set_ignore_failure(ignore_failures);\n    }\n  }\n}", "target": 0}
{"code": "arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}", "target": 1}
{"code": "static void js_initvar(js_State *J, const char *name, int idx)\n{\n\tjsR_defproperty(J, J->E->variables, name, JS_DONTENUM | JS_DONTCONF, stackidx(J, idx), NULL, NULL);\n}", "target": 0}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "static int fts3DoclistCountDocids(char *aList, int nList){\n  int nDoc = 0;                   \n  if( aList ){\n    char *aEnd = &aList[nList];   \n    char *p = aList;              \n    while( p<aEnd ){\n      nDoc++;\n      while( (*p++)&0x80 );     \n      fts3PoslistCopy(0, &p);   \n    }\n  }\n  return nDoc;\n}", "target": 0}
{"code": "int bnx2x_set_int_mode(struct bnx2x *bp)\n{\n\tint rc = 0;\n\tif (IS_VF(bp) && int_mode != BNX2X_INT_MODE_MSIX) {\n\t\tBNX2X_ERR(\"VF not loaded since interrupt mode not msix\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (int_mode) {\n\tcase BNX2X_INT_MODE_MSIX:\n\t\trc = bnx2x_enable_msix(bp);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t\tif (rc && IS_VF(bp))\n\t\t\treturn rc;\n\t\tBNX2X_DEV_INFO(\"Failed to enable multiple MSI-X (%d), set number of queues to %d\\n\",\n\t\t\t       bp->num_queues,\n\t\t\t       1 + bp->num_cnic_queues);\n\tcase BNX2X_INT_MODE_MSI:\n\t\tbnx2x_enable_msi(bp);\n\tcase BNX2X_INT_MODE_INTX:\n\t\tbp->num_ethernet_queues = 1;\n\t\tbp->num_queues = bp->num_ethernet_queues + bp->num_cnic_queues;\n\t\tBNX2X_DEV_INFO(\"set number of queues to 1\\n\");\n\t\tbreak;\n\tdefault:\n\t\tBNX2X_DEV_INFO(\"unknown value in int_mode module parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "void LibRaw::process_Sony_0x0116(uchar *buf, ushort len, unsigned long long id)\n{\n  int i = 0;\n  if (((id == 0x101ULL) || \n       (id == 0x106ULL) || \n       (id == 0x10dULL) || \n       (id == 0x10eULL)    \n       ) &&\n      (len >= 2))\n    i = 1;\n  else if ((id >= 0x111ULL) && (len >= 3))\n    i = 2;\n  else\n    return;\n  imgdata.makernotes.common.BatteryTemperature = (float)(buf[i] - 32) / 1.8f;\n}", "target": 0}
{"code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\tif (--header->nreg)\n\t\treturn;\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}", "target": 1}
{"code": "node_new_call(UChar* name, UChar* name_end, int gnum, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_CALL);\n  CALL_(node)->by_number   = by_number;\n  CALL_(node)->name        = name;\n  CALL_(node)->name_end    = name_end;\n  CALL_(node)->group_num   = gnum;\n  CALL_(node)->entry_count = 1;\n  return node;\n}", "target": 0}
{"code": "static void read_buf(FILE *fin, char *buf) {\n  if (!fgets(buf, BUFFER_SIZE, fin)) {\n    buf[0] = '\\0';\n    return;\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}", "target": 1}
{"code": "enum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,\n\t\t\t\t  void *data, bool cancel_all)\n{\n\tstruct io_cb_cancel_data match = {\n\t\t.fn\t\t= cancel,\n\t\t.data\t\t= data,\n\t\t.cancel_all\t= cancel_all,\n\t};\n\tint node;\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_pending_work(wqe, &match);\n\t\tif (match.nr_pending && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_OK;\n\t}\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\t\tio_wqe_cancel_running_work(wqe, &match);\n\t\tif (match.nr_running && !match.cancel_all)\n\t\t\treturn IO_WQ_CANCEL_RUNNING;\n\t}\n\tif (match.nr_running)\n\t\treturn IO_WQ_CANCEL_RUNNING;\n\tif (match.nr_pending)\n\t\treturn IO_WQ_CANCEL_OK;\n\treturn IO_WQ_CANCEL_NOTFOUND;\n}", "target": 0}
{"code": "InlineBoxPosition AdjustInlineBoxPositionForPrimaryDirection(\n    InlineBox* inline_box,\n    int caret_offset) {\n  if (caret_offset == inline_box->CaretRightmostOffset()) {\n    InlineBox* const next_box = inline_box->NextLeafChild();\n    if (!next_box || next_box->BidiLevel() >= inline_box->BidiLevel())\n      return InlineBoxPosition(inline_box, caret_offset);\n    const unsigned level = next_box->BidiLevel();\n    InlineBox* const prev_box =\n        InlineBoxTraversal::FindLeftBidiRun(*inline_box, level);\n    if (prev_box && prev_box->BidiLevel() == level)\n      return InlineBoxPosition(inline_box, caret_offset);\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindRightBoundaryOfEntireBidiRun(*inline_box,\n                                                             level);\n    return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n  }\n  if (IsStartOfDifferentDirection(inline_box))\n    return InlineBoxPosition(inline_box, caret_offset);\n  const unsigned level = inline_box->PrevLeafChild()->BidiLevel();\n  InlineBox* const next_box =\n      InlineBoxTraversal::FindRightBidiRun(*inline_box, level);\n  if (next_box && next_box->BidiLevel() == level)\n    return InlineBoxPosition(inline_box, caret_offset);\n  InlineBox* const result_box =\n      InlineBoxTraversal::FindLeftBoundaryOfEntireBidiRun(*inline_box, level);\n  return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_convert)\n{\n\tzval *pgsql_link, *values;\n\tchar *table_name;\n\tsize_t table_name_len;\n\tzend_ulong option = 0;\n\tPGconn *pg_link;\n\tint id = -1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(),\n\t\t\t\t\t\t\t  \"rsa|l\", &pgsql_link, &table_name, &table_name_len, &values, &option) == FAILURE) {\n\t\treturn;\n\t}\n\tif (option & ~PGSQL_CONV_OPTS) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid option is specified\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!table_name_len) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Table name is invalid\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (php_pgsql_flush_query(pg_link)) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Detected unhandled result(s) in connection\");\n\t}\n\tarray_init(return_value);\n\tif (php_pgsql_convert(pg_link, table_name, values, return_value, option) == FAILURE) {\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "static int count_fuse_fs(void)\n{\n\tstruct mntent *entp;\n\tint count = 0;\n\tconst char *mtab = _PATH_MOUNTED;\n\tFILE *fp = setmntent(mtab, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname, mtab,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (strcmp(entp->mnt_type, \"fuse\") == 0 ||\n\t\t    strncmp(entp->mnt_type, \"fuse.\", 5) == 0)\n\t\t\tcount ++;\n\t}\n\tendmntent(fp);\n\treturn count;\n}", "target": 0}
{"code": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n{\n\tconst char *s;\n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}", "target": 1}
{"code": "void RenderView::CaptureText(WebFrame* frame, string16* contents) {\n  contents->clear();\n  if (!frame)\n    return;\n#ifdef TIME_TEXT_RETRIEVAL\n  double begin = time_util::GetHighResolutionTimeNow();\n#endif\n  *contents = frame->contentAsText(kMaxIndexChars);\n#ifdef TIME_TEXT_RETRIEVAL\n  double end = time_util::GetHighResolutionTimeNow();\n  char buf[128];\n  sprintf_s(buf, \"%d chars retrieved for indexing in %gms\\n\",\n            contents.size(), (end - begin)*1000);\n  OutputDebugStringA(buf);\n#endif\n  if (contents->size() == kMaxIndexChars) {\n    size_t last_space_index = contents->find_last_of(kWhitespaceUTF16);\n    if (last_space_index == std::wstring::npos)\n      return;  \n    contents->resize(last_space_index);\n  }\n}", "target": 0}
{"code": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 1}
{"code": "int snd_dma_alloc_pages_fallback(int type, struct device *device, size_t size,\n\t\t\t\t struct snd_dma_buffer *dmab)\n{\n\tint err;\n\tsnd_assert(size > 0, return -ENXIO);\n\tsnd_assert(dmab != NULL, return -ENXIO);\n\twhile ((err = snd_dma_alloc_pages(type, device, size, dmab)) < 0) {\n\t\tif (err != -ENOMEM)\n\t\t\treturn err;\n\t\tsize >>= 1;\n\t\tif (size <= PAGE_SIZE)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (! dmab->area)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t\n\t\treturn (NULL);\n\t}\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}", "target": 1}
{"code": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n         v9fs_path_sprintf(target, \"%s\", name);\n     }\n     return 0;\n }", "target": 1}
{"code": "static PixelChannels **DestroyPixelThreadSet(const Image *images,\n  PixelChannels **pixels)\n{\n  ssize_t\n    i;\n  size_t\n    rows;\n  assert(pixels != (PixelChannels **) NULL);\n  rows=MagickMax(GetImageListLength(images),(size_t)\n    GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (PixelChannels *) NULL)\n      pixels[i]=(PixelChannels *) RelinquishMagickMemory(pixels[i]);\n  pixels=(PixelChannels **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}", "target": 0}
{"code": "static int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_epoll_pwait(int epfd,\n\t\t\tstruct compat_epoll_event __user *events,\n\t\t\tint maxevents, int timeout,\n\t\t\tconst compat_sigset_t __user *sigmask,\n\t\t\tcompat_size_t sigsetsize)\n{\n\tlong err;\n\tcompat_sigset_t csigmask;\n\tsigset_t ksigmask, sigsaved;\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&csigmask, sigmask, sizeof(csigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &csigmask);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n#ifdef CONFIG_HAS_COMPAT_EPOLL_EVENT\n\terr = compat_sys_epoll_wait(epfd, events, maxevents, timeout);\n#else\n\terr = sys_epoll_wait(epfd, events, maxevents, timeout);\n#endif\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t} else\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "static inline void ok_inflater_write_byte(ok_inflater *inflater, const uint8_t b) {\n    inflater->buffer[inflater->buffer_end_pos & BUFFER_SIZE_MASK] = b;\n    inflater->buffer_end_pos++;\n}", "target": 0}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n}", "target": 1}
{"code": "DLLIMPORT int cfg_setnstr(cfg_t *cfg, const char *name, const char *value, unsigned int index)\n{\n\tcfg_opt_t *opt;\n\topt = cfg_getopt(cfg, name);\n\tif (opt && opt->validcb2 && (*opt->validcb2)(cfg, opt, (void *)value) != 0)\n\t\treturn CFG_FAIL;\n\treturn cfg_opt_setnstr(opt, value, index);\n}", "target": 0}
{"code": "handle_fn_f7 (GsdXrandrManager *mgr, guint32 timestamp)\n{\n        GsdXrandrManagerPrivate *priv = mgr->priv;\n        GnomeRRScreen *screen = priv->rw_screen;\n        GnomeRRConfig *current;\n        GError *error;\n        g_debug (\"Handling fn-f7\");\n        error = NULL;\n        if (!gnome_rr_screen_refresh (screen, &error) && error) {\n                char *str;\n                str = g_strdup_printf (_(\"Could not refresh the screen information: %s\"), error->message);\n                g_error_free (error);\n                error_message (mgr, str, NULL, _(\"Trying to switch the monitor configuration anyway.\"));\n                g_free (str);\n        }\n        if (!priv->fn_f7_configs)\n                generate_fn_f7_configs (mgr);\n        current = gnome_rr_config_new_current (screen);\n        if (priv->fn_f7_configs &&\n            (!gnome_rr_config_match (current, priv->fn_f7_configs[0]) ||\n             !gnome_rr_config_equal (current, priv->fn_f7_configs[mgr->priv->current_fn_f7_config]))) {\n                    generate_fn_f7_configs (mgr);\n            }\n        gnome_rr_config_free (current);\n        if (priv->fn_f7_configs) {\n                mgr->priv->current_fn_f7_config++;\n                if (priv->fn_f7_configs[mgr->priv->current_fn_f7_config] == NULL)\n                        mgr->priv->current_fn_f7_config = 0;\n                g_debug (\"cycling to next configuration (%d)\", mgr->priv->current_fn_f7_config);\n                print_configuration (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], \"new config\");\n                g_debug (\"applying\");\n                error = NULL;\n                if (!gnome_rr_config_apply_with_time (priv->fn_f7_configs[mgr->priv->current_fn_f7_config], screen, timestamp, &error)) {\n                        error_message (mgr, _(\"Could not switch the monitor configuration\"), error, NULL);\n                        g_error_free (error);\n                }\n        }\n        else {\n                g_debug (\"no configurations generated\");\n        }\n        g_debug (\"done handling fn-f7\");\n}", "target": 0}
{"code": "yang_check_choice(struct lys_module *module, struct lys_node_choice *choice, struct lys_node **child,\n                  int options, struct unres_schema *unres)\n{\n    char *value;\n    if (yang_check_iffeatures(module, NULL, choice, CHOICE_KEYWORD, unres)) {\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    if (yang_check_nodes(module, (struct lys_node *)choice, *child, options, unres)) {\n        *child = NULL;\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    *child = NULL;\n    if (choice->dflt) {\n        value = (char *)choice->dflt;\n        choice->dflt = NULL;\n        if (unres_schema_add_str(module, unres, choice, UNRES_CHOICE_DFLT, value) == -1) {\n            free(value);\n            goto error;\n        }\n        free(value);\n    }\n    if (choice->when && yang_check_ext_instance(module, &choice->when->ext, choice->when->ext_size, choice->when, unres)) {\n        goto error;\n    }\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && choice->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)choice)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, choice, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "static void destroy_compound_hugetlb_page_for_demote(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\t__destroy_compound_gigantic_page(page, order, true);\n}", "target": 0}
{"code": "std::string DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 1}
{"code": "check_secret_key( ELG_secret_key *sk )\n{\n    int rc;\n    MPI y = mpi_alloc( mpi_get_nlimbs(sk->y) );\n    mpi_powm( y, sk->g, sk->x, sk->p );\n    rc = !mpi_cmp( y, sk->y );\n    mpi_free( y );\n    return rc;\n}", "target": 0}
{"code": "static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length;\n\tstatic const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };\n\tvoid *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,\n\t\t\tARRAY_SIZE(seq), &actual_length, 1000);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "copy_creds_except(krb5_context context, krb5_ccache incc,\n                  krb5_ccache outcc, krb5_principal princ)\n{\n    krb5_error_code ret, ret2;\n    krb5_cc_cursor cur;\n    krb5_creds creds;\n    ret = krb5_cc_set_flags(context, incc, 0);\n    if (ret)\n        return ret;\n    ret = krb5_cc_start_seq_get(context, incc, &cur);\n    if (ret)\n        goto cleanup;\n    while (!(ret = krb5_cc_next_cred(context, incc, &cur, &creds))) {\n        if (krb5_principal_compare(context, princ, creds.server))\n            continue;\n        ret = krb5_cc_store_cred(context, outcc, &creds);\n        krb5_free_cred_contents(context, &creds);\n        if (ret)\n            goto cleanup;\n    }\n    if (ret != KRB5_CC_END)\n        goto cleanup;\n    ret = 0;\ncleanup:\n    ret2 = krb5_cc_set_flags(context, incc, KRB5_TC_OPENCLOSE);\n    return (ret == 0) ? ret2 : ret;\n}", "target": 0}
{"code": "lyxml_parse_mem(struct ly_ctx *ctx, const char *data, int options)\n{\n    FUN_IN;\n    const char *c = data;\n    unsigned int len;\n    struct lyxml_elem *root, *first = NULL, *next;\n    if (!ctx) {\n        LOGARG;\n        return NULL;\n    }\n    if (!data) {\n        return NULL;\n    }\nrepeat:\n    while (1) {\n        if (!*c) {\n            return first;\n        } else if (is_xmlws(*c)) {\n            ign_xmlws(c);\n        } else if (!strncmp(c, \"<?\", 2)) {\n            c += 2;\n            if (parse_ignore(ctx, c, \"?>\", &len)) {\n                goto error;\n            }\n            c += len;\n        } else if (!strncmp(c, \"<!--\", 4)) {\n            c += 2;\n            if (parse_ignore(ctx, c, \"-->\", &len)) {\n                goto error;\n            }\n            c += len;\n        } else if (!strncmp(c, \"<!\", 2)) {\n            LOGERR(ctx, LY_EINVAL, \"DOCTYPE not supported in XML documents.\");\n            goto error;\n        } else if (*c == '<') {\n            break;\n        } else {\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, c);\n            goto error;\n        }\n    }\n    root = lyxml_parse_elem(ctx, c, &len, NULL, options);\n    if (!root) {\n        goto error;\n    } else if (!first) {\n        first = root;\n    } else {\n        first->prev->next = root;\n        root->prev = first->prev;\n        first->prev = root;\n    }\n    c += len;\n    ign_xmlws(c);\n    if (*c) {\n        if (options & LYXML_PARSE_MULTIROOT) {\n            goto repeat;\n        } else {\n            LOGWRN(ctx, \"There are some not parsed data:\\n%s\", c);\n        }\n    }\n    return first;\nerror:\n    LY_TREE_FOR_SAFE(first, next, root) {\n        lyxml_free(ctx, root);\n    }\n    return NULL;\n}", "target": 1}
{"code": "    size_t PentaxDngMnHeader::write(IoWrapper& ioWrapper,\n                                   ByteOrder ) const\n    {\n        ioWrapper.write(signature_, sizeOfSignature());\n        return sizeOfSignature();\n    } ", "target": 0}
{"code": "file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "cma_select_inet_ps(struct rdma_id_private *id_priv)\n{\n\tswitch (id_priv->id.ps) {\n\tcase RDMA_PS_TCP:\n\tcase RDMA_PS_UDP:\n\tcase RDMA_PS_IPOIB:\n\tcase RDMA_PS_IB:\n\t\treturn id_priv->id.ps;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n \t\treturn ret;\n \t}\n \tread_lock(&tasklist_lock);\n \tif (pid != -1) {\n \t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 1}
{"code": "bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  return true;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "    bool operator()(const StatsPartitionKey& a,\n                    const StatsPartitionKey& b) const {\n      if (a.node_id < b.node_id) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim < b.feature_dim)) {\n        return true;\n      }\n      if ((a.node_id == b.node_id) && (a.feature_dim == b.feature_dim) &&\n          (a.bucket_id < b.bucket_id)) {\n        return true;\n      }\n      return false;\n    }", "target": 0}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\t__u32 pmtu = 0;\n\tif (!asoc)\n\t\treturn;\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tif (t->pmtu_pending && t->dst) {\n\t\t\tsctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));\n\t\t\tt->pmtu_pending = 0;\n\t\t}\n\t\tif (!pmtu || (t->pathmtu < pmtu))\n\t\t\tpmtu = t->pathmtu;\n\t}\n\tif (pmtu) {\n\t\tasoc->pathmtu = pmtu;\n\t\tasoc->frag_point = sctp_frag_point(asoc, pmtu);\n\t}\n\tpr_debug(\"%s: asoc:%p, pmtu:%d, frag_point:%d\\n\", __func__, asoc,\n\t\t asoc->pathmtu, asoc->frag_point);\n}", "target": 0}
{"code": "static inline int qdisc_restart(struct net_device *dev)\n{\n\tstruct Qdisc *q = dev->qdisc;\n\tstruct sk_buff *skb;\n\tint ret = NETDEV_TX_BUSY;\n\tif (unlikely((skb = dev_dequeue_skb(dev, q)) == NULL))\n\t\treturn 0;\n\tspin_unlock(&dev->queue_lock);\n\tHARD_TX_LOCK(dev, smp_processor_id());\n\tif (!netif_subqueue_stopped(dev, skb))\n\t\tret = dev_hard_start_xmit(skb, dev);\n\tHARD_TX_UNLOCK(dev);\n\tspin_lock(&dev->queue_lock);\n\tq = dev->qdisc;\n\tswitch (ret) {\n\tcase NETDEV_TX_OK:\n\t\tret = qdisc_qlen(q);\n\t\tbreak;\n\tcase NETDEV_TX_LOCKED:\n\t\tret = handle_dev_cpu_collision(skb, dev, q);\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))\n\t\t\tprintk(KERN_WARNING \"BUG %s code %d qlen %d\\n\",\n\t\t\t       dev->name, ret, q->q.qlen);\n\t\tret = dev_requeue_skb(skb, dev, q);\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 1}
{"code": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n    mrb->num_writes++;\n}", "target": 1}
{"code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\tif (!fepriv)\n\t\treturn;\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}", "target": 1}
{"code": "std::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n  return encoded;\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "find_script_callback(char_u *fname, void *cookie)\n{\n    int sid;\n    int error = OK;\n    int *ret_sid = cookie;\n    sid = find_script_by_name(fname);\n    if (sid < 0)\n    {\n\tsid = get_new_scriptitem(&error);\n\tif (error == OK)\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(sid);\n\t    si->sn_name = vim_strsave(fname);\n\t    si->sn_state = SN_STATE_NOT_LOADED;\n\t}\n    }\n    *ret_sid = sid;\n}", "target": 0}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "int expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tint error;\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock(vma);\n\tif (address < PAGE_ALIGN(address+4))\n\t\taddress = PAGE_ALIGN(address+4);\n\telse {\n\t\tanon_vma_unlock(vma);\n\t\treturn -ENOMEM;\n\t}\n\terror = 0;\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\t\terror = acct_stack_growth(vma, size, grow);\n\t\tif (!error)\n\t\t\tvma->vm_end = address;\n\t}\n\tanon_vma_unlock(vma);\n\treturn error;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}", "target": 1}
{"code": "static int file_modsqrt(STANZA *s)\n{\n    BIGNUM *a = NULL, *p = NULL, *mod_sqrt = NULL, *ret = NULL, *ret2 = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(p = getBN(s, \"P\"))\n            || !TEST_ptr(mod_sqrt = getBN(s, \"ModSqrt\"))\n            || !TEST_ptr(ret = BN_new())\n            || !TEST_ptr(ret2 = BN_new()))\n        goto err;\n    if (!TEST_true(BN_mod_sqrt(ret, a, p, ctx))\n            || !TEST_true(BN_sub(ret2, p, ret)))\n        goto err;\n    if (BN_cmp(ret2, mod_sqrt) != 0\n            && !equalBN(\"sqrt(A) (mod P)\", mod_sqrt, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(p);\n    BN_free(mod_sqrt);\n    BN_free(ret);\n    BN_free(ret2);\n    return st;\n}", "target": 0}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t\tstruct dj_report *dj_report)\n{\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\tif (dj_dev != NULL) {\n\t\thid_destroy_device(dj_dev->hdev);\n\t\tkfree(dj_dev);\n\t} else {\n\t\tdev_err(&djrcv_dev->hdev->dev, \"%s: can't destroy a NULL device\\n\",\n\t\t\t__func__);\n\t}\n}", "target": 0}
{"code": "static void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *value = (char *) malloc(size);\n        if (value == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_getxattr(f, req, ino, name, value, size);\n        if (res > 0)\n            fuse_reply_buf(req, value, res);\n        else\n            reply_err(req, res);\n        free(value);\n    } else {\n        res = common_getxattr(f, req, ino, name, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "static void __reg64_deduce_bounds(struct bpf_reg_state *reg)\n{\n\tif (reg->smin_value >= 0 || reg->smax_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t\treturn;\n\t}\n\tif ((s64)reg->umax_value >= 0) {\n\t\treg->smin_value = reg->umin_value;\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t} else if ((s64)reg->umin_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value;\n\t}\n}", "target": 0}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1}
{"code": "DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,\n\tint jpegSubsamp)\n{\n\tunsigned long retval=0;  int mcuw, mcuh, chromasf;\n\tif(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)\n\t\t_throwg(\"tjBufSize(): Invalid argument\");\n\tmcuw=tjMCUWidth[jpegSubsamp];\n\tmcuh=tjMCUHeight[jpegSubsamp];\n\tchromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);\n\tretval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n    assert(ss.size() == 0);\n    return ret;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "int av_lockmgr_register(int (*cb)(void **mutex, enum AVLockOp op))\n{\n    if (lockmgr_cb) {\n        if (lockmgr_cb(&codec_mutex, AV_LOCK_DESTROY))\n            return -1;\n        if (lockmgr_cb(&avformat_mutex, AV_LOCK_DESTROY))\n            return -1;\n    }\n    lockmgr_cb = cb;\n    if (lockmgr_cb) {\n        if (lockmgr_cb(&codec_mutex, AV_LOCK_CREATE))\n            return -1;\n        if (lockmgr_cb(&avformat_mutex, AV_LOCK_CREATE))\n            return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\tif (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}", "target": 0}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static av_cold void avcodec_init(void)\n{\n    static int initialized = 0;\n    if (initialized != 0)\n        return;\n    initialized = 1;\n    if (CONFIG_DSPUTIL)\n        ff_dsputil_static_init();\n}", "target": 0}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "static void validate_my_share_entries(struct smbd_server_connection *sconn,\n\t\t\t\t      int num,\n\t\t\t\t      struct share_mode_entry *share_entry)\n{\n\tstruct server_id self = messaging_server_id(sconn->msg_ctx);\n\tfiles_struct *fsp;\n\tif (!serverid_equal(&self, &share_entry->pid)) {\n\t\treturn;\n\t}\n\tif (!is_valid_share_mode_entry(share_entry)) {\n\t\treturn;\n\t}\n\tfsp = file_find_dif(sconn, share_entry->id,\n\t\t\t    share_entry->share_file_id);\n\tif (!fsp) {\n\t\tDEBUG(0,(\"validate_my_share_entries: PANIC : %s\\n\",\n\t\t\t share_mode_str(talloc_tos(), num, share_entry) ));\n\t\tsmb_panic(\"validate_my_share_entries: Cannot match a \"\n\t\t\t  \"share entry with an open file\\n\");\n\t}\n\tif (((uint16)fsp->oplock_type) != share_entry->op_type) {\n\t\tgoto panic;\n\t}\n\treturn;\n panic:\n\t{\n\t\tchar *str;\n\t\tDEBUG(0,(\"validate_my_share_entries: PANIC : %s\\n\",\n\t\t\t share_mode_str(talloc_tos(), num, share_entry) ));\n\t\tstr = talloc_asprintf(talloc_tos(),\n\t\t\t\"validate_my_share_entries: \"\n\t\t\t\"file %s, oplock_type = 0x%x, op_type = 0x%x\\n\",\n\t\t\t fsp->fsp_name->base_name,\n\t\t\t (unsigned int)fsp->oplock_type,\n\t\t\t (unsigned int)share_entry->op_type );\n\t\tsmb_panic(str);\n\t}\n}", "target": 0}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n  const char\n    *geometry,\n    *path,\n    *type;\n  DrawInfo\n    *clone_info;\n  ImageInfo\n    *image_info;\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}", "target": 0}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "NTSTATUS ldapsrv_queue_reply(struct ldapsrv_call *call, struct ldapsrv_reply *reply)\n{\n\tNTSTATUS status = ldapsrv_encode(call, reply);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\tif (call->reply_size > call->reply_size + reply->blob.length\n\t    || call->reply_size + reply->blob.length > LDAP_SERVER_MAX_REPLY_SIZE) {\n\t\tDBG_WARNING(\"Refusing to queue LDAP search response size \"\n\t\t\t    \"of more than %zu bytes\\n\",\n\t\t\t    LDAP_SERVER_MAX_REPLY_SIZE);\n\t\tTALLOC_FREE(reply->blob.data);\n\t\treturn NT_STATUS_FILE_TOO_LARGE;\n\t}\n\tcall->reply_size += reply->blob.length;\n\tDLIST_ADD_END(call->replies, reply);\n\treturn status;\n}", "target": 0}
{"code": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n   }\n  return result;\n }", "target": 1}
{"code": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n        return CR_OK;\n}", "target": 1}
{"code": "static RBinSection *bin_section_from_segment(RCoreSymCacheElementSegment *seg) {\n\tif (!seg->name) {\n\t\treturn NULL;\n\t}\n\tRBinSection *s = R_NEW0 (RBinSection);\n\tif (!s) {\n\t\treturn NULL;\n\t}\n\ts->name = r_str_ndup (seg->name, 16);\n\ts->size = seg->size;\n\ts->vsize = seg->vsize;\n\ts->paddr = seg->paddr;\n\ts->vaddr = seg->vaddr;\n\ts->add = true;\n\ts->perm = strstr (s->name, \"TEXT\") ? 5 : 4;\n\ts->is_segment = true;\n\treturn s;\n}", "target": 0}
{"code": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n}", "target": 0}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "static int fixup_call_args(struct bpf_verifier_env *env)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint i, depth;\n#endif\n\tint err = 0;\n\tif (env->prog->jit_requested &&\n\t    !bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\terr = jit_subprogs(env);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\tif (err == -EFAULT)\n\t\t\treturn err;\n\t}\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tfor (i = 0; i < prog->len; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL) ||\n\t\t    insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\t\tdepth = get_callee_stack_depth(env, insn, i);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t\tbpf_patch_call_args(insn, depth);\n\t}\n\terr = 0;\n#endif\n\treturn err;\n}", "target": 0}
{"code": "int rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\treturn 0;\n}", "target": 0}
{"code": "char *php_date_full_day_name(timelib_sll y, timelib_sll m, timelib_sll d)\n{\n\ttimelib_sll day_of_week = timelib_day_of_week(y, m, d);\n\tif (day_of_week < 0) {\n\t\treturn \"Unknown\";\n\t} \n\treturn day_full_names[day_of_week];\t", "target": 0}
{"code": "zzip_disk_entry_fopen (ZZIP_DISK* disk, ZZIP_DISK_ENTRY* entry)\n{\n    ZZIP_DISK_FILE* file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file) return file;\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->header = zzip_disk_entry_to_file_header (disk, entry);\n    if (! file->header) { free (file); return 0; }\n    file->avail = zzip_file_header_usize (file->header);\n    if (! file->avail || zzip_file_header_data_stored (file->header))\n    { file->stored = zzip_file_header_to_data (file->header); return file; }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize (file->header);\n    file->zlib.next_in = zzip_file_header_to_data (file->header);\n    if (! zzip_file_header_data_deflated (file->header) ||\n\tinflateInit2 (& file->zlib, -MAX_WBITS) != Z_OK)\n    { free (file); return 0; }\n    return file;\n}", "target": 1}
{"code": "mm_sshpam_respond(void *ctx, u_int num, char **resp)\n{\n\tBuffer m;\n\tint i, ret;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_int(&m, num);\n\tfor (i = 0; i < num; ++i)\n\t\tbuffer_put_cstring(&m, resp[i]);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_RESPOND, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_RESPOND\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_RESPOND, &m);\n\tret = buffer_get_int(&m);\n\tdebug3(\"%s: pam_respond returned %d\", __func__, ret);\n\tbuffer_free(&m);\n\treturn (ret);\n}", "target": 0}
{"code": "int udp_sendpage(struct sock *sk, struct page *page, int offset,\n\t\t size_t size, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ret;\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\tif (!up->pending) {\n\t\tstruct msghdr msg = {\t.msg_flags = flags|MSG_MORE };\n\t\tret = udp_sendmsg(sk, &msg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tlock_sock(sk);\n\tif (unlikely(!up->pending)) {\n\t\trelease_sock(sk);\n\t\tnet_dbg_ratelimited(\"udp cork app bug 3\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = ip_append_page(sk, &inet->cork.fl.u.ip4,\n\t\t\t     page, offset, size, flags);\n\tif (ret == -EOPNOTSUPP) {\n\t\trelease_sock(sk);\n\t\treturn sock_no_sendpage(sk->sk_socket, page, offset,\n\t\t\t\t\tsize, flags);\n\t}\n\tif (ret < 0) {\n\t\tudp_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\tup->len += size;\n\tif (!(up->corkflag || (flags&MSG_MORE)))\n\t\tret = udp_push_pending_frames(sk);\n\tif (!ret)\n\t\tret = size;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static int kvp_get_value(int pool, __u8 *key, int key_size, __u8 *value,\n\t\t\tint value_size)\n{\n\tint i;\n\tint num_records;\n\tstruct kvp_record *record;\n\tif ((key_size > HV_KVP_EXCHANGE_MAX_KEY_SIZE) ||\n\t\t(value_size > HV_KVP_EXCHANGE_MAX_VALUE_SIZE))\n\t\treturn 1;\n\tkvp_update_mem_state(pool);\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\tmemcpy(value, record[i].value, value_size);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "int ipmi_validate_addr(struct ipmi_addr *addr, int len)\n{\n\tif (len < sizeof(struct ipmi_system_interface_addr))\n\t\treturn -EINVAL;\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tif (addr->channel != IPMI_BMC_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif ((addr->channel == IPMI_BMC_CHANNEL)\n\t    || (addr->channel >= IPMI_MAX_CHANNELS)\n\t    || (addr->channel < 0))\n\t\treturn -EINVAL;\n\tif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_ipmb_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (is_lan_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_lan_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}", "target": 1}
{"code": "static void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\tsp = sctp_sk(sk);\n\tif (sp->ep == NULL)\n\t\treturn;\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}", "target": 1}
{"code": "u32 gf_fs_get_max_resolution_chain_length(GF_FilterSession *session)\n{\n\tif (!session) return 0;\n\treturn session->max_resolve_chain_len;\n}", "target": 0}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "libxlDomainEventHandler(void *data, libxl_event *event)\n{\n    libxlDriverPrivate *driver = data;\n    libxl_shutdown_reason xl_reason = event->u.domain_shutdown.shutdown_reason;\n    virDomainObj *vm = NULL;\n    g_autoptr(libxlDriverConfig) cfg = NULL;\n    VIR_DEBUG(\"Received libxl event '%d' for domid '%d'\", event->type, event->domid);\n    if (event->type != LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN &&\n            event->type != LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        VIR_INFO(\"Unhandled event type %d\", event->type);\n        goto cleanup;\n    }\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_SUSPEND)\n        goto cleanup;\n    vm = virDomainObjListFindByID(driver->domains, event->domid);\n    if (!vm) {\n        goto cleanup;\n    }\n    if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {\n        struct libxlEventHandlerThreadInfo *shutdown_info = NULL;\n        virThread thread;\n        g_autofree char *name = NULL;\n        shutdown_info = g_new0(struct libxlEventHandlerThreadInfo, 1);\n        shutdown_info->driver = driver;\n        shutdown_info->vm = vm;\n        shutdown_info->event = (libxl_event *)event;\n        name = g_strdup_printf(\"ev-%d\", event->domid);\n        if (virThreadCreateFull(&thread, false, libxlDomainShutdownThread,\n                                name, false, shutdown_info) < 0) {\n            VIR_ERROR(_(\"Failed to create thread to handle domain shutdown\"));\n            VIR_FREE(shutdown_info);\n            goto cleanup;\n        }\n        return;\n    } else if (event->type == LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        libxlDomainHandleDeath(driver, vm);\n    }\n cleanup:\n    virDomainObjEndAPI(&vm);\n    cfg = libxlDriverConfigGet(driver);\n    libxl_event_free(cfg->ctx, (libxl_event *)event);\n}", "target": 1}
{"code": " void FrameView::updateLayoutAndStyleForPainting()\n {\n     RefPtr<FrameView> protector(this);\n     updateLayoutAndStyleIfNeededRecursive();\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get());\n        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());\n        view->compositor()->updateIfNeededRecursive();\n        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())\n            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();\n        updateCompositedSelectionBoundsIfNeeded();\n        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());\n        invalidateTreeIfNeededRecursive();\n    }\n    scrollContentsIfNeededRecursive();\n    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);\n}", "target": 1}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "dissect_header_lens_v1(tvbuff_t *tvb, int offset, proto_tree *tree, int encoding, int * const *hf_indexes)\n{\n    int param_count;\n    proto_item *ti;\n    proto_tree *len_tree;\n    for (param_count = 0; hf_indexes[param_count]; param_count++);\n    ti = proto_tree_add_item(tree, hf_se_param_lens, tvb, offset, param_count * SYSDIG_PARAM_SIZE, ENC_NA);\n    len_tree = proto_item_add_subtree(ti, ett_sysdig_parm_lens);\n    for (param_count = 0; hf_indexes[param_count]; param_count++) {\n        proto_tree_add_item(len_tree, hf_se_param_len, tvb, offset + (param_count * SYSDIG_PARAM_SIZE), SYSDIG_PARAM_SIZE, encoding);\n    }\n    proto_item_set_len(ti, param_count * SYSDIG_PARAM_SIZE);\n    return param_count * SYSDIG_PARAM_SIZE;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "__visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)\n{\n\tstruct kvm_lock_waiting *w;\n\tint cpu;\n\tu64 start;\n\tunsigned long flags;\n\tif (in_nmi())\n\t\treturn;\n\tw = this_cpu_ptr(&klock_waiting);\n\tcpu = smp_processor_id();\n\tstart = spin_time_start();\n\tlocal_irq_save(flags);\n\tw->lock = NULL;\n\tsmp_wmb();\n\tw->want = want;\n\tsmp_wmb();\n\tw->lock = lock;\n\tadd_stats(TAKEN_SLOW, 1);\n\tcpumask_set_cpu(cpu, &waiting_cpus);\n\tbarrier();\n\t__ticket_enter_slowpath(lock);\n\tif (ACCESS_ONCE(lock->tickets.head) == want) {\n\t\tadd_stats(TAKEN_SLOW_PICKUP, 1);\n\t\tgoto out;\n\t}\n\tif (arch_irqs_disabled_flags(flags))\n\t\thalt();\n\telse\n\t\tsafe_halt();\nout:\n\tcpumask_clear_cpu(cpu, &waiting_cpus);\n\tw->lock = NULL;\n\tlocal_irq_restore(flags);\n\tspin_time_accum_blocked(start);\n}", "target": 0}
{"code": "asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds,\n\tunsigned int nfds, struct compat_timespec __user *tsp,\n\tconst compat_sigset_t __user *sigmask, compat_size_t sigsetsize)\n{\n\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\ts64 timeout = -1;\n\tint ret;\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ROUND_UP(ts.tv_nsec, 1000000000/HZ);\n\t\ttimeout += ts.tv_sec * HZ;\n\t}\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ss32, sigmask, sizeof(ss32)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &ss32);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\tret = do_sys_poll(ufds, nfds, &timeout);\n\tif (ret == -EINTR) {\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\tif (tsp && timeout >= 0) {\n\t\tstruct compat_timespec rts;\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trts.tv_nsec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ)) *\n\t\t\t\t\t1000;\n\t\trts.tv_sec = timeout;\n\t\tif (compat_timespec_compare(&rts, &ts) >= 0)\n\t\t\trts = ts;\n\t\tif (copy_to_user(tsp, &rts, sizeof(rts))) {\nsticky:\n\t\t\tif (ret == -ERESTARTNOHAND && timeout >= 0)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "STATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             \n                const STRLEN y,             \n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n        find(head, src[i-1])->value = i;\n    }\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\tif (!sanity(i))\n\t\treturn 0;\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}", "target": 1}
{"code": "bool AsyncPixelTransfersCompletedQuery::End(\n    base::subtle::Atomic32 submit_count) {\n  AsyncMemoryParams mem_params;\n  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());\n  if (!buffer.shared_memory)\n    return false;\n  mem_params.shared_memory = buffer.shared_memory;\n   mem_params.shm_size = buffer.size;\n   mem_params.shm_data_offset = shm_offset();\n   mem_params.shm_data_size = sizeof(QuerySync);\n   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);\n  manager()->decoder()->GetAsyncPixelTransferManager()\n      ->AsyncNotifyCompletion(mem_params, observer_);\n  return AddToPendingTransferQueue(submit_count);\n}", "target": 1}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tunsigned long cr4;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tcr4 = read_cr4();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t\n\tvmx->host_state.vmcs_host_cr4 = cr4;\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 0}
{"code": "njs_string_decode_base64_core(njs_vm_t *vm, njs_value_t *value,\n    const njs_str_t *src, njs_bool_t url)\n{\n    size_t     length;\n    const u_char *basis;\n    njs_str_t  dst;\n    basis = (url) ? njs_basis64url : njs_basis64;\n    length = njs_decode_base64_length_core(src, basis, &dst.length);\n    if (njs_slow_path(dst.length == 0)) {\n        vm->retval = njs_string_empty;\n        return NJS_OK;\n    }\n    dst.start = njs_string_alloc(vm, value, dst.length, length);\n    if (njs_slow_path(dst.start == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_decode_base64_core(&dst, src, basis);\n    return NJS_OK;\n}", "target": 0}
{"code": "my_bool STDCALL mysql_stmt_free_result(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_free_result\");\n  DBUG_RETURN(reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT |\n                                RESET_CLEAR_ERROR));\n}", "target": 0}
{"code": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client,\n                                           uint32_t port_index,\n                                           const std::vector<uint8>& data,\n                                           double timestamp) {\n  DCHECK_LT(port_index, output_streams_.size());\n   output_streams_[port_index]->Send(data);\n   client->AccumulateMidiBytesSent(data.size());\n }", "target": 1}
{"code": "parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + i < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "vm_fault_t gru_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct gru_thread_state *gts;\n\tunsigned long paddr, vaddr;\n\tunsigned long expires;\n\tvaddr = vmf->address;\n\tgru_dbg(grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\",\n\t\tvma, vaddr, GSEG_BASE(vaddr));\n\tSTAT(nopfn);\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\tgru_check_context_placement(gts);\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))\n\t\t\t\tgru_steal_context(gts);\n\t\t\tgoto again;\n\t\t}\n\t\tgru_load_context(gts);\n\t\tpaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\n\t\tremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\n\t\t\t\tpaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\n\t\t\t\tvma->vm_page_prot);\n\t}\n\tpreempt_enable();\n\tmutex_unlock(&gts->ts_ctxlock);\n\treturn VM_FAULT_NOPAGE;\n}", "target": 1}
{"code": "pch_normalize (enum diff format)\n{\n  lin old = 1;\n  lin new = p_ptrn_lines + 1;\n  while (p_Char[new] == '=' || p_Char[new] == '\\n')\n    new++;\n  if (format == UNI_DIFF)\n    {\n      for (; old <= p_ptrn_lines; old++)\n\tif (p_Char[old] == '!')\n\t  p_Char[old] = '-';\n      for (; new <= p_end; new++)\n\tif (p_Char[new] == '!')\n\t  p_Char[new] = '+';\n    }\n  else\n    {\n      while (old <= p_ptrn_lines)\n\t{\n\t  if (p_Char[old] == '-')\n\t    {\n\t      if (new <= p_end && p_Char[new] == '+')\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      p_Char[old] = '!';\n\t\t      old++;\n\t\t    }\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t  do\n\t\t    {\n\t\t      p_Char[new] = '!';\n\t\t      new++;\n\t\t    }\n\t\t  while (new <= p_end && p_Char[new] == '+');\n\t\t}\n\t      else\n\t\t{\n\t\t  do\n\t\t    old++;\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t}\n\t    }\n\t  else if (new <= p_end && p_Char[new] == '+')\n\t    {\n\t      do\n\t\tnew++;\n\t      while (new <= p_end && p_Char[new] == '+');\n\t    }\n\t  else\n\t    {\n\t      old++;\n\t      new++;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)\n{\n\tunsigned long flags;\n\tstruct page *page, *h;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry_safe(page, h, &n->partial, lru) {\n\t\tif (!page->inuse) {\n\t\t\tlist_del(&page->lru);\n\t\t\tdiscard_slab(s, page);\n\t\t\tn->nr_partial--;\n\t\t} else {\n\t\t\tlist_slab_objects(s, page,\n\t\t\t\t\"Objects remaining on kmem_cache_close()\");\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n}", "target": 0}
{"code": "PHP_FUNCTION(curl_exec)\n{\n\tCURLcode\terror;\n\tzval\t\t*zid;\n\tphp_curl\t*ch;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &zid) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(ch, php_curl *, zid, -1, le_curl_name, le_curl);\n\t_php_curl_verify_handlers(ch, 1);\n\t_php_curl_cleanup_handle(ch);\n\terror = curl_easy_perform(ch->cp);\n\tSAVE_CURL_ERROR(ch, error);\n\tif (error != CURLE_OK && error != CURLE_PARTIAL_FILE) {\n\t\tsmart_str_free(&ch->handlers->write->buf);\n\t\tRETURN_FALSE;\n\t}\n\tif (!Z_ISUNDEF(ch->handlers->std_err)) {\n\t\tphp_stream  *stream;\n\t\tstream = zend_fetch_resource(&ch->handlers->std_err, -1, NULL, NULL, 2, php_file_le_stream(), php_file_le_pstream());\n\t\tif (stream) {\n\t\t\tphp_stream_flush(stream);\n\t\t}\n\t}\n\tif (ch->handlers->write->method == PHP_CURL_RETURN && ch->handlers->write->buf.s) {\n\t\tsmart_str_0(&ch->handlers->write->buf);\n\t\tRETURN_STR(zend_string_copy(ch->handlers->write->buf.s));\n\t}\n\tif (ch->handlers->write->method == PHP_CURL_FILE && ch->handlers->write->fp) {\n\t\tfflush(ch->handlers->write->fp);\n\t}\n\tif (ch->handlers->write_header->method == PHP_CURL_FILE && ch->handlers->write_header->fp) {\n\t\tfflush(ch->handlers->write_header->fp);\n\t}\n\tif (ch->handlers->write->method == PHP_CURL_RETURN) {\n\t\tRETURN_EMPTY_STRING();\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}", "target": 0}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "    bool getTextValue(std::string& value, const XmpData::iterator& pos)\n    {\n        if (pos->typeId() == langAlt) {\n            value = pos->toString(0);\n            if (!pos->value().ok() && pos->count() == 1) {\n                value = pos->toString();\n                if (   pos->value().ok()\n                    && value.length() > 5 && value.substr(0, 5) == \"lang=\") {\n                    const std::string::size_type first_space_pos = value.find_first_of(' ');\n                    if (first_space_pos != std::string::npos) {\n                        value = value.substr(first_space_pos + 1);\n                    }\n                    else {\n                        value.clear();\n                    }\n                }\n            }\n        }\n        else {\n            value = pos->toString();\n        }\n        return pos->value().ok();\n    }", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tkfree(clt);\n}", "target": 1}
{"code": "read_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }", "target": 1}
{"code": "    Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "static void domain_exit(struct dmar_domain *domain)\n{\n\tstruct page *freelist = NULL;\n\tif (!domain)\n\t\treturn;\n\trcu_read_lock();\n\tdomain_remove_dev_info(domain);\n\trcu_read_unlock();\n\tput_iova_domain(&domain->iovad);\n\tfreelist = domain_unmap(domain, 0, DOMAIN_MAX_PFN(domain->gaw));\n\tdma_free_pagelist(freelist);\n\tfree_domain_mem(domain);\n}", "target": 0}
{"code": "static u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)\n{\n    DNXHDEncContext *ctx = avctx->priv_data;\n    static const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 };\n    memset(buf, 0, 640);\n    memcpy(buf, header_prefix, 5);\n    buf[5] = ctx->interlaced ? ctx->cur_field+2 : 0x01;\n    buf[6] = 0x80; \n    buf[7] = 0xa0; \n    AV_WB16(buf + 0x18, avctx->height>>ctx->interlaced); \n    AV_WB16(buf + 0x1a, avctx->width);  \n    AV_WB16(buf + 0x1d, avctx->height>>ctx->interlaced); \n    buf[0x21] = ctx->cid_table->bit_depth == 10 ? 0x58 : 0x38;\n    buf[0x22] = 0x88 + (ctx->interlaced<<2);\n    AV_WB32(buf + 0x28, ctx->cid); \n    buf[0x2c] = ctx->interlaced ? 0 : 0x80;\n    buf[0x5f] = 0x01; \n    buf[0x167] = 0x02; \n    AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); \n    buf[0x16d] = ctx->m.mb_height; \n    buf[0x16f] = 0x10; \n    ctx->msip = buf + 0x170;\n    return 0;\n}", "target": 0}
{"code": "bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n}", "target": 1}
{"code": "ins_compl_stop(int c, int prev_mode, int retval)\n{\n    char_u\t*ptr;\n    int\t\twant_cindent;\n    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)\n    {\n\tif (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)\n\t    ptr = compl_curr_match->cp_str;\n\telse\n\t    ptr = NULL;\n\tins_compl_fixRedoBufForLeader(ptr);\n    }\n    want_cindent = (get_can_cindent() && cindent_on());\n    if (compl_cont_mode == CTRL_X_WHOLE_LINE)\n    {\n\tif (want_cindent)\n\t{\n\t    do_c_expr_indent();\n\t    want_cindent = FALSE;\t\n\t}\n    }\n    else\n    {\n\tint prev_col = curwin->w_cursor.col;\n\tif (prev_col > 0)\n\t    dec_cursor();\n\tif (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)\n\t    insertchar(NUL, 0, -1);\n\tif (prev_col > 0\n\t\t&& ml_get_curline()[curwin->w_cursor.col] != NUL)\n\t    inc_cursor();\n    }\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n    if (c == Ctrl_E)\n    {\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    ins_bytes(compl_leader + get_compl_len());\n\telse if (compl_first_match != NULL)\n\t    ins_bytes(compl_orig_text + get_compl_len());\n\tretval = TRUE;\n    }\n    auto_format(FALSE, TRUE);\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    if (!shortmess(SHM_COMPLETIONMENU))\n\tmsg_clr_cmdline();\t\n    ctrl_x_mode = CTRL_X_NORMAL;\n    compl_enter_selects = FALSE;\n    if (edit_submode != NULL)\n    {\n\tedit_submode = NULL;\n\tshowmode();\n    }\n#ifdef FEAT_CMDWIN\n    if (c == Ctrl_C && cmdwin_type != 0)\n\tupdate_screen(0);\n#endif\n    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))\n\tdo_c_expr_indent();\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n    return retval;\n}", "target": 1}
{"code": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 0}
{"code": "static int check_is_mount_child(void *p)\n{\n\tconst char **a = p;\n\tconst char *last = a[0];\n\tconst char *mnt = a[1];\n\tint res;\n\tconst char *procmounts = \"/proc/mounts\";\n\tint found;\n\tFILE *fp;\n\tstruct mntent *entp;\n\tint count;\n\tres = mount(\"\", \"/\", \"\", MS_PRIVATE | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to mark mounts private: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tcount = 0;\n\twhile (getmntent(fp) != NULL)\n\t\tcount++;\n\tendmntent(fp);\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tres = mount(\".\", \"/\", \"\", MS_BIND | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to bind parent to /: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfound = 0;\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (entp->mnt_dir[0] == '/' &&\n\t\t    strcmp(entp->mnt_dir + 1, last) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tendmntent(fp);\n\tif (!found) {\n\t\tfprintf(stderr, \"%s: %s not mounted\\n\", progname, mnt);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\tmutex_lock(&econet_mutex);\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\tmutex_unlock(&econet_mutex);\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}", "target": 1}
{"code": "JOIN::add_sorting_to_table(JOIN_TAB *tab, ORDER *order)\n{\n  tab->filesort= \n    new (thd->mem_root) Filesort(order, HA_POS_ERROR, tab->keep_current_rowid,\n                                 tab->select);\n  if (!tab->filesort)\n    return true;\n  if (tab->select)\n  {\n    tab->select= NULL;\n    tab->set_select_cond(NULL, __LINE__);\n  }\n  tab->read_first_record= join_init_read_record;\n  return false;\n}", "target": 0}
{"code": "void key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}", "target": 0}
{"code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\tif (up_flag)\n\t\treturn;\n\tif (value < 10) {\n\t\tbase = 10;\n\t} else {\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}", "target": 1}
{"code": "void WriteMenu(IPC::Message* m, const PP_Flash_Menu* menu) {\n  m->WriteUInt32(menu->count);\n  for (uint32_t i = 0; i < menu->count; ++i)\n    WriteMenuItem(m, menu->items + i);\n}", "target": 0}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "void undefer_input(__G)\n    __GDEF\n{\n    if (G.incnt > 0)\n        G.csize += G.incnt;\n    if (G.incnt_leftover > 0) {\n        G.incnt = G.incnt_leftover + (int)G.csize;\n        G.inptr = G.inptr_leftover - (int)G.csize;\n        G.incnt_leftover = 0;\n    } else if (G.incnt < 0)\n        G.incnt = 0;\n} ", "target": 1}
{"code": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n    return size;\n}", "target": 1}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static int transmit_skb(struct sk_buff *skb, struct caifsock *cf_sk,\n\t\t\tint noblock, long timeo)\n{\n\tstruct cfpkt *pkt;\n\tpkt = cfpkt_fromnative(CAIF_DIR_OUT, skb);\n\tmemset(skb->cb, 0, sizeof(struct caif_payload_info));\n\tcfpkt_set_prio(pkt, cf_sk->sk.sk_priority);\n\tif (cf_sk->layer.dn == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\treturn cf_sk->layer.dn->transmit(cf_sk->layer.dn, pkt);\n}", "target": 0}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "ExpressionConvert::ExpressionConvert(ExpressionContext* const expCtx,\n                                     boost::intrusive_ptr<Expression> input,\n                                     boost::intrusive_ptr<Expression> to,\n                                     boost::intrusive_ptr<Expression> onError,\n                                     boost::intrusive_ptr<Expression> onNull)\n    : Expression(expCtx, {std::move(input), std::move(to), std::move(onError), std::move(onNull)}),\n      _input(_children[0]),\n      _to(_children[1]),\n      _onError(_children[2]),\n      _onNull(_children[3]) {}", "target": 0}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "decompileSUBSTRING(int n, SWF_ACTION *actions,int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"substr\",\"(\", 3,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static const char *subtype_to_string(uint32_t subtype)\n{\n\tswitch (subtype & 0x03) {\n\tcase 0x01:\n\t\treturn \"Audio Book\";\n\tcase 0x02:\n\t\treturn \"Podcast\";\n\tcase 0x03:\n\t\treturn \"Audio Book, Podcast\";\n\t}\n\treturn \"None\";\n}", "target": 0}
{"code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}", "target": 0}
{"code": "AP_DECLARE(const char *) ap_context_prefix(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_prefix)\n        return conf->context_prefix;\n    else\n        return \"\";\n}", "target": 0}
{"code": "int sldns_str2wire_dname_buf_origin(const char* str, uint8_t* buf, size_t* len,\n\tuint8_t* origin, size_t origin_len)\n{\n\tsize_t dlen = *len;\n\tint rel = 0;\n\tint s = sldns_str2wire_dname_buf_rel(str, buf, &dlen, &rel);\n\tif(s) return s;\n\tif(rel && origin && dlen > 0) {\n\t\tif(dlen + origin_len - 1 > LDNS_MAX_DOMAINLEN)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_DOMAINNAME_OVERFLOW,\n\t\t\t\tLDNS_MAX_DOMAINLEN);\n\t\tif(dlen + origin_len - 1 > *len)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\t*len);\n\t\tmemmove(buf+dlen-1, origin, origin_len);\n\t\t*len = dlen + origin_len - 1;\n\t} else\n\t\t*len = dlen;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 1}
{"code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n \tif (iter) {\n \t\tclass_dev_iter_exit(iter);\n \t\tkfree(iter);\n \t}\n }", "target": 1}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "static void SVGStripString(const MagickBooleanType trim,char *message)\n{\n  register char\n    *p,\n    *q;\n  size_t\n    length;\n  assert(message != (char *) NULL);\n  if (*message == '\\0')\n    return;\n  q=message;\n  for (p=message; *p != '\\0'; p++)\n  {\n    if ((*p == '/') && (*(p+1) == '*'))\n      {\n        for ( ; *p != '\\0'; p++)\n          if ((*p == '*') && (*(p+1) == '/'))\n            break;\n        if (*p == '\\0')\n          break;\n        p+=2;\n      }\n    *q++=(*p);\n  }\n  *q='\\0';\n  if (trim != MagickFalse)\n    {\n      length=strlen(message);\n      p=message;\n      while (isspace((int) ((unsigned char) *p)) != 0)\n        p++;\n      if ((*p == '\\'') || (*p == '\"'))\n        p++;\n      q=message+length-1;\n      while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n        q--;\n      if (q > p)\n        if ((*q == '\\'') || (*q == '\"'))\n          q--;\n      (void) memmove(message,p,(size_t) (q-p+1));\n      message[q-p+1]='\\0';\n    }\n  for (p=message; *p != '\\0'; p++)\n    if (*p == '\\n')\n      *p=' ';\n}", "target": 1}
{"code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  return tensor->is_variable ? tensor : nullptr;\n}", "target": 1}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tu32 jmp_sz = sizeof(struct bpf_idx_pair) * src->jmp_history_cnt;\n\tint i, err;\n\tif (dst_state->jmp_history_cnt < src->jmp_history_cnt) {\n\t\tkfree(dst_state->jmp_history);\n\t\tdst_state->jmp_history = kmalloc(jmp_sz, GFP_USER);\n\t\tif (!dst_state->jmp_history)\n\t\t\treturn -ENOMEM;\n\t}\n\tmemcpy(dst_state->jmp_history, src->jmp_history, jmp_sz);\n\tdst_state->jmp_history_cnt = src->jmp_history_cnt;\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tdst_state->active_spin_lock = src->active_spin_lock;\n\tdst_state->branches = src->branches;\n\tdst_state->parent = src->parent;\n\tdst_state->first_insn_idx = src->first_insn_idx;\n\tdst_state->last_insn_idx = src->last_insn_idx;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void RemoteFsDevice::saveProperties(const DeviceOptions &newOpts, const Details &nd)\n{\n    bool connected=isConnected();\n    if (configured && (!connected || opts==newOpts) && (connected || details==nd)) {\n        return;\n    }\n    bool isLocal=details.isLocalFile();\n    if (connected) {\n        if (!configured) {\n            details.configured=configured=true;\n            details.save();\n        }\n        if (opts.useCache!=newOpts.useCache) {\n            if (opts.useCache) {\n                saveCache();\n            } else if (opts.useCache && !newOpts.useCache) {\n                removeCache();\n            }\n        }\n        opts=newOpts;\n        writeOpts(settingsFileName(), opts, true);\n    }\n    if (!connected || isLocal) {\n        Details newDetails=nd;\n        Details oldDetails=details;\n        bool newName=!oldDetails.name.isEmpty() && oldDetails.name!=newDetails.name;\n        bool newDir=oldDetails.url.path()!=newDetails.url.path();\n        if (isLocal && newDir && opts.useCache) {\n            removeCache();\n        }\n        details=newDetails;\n        details.configured=configured=true;\n        details.save();\n        if (newName) {\n            if (!details.isLocalFile()) {\n                QString oldMount=mountPoint(oldDetails, false);\n                if (!oldMount.isEmpty() && QDir(oldMount).exists()) {\n                    ::rmdir(QFile::encodeName(oldMount).constData());\n                }\n            }\n            setData(details.name);\n            renamed(oldDetails.name, details.name);\n            deviceId=createUdi(details.name);\n            emit udiChanged();\n            m_itemData=details.name;\n            setStatusMessage(QString());\n        }\n        if (isLocal && newDir && scanned) {\n            rescan(true);\n        }\n    }\n    emit configurationChanged();\n}", "target": 0}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "u64 gf_isom_get_first_mdat_start(GF_ISOFile *movie)\n{\n\tu64 offset;\n\tif (!movie) return 0;\n\toffset = movie->first_data_toplevel_offset + 8;\n\tif (movie->first_data_toplevel_size > 0xFFFFFFFFUL)\n\t\toffset += 8;\n\treturn offset;\n}", "target": 0}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 1}
{"code": "LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR *sFile)\n    : LibRaw_buffer_datastream(NULL, 0), hMap_(0), pView_(NULL)\n{\n  HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, 0);\n  if (hFile == INVALID_HANDLE_VALUE)\n    throw std::runtime_error(\"failed to open the file\");\n  try\n  {\n    Open(hFile);\n  }\n  catch (...)\n  {\n    CloseHandle(hFile);\n    throw;\n  }\n  CloseHandle(hFile); \n  reconstruct_base();\n}", "target": 0}
{"code": "_gnutls_x509_read_value(ASN1_TYPE c, const char *root,\n\t\t\tgnutls_datum_t * ret)\n{\n\tint len = 0, result;\n\tuint8_t *tmp = NULL;\n\tunsigned int etype;\n\tresult = asn1_read_value_type(c, root, NULL, &len, &etype);\n\tif (result == 0 && len == 0) {\n\t\treturn gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t}\n\tif (result != ASN1_MEM_ERROR) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\treturn result;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tlen = (len + 7)/8;\n\t}\n\ttmp = gnutls_malloc((size_t) len + 1);\n\tif (tmp == NULL) {\n\t\tgnutls_assert();\n\t\tresult = GNUTLS_E_MEMORY_ERROR;\n\t\tgoto cleanup;\n\t}\n\tresult = asn1_read_value(c, root, tmp, &len);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tret->size = (len+7) / 8;\n\t} else {\n\t\tret->size = (unsigned) len;\n\t}\n\ttmp[ret->size] = 0;\n\tret->data = tmp;\n\treturn 0;\n      cleanup:\n\tgnutls_free(tmp);\n\treturn result;\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void PCM::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tif (m_track->totalfframes != -1 &&\n\t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n\t{\n\t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n\t}\n\tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n\tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n\tCHNK(printf(\"reading %\" AF_FRAMECOUNT_PRINT_FMT \" frames from pcm file \"\n\t\t\"(got %\" AF_FRAMECOUNT_PRINT_FMT \")\\n\",\n\t\tframesToRead, framesRead));\n\tm_track->nextfframe += framesRead;\n\tm_track->fpos_next_frame += (framesRead>0) ? framesRead * m_bytesPerFrame : 0;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\tif (framesRead != framesToRead && m_track->totalfframes != -1)\n\t{\n\t\tif (m_track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, \"\n\t\t\t\t\"should be %d\",\n\t\t\t\tm_track->nextfframe,\n\t\t\t\tm_track->totalfframes);\n\t\t\tm_track->filemodhappy = false;\n\t\t}\n\t}\n\tm_outChunk->frameCount = framesRead;\n}", "target": 0}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\tmm->address = address;\n\tmm->size = size;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\treturn (mm);\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "HMAC_SHA256_Update(struct HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n  scrypt_SHA256_Update(&ctx->ictx, in, len);\n}", "target": 1}
{"code": "static void nf_tables_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(trans->ctx.chain);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(nft_trans_set(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}", "target": 0}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 1}
{"code": "R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (curl_env && *curl_env) {\n\t\tchar *encoded_url = r_str_escape (url);\n\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n\t\tfree (encoded_url);\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = strlen (res);\n\t\t\t}\n\t\t}\n\t\tfree (curl_env);\n\t\treturn res;\n\t}\n\tfree (curl_env);\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 1}
{"code": "http_rxchunk(struct http *hp)\n{\n\tchar *q;\n\tint l, i;\n\tl = hp->prxbuf;\n\tdo\n\t\t(void)http_rxchar(hp, 1, 0);\n\twhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\n\tvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\n\ti = strtoul(hp->rxbuf + l, &q, 16);\n\tbprintf(hp->chunklen, \"%d\", i);\n\tif ((q == hp->rxbuf + l) ||\n\t\t(*q != '\\0' && !vct_islws(*q))) {\n\t\tvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n\t\t    *q, q - (hp->rxbuf + l));\n\t}\n\tassert(q != hp->rxbuf + l);\n\tassert(*q == '\\0' || vct_islws(*q));\n\thp->prxbuf = l;\n\tif (i > 0) {\n\t\t(void)http_rxchar(hp, i, 0);\n\t\tvtc_dump(hp->vl, 4, \"chunk\",\n\t\t    hp->rxbuf + l, i);\n\t}\n\tl = hp->prxbuf;\n\t(void)http_rxchar(hp, 2, 0);\n\tif(!vct_iscrlf(hp->rxbuf[l]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[0] = %02x\",\n\t\t    hp->rxbuf[l] & 0xff);\n\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[1] = %02x\",\n\t\t    hp->rxbuf[l + 1] & 0xff);\n\thp->prxbuf = l;\n\thp->rxbuf[l] = '\\0';\n\treturn (i);\n}", "target": 1}
{"code": "static void DecodeFPDelta(unsigned char *input, unsigned char *output, int cols,\n                          int channels, int bytesPerSample)\n{\n  DecodeDeltaBytes(input, cols * bytesPerSample, channels);\n  int32_t rowIncrement = cols * channels;\n  if (bytesPerSample == 2)\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n#else\n    const unsigned char *input1 = input;\n    const unsigned char *input0 = input + rowIncrement;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output += 2;\n    }\n  }\n  else if (bytesPerSample == 3)\n  {\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output += 3;\n    }\n  }\n  else\n  {\n#if LibRawBigEndian\n    const unsigned char *input0 = input;\n    const unsigned char *input1 = input + rowIncrement;\n    const unsigned char *input2 = input + rowIncrement * 2;\n    const unsigned char *input3 = input + rowIncrement * 3;\n#else\n    const unsigned char *input3 = input;\n    const unsigned char *input2 = input + rowIncrement;\n    const unsigned char *input1 = input + rowIncrement * 2;\n    const unsigned char *input0 = input + rowIncrement * 3;\n#endif\n    for (int col = 0; col < rowIncrement; ++col)\n    {\n      output[0] = input0[col];\n      output[1] = input1[col];\n      output[2] = input2[col];\n      output[3] = input3[col];\n      output += 4;\n    }\n  }\n}", "target": 0}
{"code": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "MotionVector luma_motion_vector_prediction(base_context* ctx,\n                                           const slice_segment_header* shdr,\n                                           de265_image* img,\n                                           const PBMotionCoding& motion,\n                                           int xC,int yC,int nCS,int xP,int yP,\n                                           int nPbW,int nPbH, int l,\n                                           int refIdx, int partIdx)\n{\n  MotionVector mvpList[2];\n  fill_luma_motion_vector_predictors(ctx, shdr, img,\n                                     xC,yC,nCS,xP,yP,\n                                     nPbW, nPbH, l, refIdx, partIdx,\n                                     mvpList);\n  return mvpList[ l ? motion.mvp_l1_flag : motion.mvp_l0_flag ];\n}", "target": 0}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}", "target": 1}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "dirserv_set_router_is_running(routerinfo_t *router, time_t now)\n{\n  int answer;\n  if (router_is_me(router)) {\n    answer = ! we_are_hibernating();\n  } else if (router->is_hibernating &&\n             (router->cache_info.published_on +\n              HIBERNATION_PUBLICATION_SKEW) > router->last_reachable) {\n    answer = 0;\n  } else if (get_options()->AssumeReachable) {\n    answer = 1;\n  } else {\n    answer = (now < router->last_reachable + REACHABLE_TIMEOUT);\n  }\n  if (!answer && running_long_enough_to_decide_unreachable()) {\n    time_t when = now;\n    if (router->last_reachable &&\n        router->last_reachable + REACHABILITY_TEST_CYCLE_PERIOD < now)\n      when = router->last_reachable + REACHABILITY_TEST_CYCLE_PERIOD;\n    rep_hist_note_router_unreachable(router->cache_info.identity_digest, when);\n  }\n  router->is_running = answer;\n}", "target": 0}
{"code": "status _af_set_sample_format (_AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      \n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\treturn AF_SUCCEED;\n}", "target": 0}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}", "target": 1}
{"code": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    const unsigned char *p = buf;\n    unsigned char *der = NULL;\n    X509 *x509 = d2i_X509(NULL, &p, len);\n    if (x509 != NULL) {\n        BIO *bio = BIO_new(BIO_s_null());\n        X509_print(bio, x509);\n        BIO_free(bio);\n        i2d_X509(x509, &der);\n        OPENSSL_free(der);\n        X509_free(x509);\n    }\n    ERR_clear_error();\n    return 0;\n}", "target": 1}
{"code": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n  fs::path path = doc_root_ / request->url().path();\n  try {\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n    auto response = std::make_shared<Response>(Status::kOK);\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n    response->SetBody(body, true);\n    return response;\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}", "target": 1}
{"code": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n    return OK;\n}", "target": 1}
{"code": "static void *intel_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  unsigned long attrs)\n{\n\tstruct page *page = NULL;\n\tint order;\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\tif (!iommu_no_mapping(dev))\n\t\tflags &= ~(GFP_DMA | GFP_DMA32);\n\telse if (dev->coherent_dma_mask < dma_get_required_mask(dev)) {\n\t\tif (dev->coherent_dma_mask < DMA_BIT_MASK(32))\n\t\t\tflags |= GFP_DMA;\n\t\telse\n\t\t\tflags |= GFP_DMA32;\n\t}\n\tif (gfpflags_allow_blocking(flags)) {\n\t\tunsigned int count = size >> PAGE_SHIFT;\n\t\tpage = dma_alloc_from_contiguous(dev, count, order,\n\t\t\t\t\t\t flags & __GFP_NOWARN);\n\t\tif (page && iommu_no_mapping(dev) &&\n\t\t    page_to_phys(page) + size > dev->coherent_dma_mask) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages(flags, order);\n\tif (!page)\n\t\treturn NULL;\n\tmemset(page_address(page), 0, size);\n\t*dma_handle = __intel_map_single(dev, page_to_phys(page), size,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t dev->coherent_dma_mask);\n\tif (*dma_handle)\n\t\treturn page_address(page);\n\tif (!dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT))\n\t\t__free_pages(page, order);\n\treturn NULL;\n}", "target": 0}
{"code": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}", "target": 0}
{"code": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "GF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}", "target": 0}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "AP_DECLARE(int) ap_getline(char *s, int n, request_rec *r, int fold)\n{\n    char *tmp_s = s;\n    apr_status_t rv;\n    apr_size_t len;\n    apr_bucket_brigade *tmp_bb;\n    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    rv = ap_rgetline(&tmp_s, n, &len, r, fold, tmp_bb);\n    apr_brigade_destroy(tmp_bb);\n    if (rv == APR_ENOSPC) {\n        return n;\n    }\n    if (rv != APR_SUCCESS) {\n        return -1;\n    }\n    return (int)len;\n}", "target": 0}
{"code": "check_tty(const char *tty)\n{\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\tif (strlen(tty) == 0) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}", "target": 1}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 1}
{"code": " bool BaseSettingChange::Init(Profile* profile) {\n  DCHECK(profile);\n   profile_ = profile;\n   return true;\n }", "target": 1}
{"code": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\tvalue = 0;\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\treturn value;\n}", "target": 1}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static bool open_match_attributes(connection_struct *conn,\n\t\t\t\t  uint32 old_dos_attr,\n\t\t\t\t  uint32 new_dos_attr,\n\t\t\t\t  mode_t existing_unx_mode,\n\t\t\t\t  mode_t new_unx_mode,\n\t\t\t\t  mode_t *returned_unx_mode)\n{\n\tuint32 noarch_old_dos_attr, noarch_new_dos_attr;\n\tnoarch_old_dos_attr = (old_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tnoarch_new_dos_attr = (new_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tif((noarch_old_dos_attr == 0 && noarch_new_dos_attr != 0) || \n\t   (noarch_old_dos_attr != 0 && ((noarch_old_dos_attr & noarch_new_dos_attr) == noarch_old_dos_attr))) {\n\t\t*returned_unx_mode = new_unx_mode;\n\t} else {\n\t\t*returned_unx_mode = (mode_t)0;\n\t}\n\tDEBUG(10,(\"open_match_attributes: old_dos_attr = 0x%x, \"\n\t\t  \"existing_unx_mode = 0%o, new_dos_attr = 0x%x \"\n\t\t  \"returned_unx_mode = 0%o\\n\",\n\t\t  (unsigned int)old_dos_attr,\n\t\t  (unsigned int)existing_unx_mode,\n\t\t  (unsigned int)new_dos_attr,\n\t\t  (unsigned int)*returned_unx_mode ));\n\tif (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\tif (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\treturn offset + (len + 1) * 2;\n}", "target": 1}
{"code": "static inline MagickBooleanType ValidatePixelCacheMorphology(\n  const Image *magick_restrict image)\n{\n  const CacheInfo\n    *magick_restrict cache_info;\n  const PixelChannelMap\n    *magick_restrict p,\n    *magick_restrict q;\n  cache_info=(CacheInfo *) image->cache;\n  p=image->channel_map;\n  q=cache_info->channel_map;\n  if ((image->storage_class != cache_info->storage_class) ||\n      (image->colorspace != cache_info->colorspace) ||\n      (image->alpha_trait != cache_info->alpha_trait) ||\n      (image->read_mask != cache_info->read_mask) ||\n      (image->write_mask != cache_info->write_mask) ||\n      (image->columns != cache_info->columns) ||\n      (image->rows != cache_info->rows) ||\n      (image->number_channels != cache_info->number_channels) ||\n      (memcmp(p,q,image->number_channels*sizeof(*p)) != 0) ||\n      (image->metacontent_extent != cache_info->metacontent_extent) ||\n      (cache_info->nexus_info == (NexusInfo **) NULL))\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "  tt_size_reset( TT_Size  size,\n                 FT_Bool  only_height )\n  {\n    TT_Face           face;\n     FT_Size_Metrics*  metrics;\n    size->ttmetrics.valid = FALSE;\n     face = (TT_Face)size->root.face;\n     metrics = &size->metrics;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->ascender =\n        FT_PIX_ROUND( FT_MulFix( face->root.ascender, metrics->y_scale ) );\n      metrics->descender =\n        FT_PIX_ROUND( FT_MulFix( face->root.descender, metrics->y_scale ) );\n      metrics->height =\n        FT_PIX_ROUND( FT_MulFix( face->root.height, metrics->y_scale ) );\n    }\n    size->ttmetrics.valid = TRUE;\n    if ( only_height )\n      return FT_Err_Ok;\n    if ( face->header.Flags & 8 )\n    {\n      metrics->x_scale = FT_DivFix( metrics->x_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->y_scale = FT_DivFix( metrics->y_ppem << 6,\n                                    face->root.units_per_EM );\n      metrics->max_advance =\n        FT_PIX_ROUND( FT_MulFix( face->root.max_advance_width,\n                                 metrics->x_scale ) );\n    }\n    if ( metrics->x_ppem >= metrics->y_ppem )\n    {\n      size->ttmetrics.scale   = metrics->x_scale;\n      size->ttmetrics.ppem    = metrics->x_ppem;\n      size->ttmetrics.x_ratio = 0x10000L;\n      size->ttmetrics.y_ratio = FT_DivFix( metrics->y_ppem,\n                                           metrics->x_ppem );\n    }\n    else\n    {\n      size->ttmetrics.scale   = metrics->y_scale;\n      size->ttmetrics.ppem    = metrics->y_ppem;\n      size->ttmetrics.x_ratio = FT_DivFix( metrics->x_ppem,\n                                           metrics->y_ppem );\n      size->ttmetrics.y_ratio = 0x10000L;\n    }\n#ifdef TT_USE_BYTECODE_INTERPRETER\n    size->cvt_ready = -1;\n#endif \n    return FT_Err_Ok;\n  }", "target": 1}
{"code": "PHP_PGSQL_API int php_pgsql_delete(PGconn *pg_link, const char *table, zval *ids_array, zend_ulong opt, zend_string **sql) \n{\n\tzval ids_converted;\n\tsmart_str querystr = {0};\n\tint ret = FAILURE;\n\tassert(pg_link != NULL);\n\tassert(table != NULL);\n\tassert(Z_TYPE_P(ids_array) == IS_ARRAY);\n\tassert(!(opt & ~(PGSQL_CONV_FORCE_NULL|PGSQL_DML_EXEC|PGSQL_DML_STRING|PGSQL_DML_ESCAPE)));\n\tif (zend_hash_num_elements(Z_ARRVAL_P(ids_array)) == 0) {\n\t\treturn FAILURE;\n\t}\n\tZVAL_UNDEF(&ids_converted);\n\tif (!(opt & (PGSQL_DML_NO_CONV|PGSQL_DML_ESCAPE))) {\n\t\tarray_init(&ids_converted);\n\t\tif (php_pgsql_convert(pg_link, table, ids_array, &ids_converted, (opt & PGSQL_CONV_OPTS)) == FAILURE) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tids_array = &ids_converted;\n\t}\n\tsmart_str_appends(&querystr, \"DELETE FROM \");\n\tbuild_tablename(&querystr, pg_link, table);\n\tsmart_str_appends(&querystr, \" WHERE \");\n\tif (build_assignment_string(pg_link, &querystr, Z_ARRVAL_P(ids_array), 1, \" AND \", sizeof(\" AND \")-1, opt))\n\t\tgoto cleanup;\n\tsmart_str_appendc(&querystr, ';');\n\tsmart_str_0(&querystr);\n\tif ((opt & PGSQL_DML_EXEC) && do_exec(&querystr, PGRES_COMMAND_OK, pg_link, opt) == 0) {\n\t\tret = SUCCESS;\n\t} else if (opt & PGSQL_DML_STRING) {\n\t\tret = SUCCESS;\n\t}\ncleanup:\n\tzval_ptr_dtor(&ids_converted);\n\tif (ret == SUCCESS && (opt & PGSQL_DML_STRING)) {\n\t\t*sql = querystr.s;\n\t}\n\telse {\n\t\tsmart_str_free(&querystr);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_device_gray(ctx);\n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t}\n\tfz_end_mask(ctx, pr->dev);\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\treturn gstate;\n}", "target": 1}
{"code": "GF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;", "target": 0}
{"code": "ref_param_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                           gs_param_float_array * pvalue)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n    ref aref, elt;\n    int code = ref_param_read_array(iplist, pkey, &loc);\n    float *pfv;\n    uint size;\n    long i;\n    if (code != 0)\n        return code;\n    size = r_size(loc.pvalue);\n    pfv = (float *)gs_alloc_byte_array(plist->memory, size, sizeof(float),\n                                       \"ref_param_read_float_array\");\n    if (pfv == 0)\n        return_error(gs_error_VMerror);\n    aref = *loc.pvalue;\n    loc.pvalue = &elt;\n    for (i = 0; code >= 0 && i < size; i++) {\n        array_get(plist->memory, &aref, i, &elt);\n        code = float_param(&elt, pfv + i);\n    }\n    if (code < 0) {\n        gs_free_object(plist->memory, pfv, \"ref_read_float_array_param\");\n        return (*loc.presult = code);\n    }\n    pvalue->data = pfv;\n    pvalue->size = size;\n    pvalue->persistent = true;\n    return 0;\n}", "target": 0}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Char *str; \n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  XML_Content *dest = ret; \n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; \n  str = (XML_Char *)&ret[dtd->scaffCount];\n  (--stackTop)->numchildren = 0;\n  for (; dest < destLimit; dest++) {\n    const int src_node = (int)(stackTop++)->numchildren;\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}", "target": 1}
{"code": "static MYSQL *db_connect(char *host, char *database,\n                         char *user, char *passwd)\n{\n  MYSQL *mysql;\n  if (verbose)\n    fprintf(stdout, \"Connecting to %s\\n\", host ? host : \"localhost\");\n  if (!(mysql= mysql_init(NULL)))\n    return 0;\n  if (opt_compress)\n    mysql_options(mysql,MYSQL_OPT_COMPRESS,NullS);\n  if (opt_local_file)\n    mysql_options(mysql,MYSQL_OPT_LOCAL_INFILE,\n\t\t  (char*) &opt_local_file);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(mysql, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlimport\");\n  if (!(mysql_real_connect(mysql,host,user,passwd,\n                           database,opt_mysql_port,opt_mysql_unix_port,\n                           0)))\n  {\n    ignore_errors=0;\t  \n    db_error(mysql);\n  }\n  mysql->reconnect= 0;\n  if (verbose)\n    fprintf(stdout, \"Selecting database %s\\n\", database);\n  if (mysql_select_db(mysql, database))\n  {\n    ignore_errors=0;\n    db_error(mysql);\n  }\n  return mysql;\n}", "target": 1}
{"code": "static int is_ncq(uint8_t ata_cmd)\n{\n    switch (ata_cmd) {\n    case READ_FPDMA_QUEUED:\n    case WRITE_FPDMA_QUEUED:\n    case NCQ_NON_DATA:\n    case RECEIVE_FPDMA_QUEUED:\n    case SEND_FPDMA_QUEUED:\n        return 1;\n    default:\n        return 0;\n    }\n}", "target": 0}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "std::map<string, AttrValue> GetSetAttrs(const FunctionDef& fdef) {\n  std::map<string, AttrValue> set_attrs;\n  for (const auto& pair : fdef.attr()) {\n    if (pair.second.value_case() != AttrValue::VALUE_NOT_SET) {\n      set_attrs[pair.first] = pair.second;\n    }\n  }\n  return set_attrs;\n}", "target": 0}
{"code": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) \n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n{\n    uint count = min(max_data,\n                     pcs->status.write_pos - pcs->status.read_pos);\n    if (count)\n        memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n    pcs->status.read_pos += count;\n    if (pcs->status.read_pos == pcs->status.write_pos) {\n        gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n        pcs->status.write_pos = pcs->status.read_pos = 0;\n    }\n    return count;\n}", "target": 1}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "static ssize_t carrier_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\treturn netdev_store(dev, attr, buf, len, change_carrier);", "target": 0}
{"code": "void ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\tqsDNSActive.remove(unresolved);\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}", "target": 0}
{"code": "void dtls1_reset_seq_numbers(SSL *s, int rw)\n{\n    unsigned char *seq;\n    unsigned int seq_bytes = sizeof(s->s3->read_sequence);\n    if (rw & SSL3_CC_READ) {\n        seq = s->s3->read_sequence;\n        s->d1->r_epoch++;\n        memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));\n        memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\n    } else {\n        seq = s->s3->write_sequence;\n        memcpy(s->d1->last_write_sequence, seq,\n               sizeof(s->s3->write_sequence));\n        s->d1->w_epoch++;\n    }\n    memset(seq, 0x00, seq_bytes);\n}", "target": 1}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "      CImg<boolT> is_inside_string(CImg<charT>& expr) const {\n        bool is_escaped = false, next_is_escaped = false;\n        unsigned int mode = 0, next_mode = 0; \n        CImg<boolT> res = CImg<charT>::string(expr);\n        bool *pd = res._data;\n        for (const char *ps = expr._data; *ps; ++ps) {\n          if (!next_is_escaped && *ps=='\\\\') next_is_escaped = true;\n          if (!is_escaped && *ps=='\\'') { \n            if (!mode && ps>expr._data && *(ps - 1)=='[') next_mode = mode = 2; \n            else if (mode==2 && *(ps + 1)==']') next_mode = !mode; \n            else if (mode<2) next_mode = mode?(mode = 0):1; \n          }\n          *(pd++) = mode>=1 || is_escaped;\n          mode = next_mode;\n          is_escaped = next_is_escaped;\n          next_is_escaped = false;\n        }\n        return res;", "target": 0}
{"code": "  int DoWrite(WriteWrap* w,\n              uv_buf_t* bufs,\n              size_t count,\n              uv_stream_t* send_handle) override {\n    return UV_ENOSYS;  \n  }", "target": 1}
{"code": "SWFShape_setLineStyle_internal(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tint line;\n\tif ( shape->isEnded )\n\t\treturn;\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, 0) )\n\t\t\tbreak;\n\t}\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle(shape, width, r, g, b, a);\n\telse\n\t\t++line;\n\tfinishSetLine(shape, line, width);\n}", "target": 0}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    WebKitWebFrame *frame;\n    JSGlobalContextRef context;\n    JSObjectRef globalobject;\n    JSStringRef var_name;\n    JSStringRef js_script;\n    JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n    context = webkit_web_frame_get_global_context(frame);\n    globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n    }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n    JSStringRelease(js_script);\n}", "target": 1}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_displayable_charset(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tif (len < 3) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tpdu->params_len = 0;\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "static void sta_ps_end(struct sta_info *sta)\n{\n\tps_dbg(sta->sdata, \"STA %pM aid %d exits power save mode\\n\",\n\t       sta->sta.addr, sta->sta.aid);\n\tif (test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d driver-ps-blocked\\n\",\n\t\t       sta->sta.addr, sta->sta.aid);\n\t\treturn;\n\t}\n\tset_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\tieee80211_sta_ps_deliver_wakeup(sta);\n}", "target": 0}
{"code": "static int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us)\n{\n\tu64 rt_runtime, rt_period;\n\trt_period = ktime_to_ns(tg->rt_bandwidth.rt_period);\n\trt_runtime = (u64)rt_runtime_us * NSEC_PER_USEC;\n\tif (rt_runtime_us < 0)\n\t\trt_runtime = RUNTIME_INF;\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}", "target": 0}
{"code": "static const char *set_signature_flag(cmd_parms *cmd, void *d_,\n                                      const char *arg)\n{\n    core_dir_config *d = d_;\n    if (ap_cstr_casecmp(arg, \"On\") == 0) {\n        d->server_signature = srv_sig_on;\n    }\n    else if (ap_cstr_casecmp(arg, \"Off\") == 0) {\n        d->server_signature = srv_sig_off;\n    }\n    else if (ap_cstr_casecmp(arg, \"EMail\") == 0) {\n        d->server_signature = srv_sig_withmail;\n    }\n    else {\n        return \"ServerSignature: use one of: off | on | email\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "static bool intel_iommu_capable(enum iommu_cap cap)\n{\n\tif (cap == IOMMU_CAP_CACHE_COHERENCY)\n\t\treturn domain_update_iommu_snooping(NULL) == 1;\n\tif (cap == IOMMU_CAP_INTR_REMAP)\n\t\treturn irq_remapping_enabled == 1;\n\treturn false;\n}", "target": 0}
{"code": "GF_Err fiin_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_PAEN:\n\t\tBOX_FIELD_LIST_ASSIGN(partition_entries)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SEGR:\n\t\tBOX_FIELD_ASSIGN(session_info, FDSessionGroupBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_GITN:\n\t\tBOX_FIELD_ASSIGN(group_id_to_name, GroupIdToNameBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "_asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n\t\t\t int der_len, unsigned flags)\n{\n  int len2, len3;\n  int counter, counter_end;\n  int result;\n  len2 = asn1_get_length_der (der, der_len, &len3);\n  if (len2 < -1)\n    return ASN1_DER_ERROR;\n  counter = len3 + 1;\n  if (len2 == -1)\n    counter_end = der_len - 2;\n  else\n    counter_end = der_len;\n  while (counter < counter_end)\n    {\n      len2 = asn1_get_length_der (der + counter, der_len, &len3);\n      if (IS_ERR(len2, flags))\n\t{\n\t  warn();\n\t  return ASN1_DER_ERROR;\n\t}\n      if (len2 >= 0)\n\t{\n\t  DECR_LEN(der_len, len2+len3);\n\t  _asn1_append_value (node, der + counter + len3, len2);\n\t}\n      else\n\t{\t\t\t\n\t  DECR_LEN(der_len, len3);\n\t  result =\n\t    _asn1_extract_der_octet (node, der + counter + len3,\n\t\t\t\t     der_len, flags);\n\t  if (result != ASN1_SUCCESS)\n\t    return result;\n\t  len2 = 0;\n\t}\n      DECR_LEN(der_len, 1);\n      counter += len2 + len3 + 1;\n    }\n  return ASN1_SUCCESS;\ncleanup:\n  return result;\n}", "target": 1}
{"code": "_asn1_ltostr (long v, char *str)\n {\n   long d, r;\n   char temp[LTOSTR_MAX_SIZE];\n  int count, k, start;\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      v = -v;\n    }\n  else\n    start = 0;\n  count = 0;\n  do\n    {\n      d = v / 10;\n      r = v - d * 10;\n      temp[start + count] = '0' + (char) r;\n       count++;\n       v = d;\n     }\n  while (v);\n   for (k = 0; k < count; k++)\n     str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}", "target": 1}
{"code": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 1}
{"code": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n    if (!callsite)\n        return;\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n    asm volatile(\"pushq %[rflags] \\n\\t\" \n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     \n                 \"ldmxcsr %[mxcsr] \\n\\t\" \n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n    oe_longjmp(&callsite->jmpbuf, 1);\n}", "target": 1}
{"code": "struct gendisk *alloc_disk(int minors)\n{\n\treturn alloc_disk_node(minors, NUMA_NO_NODE);\n}", "target": 0}
{"code": "static void __init acpi_request_region (struct acpi_generic_address *gas,\n\tunsigned int length, char *desc)\n{\n\tu64 addr;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !length)\n\t\treturn;\n\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\n\t\trequest_region(addr, length, desc);\n\telse if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\trequest_mem_region(addr, length, desc);\n}", "target": 0}
{"code": "static int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\tptrace_signal_deliver(regs, cookie);\n\tptrace_stop(signr, 0, info);\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\tcurrent->exit_code = 0;\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\treturn signr;\n}", "target": 0}
{"code": "static int cac_is_cert(cac_private_data_t * priv, const sc_path_t *in_path)\n{\n\tcac_object_t test_obj;\n\ttest_obj.path = *in_path;\n\ttest_obj.path.index = 0;\n\ttest_obj.path.count = 0;\n\treturn (list_contains(&priv->pki_list, &test_obj) != 0);\n}", "target": 0}
{"code": "void HTMLInputElement::defaultEventHandler(Event* evt)\n{\n    if (evt->isMouseEvent() && evt->type() == EventTypeNames::click && toMouseEvent(evt)->button() == LeftButton) {\n        m_inputTypeView->handleClickEvent(toMouseEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isTouchEvent()) {\n        m_inputTypeView->handleTouchEvent(toTouchEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keydown) {\n        m_inputTypeView->handleKeydownEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    bool callBaseClassEarly = isTextField() && (evt->type() == EventTypeNames::keydown || evt->type() == EventTypeNames::keypress);\n    if (callBaseClassEarly) {\n        HTMLTextFormControlElement::defaultEventHandler(evt);\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->type() == EventTypeNames::DOMActivate) {\n        m_inputType->handleDOMActivateEvent(evt);\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keypress) {\n        m_inputTypeView->handleKeypressEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (evt->isKeyboardEvent() && evt->type() == EventTypeNames::keyup) {\n        m_inputTypeView->handleKeyupEvent(toKeyboardEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    if (m_inputTypeView->shouldSubmitImplicitly(evt)) {\n        if (isSearchField())\n            onSearch();\n        if (wasChangedSinceLastFormControlChangeEvent())\n            dispatchFormControlChangeEvent();\n        RefPtr<HTMLFormElement> formForSubmission = m_inputTypeView->formForSubmission();\n        if (formForSubmission)\n            formForSubmission->submitImplicitly(evt, canTriggerImplicitSubmission());\n        evt->setDefaultHandled();\n        return;\n    }\n    if (evt->isBeforeTextInsertedEvent())\n        m_inputTypeView->handleBeforeTextInsertedEvent(static_cast<BeforeTextInsertedEvent*>(evt));\n    if (evt->isMouseEvent() && evt->type() == EventTypeNames::mousedown) {\n        m_inputTypeView->handleMouseDownEvent(toMouseEvent(evt));\n        if (evt->defaultHandled())\n            return;\n    }\n    m_inputTypeView->forwardEvent(evt);\n    if (!callBaseClassEarly && !evt->defaultHandled())\n        HTMLTextFormControlElement::defaultEventHandler(evt);\n}", "target": 0}
{"code": "get_text_gray_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                         ptr[aindex] = 0xFF;)\n    else\n      GRAY_RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}", "target": 0}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}", "target": 0}
{"code": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\t*converted = sli;\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n \tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 1}
{"code": "cache_user_id (KBNODE keyblock)\n{\n  user_id_db_t r;\n  const char *uid;\n  size_t uidlen;\n  keyid_list_t keyids = NULL;\n  KBNODE k;\n  for (k = keyblock; k; k = k->next)\n    {\n      if (k->pkt->pkttype == PKT_PUBLIC_KEY\n\t  || k->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  keyid_list_t a = xmalloc_clear (sizeof *a);\n\t  keyid_from_pk (k->pkt->pkt.public_key, a->keyid);\n\t  for (r = user_id_db; r; r = r->next)\n\t    {\n\t      keyid_list_t b = r->keyids;\n\t      for (b = r->keyids; b; b = b->next)\n\t\t{\n\t\t  if (b->keyid[0] == a->keyid[0]\n\t\t      && b->keyid[1] == a->keyid[1])\n\t\t    {\n\t\t      if (DBG_CACHE)\n\t\t\tlog_debug (\"cache_user_id: already in cache\\n\");\n\t\t      release_keyid_list (keyids);\n\t\t      xfree (a);\n\t\t      return;\n\t\t    }\n\t\t}\n\t    }\n\t  a->next = keyids;\n\t  keyids = a;\n\t}\n    }\n  if (!keyids)\n    BUG (); \n  uid = get_primary_uid (keyblock, &uidlen);\n  if (uid_cache_entries >= MAX_UID_CACHE_ENTRIES)\n    {\n      r = user_id_db;\n      user_id_db = r->next;\n      release_keyid_list (r->keyids);\n      xfree (r);\n      uid_cache_entries--;\n    }\n  r = xmalloc (sizeof *r + uidlen - 1);\n  r->keyids = keyids;\n  r->len = uidlen;\n  memcpy (r->name, uid, r->len);\n  r->next = user_id_db;\n  user_id_db = r;\n  uid_cache_entries++;\n}", "target": 0}
{"code": "static lu_mem markbeingfnz (global_State *g) {\n  GCObject *o;\n  lu_mem count = 0;\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    count++;\n    markobject(g, o);\n  }\n  return count;\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "onigenc_property_list_add_property(UChar* name, const OnigCodePoint* prop,\n     hash_table_type **table, const OnigCodePoint*** plist, int *pnum,\n     int *psize)\n{\n#define PROP_INIT_SIZE     16\n  int r;\n  if (*psize <= *pnum) {\n    int new_size = (*psize == 0 ? PROP_INIT_SIZE : *psize * 2);\n    r = resize_property_list(new_size, plist, psize);\n    if (r != 0) return r;\n  }\n  (*plist)[*pnum] = prop;\n  if (ONIG_IS_NULL(*table)) {\n    *table = onig_st_init_strend_table_with_size(PROP_INIT_SIZE);\n    if (ONIG_IS_NULL(*table)) return ONIGERR_MEMORY;\n  }\n  *pnum = *pnum + 1;\n  onig_st_insert_strend(*table, name, name + strlen((char* )name),\n\t\t\t(hash_data_type )(*pnum + ONIGENC_MAX_STD_CTYPE));\n  return 0;\n}", "target": 0}
{"code": "static void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_MOV_DR_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}", "target": 0}
{"code": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }", "target": 1}
{"code": "static ssize_t stream_writev_cb(RedStream *s, const struct iovec *iov, int iovcnt)\n{\n    ssize_t ret = 0;\n    do {\n        int tosend;\n        ssize_t n, expected = 0;\n        int i;\n#ifdef IOV_MAX\n        tosend = MIN(iovcnt, IOV_MAX);\n#else\n        tosend = iovcnt;\n#endif\n        for (i = 0; i < tosend; i++) {\n            expected += iov[i].iov_len;\n        }\n        n = socket_writev(s->socket, iov, tosend);\n        if (n <= expected) {\n            if (n > 0)\n                ret += n;\n            return ret == 0 ? n : ret;\n        }\n        ret += n;\n        iov += tosend;\n        iovcnt -= tosend;\n    } while(iovcnt > 0);\n    return ret;\n}", "target": 0}
{"code": "void ok_inflater_free(ok_inflater *inflater) {\n    if (inflater) {\n        ok_png_allocator allocator = inflater->allocator;\n        void *allocator_user_data = inflater->allocator_user_data;\n        allocator.free(allocator_user_data, inflater->buffer);\n        allocator.free(allocator_user_data, inflater->code_length_huffman);\n        allocator.free(allocator_user_data, inflater->literal_huffman);\n        allocator.free(allocator_user_data, inflater->distance_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_literal_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_distance_huffman);\n        allocator.free(allocator_user_data, inflater);\n    }\n}", "target": 0}
{"code": "struct torture_suite *torture_smb2_notify_inotify_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"notify-inotify\");\n\tsuite->description = talloc_strdup(suite, \"SMB2-NOTIFY tests that use inotify\");\n\ttorture_suite_add_2smb2_test(suite, \"inotify-rename\", torture_smb2_inotify_rename);\n\treturn suite;\n}", "target": 0}
{"code": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}", "target": 1}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "void connection_graceful_shutdown_maint (server *srv) {\n    connections * const conns = &srv->conns;\n    const int graceful_expire =\n      (srv->graceful_expire_ts && srv->graceful_expire_ts < log_epoch_secs);\n    for (uint32_t ndx = 0; ndx < conns->used; ++ndx) {\n        connection * const con = conns->ptr[ndx];\n        int changed = 0;\n        request_st * const r = &con->request;\n        if (r->state == CON_STATE_CLOSE) {\n            if (HTTP_LINGER_TIMEOUT > 1)\n                con->close_timeout_ts -= (HTTP_LINGER_TIMEOUT - 1);\n            if (log_epoch_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)\n                changed = 1;\n        }\n        else if (con->h2 && r->state == CON_STATE_WRITE) {\n            h2_send_goaway(con, H2_E_NO_ERROR);\n            if (0 == con->h2->rused && chunkqueue_is_empty(con->write_queue)) {\n                connection_set_state(r, CON_STATE_RESPONSE_END);\n                changed = 1;\n            }\n        }\n        else if (r->state == CON_STATE_READ && con->request_count > 1\n                 && chunkqueue_is_empty(con->read_queue)) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        if (graceful_expire) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        r->keep_alive = 0;            \n        r->conf.bytes_per_second = 0;         \n        r->conf.global_bytes_per_second = 0;  \n        if (con->traffic_limit_reached) {\n            con->traffic_limit_reached = 0;\n            changed = 1;\n        }\n        if (changed) {\n            connection_state_machine(con);\n        }\n    }\n}", "target": 0}
{"code": "fbStore_a1r1g1b1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  pixel;\n        Splita(READ(values + i));\n        pixel = (((a >> 4) & 0x8) |\n                 ((r >> 5) & 0x4) |\n                 ((g >> 6) & 0x2) |\n                 ((b >> 7)      ));\n        Store4(bits, i + x, pixel);\n    }\n}", "target": 0}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static inline int is_zero_pfn(unsigned long pfn)\n{\n\textern unsigned long zero_pfn;\n\treturn pfn == zero_pfn;\n}", "target": 0}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "check_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL convert_to_double(zval *op) \n{\n\tdouble tmp;\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\tZVAL_DOUBLE(op, 0.0);\n\t\t\tbreak;\n\t\tcase IS_TRUE:\n\t\t\tZVAL_DOUBLE(op, 1.0);\n\t\t\tbreak;\n\t\tcase IS_RESOURCE: {\n\t\t\t\tdouble d = (double) Z_RES_HANDLE_P(op);\n\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\tZVAL_DOUBLE(op, d);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_LONG:\n\t\t\tZVAL_DOUBLE(op, (double) Z_LVAL_P(op));\n\t\t\tbreak;\n\t\tcase IS_DOUBLE:\n\t\t\tbreak;\n\t\tcase IS_STRING:\n\t\t\t{\n\t\t\t\tzend_string *str = Z_STR_P(op);\n\t\t\t\tZVAL_DOUBLE(op, zend_strtod(ZSTR_VAL(str), NULL));\n\t\t\t\tzend_string_release_ex(str, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IS_ARRAY:\n\t\t\ttmp = (zend_hash_num_elements(Z_ARRVAL_P(op))?1:0);\n\t\t\tzval_ptr_dtor(op);\n\t\t\tZVAL_DOUBLE(op, tmp);\n\t\t\tbreak;\n\t\tcase IS_OBJECT:\n\t\t\t{\n\t\t\t\tzval dst;\n\t\t\t\tconvert_object_to_type(op, &dst, IS_DOUBLE, convert_to_double);\n\t\t\t\tzval_ptr_dtor(op);\n\t\t\t\tif (Z_TYPE(dst) == IS_DOUBLE) {\n\t\t\t\t\tZVAL_DOUBLE(op, Z_DVAL(dst));\n\t\t\t\t} else {\n\t\t\t\t\tZVAL_DOUBLE(op, 1.0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\tzend_unwrap_reference(op);\n\t\t\tgoto try_again;\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n}", "target": 0}
{"code": "POSITION::POSITION()\n{\n  table= 0;\n  records_read= cond_selectivity= read_time= 0.0;\n  prefix_record_count= 0.0;\n  key= 0;\n  use_join_buffer= 0;\n  sj_strategy= SJ_OPT_NONE;\n  n_sj_tables= 0;\n  spl_plan= 0;\n  range_rowid_filter_info= 0;\n  ref_depend_map= dups_producing_tables= 0;\n  inner_tables_handled_with_other_sjs= 0;\n  dups_weedout_picker.set_empty();\n  firstmatch_picker.set_empty();\n  loosescan_picker.set_empty();\n  sjmat_picker.set_empty();\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tmake_pages_present(addr, prev->vm_end);\n\treturn prev;\n}", "target": 0}
{"code": "update_total_bandwidth_weights(const routerstatus_t *rs,\n                               int is_exit, int is_guard,\n                               int64_t *G, int64_t *M, int64_t *E, int64_t *D,\n                               int64_t *T)\n{\n  int default_bandwidth = rs->bandwidth_kb;\n  int guardfraction_bandwidth = 0;\n  if (!rs->has_bandwidth) {\n    log_info(LD_BUG, \"Missing consensus bandwidth for router %s\",\n             rs->nickname);\n    return;\n  }\n  if (rs->has_guardfraction) {\n    guardfraction_bandwidth_t guardfraction_bw;\n    tor_assert(is_guard);\n    guard_get_guardfraction_bandwidth(&guardfraction_bw,\n                                      rs->bandwidth_kb,\n                                      rs->guardfraction_percentage);\n    default_bandwidth = guardfraction_bw.guard_bw;\n    guardfraction_bandwidth = guardfraction_bw.non_guard_bw;\n  }\n  *T += default_bandwidth;\n  if (is_exit && is_guard) {\n    *D += default_bandwidth;\n    if (rs->has_guardfraction) {\n      *E += guardfraction_bandwidth;\n    }\n  } else if (is_exit) {\n    *E += default_bandwidth;\n  } else if (is_guard) {\n    *G += default_bandwidth;\n    if (rs->has_guardfraction) {\n      *M += guardfraction_bandwidth;\n    }\n  } else {\n    *M += default_bandwidth;\n  }\n}", "target": 0}
{"code": "int lowmem_reserve_ratio_sysctl_handler(struct ctl_table *table, int write,\n\tvoid __user *buffer, size_t *length, loff_t *ppos)\n{\n\tproc_dointvec_minmax(table, write, buffer, length, ppos);\n\tsetup_per_zone_lowmem_reserve();\n\treturn 0;\n}", "target": 0}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n  return out;\n}", "target": 1}
{"code": "  virtual std::string GetHtmlInfo(int refresh) {\n    std::string output;\n    output.append(\"<html><head><title>About Network</title>\");\n    if (refresh > 0)\n      output.append(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" +\n          base::IntToString(refresh) + \"\\\"/>\");\n    output.append(\"</head><body>\");\n    if (refresh > 0) {\n      output.append(\"(Auto-refreshing page every \" +\n                    base::IntToString(refresh) + \"s)\");\n    } else {\n      output.append(\"(To auto-refresh this page: about:network/&lt;secs&gt;)\");\n    }\n    output.append(\"<h3>Ethernet:</h3><table border=1>\");\n    if (ethernet_ && ethernet_enabled()) {\n      output.append(\"<tr>\" + ToHtmlTableHeader(ethernet_) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(ethernet_) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(wifi_networks_[i]) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(wifi_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Cellular:</h3><table border=1>\");\n    for (size_t i = 0; i < cellular_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(cellular_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(cellular_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Remembered Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < remembered_wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\n            \"<tr>\" + ToHtmlTableHeader(remembered_wifi_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(remembered_wifi_networks_[i]) +\n          \"</tr>\");\n    }\n    output.append(\"</table></body></html>\");\n    return output;\n  }", "target": 0}
{"code": "iasecc_init_amos_or_sagem(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\tcard->caps = IASECC_CARD_DEFAULT_CAPS;\n\tif (card->type == SC_CARD_TYPE_IASECC_MI)   {\n\t\trv = iasecc_mi_match(card);\n\t\tif (rv)\n\t\t\tcard->type = SC_CARD_TYPE_IASECC_MI2;\n\t\telse\n\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t}\n\trv = iasecc_parse_ef_atr(card);\n\tif (rv == SC_ERROR_FILE_NOT_FOUND)   {\n\t\trv = iasecc_select_mf(card, NULL);\n\t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\t\trv = iasecc_parse_ef_atr(card);\n\t}\n\tLOG_TEST_RET(ctx, rv, \"IASECC: ATR parse failed\");\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n    type = crm_element_value(update_msg, F_SUBTYPE);\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1}
{"code": "static void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tspin_lock(&n->list_lock);\n\tn->nr_partial++;\n\tif (tail)\n\t\tlist_add_tail(&page->lru, &n->partial);\n\telse\n\t\tlist_add(&page->lru, &n->partial);\n\tspin_unlock(&n->list_lock);\n}", "target": 0}
{"code": "static GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int partition_get_logical_type(blkid_partition par)\n{\n\tblkid_parttable tab;\n\tif (!par)\n\t\treturn -1;\n\ttab = blkid_partition_get_table(par);\n\tif (!tab || !tab->type)\n\t\treturn -1;\n\tif (tab->parent)\n\t\treturn 'L';  \n\tif (!strcmp(tab->type, \"dos\")) {\n\t\tif (par->partno > 4)\n\t\t\treturn 'L';\t\n\t        if(par->type == MBR_DOS_EXTENDED_PARTITION ||\n                   par->type == MBR_W95_EXTENDED_PARTITION ||\n\t\t   par->type == MBR_LINUX_EXTENDED_PARTITION)\n\t\t\treturn 'E';\n\t}\n\treturn 'P';\n}", "target": 0}
{"code": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_call_handlers(ndp, msg);;\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}", "target": 1}
{"code": "renumber_by_map(Node* node, GroupNumRemap* map)\n{\n  int r = 0;\n  switch (NTYPE(node)) {\n  case NT_LIST:\n  case NT_ALT:\n    do {\n      r = renumber_by_map(NCAR(node), map);\n    } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    break;\n  case NT_QTFR:\n    r = renumber_by_map(NQTFR(node)->target, map);\n    break;\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n      if (en->type == ENCLOSE_CONDITION)\n\ten->regnum = map[en->regnum].new_val;\n      r = renumber_by_map(en->target, map);\n    }\n    break;\n  case NT_BREF:\n    r = renumber_node_backref(node, map);\n    break;\n  case NT_ANCHOR:\n    if (NANCHOR(node)->target)\n      r = renumber_by_map(NANCHOR(node)->target, map);\n    break;\n  default:\n    break;\n  }\n  return r;\n}", "target": 0}
{"code": "static void bnx2x_free_mcast_macs_list(struct list_head *mcast_group_list)\n{\n\tstruct bnx2x_mcast_list_elem_group *current_mcast_group;\n\twhile (!list_empty(mcast_group_list)) {\n\t\tcurrent_mcast_group = list_first_entry(mcast_group_list,\n\t\t\t\t      struct bnx2x_mcast_list_elem_group,\n\t\t\t\t      mcast_group_link);\n\t\tlist_del(&current_mcast_group->mcast_group_link);\n\t\tfree_page((unsigned long)current_mcast_group);\n\t}\n}", "target": 0}
{"code": "void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = \"generic DVB-USB module\";\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tname = d->desc->name;\n\t\tdvb_usb_exit(d);\n\t}\n\tinfo(\"%s successfully deinitialized and disconnected.\", name);\n}", "target": 1}
{"code": "cdf_getmonth(int year, int days)\n{\n\tsize_t m;\n\tfor (m = 0; m < sizeof(mdays) / sizeof(mdays[0]); m++) {\n\t\tdays -= mdays[m];\n\t\tif (m == 1 && isleap(year))\n\t\t\tdays--;\n\t\tif (days <= 0)\n\t\t\treturn (int)m;\n\t}\n\treturn (int)m;\n}", "target": 0}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\t\treturn 0;\n\t}\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tdown_read(&current->mm->mmap_sem);\n\tnpages = get_user_pages(current, current->mm, user_addr, npages, !write,\n\t\t\t\t0, req->pages, NULL);\n\tup_read(&current->mm->mmap_sem);\n\tif (npages < 0)\n\t\treturn npages;\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\treturn 0;\n}", "target": 0}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "static bool get_sequence_numbers(struct torture_context *torture,\n\t\t\t\t struct torture_domain_sequence **seqs)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tconst char *extra_data;\n\tchar line[256];\n\tuint32_t count = 0;\n\tstruct torture_domain_sequence *s = NULL;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SHOW_SEQUENCE, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL sequence list\");\n\twhile (next_token(&extra_data, line, \"\\n\", sizeof(line))) {\n\t\tchar *p, *lp;\n\t\tuint32_t seq;\n\t\ts = talloc_realloc(torture, s, struct torture_domain_sequence,\n\t\t\t\t   count + 2);\n\t\tZERO_STRUCT(s[count+1]);\n\t\tlp = line;\n\t\tp = strchr(lp, ' ');\n\t\ttorture_assert(torture, p, \"invalid line format\");\n\t\t*p = 0;\n\t\ts[count].netbios_name = talloc_strdup(s, lp);\n\t\tlp = p+1;\n\t\ttorture_assert(torture, strncmp(lp, \": \", 2) == 0,\n\t\t\t       \"invalid line format\");\n\t\tlp += 2;\n\t\tif (strcmp(lp, \"DISCONNECTED\") == 0) {\n\t\t\tseq = (uint32_t)-1;\n\t\t} else {\n\t\t\tseq = (uint32_t)strtol(lp, &p, 10);\n\t\t\ttorture_assert(torture, (*p == '\\0'),\n\t\t\t\t       \"invalid line format\");\n\t\t\ttorture_assert(torture, (seq != (uint32_t)-1),\n\t\t\t\t       \"sequence number -1 encountered\");\n\t\t}\n\t\ts[count].seq = seq;\n\t\tcount++;\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\ttorture_assert(torture, count >= 2, \"The list of domain sequence \"\n\t\t       \"numbers should contain 2 entries\");\n\t*seqs = s;\n\treturn true;\n}", "target": 0}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,\n                                      const FilePath& text) {\n  FilePath old_cur_directory;\n  if (!base_dir.empty()) {\n    file_util::GetCurrentDirectory(&old_cur_directory);\n    file_util::SetCurrentDirectory(base_dir);\n  }\n  FilePath::StringType trimmed;\n   PrepareStringForFileOps(text, &trimmed);\n   bool is_file = true;\n   FilePath full_path;\n  if (!ValidPathForFile(trimmed, &full_path)) {\n#if defined(OS_WIN)\n    std::wstring unescaped = UTF8ToWide(UnescapeURLComponent(\n        WideToUTF8(trimmed),\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS));\n#elif defined(OS_POSIX)\n    std::string unescaped = UnescapeURLComponent(\n        trimmed,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n#endif\n    if (!ValidPathForFile(unescaped, &full_path))\n      is_file = false;\n  }\n  if (!base_dir.empty())\n    file_util::SetCurrentDirectory(old_cur_directory);\n  if (is_file) {\n    GURL file_url = net::FilePathToFileURL(full_path);\n    if (file_url.is_valid())\n      return GURL(UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n          net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n          NULL, NULL)));\n  }\n#if defined(OS_WIN)\n  std::string text_utf8 = WideToUTF8(text.value());\n#elif defined(OS_POSIX)\n  std::string text_utf8 = text.value();\n#endif\n  return FixupURL(text_utf8, std::string());\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tsize_t oldoff = buf->off;\n\tif (buf->totallen < need) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\treturn (0);\n}", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)\n{\n  unsigned error = 0;\n  char *key = 0, *str = 0;\n  unsigned i;\n  while(!error) \n  {\n    unsigned length, string2_begin;\n    length = 0;\n    while(length < chunkLength && data[length] != 0) length++;\n    if(length < 1 || length > 79) CERROR_BREAK(error, 89); \n    key = (char*)malloc(length + 1);\n    if(!key) CERROR_BREAK(error, 83); \n    key[length] = 0;\n    for(i = 0; i < length; i++) key[i] = (char)data[i];\n    string2_begin = length + 1; \n    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;\n    str = (char*)malloc(length + 1);\n    if(!str) CERROR_BREAK(error, 83); \n    str[length] = 0;\n    for(i = 0; i < length; i++) str[i] = (char)data[string2_begin + i];\n    error = lodepng_add_text(info, key, str);\n    break;\n  }\n  free(key);\n  free(str);\n  return error;\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DefineImageRegistry(const RegistryType type,\n  const char *option,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n  register char\n    *p;\n  assert(option != (const char *) NULL);\n  (void) CopyMagickString(key,option,MagickPathExtent);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageRegistry(type,key,value,exception));\n}", "target": 0}
{"code": "yang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n        if (j == deviate->unique[index].expr_size) {\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n            k = i; \n            i = -1; \n            break;\n        }\n    }\n    if (i != -1) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\tret = 1; \n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}", "target": 0}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 1}
{"code": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n   tab_strip_model_->SetTabBlocked(index, blocked);\n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}", "target": 1}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *length); \n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; \n\t\treturn TRUE;\n\t}\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type); \n\t*type &= 0x0F;                \n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); \n\telse\n\t\t*channel_id = 0; \n\treturn TRUE;\n}", "target": 1}
{"code": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\tefi_init();\n\tio_port_init();\n#ifdef CONFIG_IA64_GENERIC\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\tparse_early_param();\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n#ifdef CONFIG_ACPI\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t\n# endif\n#endif \n\tfind_memory();\n \tia64_sal_init(__va(efi.sal_systab));\n #ifdef CONFIG_SMP\n \tcpu_physical_id(0) = hard_smp_processor_id();\n #endif\n\tcpu_init();\t\n\tmmu_context_init();\t\n\tcheck_sal_cache_flush();\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\tif (!nomca)\n\t\tia64_mca_init();\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}", "target": 1}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "int LibRaw_bigfile_datastream::jpeg_src(void *jpegdata)\n{\n#ifdef NO_JPEG\n  return -1;\n#else\n  if (!f)\n    return -1;\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_stdio_src(cinfo, f);\n  return 0; \n#endif\n}", "target": 0}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "void sc_pkcs15emu_sc_hsm_free_cvc(sc_cvc_t *cvc)\n{\n\tif (cvc->signature) {\n\t\tfree(cvc->signature);\n\t\tcvc->signature = NULL;\n\t}\n\tif (cvc->primeOrModulus) {\n\t\tfree(cvc->primeOrModulus);\n\t\tcvc->primeOrModulus = NULL;\n\t}\n\tif (cvc->coefficientAorExponent) {\n\t\tfree(cvc->coefficientAorExponent);\n\t\tcvc->coefficientAorExponent = NULL;\n\t}\n\tif (cvc->coefficientB) {\n\t\tfree(cvc->coefficientB);\n\t\tcvc->coefficientB = NULL;\n\t}\n\tif (cvc->basePointG) {\n\t\tfree(cvc->basePointG);\n\t\tcvc->basePointG = NULL;\n\t}\n\tif (cvc->order) {\n\t\tfree(cvc->order);\n\t\tcvc->order = NULL;\n\t}\n\tif (cvc->publicPoint) {\n\t\tfree(cvc->publicPoint);\n\t\tcvc->publicPoint = NULL;\n\t}\n\tif (cvc->cofactor) {\n\t\tfree(cvc->cofactor);\n\t\tcvc->cofactor = NULL;\n\t}\n}", "target": 0}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "xfs_bmbt_lookup_first(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t\n{\n\tcur->bc_rec.b.br_startoff = 0;\n\tcur->bc_rec.b.br_startblock = 0;\n\tcur->bc_rec.b.br_blockcount = 0;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}", "target": 0}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static krb5_error_code hdb_samba4_lock(krb5_context context, HDB *db, int operation)\n{\n\treturn 0;\n}", "target": 0}
{"code": "static int mmap_kmem(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned long pfn;\n\tpfn = __pa((u64)vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;\n\tif (!pfn_valid(pfn))\n\t\treturn -EIO;\n\tvma->vm_pgoff = pfn;\n\treturn mmap_mem(file, vma);\n}", "target": 0}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 1}
{"code": "header_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} ", "target": 1}
{"code": "static CuckooFilter *cfCreate(RedisModuleKey *key, size_t capacity, size_t bucketSize,\n                              size_t maxIterations, size_t expansion) {\n    if (capacity < bucketSize * 2)\n        return NULL;\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    if (CuckooFilter_Init(cf, capacity, bucketSize, maxIterations, expansion) != 0) {\n        RedisModule_Free(cf); \n        cf = NULL;            \n    }\n    RedisModule_ModuleTypeSetValue(key, CFType, cf);\n    return cf;\n}", "target": 1}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n \tmsr.host_initiated = false;\n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "TEST_F(ExtractorTest, TestDoubleCustomHeaderToken) {\n  auto headers = TestRequestHeaderMapImpl{{\"token-header\", \"jwt_token\"}, {\"token-header\", \"foo\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token,foo\");\n}", "target": 0}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "static int rfcomm_sock_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rfcomm_sock_debugfs_show, inode->i_private);\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_set_error_verbosity)\n{\n\tzval *pgsql_link = NULL;\n\tzend_long verbosity;\n\tint id = -1, argc = ZEND_NUM_ARGS();\n\tPGconn *pgsql;\n\tif (argc == 1) {\n\t\tif (zend_parse_parameters(argc, \"l\", &verbosity) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tid = FETCH_DEFAULT_LINK();\n\t\tCHECK_DEFAULT_LINK(id);\n\t} else {\n\t\tif (zend_parse_parameters(argc, \"rl\", &pgsql_link, &verbosity) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\t\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (verbosity & (PQERRORS_TERSE|PQERRORS_DEFAULT|PQERRORS_VERBOSE)) {\n\t\tRETURN_LONG(PQsetErrorVerbosity(pgsql, verbosity));\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "init(void)\n{\n#ifdef USE_CALLOUT\n    int id;\n    OnigEncoding enc;\n    char* name;\n    unsigned int args[4];\n    OnigValue opts[4];\n    enc = ONIG_ENCODING_UTF16_BE;\n    name = \"\\000F\\000A\\000I\\000L\\000\\000\";            BC0_P(name, fail);\n    name = \"\\000M\\000I\\000S\\000M\\000A\\000T\\000C\\000H\\000\\000\"; BC0_P(name, mismatch);\n    name = \"\\000M\\000A\\000X\\000\\000\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_CHAR;\n    opts[0].c = 'X';\n    BC_B_O(name, max, 2, args, 1, opts);\n    name = \"\\000E\\000R\\000R\\000O\\000R\\000\\000\";\n    args[0] = ONIG_TYPE_LONG; opts[0].l = ONIG_ABORT;\n    BC_P_O(name, error, 1, args, 1, opts);\n    name = \"\\000C\\000O\\000U\\000N\\000T\\000\\000\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, count, 1, args, 1, opts);\n    name = \"\\000T\\000O\\000T\\000A\\000L\\000_\\000C\\000O\\000U\\000N\\000T\\000\\000\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, total_count, 1, args, 1, opts);\n    name = \"\\000C\\000M\\000P\\000\\000\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_STRING;\n    args[2] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    BC_P(name, cmp, 3, args);\n#endif \n  return ONIG_NORMAL;\n}", "target": 0}
{"code": "static int truncate_error_page(struct page *p, unsigned long pfn,\n\t\t\t\tstruct address_space *mapping)\n{\n\tint ret = MF_FAILED;\n\tif (mapping->a_ops->error_remove_page) {\n\t\tint err = mapping->a_ops->error_remove_page(mapping, p);\n\t\tif (err != 0) {\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to punch page: %d\\n\",\n\t\t\t\tpfn, err);\n\t\t} else if (page_has_private(p) &&\n\t\t\t   !try_to_release_page(p, GFP_NOIO)) {\n\t\t\tpr_info(\"Memory failure: %#lx: failed to release buffers\\n\",\n\t\t\t\tpfn);\n\t\t} else {\n\t\t\tret = MF_RECOVERED;\n\t\t}\n\t} else {\n\t\tif (invalidate_inode_page(p))\n\t\t\tret = MF_RECOVERED;\n\t\telse\n\t\t\tpr_info(\"Memory failure: %#lx: Failed to invalidate\\n\",\n\t\t\t\tpfn);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": " mrb_class_real(struct RClass* cl)\n {\n  if (cl == 0)\n    return NULL;\n   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n     cl = cl->super;\n   }\n   return cl;\n }", "target": 1}
{"code": "parse_table(\n\tstruct buf *ob,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size)\n{\n\tsize_t i;\n\tstruct buf *header_work = 0;\n\tstruct buf *body_work = 0;\n\tsize_t columns;\n\tint *col_data = NULL;\n\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n\tif (i > 0) {\n\t\twhile (i < size) {\n\t\t\tsize_t row_start;\n\t\t\tint pipes = 0;\n\t\t\trow_start = i;\n\t\t\twhile (i < size && data[i] != '\\n')\n\t\t\t\tif (data[i++] == '|')\n\t\t\t\t\tpipes++;\n\t\t\tif (pipes == 0 || i == size) {\n\t\t\t\ti = row_start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparse_table_row(\n\t\t\t\tbody_work,\n\t\t\t\trndr,\n\t\t\t\tdata + row_start,\n\t\t\t\ti - row_start,\n\t\t\t\tcolumns,\n\t\t\t\tcol_data, 0\n\t\t\t);\n\t\t\ti++;\n\t\t}\n\t\tif (rndr->cb.table)\n\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n\t}\n\tfree(col_data);\n\trndr_popbuf(rndr, BUFFER_SPAN);\n\trndr_popbuf(rndr, BUFFER_BLOCK);\n\treturn i;\n}", "target": 0}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "void _af_print_tracks (AFfilehandle filehandle)\n{\n\tint\ti;\n\tfor (i=0; i<filehandle->trackCount; i++)\n\t{\n\t\t_Track\t*track = &filehandle->tracks[i];\n\t\tprintf(\"track %d\\n\", i);\n\t\tprintf(\" id %d\\n\", track->id);\n\t\tprintf(\" sample format\\n\");\n\t\t_af_print_audioformat(&track->f);\n\t\tprintf(\" virtual format\\n\");\n\t\t_af_print_audioformat(&track->v);\n\t\tprintf(\" total file frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalfframes);\n\t\tprintf(\" total virtual frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalvframes);\n\t\tprintf(\" next file frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextfframe);\n\t\tprintf(\" next virtual frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextvframe);\n\t\tprintf(\" frames to ignore: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->frames2ignore);\n\t\tprintf(\" data_size: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->data_size);\n\t\tprintf(\" fpos_first_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_first_frame);\n\t\tprintf(\" fpos_next_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_next_frame);\n\t\tprintf(\" fpos_after_data: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_after_data);\n\t\tprintf(\" channel matrix:\");\n\t\t_af_print_channel_matrix(track->channelMatrix,\n\t\t\ttrack->f.channelCount, track->v.channelCount);\n\t\tprintf(\"\\n\");\n\t\tprintf(\" marker count: %d\\n\", track->markerCount);\n\t}\n}", "target": 0}
{"code": "match_named_captures_iter(const OnigUChar *name, const OnigUChar *name_end,\n\tint back_num, int *back_refs, OnigRegex regex, void *arg) {\n    struct MEMO *memo = MEMO_CAST(arg);\n    VALUE hash = memo->v1;\n    VALUE match = memo->v2;\n    VALUE key = rb_enc_str_new((const char *)name, name_end-name, regex->enc);\n    VALUE value;\n    int i;\n    int found = 0;\n    for (i = 0; i < back_num; i++) {\n\tvalue = rb_reg_nth_match(back_refs[i], match);\n\tif (RTEST(value)) {\n\t    rb_hash_aset(hash, key, value);\n\t    found = 1;\n\t}\n    }\n    if (found == 0) {\n\trb_hash_aset(hash, key, Qnil);\n    }\n    return 0;\n}", "target": 0}
{"code": "static void init_reg_state(struct bpf_verifier_env *env,\n\t\t\t   struct bpf_func_state *state)\n{\n\tstruct bpf_reg_state *regs = state->regs;\n\tint i;\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tmark_reg_not_init(env, regs, i);\n\t\tregs[i].live = REG_LIVE_NONE;\n\t\tregs[i].parent = NULL;\n\t\tregs[i].subreg_def = DEF_NOT_SUBREG;\n\t}\n\tregs[BPF_REG_FP].type = PTR_TO_STACK;\n\tmark_reg_known_zero(env, regs, BPF_REG_FP);\n\tregs[BPF_REG_FP].frameno = state->frameno;\n}", "target": 0}
{"code": "void rfc_send_rls(tRFC_MCB* p_mcb, uint8_t dlci, bool is_command,\n uint8_t status) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_RLS;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_RLS_LEN << 1);\n *p_data++ = RFCOMM_EA | RFCOMM_CR_MASK | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_RLS_ERROR | status;\n  p_buf->len = RFCOMM_MX_RLS_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_P(rval));\n#endif\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\t\tif (!(*var_hashx)->first) {\n\t\t\t(*var_hashx)->first = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last)->next = var_hash;\n\t\t}\n\t\t(*var_hashx)->last = var_hash;\n\t}\n\tvar_hash->data[var_hash->used_slots++] = rval;\n}", "target": 0}
{"code": "static int scrub_extent_for_parity(struct scrub_parity *sparity,\n\t\t\t\t   u64 logical, u64 len,\n\t\t\t\t   u64 physical, struct btrfs_device *dev,\n\t\t\t\t   u64 flags, u64 gen, int mirror_num)\n{\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\tint ret;\n\tu8 csum[BTRFS_CSUM_SIZE];\n\tu32 blocksize;\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state)) {\n\t\tscrub_parity_mark_sectors_error(sparity, logical, len);\n\t\treturn 0;\n\t}\n\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\tblocksize = sparity->stripe_len;\n\t} else if (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tblocksize = sparity->stripe_len;\n\t} else {\n\t\tblocksize = sctx->fs_info->sectorsize;\n\t\tWARN_ON(1);\n\t}\n\twhile (len) {\n\t\tu64 l = min_t(u64, len, blocksize);\n\t\tint have_csum = 0;\n\t\tif (flags & BTRFS_EXTENT_FLAG_DATA) {\n\t\t\thave_csum = scrub_find_csum(sctx, logical, csum);\n\t\t\tif (have_csum == 0)\n\t\t\t\tgoto skip;\n\t\t}\n\t\tret = scrub_pages_for_parity(sparity, logical, l, physical, dev,\n\t\t\t\t\t     flags, gen, mirror_num,\n\t\t\t\t\t     have_csum ? csum : NULL);\n\t\tif (ret)\n\t\t\treturn ret;\nskip:\n\t\tlen -= l;\n\t\tlogical += l;\n\t\tphysical += l;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "pipe_setup (Pipe *pipe, FILE *logf, gpointer user_data)\n{\n\tGIOFlags flags = 0;\n\tpipe->logf = logf;\n\tpipe->buf = g_string_sized_new (512);\n\tpipe->channel = g_io_channel_unix_new (pipe->fd);\n\tg_io_channel_set_encoding (pipe->channel, NULL, NULL);\n\tflags = g_io_channel_get_flags (pipe->channel);\n\tg_io_channel_set_flags (pipe->channel, flags | G_IO_FLAG_NONBLOCK, NULL);\n\tg_io_channel_set_buffered (pipe->channel, FALSE);\n\tpipe->watch = g_io_add_watch (pipe->channel,\n\t                              G_IO_IN | G_IO_ERR | G_IO_PRI,\n\t                              data_available,\n\t                              user_data);\n}", "target": 0}
{"code": "    inline char lowercase(const char x) {\n      return (char)((x<'A'||x>'Z')?x:x - 'A' + 'a');", "target": 0}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\tif (reg->smin_value >= 0 || reg->smax_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t\treturn;\n\t}\n\tif ((s64)reg->umax_value >= 0) {\n\t\treg->smin_value = reg->umin_value;\n\t\treg->smax_value = reg->umax_value = min_t(u64, reg->smax_value,\n\t\t\t\t\t\t\t  reg->umax_value);\n\t} else if ((s64)reg->umin_value < 0) {\n\t\treg->smin_value = reg->umin_value = max_t(u64, reg->smin_value,\n\t\t\t\t\t\t\t  reg->umin_value);\n\t\treg->smax_value = reg->umax_value;\n\t}\n}", "target": 0}
{"code": "static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; \n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); \n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n        return len;\n    }\n    return -1;\n}", "target": 0}
{"code": "static void jsR_callfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\tscope = jsR_newenvironment(J, jsV_newobject(J, JS_COBJECT, NULL), scope);\n\tjsR_savescope(J, scope);\n\tif (F->arguments) {\n\t\tjs_newobject(J);\n\t\tif (!J->strict) {\n\t\t\tjs_currentfunction(J);\n\t\t\tjs_defproperty(J, -2, \"callee\", JS_DONTENUM);\n\t\t}\n\t\tjs_pushnumber(J, n);\n\t\tjs_defproperty(J, -2, \"length\", JS_DONTENUM);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tjs_copy(J, i + 1);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tjs_initvar(J, \"arguments\", -1);\n\t\tjs_pop(J, 1);\n\t}\n\tfor (i = 0; i < F->numparams; ++i) {\n\t\tif (i < n)\n\t\t\tjs_initvar(J, F->vartab[i], i + 1);\n\t\telse {\n\t\t\tjs_pushundefined(J);\n\t\t\tjs_initvar(J, F->vartab[i], -1);\n\t\t\tjs_pop(J, 1);\n\t\t}\n\t}\n\tjs_pop(J, n);\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\tjsR_restorescope(J);\n}", "target": 0}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "oneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    \n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n    if (ptr[l] == NUL && (ve_flags & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}", "target": 0}
{"code": "static struct nfs4_ff_layout_mirror *ff_layout_alloc_mirror(gfp_t gfp_flags)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tmirror = kzalloc(sizeof(*mirror), gfp_flags);\n\tif (mirror != NULL) {\n\t\tspin_lock_init(&mirror->lock);\n\t\trefcount_set(&mirror->ref, 1);\n\t\tINIT_LIST_HEAD(&mirror->mirrors);\n\t}\n\treturn mirror;\n}", "target": 0}
{"code": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    return proxy;\n}", "target": 1}
{"code": "htmlCtxtReset(htmlParserCtxtPtr ctxt)\n{\n    xmlParserInputPtr input;\n    xmlDictPtr dict;\n    if (ctxt == NULL)\n        return;\n    xmlInitParser();\n    dict = ctxt->dict;\n    while ((input = inputPop(ctxt)) != NULL) { \n        xmlFreeInputStream(input);\n    }\n    ctxt->inputNr = 0;\n    ctxt->input = NULL;\n    ctxt->spaceNr = 0;\n    if (ctxt->spaceTab != NULL) {\n\tctxt->spaceTab[0] = -1;\n\tctxt->space = &ctxt->spaceTab[0];\n    } else {\n\tctxt->space = NULL;\n    }\n    ctxt->nodeNr = 0;\n    ctxt->node = NULL;\n    ctxt->nameNr = 0;\n    ctxt->name = NULL;\n    DICT_FREE(ctxt->version);\n    ctxt->version = NULL;\n    DICT_FREE(ctxt->encoding);\n    ctxt->encoding = NULL;\n    DICT_FREE(ctxt->directory);\n    ctxt->directory = NULL;\n    DICT_FREE(ctxt->extSubURI);\n    ctxt->extSubURI = NULL;\n    DICT_FREE(ctxt->extSubSystem);\n    ctxt->extSubSystem = NULL;\n    if (ctxt->myDoc != NULL)\n        xmlFreeDoc(ctxt->myDoc);\n    ctxt->myDoc = NULL;\n    ctxt->standalone = -1;\n    ctxt->hasExternalSubset = 0;\n    ctxt->hasPErefs = 0;\n    ctxt->html = 1;\n    ctxt->external = 0;\n    ctxt->instate = XML_PARSER_START;\n    ctxt->token = 0;\n    ctxt->wellFormed = 1;\n    ctxt->nsWellFormed = 1;\n    ctxt->disableSAX = 0;\n    ctxt->valid = 1;\n    ctxt->vctxt.userData = ctxt;\n    ctxt->vctxt.error = xmlParserValidityError;\n    ctxt->vctxt.warning = xmlParserValidityWarning;\n    ctxt->record_info = 0;\n    ctxt->nbChars = 0;\n    ctxt->checkIndex = 0;\n    ctxt->inSubset = 0;\n    ctxt->errNo = XML_ERR_OK;\n    ctxt->depth = 0;\n    ctxt->charset = XML_CHAR_ENCODING_NONE;\n    ctxt->catalogs = NULL;\n    xmlInitNodeInfoSeq(&ctxt->node_seq);\n    if (ctxt->attsDefault != NULL) {\n        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);\n        ctxt->attsDefault = NULL;\n    }\n    if (ctxt->attsSpecial != NULL) {\n        xmlHashFree(ctxt->attsSpecial, NULL);\n        ctxt->attsSpecial = NULL;\n    }\n}", "target": 0}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n    gr_face_destroy(face);\n    return 0;\n}", "target": 1}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& shift_object3d() {\n      if (_height!=3 || _depth>1 || _spectrum>1)\n        throw CImgInstanceException(_cimg_instance\n                                    \"shift_object3d(): Instance is not a set of 3d vertices.\",\n                                    cimg_instance);\n      CImg<T> xcoords = get_shared_row(0), ycoords = get_shared_row(1), zcoords = get_shared_row(2);\n      float\n        xm, xM = (float)xcoords.max_min(xm),\n        ym, yM = (float)ycoords.max_min(ym),\n        zm, zM = (float)zcoords.max_min(zm);\n      xcoords-=(xm + xM)/2; ycoords-=(ym + yM)/2; zcoords-=(zm + zM)/2;\n      return *this;", "target": 0}
{"code": "int GetDPI(const PrintMsg_Print_Params* print_params) {\n#if defined(OS_MACOSX)\n  return kPointsPerInch;\n#else\n  return static_cast<int>(print_params->dpi);\n#endif  \n}", "target": 0}
{"code": "static int chdir_to_parent(char *copy, const char **lastp)\n{\n\tchar *tmp;\n\tconst char *parent;\n\tchar buf[65536];\n\tint res;\n\ttmp = strrchr(copy, '/');\n\tif (tmp == NULL || tmp[1] == '\\0') {\n\t\tfprintf(stderr, \"%s: internal error: invalid abs path: <%s>\\n\",\n\t\t\tprogname, copy);\n\t\treturn -1;\n\t}\n\tif (tmp != copy) {\n\t\t*tmp = '\\0';\n\t\tparent = copy;\n\t\t*lastp = tmp + 1;\n\t} else if (tmp[1] != '\\0') {\n\t\t*lastp = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\t*lastp = \".\";\n\t\tparent = \"/\";\n\t}\n\tres = chdir(parent);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to %s: %s\\n\",\n\t\t\tprogname, parent, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getcwd(buf, sizeof(buf)) == NULL) {\n\t\tfprintf(stderr, \"%s: failed to obtain current directory: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, parent) != 0) {\n\t\tfprintf(stderr, \"%s: mountpoint moved (%s -> %s)\\n\", progname,\n\t\t\tparent, buf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "setup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n     kdc_realm_t         *newrealm;\n     kret = 0;\n     if (kdc_numrealms > 1) {\n         if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                          (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}", "target": 1}
{"code": "bool SVGDocumentExtensions::isElementPendingResource(Element* element, const AtomicString& id) const\n{\n    ASSERT(element);\n    if (!hasPendingResource(id))\n        return false;\n    return m_pendingResources.get(id)->contains(element);\n}", "target": 0}
{"code": "static int pam_winbind_request_log(struct pwb_context *ctx,\n\t\t\t\t   int retval,\n\t\t\t\t   const char *user,\n\t\t\t\t   const char *fn)\n{\n\tswitch (retval) {\n\tcase PAM_AUTH_ERR:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' denied access \"\n\t\t\t \"(incorrect password or invalid membership)\", user);\n\t\treturn retval;\n\tcase PAM_ACCT_EXPIRED:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' account expired\",\n\t\t\t user);\n\t\treturn retval;\n\tcase PAM_AUTHTOK_EXPIRED:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' password expired\",\n\t\t\t user);\n\t\treturn retval;\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t\t_pam_log(ctx, LOG_WARNING, \"user '%s' new password \"\n\t\t\t \"required\", user);\n\t\treturn retval;\n\tcase PAM_USER_UNKNOWN:\n\t\t_pam_log_debug(ctx, LOG_NOTICE, \"user '%s' not found\",\n\t\t\t       user);\n\t\tif (ctx->ctrl & WINBIND_UNKNOWN_OK_ARG) {\n\t\t\treturn PAM_IGNORE;\n\t\t}\n\t\treturn retval;\n\tcase PAM_SUCCESS:\n\t\tif (strcmp(fn, \"wbcLogonUser\") == 0) {\n\t\t\t_pam_log(ctx, LOG_NOTICE,\n\t\t\t\t \"user '%s' granted access\", user);\n\t\t} else {\n\t\t\t_pam_log(ctx, LOG_NOTICE,\n\t\t\t\t \"user '%s' OK\", user);\n\t\t}\n\t\treturn retval;\n\tdefault:\n\t\t_pam_log(ctx, LOG_ERR,\n\t\t\t \"internal module error (retval = %s(%d), user = '%s')\",\n\t\t\t_pam_error_code_str(retval), retval, user);\n\t\treturn retval;\n\t}\n}", "target": 0}
{"code": "GF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tu8 *data=NULL;\n\tu32 size=0;\n\tGF_Err e;\n\tGF_Box *clone=NULL;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_size(box);\n\tif (!e)\n\t\te = gf_isom_box_write(box, bs);\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\tif (!e) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t\te = gf_isom_box_parse(&clone, bs);\n\t\tgf_bs_del(bs);\n\t}\n\tif (data)\n\t\tgf_free(data);\n\tif (e) {\n\t\tif (clone)\n\t\t\tgf_isom_box_del(clone);\n\t\tclone = NULL;\n\t}\n\treturn clone;\n}", "target": 0}
{"code": "int vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n \t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\t\treturn -ENOTCONN;\n \t\tpvc.sap_family = AF_ATMPVC;\n \t\tpvc.sap_addr.itf = vcc->dev->number;\n \t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->getsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);\n}", "target": 1}
{"code": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": "unsigned int _gnutls_x509_verify_certificate(\n    const gnutls_x509_crt_t *certificate_list, int clist_size,\n    const gnutls_x509_crt_t *trusted_cas, int tcas_size,\n    const gnutls_x509_crl_t *CRLs, int crls_size,\n    unsigned int flags)\n{\n    int i = 0, ret;\n    unsigned int status = 0, output;\n    ret =\n\t_gnutls_verify_certificate2(certificate_list[clist_size-1], \n\t    trusted_cas, tcas_size, flags, &output);\n    if (ret == 0) {\n\tgnutls_assert();\n\tstatus |= output;\n\tstatus |= GNUTLS_CERT_INVALID;\n\treturn status;\n    }\n#ifdef ENABLE_PKI\n    for (i = 0; i < clist_size; i++) {\n\tret = gnutls_x509_crt_check_revocation(certificate_list[i],\n\t\t\t\t\t       CRLs, crls_size);\n\tif (ret == 1) {\t\t\n\t    status |= GNUTLS_CERT_REVOKED;\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n#endif\n    for (i = clist_size-1; i > 0; i--) {\n\tif (i - 1 < 0)\n\t    break;\n        flags ^= GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT;\n\tif ((ret =\n\t     _gnutls_verify_certificate2(certificate_list[i-1],\n                  &certificate_list[i], 1, flags, NULL)) == 0) {\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n    return 0;\n}", "target": 0}
{"code": "int sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\tINFO(\"Creating initial consoles under container /dev\");\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\tif (!dir_exists(path))  \n\t\treturn 0;\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static void sco_conn_ready(struct sco_conn *conn)\n{\n\tstruct sock *parent;\n\tstruct sock *sk = conn->sk;\n\tBT_DBG(\"conn %p\", conn);\n\tif (sk) {\n\t\tlock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tsk->sk_state_change(sk);\n\t\trelease_sock(sk);\n\t} else {\n\t\tsco_conn_lock(conn);\n\t\tif (!conn->hcon) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tparent = sco_get_sock_listen(&conn->hcon->src);\n\t\tif (!parent) {\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tlock_sock(parent);\n\t\tsk = sco_sock_alloc(sock_net(parent), NULL,\n\t\t\t\t    BTPROTO_SCO, GFP_ATOMIC, 0);\n\t\tif (!sk) {\n\t\t\trelease_sock(parent);\n\t\t\tsco_conn_unlock(conn);\n\t\t\treturn;\n\t\t}\n\t\tsco_sock_init(sk, parent);\n\t\tbacpy(&sco_pi(sk)->src, &conn->hcon->src);\n\t\tbacpy(&sco_pi(sk)->dst, &conn->hcon->dst);\n\t\thci_conn_hold(conn->hcon);\n\t\t__sco_chan_add(conn, sk, parent);\n\t\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\t\tsk->sk_state = BT_CONNECT2;\n\t\telse\n\t\t\tsk->sk_state = BT_CONNECTED;\n\t\tparent->sk_data_ready(parent);\n\t\trelease_sock(parent);\n\t\tsco_conn_unlock(conn);\n\t}\n}", "target": 0}
{"code": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      break;\n  }\n  _Data[j] = 0;\n}", "target": 1}
{"code": "int nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "send_userauth_info_request(Authctxt *authctxt)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tint i;\n\tu_int *echo_on;\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\tpacket_start(SSH2_MSG_USERAUTH_INFO_REQUEST);\n\tpacket_put_cstring(name);\n\tpacket_put_cstring(instr);\n\tpacket_put_cstring(\"\");\t\t\n\tpacket_put_int(kbdintctxt->nreq);\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tpacket_put_cstring(prompts[i]);\n\t\tpacket_put_char(echo_on[i]);\n\t}\n\tpacket_send();\n\tpacket_write_wait();\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\txfree(prompts[i]);\n\txfree(prompts);\n\txfree(echo_on);\n\txfree(name);\n\txfree(instr);\n\treturn 1;\n}", "target": 0}
{"code": "convert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}", "target": 1}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "void fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\tgc_args.more = icmp6_dst_gc();\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}", "target": 0}
{"code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 0}
{"code": "    CImg<T>& LabtoXYZ(const bool use_D65=true) {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"LabtoXYZ(): Instance is not a Lab image.\",\n                                    cimg_instance);\n      const CImg<Tfloat> white = CImg<Tfloat>(1,1,1,3,255).RGBtoXYZ(use_D65);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=128))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          L = (Tfloat)p1[N],\n          a = (Tfloat)p2[N],\n          b = (Tfloat)p3[N],\n          cY = (L + 16)/116,\n          cZ = cY - b/200,\n          cX = a/500 + cY,\n          X = (Tfloat)(24389*cX>216?cX*cX*cX:(116*cX - 16)*27/24389),\n          Y = (Tfloat)(27*L>216?cY*cY*cY:27*L/24389),\n          Z = (Tfloat)(24389*cZ>216?cZ*cZ*cZ:(116*cZ - 16)*27/24389);\n        p1[N] = (T)(X*white[0]);\n        p2[N] = (T)(Y*white[1]);\n        p3[N] = (T)(Z*white[2]);\n      }\n      return *this;", "target": 0}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "  PutOperationParams() {}", "target": 0}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "_XimEncodeSavedPreeditValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tif (ic->private.proto.preedit_font)\n\t    Xfree(ic->private.proto.preedit_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.preedit_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.preedit_font        = tmp;\n\tic->private.proto.preedit_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "    void CiffHeader::print(std::ostream& os, const std::string& prefix) const\n    {\n        std::ios::fmtflags f( os.flags() );\n        os << prefix\n           << _(\"Header, offset\") << \" = 0x\" << std::setw(8) << std::setfill('0')\n           << std::hex << std::right << offset_ << \"\\n\";\n        if (pRootDir_) pRootDir_->print(os, byteOrder_, prefix);\n        os.flags(f);\n    } ", "target": 0}
{"code": "static void ml_ff_destroy(struct ff_device *ff)\n{\n\tstruct ml_device *ml = ff->private;\n\tkfree(ml->private);\n}", "target": 1}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    return true;\n}", "target": 1}
{"code": "st_lookup(st_table *table, register st_data_t key, st_data_t *value)\n{\n    st_index_t hash_val, bin_pos;\n    register st_table_entry *ptr;\n    if (table->entries_packed) {\n        st_index_t i;\n        for (i = 0; i < table->num_entries; i++) {\n            if ((st_data_t)table->bins[i*2] == key) {\n                if (value !=0) *value = (st_data_t)table->bins[i*2+1];\n                return 1;\n            }\n        }\n        return 0;\n    }\n    hash_val = do_hash(key, table);\n    FIND_ENTRY(table, ptr, hash_val, bin_pos);\n    if (ptr == 0) {\n\treturn 0;\n    }\n    else {\n\tif (value != 0)  *value = ptr->record;\n\treturn 1;\n    }\n}", "target": 0}
{"code": "void Item_string::print(String *str, enum_query_type query_type)\n{\n  const bool print_introducer=\n    !(query_type & QT_WITHOUT_INTRODUCERS) && is_cs_specified();\n  if (print_introducer)\n  {\n    str->append('_');\n    str->append(collation.collation->csname);\n  }\n  str->append('\\'');\n  if (query_type & QT_TO_SYSTEM_CHARSET)\n  {\n    if (print_introducer)\n    {\n      ErrConvString tmp(str_value.ptr(), str_value.length(), &my_charset_bin);\n      str->append(tmp.ptr());\n    }\n    else\n    {\n      if (my_charset_same(str_value.charset(), system_charset_info))\n        str_value.print(str); \n      else \n      {\n        THD *thd= current_thd;\n        LEX_STRING utf8_lex_str;\n        thd->convert_string(&utf8_lex_str,\n                            system_charset_info,\n                            str_value.c_ptr_safe(),\n                            str_value.length(),\n                            str_value.charset());\n        String utf8_str(utf8_lex_str.str,\n                        utf8_lex_str.length,\n                        system_charset_info);\n        utf8_str.print(str);\n      }\n    }\n  }\n  else\n  {\n    str_value.print(str);\n  }\n  str->append('\\'');\n}", "target": 0}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "flush_chunk(tor_socket_t s, buf_t *buf, chunk_t *chunk, size_t sz,\n            size_t *buf_flushlen)\n{\n  ssize_t write_result;\n  if (sz > chunk->datalen)\n    sz = chunk->datalen;\n  write_result = tor_socket_send(s, chunk->data, sz, 0);\n  if (write_result < 0) {\n    int e = tor_socket_errno(s);\n    if (!ERRNO_IS_EAGAIN(e)) { \n#ifdef _WIN32\n      if (e == WSAENOBUFS)\n        log_warn(LD_NET,\"write() failed: WSAENOBUFS. Not enough ram?\");\n#endif\n      return -1;\n    }\n    log_debug(LD_NET,\"write() would block, returning.\");\n    return 0;\n  } else {\n    *buf_flushlen -= write_result;\n    buf_remove_from_front(buf, write_result);\n    tor_assert(write_result < INT_MAX);\n    return (int)write_result;\n  }\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "STATIC const char *\nS_cntrl_to_mnemonic(const U8 c)\n{\n    switch (c) {\n        case '\\a':       return \"\\\\a\";\n        case '\\b':       return \"\\\\b\";\n        case ESC_NATIVE: return \"\\\\e\";\n        case '\\f':       return \"\\\\f\";\n        case '\\n':       return \"\\\\n\";\n        case '\\r':       return \"\\\\r\";\n        case '\\t':       return \"\\\\t\";\n    }\n    return NULL;", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        if (! opj_j2k_read_SQcd_SQcc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n        opj_j2k_copy_tile_quantization_parameters(p_j2k);\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "ExprResolveString(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_atom_t *val_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_STRING) {\n            log_err(ctx, \"Found constant of type %s, expected a string\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *val_rtrn = expr->string.str;\n        return true;\n    case EXPR_IDENT:\n        log_err(ctx, \"Identifier \\\"%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_INVERT:\n    case EXPR_NOT:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of strings not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveString\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "static int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "leaving_window(win_T *win)\n{\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t\n    restart_edit = NUL;\n    if (State & INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}", "target": 0}
{"code": "bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) {\n  pdfdocLocker();\n  if (str->getLength() <= 0)\n  {\n    error(errSyntaxError, -1, \"Document stream is empty\");\n    return false;\n  }\n  str->setPos(0, -1);\n  if (str->getPos() < 0)\n  {\n    error(errSyntaxError, -1, \"Document base stream is not seekable\");\n    return false;\n  }\n  str->reset();\n  checkHeader();\n  bool wasReconstructed = false;\n  xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed);\n  if (!xref->isOk()) {\n    if (wasReconstructed) {\n      delete xref;\n      startXRefPos = -1;\n      xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed);\n    }\n    if (!xref->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read xref table\");\n      errCode = xref->getErrorCode();\n      return false;\n    }\n  }\n  if (!checkEncryption(ownerPassword, userPassword)) {\n    errCode = errEncrypted;\n    return false;\n  }\n  catalog = new Catalog(this);\n  if (catalog && !catalog->isOk()) {\n    if (!wasReconstructed)\n    {\n      delete catalog;\n      delete xref;\n      xref = new XRef(str, 0, 0, nullptr, true);\n      catalog = new Catalog(this);\n    }\n    if (catalog && !catalog->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read page catalog\");\n      errCode = errBadCatalog;\n      return false;\n    }\n  }\n  extractPDFSubtype();\n  return xref->isOk();\n}", "target": 1}
{"code": "static void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}", "target": 0}
{"code": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}", "target": 1}
{"code": "coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; \n\t}\n\treturn MIN(buf_len,attribute_len+len);\n}", "target": 0}
{"code": "cmd_genkey (assuan_context_t ctx, char *line)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  int rc;\n  char *keyno;\n  int force;\n  const char *s;\n  time_t timestamp;\n  if ( IS_LOCKED (ctrl) )\n    return gpg_error (GPG_ERR_LOCKED);\n  force = has_option (line, \"--force\");\n  if ((s=has_option_name (line, \"--timestamp\")))\n    {\n      if (*s != '=')\n        return set_error (GPG_ERR_ASS_PARAMETER, \"missing value for option\");\n      timestamp = isotime2epoch (s+1);\n      if (timestamp < 1)\n        return set_error (GPG_ERR_ASS_PARAMETER, \"invalid time value\");\n    }\n  else\n    timestamp = 0;\n  line = skip_options (line);\n  if (!*line)\n    return set_error (GPG_ERR_ASS_PARAMETER, \"no key number given\");\n  keyno = line;\n  while (*line && !spacep (line))\n    line++;\n  *line = 0;\n  if ((rc = open_card (ctrl, NULL)))\n    return rc;\n  if (!ctrl->app_ctx)\n    return gpg_error (GPG_ERR_UNSUPPORTED_OPERATION);\n  keyno = xtrystrdup (keyno);\n  if (!keyno)\n    return out_of_core ();\n  rc = app_genkey (ctrl->app_ctx, ctrl, keyno, force? 1:0,\n                   timestamp, pin_cb, ctx);\n  xfree (keyno);\n  TEST_CARD_REMOVAL (ctrl, rc);\n  return rc;\n}", "target": 0}
{"code": "join_path_from_pattern(struct glob_pattern **beg)\n{\n    struct glob_pattern *p;\n    char *path = NULL;\n    size_t path_len = 0;\n    for (p = *beg; p; p = p->next) {\n\tconst char *str;\n\tswitch (p->type) {\n\t  case RECURSIVE:\n\t    str = \"**\";\n\t    break;\n\t  case MATCH_DIR:\n\t    str = \"\";\n\t    break;\n\t  default:\n\t    str = p->str;\n\t    if (!str) continue;\n\t}\n\tif (!path) {\n\t    path_len = strlen(str);\n\t    path = GLOB_ALLOC_N(char, path_len + 1);\n\t    memcpy(path, str, path_len);\n\t    path[path_len] = '\\0';\n        }\n        else {\n\t    size_t len = strlen(str);\n\t    char *tmp;\n\t    tmp = GLOB_REALLOC(path, path_len + len + 2);\n\t    if (tmp) {\n\t\tpath = tmp;\n\t\tpath[path_len++] = '/';\n\t\tmemcpy(path + path_len, str, len);\n\t\tpath_len += len;\n\t\tpath[path_len] = '\\0';\n\t    }\n\t}\n    }\n    return path;\n}", "target": 0}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void FetchManager::Loader::Start() {\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(execution_context_) &&\n      !execution_context_->GetContentSecurityPolicy()->AllowConnectToSource(\n          fetch_request_data_->Url())) {\n    PerformNetworkError(\n        \"Refused to connect to '\" + fetch_request_data_->Url().ElidedString() +\n        \"' because it violates the document's Content Security Policy.\");\n    return;\n  }\n  if ((SecurityOrigin::Create(fetch_request_data_->Url())\n           ->IsSameSchemeHostPort(fetch_request_data_->Origin().get())) ||\n      (fetch_request_data_->Url().ProtocolIsData() &&\n       fetch_request_data_->SameOriginDataURLFlag()) ||\n      (fetch_request_data_->Mode() == FetchRequestMode::kNavigate)) {\n    PerformSchemeFetch();\n    return;\n  }\n  if (fetch_request_data_->Mode() == FetchRequestMode::kSameOrigin) {\n    PerformNetworkError(\"Fetch API cannot load \" +\n                        fetch_request_data_->Url().GetString() +\n                        \". Request mode is \\\"same-origin\\\" but the URL\\'s \"\n                        \"origin is not same as the request origin \" +\n                        fetch_request_data_->Origin()->ToString() + \".\");\n    return;\n  }\n   if (fetch_request_data_->Mode() == FetchRequestMode::kNoCORS) {\n     fetch_request_data_->SetResponseTainting(FetchRequestData::kOpaqueTainting);\n    PerformSchemeFetch();\n    return;\n  }\n  if (!SchemeRegistry::ShouldTreatURLSchemeAsSupportingFetchAPI(\n          fetch_request_data_->Url().Protocol())) {\n    PerformNetworkError(\n        \"Fetch API cannot load \" + fetch_request_data_->Url().GetString() +\n        \". URL scheme must be \\\"http\\\" or \\\"https\\\" for CORS request.\");\n    return;\n  }\n  fetch_request_data_->SetResponseTainting(FetchRequestData::kCORSTainting);\n  PerformHTTPFetch();\n}", "target": 1}
{"code": "void RenderThreadImpl::Shutdown() {\n  FOR_EACH_OBSERVER(\n      RenderProcessObserver, observers_, OnRenderProcessShutdown());\n  ChildThread::Shutdown();\n  if (memory_observer_) {\n    message_loop()->RemoveTaskObserver(memory_observer_.get());\n    memory_observer_.reset();\n  }\n  if (webkit_platform_support_) {\n    WebView::willEnterModalLoop();\n    webkit_platform_support_->web_database_observer_impl()->\n        WaitForAllDatabasesToClose();\n    WebView::didExitModalLoop();\n  }\n  if (devtools_agent_message_filter_.get()) {\n    RemoveFilter(devtools_agent_message_filter_.get());\n    devtools_agent_message_filter_ = NULL;\n  }\n  RemoveFilter(audio_input_message_filter_.get());\n  audio_input_message_filter_ = NULL;\n#if defined(ENABLE_WEBRTC)\n  RTCPeerConnectionHandler::DestructAllHandlers();\n  peer_connection_factory_.reset();\n#endif\n  RemoveFilter(vc_manager_->video_capture_message_filter());\n  vc_manager_.reset();\n  RemoveFilter(db_message_filter_.get());\n  db_message_filter_ = NULL;\n  if (file_thread_)\n    file_thread_->Stop();\n  if (compositor_output_surface_filter_.get()) {\n    RemoveFilter(compositor_output_surface_filter_.get());\n    compositor_output_surface_filter_ = NULL;\n  }\n  media_thread_.reset();\n  RemoveFilter(audio_message_filter_.get());\n  audio_message_filter_ = NULL;\n  compositor_thread_.reset();\n  input_handler_manager_.reset();\n  if (input_event_filter_.get()) {\n    RemoveFilter(input_event_filter_.get());\n    input_event_filter_ = NULL;\n  }\n  embedded_worker_dispatcher_.reset();\n  main_thread_indexed_db_dispatcher_.reset();\n  main_thread_compositor_task_runner_ = NULL;\n  main_message_loop_.reset();\n  if (webkit_platform_support_)\n    blink::shutdown();\n  lazy_tls.Pointer()->Set(NULL);\n#if defined(OS_WIN)\n  NPChannelBase::CleanupChannels();\n#endif\n}", "target": 0}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "incomplete_transaction_log(uschar *what)\n{\nif (sender_address == NULL ||                 \n    !LOGGING(smtp_incomplete_transaction))\n  return;\nif (recipients_count > 0)\n  {\n  int i;\n  raw_recipients = store_get(recipients_count * sizeof(uschar *));\n  for (i = 0; i < recipients_count; i++)\n    raw_recipients[i] = recipients_list[i].address;\n  raw_recipients_count = recipients_count;\n  }\nlog_write(L_smtp_incomplete_transaction, LOG_MAIN|LOG_SENDER|LOG_RECIPIENTS,\n  \"%s incomplete transaction (%s)\", host_and_ident(TRUE), what);\n}", "target": 0}
{"code": "void CredentialManagerImpl::OnProvisionalSaveComplete() {\n  DCHECK(form_manager_);\n  DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());\n  const autofill::PasswordForm& form = form_manager_->pending_credentials();\n  if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {\n    form_manager_->Save();\n    return;\n  }\n  if (!form.federation_origin.unique()) {\n    for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {\n      if (match->username_value == form.username_value &&\n          match->federation_origin.IsSameOriginWith(form.federation_origin)) {\n        form_manager_->Update(*match);\n        return;\n      }\n    }\n  } else if (!form_manager_->IsNewLogin()) {\n    form_manager_->Update(*form_manager_->preferred_match());\n     return;\n   }\n  client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);\n}", "target": 1}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "ChooserContextBase::GetGrantedObjects(const GURL& requesting_origin,\n                                      const GURL& embedding_origin) {\n  DCHECK_EQ(requesting_origin, requesting_origin.GetOrigin());\n  DCHECK_EQ(embedding_origin, embedding_origin.GetOrigin());\n  if (!CanRequestObjectPermission(requesting_origin, embedding_origin))\n     return {};\n   std::vector<std::unique_ptr<Object>> results;\n  auto* info = new content_settings::SettingInfo();\n   std::unique_ptr<base::DictionaryValue> setting =\n      GetWebsiteSetting(requesting_origin, embedding_origin, info);\n   std::unique_ptr<base::Value> objects;\n   if (!setting->Remove(kObjectListKey, &objects))\n     return results;\n  std::unique_ptr<base::ListValue> object_list =\n      base::ListValue::From(std::move(objects));\n  if (!object_list)\n    return results;\n  for (auto& object : *object_list) {\n     base::DictionaryValue* object_dict;\n     if (object.GetAsDictionary(&object_dict) && IsValidObject(*object_dict)) {\n       results.push_back(std::make_unique<Object>(\n          requesting_origin, embedding_origin, object_dict, info->source,\n           host_content_settings_map_->is_incognito()));\n     }\n   }\n  return results;\n}", "target": 1}
{"code": "void http_capture_bad_message(struct error_snapshot *es, struct session *s,\n                              struct buffer *buf, struct http_msg *msg,\n\t\t\t      int state, struct proxy *other_end)\n{\n\tif (buf->r <= (buf->data + msg->som)) { \n\t\tint len1 = buf->size - msg->som;\n\t\tes->len = buf->r - (buf->data + msg->som) + buf->size;\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(len1, sizeof(es->buf)));\n\t\tif (es->len > len1 && len1 < sizeof(es->buf))\n\t\t\tmemcpy(es->buf + len1, buf->data, MIN(es->len, sizeof(es->buf)) - len1);\n\t}\n\telse {\n\t\tes->len = buf->r - (buf->data + msg->som);\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(es->len, sizeof(es->buf)));\n\t}\n\tif (msg->err_pos >= 0)\n\t\tes->pos  = msg->err_pos - msg->som;\n\telse if (buf->lr >= (buf->data + msg->som))\n\t\tes->pos  = buf->lr - (buf->data + msg->som);\n\telse\n\t\tes->pos  = buf->lr - (buf->data + msg->som) + buf->size;\n\tes->when = date; \n\tes->sid  = s->uniq_id;\n\tes->srv  = s->srv;\n\tes->oe   = other_end;\n\tes->src  = s->cli_addr;\n\tes->state = state;\n\tes->flags = buf->flags;\n\tes->ev_id = error_snapshot_id++;\n}", "target": 0}
{"code": "PHP_MINIT_FUNCTION(spl_heap) \n{\n\tREGISTER_SPL_STD_CLASS_EX(SplHeap, spl_heap_object_new, spl_funcs_SplHeap);\n\tmemcpy(&spl_handler_SplHeap, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplHeap.clone_obj      = spl_heap_object_clone;\n\tspl_handler_SplHeap.count_elements = spl_heap_object_count_elements;\n\tspl_handler_SplHeap.get_debug_info = spl_heap_object_get_debug_info;\n\tREGISTER_SPL_IMPLEMENTS(SplHeap, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplHeap, Countable);\n\tspl_ce_SplHeap->get_iterator = spl_heap_get_iterator;\n\tREGISTER_SPL_SUB_CLASS_EX(SplMinHeap,           SplHeap,        spl_heap_object_new, spl_funcs_SplMinHeap);\n\tREGISTER_SPL_SUB_CLASS_EX(SplMaxHeap,           SplHeap,        spl_heap_object_new, spl_funcs_SplMaxHeap);\n\tspl_ce_SplMaxHeap->get_iterator = spl_heap_get_iterator;\n\tspl_ce_SplMinHeap->get_iterator = spl_heap_get_iterator;\n\tREGISTER_SPL_STD_CLASS_EX(SplPriorityQueue, spl_heap_object_new, spl_funcs_SplPriorityQueue);\n\tmemcpy(&spl_handler_SplPriorityQueue, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplPriorityQueue.clone_obj      = spl_heap_object_clone;\n\tspl_handler_SplPriorityQueue.count_elements = spl_heap_object_count_elements;\n\tspl_handler_SplPriorityQueue.get_debug_info = spl_pqueue_object_get_debug_info;\n\tREGISTER_SPL_IMPLEMENTS(SplPriorityQueue, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplPriorityQueue, Countable);\n\tspl_ce_SplPriorityQueue->get_iterator = spl_pqueue_get_iterator;\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_BOTH\",      SPL_PQUEUE_EXTR_BOTH);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_PRIORITY\",  SPL_PQUEUE_EXTR_PRIORITY);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_DATA\",      SPL_PQUEUE_EXTR_DATA);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": " HarfBuzzShaperBase::HarfBuzzShaperBase(const Font* font, const TextRun& run)\n     : m_font(font)\n     , m_run(run)\n     , m_wordSpacingAdjustment(font->wordSpacing())\n     , m_letterSpacing(font->letterSpacing())\n {\n }", "target": 1}
{"code": "static int fib6_remove_prefsrc(struct rt6_info *rt, void *arg)\n{\n\tstruct net_device *dev = ((struct arg_dev_net_ip *)arg)->dev;\n\tstruct net *net = ((struct arg_dev_net_ip *)arg)->net;\n\tstruct in6_addr *addr = ((struct arg_dev_net_ip *)arg)->addr;\n\tif (((void *)rt->dst.dev == dev || !dev) &&\n\t    rt != net->ipv6.ip6_null_entry &&\n\t    ipv6_addr_equal(addr, &rt->rt6i_prefsrc.addr)) {\n\t\trt->rt6i_prefsrc.plen = 0;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\treturn ser_to_dev(synth->ser, dev_no);\n}", "target": 0}
{"code": "der_to_ldap_BitString (struct berval *berValue,\n                                   struct berval *ldapValue)\n{\n\tber_len_t bitPadding=0;\n\tber_len_t bits, maxBits;\n\tchar *tmpStr;\n\tunsigned char byte;\n\tber_len_t bitLength;\n\tber_len_t valLen;\n\tunsigned char* valPtr;\n\tldapValue->bv_len=0;\n\tldapValue->bv_val=NULL;\n\tvalLen=berValue->bv_len;\n\tvalPtr=(unsigned char*)berValue->bv_val;\n\tif (valLen) {\n\t\tbitPadding=(ber_len_t)(valPtr[0]);\n\t\tvalLen--;\n\t\tvalPtr++;\n\t}\n\tif (bitPadding >= BITS_PER_BYTE) {\n\t\tif (valLen*BITS_PER_BYTE > bitPadding ) {\n\t\t\tvalLen-=(bitPadding/BITS_PER_BYTE);\n\t\t\tbitPadding%=BITS_PER_BYTE;\n\t\t} else {\n\t\t\tvalLen=0;\n\t\t\tbitPadding=0;\n\t\t}\n\t}\n\tif (valLen*BITS_PER_BYTE < bitPadding ) {\n\t\tbitPadding=0;\n\t\tvalLen=0;\n\t}\n\tbitLength=valLen*BITS_PER_BYTE-bitPadding;\n\ttmpStr=LDAP_MALLOC(bitLength + STR_OVERHEAD + 1);\n\tif (!tmpStr)\n\t\treturn LDAP_NO_MEMORY;\n\tldapValue->bv_val=tmpStr;\n\tldapValue->bv_len=bitLength + STR_OVERHEAD;\n\tmaxBits=BITS_PER_BYTE;\n\t*tmpStr++ ='\\'';\n\twhile(valLen) {\n\t\tbyte=*valPtr;\n\t\tif (valLen==1)\n\t\t\tmaxBits-=bitPadding;\n\t\tfor (bits=0; bits<maxBits; bits++) {\n\t\t\tif (0x80 & byte)\n\t\t\t\t*tmpStr='1';\n\t\t\telse\n\t\t\t\t*tmpStr='0';\n\t\t\ttmpStr++;\n\t\t\tbyte<<=1;\n\t\t}\n\t\tvalPtr++;\n\t\tvalLen--;\n\t}\n\t*tmpStr++ ='\\'';\n\t*tmpStr++ ='B';\n\t*tmpStr=0;\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, FailGracefullyOnInvalidExpression) {\n    ASSERT_THROWS_CODE(createMatcher(fromjson(\"{$expr: {$anyElementTrue: undefined}}\")),\n                       AssertionException,\n                       17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$and: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$or: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$nor: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "SPL_API int spl_hash_verify_pos(spl_array_object * intern TSRMLS_DC) \n{\n\tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\treturn spl_hash_verify_pos_ex(intern, ht TSRMLS_CC);\n}", "target": 0}
{"code": "static void encode_setattr(struct xdr_stream *xdr, const struct nfs_setattrargs *arg, const struct nfs_server *server, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_SETATTR, decode_setattr_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, &arg->stateid);\n\tencode_attrs(xdr, arg->iap, server);\n}", "target": 0}
{"code": "snmp_oid_encode_oid(unsigned char *out, uint32_t *out_len, uint32_t *oid)\n{\n  uint32_t original_out_len;\n  uint32_t *oid_start = oid;\n  uint32_t num;\n  original_out_len = *out_len;\n  while(*oid != ((uint32_t)-1)) {\n    ++oid;\n  }\n  --oid;\n  while(oid != oid_start) {\n    num = *oid;\n    (*out_len)++;\n    *out-- = (uint8_t)(num & 0x7F);\n    num >>= 7;\n    while(num) {\n      (*out_len)++;\n      *out-- = (uint8_t)((num & 0x7F) | 0x80);\n      num >>= 7;\n    }\n    --oid;\n  }\n  num = *(out + 1) + 40 * *oid;\n  (*out_len)--;\n  out++;\n  (*out_len)++;\n  *out-- = (uint8_t)(num & 0x7F);\n  num >>= 7;\n  while(num) {\n    (*out_len)++;\n    *out-- = (uint8_t)((num & 0x7F) | 0x80);\n    num >>= 7;\n  }\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, SNMP_DATA_TYPE_OBJECT);\n  return out;\n}", "target": 1}
{"code": "static irqreturn_t xennet_tx_interrupt(int irq, void *dev_id)\n{\n\tunsigned int eoiflag = XEN_EOI_FLAG_SPURIOUS;\n\tif (likely(xennet_handle_tx(dev_id, &eoiflag)))\n\t\txen_irq_lateeoi(irq, eoiflag);\n\treturn IRQ_HANDLED;\n}", "target": 0}
{"code": "static gboolean discover_timeout(gpointer user_data)\n{\n\tGDHCPClient *dhcp_client = user_data;\n\tdhcp_client->retry_times++;\n\tg_dhcp_client_start(dhcp_client, NULL);\n\treturn FALSE;\n}", "target": 0}
{"code": "static WERROR dcesrv_DnssrvComplexOperation(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct DnssrvComplexOperation *r)\n{\n\tstruct dnsserver_state *dsstate;\n\tstruct dnsserver_zone *z;\n\tWERROR ret;\n\tZERO_STRUCTP(r->out.pdwTypeOut);\n\tZERO_STRUCTP(r->out.ppDataOut);\n\tif ((dsstate = dnsserver_connect(dce_call)) == NULL) {\n\t\treturn WERR_DNS_ERROR_DS_UNAVAILABLE;\n\t}\n\tif (r->in.pszZone == NULL) {\n\t\tret = dnsserver_complex_operate_server(dsstate, mem_ctx,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t} else {\n\t\tz = dnsserver_find_zone(dsstate->zones, r->in.pszZone);\n\t\tif (z == NULL) {\n\t\t\treturn WERR_DNS_ERROR_ZONE_DOES_NOT_EXIST;\n\t\t}\n\t\tret = dnsserver_complex_operate_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t}\n\tif (W_ERROR_EQUAL(ret, WERR_CALL_NOT_IMPLEMENTED)) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(DnssrvComplexOperation, NDR_IN, r);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 1}
{"code": "static int __iommu_calculate_agaw(struct intel_iommu *iommu, int max_gaw)\n{\n\tunsigned long sagaw;\n\tint agaw = -1;\n\tsagaw = cap_sagaw(iommu->cap);\n\tfor (agaw = width_to_agaw(max_gaw);\n\t     agaw >= 0; agaw--) {\n\t\tif (test_bit(agaw, &sagaw))\n\t\t\tbreak;\n\t}\n\treturn agaw;\n}", "target": 0}
{"code": "static void session_init_control(struct avrcp *session)\n{\n\tsession->passthrough_id = avctp_register_passthrough_handler(\n\t\t\t\t\t\t\tsession->conn,\n\t\t\t\t\t\t\thandle_passthrough,\n\t\t\t\t\t\t\tsession);\n\tsession->passthrough_handlers = passthrough_handlers;\n\tsession->control_id = avctp_register_pdu_handler(session->conn,\n\t\t\t\t\t\t\tAVC_OP_VENDORDEP,\n\t\t\t\t\t\t\thandle_vendordep_pdu,\n\t\t\t\t\t\t\tsession);\n\tsession->control_handlers = control_handlers;\n\tif (btd_device_get_service(session->dev, AVRCP_TARGET_UUID) != NULL)\n\t\tcontroller_init(session);\n\tif (btd_device_get_service(session->dev, AVRCP_REMOTE_UUID) != NULL)\n\t\ttarget_init(session);\n}", "target": 0}
{"code": "irc_nick_nicklist_remove (struct t_irc_server *server,\n                          struct t_irc_channel *channel,\n                          struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    weechat_nicklist_remove_nick (channel->buffer,\n                                  weechat_nicklist_search_nick (channel->buffer,\n                                                                ptr_group,\n                                                                nick->name));\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "MP4::Properties::length() const\n{\n  return d->length;\n}", "target": 0}
{"code": "static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\tif (dev != loopback_dev) {\n\t\tif (idev && idev->dev == dev) {\n\t\t\tstruct inet6_dev *loopback_idev =\n\t\t\t\tin6_dev_get(loopback_dev);\n\t\t\tif (loopback_idev) {\n\t\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t}\n\t\tif (rt->n && rt->n->dev == dev) {\n\t\t\trt->n->dev = loopback_dev;\n\t\t\tdev_hold(loopback_dev);\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n}", "target": 0}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n     point = (Int)args[0];\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n     {\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }", "target": 1}
{"code": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; \n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else \n            c+= sprintf(&str[c], \"   \");\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) \n                    str[c++] = ' ';\n                else if(isprint(mem[j])) \n                    str[c++] = 0xFF & mem[j];\n                else \n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}", "target": 1}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static void move_huge_pte(struct vm_area_struct *vma, unsigned long old_addr,\n\t\t\t  unsigned long new_addr, pte_t *src_pte)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpte_t *dst_pte, pte;\n\tspinlock_t *src_ptl, *dst_ptl;\n\tdst_pte = huge_pte_offset(mm, new_addr, huge_page_size(h));\n\tdst_ptl = huge_pte_lock(h, mm, dst_pte);\n\tsrc_ptl = huge_pte_lockptr(h, mm, src_pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_lock_nested(src_ptl, SINGLE_DEPTH_NESTING);\n\tpte = huge_ptep_get_and_clear(mm, old_addr, src_pte);\n\tset_huge_pte_at(mm, new_addr, dst_pte, pte);\n\tif (src_ptl != dst_ptl)\n\t\tspin_unlock(src_ptl);\n\tspin_unlock(dst_ptl);\n}", "target": 0}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "PHP_FUNCTION(class_parents)\n{\n\tzval *obj;\n\tzend_class_entry *parent_class, *ce;\n\tzend_bool autoload = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|b\", &obj, &autoload) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (Z_TYPE_P(obj) != IS_OBJECT && Z_TYPE_P(obj) != IS_STRING) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"object or string expected\");\n\t\tRETURN_FALSE;\n\t}\n\tif (Z_TYPE_P(obj) == IS_STRING) {\n\t\tif (NULL == (ce = spl_find_ce_by_name(Z_STRVAL_P(obj), Z_STRLEN_P(obj), autoload TSRMLS_CC))) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tce = Z_OBJCE_P(obj);\n\t}\n\tarray_init(return_value);\n\tparent_class = ce->parent;\n\twhile (parent_class) {\n\t\tspl_add_class_name(return_value, parent_class, 0, 0 TSRMLS_CC);\n\t\tparent_class = parent_class->parent;\n\t}\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_setclientid_confirm(struct rpc_rqst *req,\n\t\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t\t     struct nfs4_setclientid_res *arg)\n{\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\tconst u32 lease_bitmap[3] = { FATTR4_WORD0_LEASE_TIME };\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_setclientid_confirm(xdr, arg, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_fsinfo(xdr, lease_bitmap, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "static int fts3ContentColumns(\n  sqlite3 *db,                    \n  const char *zDb,                \n  const char *zTbl,               \n  const char ***pazCol,           \n  int *pnCol,                     \n  int *pnStr                      \n){\n  int rc = SQLITE_OK;             \n  char *zSql;                       \n  sqlite3_stmt *pStmt = 0;        \n  zSql = sqlite3_mprintf(\"SELECT * FROM %Q.%Q\", zDb, zTbl);\n  if( !zSql ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);\n  }\n  sqlite3_free(zSql);\n  if( rc==SQLITE_OK ){\n    const char **azCol;           \n    int nStr = 0;                 \n    int nCol;                     \n    int i;                        \n    nCol = sqlite3_column_count(pStmt);\n    for(i=0; i<nCol; i++){\n      const char *zCol = sqlite3_column_name(pStmt, i);\n      nStr += (int)strlen(zCol) + 1;\n    }\n    azCol = (const char **)sqlite3_malloc(sizeof(char *) * nCol + nStr);\n    if( azCol==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      char *p = (char *)&azCol[nCol];\n      for(i=0; i<nCol; i++){\n        const char *zCol = sqlite3_column_name(pStmt, i);\n        int n = (int)strlen(zCol)+1;\n        memcpy(p, zCol, n);\n        azCol[i] = p;\n        p += n;\n      }\n    }\n    sqlite3_finalize(pStmt);\n    *pnCol = nCol;\n    *pnStr = nStr;\n    *pazCol = azCol;\n  }\n  return rc;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_assert(pj_cis_match(spec,0)==0);\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "HttpStateData::getMoreRequestBody(MemBuf &buf)\n{\n    if (!flags.chunked_request)\n        return Client::getMoreRequestBody(buf);\n    MemBuf raw;\n    Must(requestBodySource != NULL);\n    if (!requestBodySource->getMoreData(raw))\n        return false; \n    const mb_size_t rawDataSize = raw.contentSize();\n    buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);\n    buf.appendf(\"%x\\r\\n\", static_cast<unsigned int>(rawDataSize));\n    buf.append(raw.content(), rawDataSize);\n    buf.append(\"\\r\\n\", 2);\n    Must(rawDataSize > 0); \n    if (receivedWholeRequestBody) {\n        Must(!flags.sentLastChunk);\n        flags.sentLastChunk = true;\n        buf.append(\"0\\r\\n\\r\\n\", 5);\n    }\n    return true;\n}", "target": 0}
{"code": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}", "target": 1}
{"code": "void LibRaw::adjust_bl()\n{\n  int clear_repeat=0;\n   if (O.user_black >= 0) \n     {\n       C.black = O.user_black;\n       clear_repeat = 1;\n     }\n   for(int i=0; i<4; i++)\n     if(O.user_cblack[i]>-1000000)\n       {\n         C.cblack[i] = O.user_cblack[i];\n         clear_repeat  = 1;\n       }\n   if(clear_repeat)\n     C.cblack[4]=C.cblack[5]=0;\n   if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n   else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n  int i = C.cblack[3];\n  int c;\n  for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];\n  for(c=0;c<4;c++) C.cblack[c] -= i; \n  C.black += i;\n  if(C.cblack[4] && C.cblack[5])\n    {\n      i = C.cblack[6];\n      for(c=1; c<C.cblack[4]*C.cblack[5]; c++)\n        if(i>C.cblack[6+c]) i = C.cblack[6+c];\n      int nonz=0;\n      for(c=0; c<C.cblack[4]*C.cblack[5]; c++)\n        {\n          C.cblack[6+c]-=i;\n          if(C.cblack[6+c])nonz++;\n        }\n      C.black +=i;\n      if(!nonz)\n        C.cblack[4] = C.cblack[5] = 0;\n    }\n  for(c=0;c<4;c++) C.cblack[c] += C.black; \n}", "target": 0}
{"code": "    void RafImage::setIptcData(const IptcData& )\n    {\n        throw(Error(kerInvalidSettingForImage, \"IPTC metadata\", \"RAF\"));\n    }", "target": 0}
{"code": "static void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb->destructor = sctp_control_release_owner;\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "prompt_text(void)\n{\n    if (curbuf->b_prompt_text == NULL)\n\treturn (char_u *)\"% \";\n    return curbuf->b_prompt_text;\n}", "target": 0}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n \t    return(-1);\t\n \tND_TCHECK2(*s, 1);\n \ts += (*s) + 1;\n     }\n     return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 1}
{"code": "void iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  int len = snprintf(buf, 64, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { \n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}", "target": 1}
{"code": "    Image::UniquePtr ImageFactory::create(ImageType type,\n                                        const std::wstring& wpath)\n    {\n        std::unique_ptr<FileIo> fileIo(new FileIo(wpath));\n        if (fileIo->open(\"w+b\") != 0) {\n            throw WError(kerFileOpenFailed, wpath, \"w+b\", strError().c_str());\n        }\n        fileIo->close();\n        BasicIo::UniquePtr io(std::move(fileIo));\n        Image::UniquePtr image = create(type, std::move(io));\n        if (image.get() == 0) throw Error(kerUnsupportedImageType, static_cast<int>(type));\n        return image;\n    }", "target": 0}
{"code": "void _WM_do_meta_sequenceno(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "target": 0}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}", "target": 1}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "int tm_adopt(\n  char  *id,\n  int    adoptCmd,\n  pid_t  pid)\n  {\n  int rc = TM_SUCCESS;\n  int status, ret;\n  pid_t sid;\n  char *env;\n  struct tcp_chan *chan = NULL;\n  sid = getsid(pid);\n  if (init_done) return TM_BADINIT;\n  init_done = 1;\n  if ((tm_jobid = getenv(\"PBS_JOBID\")) == NULL)\n    tm_jobid = (char *)\"ADOPT JOB\";\n  tm_jobid_len = strlen(tm_jobid);\n  if ((tm_jobcookie = getenv(\"PBS_JOBCOOKIE\")) == NULL)\n    tm_jobcookie = (char *)\"ADOPT COOKIE\";\n  tm_jobcookie_len = strlen(tm_jobcookie);\n  tm_jobndid = 0;\n  tm_jobtid = 0;\n  if ((env = getenv(\"PBS_MOMPORT\")) == NULL || (tm_momport = atoi(env)) == 0)\n    tm_momport = PBS_MANAGER_SERVICE_PORT;\n  if (adoptCmd != TM_ADOPT_ALTID && adoptCmd != TM_ADOPT_JOBID)\n    return TM_EUNKNOWNCMD;\n  if (startcom(adoptCmd, TM_NULL_EVENT, &chan) != DIS_SUCCESS)\n    return TM_ESYSTEM;\n  if (diswsi(chan, sid) != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswsi(chan, pid) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  if (diswcs(chan, id, strlen(id)) != DIS_SUCCESS)\n    {\n    rc =  TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  DIS_tcp_wflush(chan);\n  status = disrsi(chan, &ret);\n  if (ret != DIS_SUCCESS)\n    {\n    rc = TM_ENOTCONNECTED;\n    goto tm_adopt_cleanup;\n    }\n  tm_finalize();\n  if (local_conn > -1)\n    {\n    close(local_conn);\n    local_conn = -1;\n    }\n  DIS_tcp_cleanup(chan);\n  return (status == TM_OKAY ?\n          TM_SUCCESS :\n          TM_ENOTFOUND);\ntm_adopt_cleanup:\n  if (chan != NULL)\n    DIS_tcp_cleanup(chan);\n  return rc;\n  }", "target": 1}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "const char *get_errname_from_code(uint error_code)\n{\n  const char *name;\n  if ((name= get_errname_from_code(error_code, global_error_names)) !=\n      unknown_error)\n    return name;\n  return get_errname_from_code(error_code, handler_error_names);\n}", "target": 0}
{"code": "static void hci_sock_cmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\t__u32 mask = hci_pi(sk)->cmsg_mask;\n\tif (mask & HCI_CMSG_DIR) {\n\t\tint incoming = bt_cb(skb)->incoming;\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_DIR, sizeof(incoming),\n\t\t\t &incoming);\n\t}\n\tif (mask & HCI_CMSG_TSTAMP) {\n#ifdef CONFIG_COMPAT\n\t\tstruct compat_timeval ctv;\n#endif\n\t\tstruct timeval tv;\n\t\tvoid *data;\n\t\tint len;\n\t\tskb_get_timestamp(skb, &tv);\n\t\tdata = &tv;\n\t\tlen = sizeof(tv);\n#ifdef CONFIG_COMPAT\n\t\tif (!COMPAT_USE_64BIT_TIME &&\n\t\t    (msg->msg_flags & MSG_CMSG_COMPAT)) {\n\t\t\tctv.tv_sec = tv.tv_sec;\n\t\t\tctv.tv_usec = tv.tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n#endif\n\t\tput_cmsg(msg, SOL_HCI, HCI_CMSG_TSTAMP, len, data);\n\t}\n}", "target": 0}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "static int decode_attr_fsid(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_fsid *fsid)\n{\n\t__be32 *p;\n\tint ret = 0;\n\tfsid->major = 0;\n\tfsid->minor = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FSID - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FSID)) {\n\t\tp = xdr_inline_decode(xdr, 16);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tp = xdr_decode_hyper(p, &fsid->major);\n\t\txdr_decode_hyper(p, &fsid->minor);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FSID;\n\t\tret = NFS_ATTR_FATTR_FSID;\n\t}\n\tdprintk(\"%s: fsid=(0x%Lx/0x%Lx)\\n\", __func__,\n\t\t\t(unsigned long long)fsid->major,\n\t\t\t(unsigned long long)fsid->minor);\n\treturn ret;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n \tflush_altivec_to_thread(src);\n \tflush_vsx_to_thread(src);\n \tflush_spe_to_thread(src);\n \t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n     next_start_code_studio(gb);\n }", "target": 1}
{"code": "new_httpd(isc_httpdmgr_t *httpdmgr, isc_nmhandle_t *handle) {\n\tisc_httpd_t *httpd = NULL;\n\tchar *headerdata = NULL;\n\tREQUIRE(VALID_HTTPDMGR(httpdmgr));\n\thttpd = isc_nmhandle_getdata(handle);\n\tif (httpd == NULL) {\n\t\thttpd = isc_nmhandle_getextra(handle);\n\t\t*httpd = (isc_httpd_t){ .handle = NULL };\n\t\thttpdmgr_attach(httpdmgr, &httpd->mgr);\n\t}\n\tif (httpd->handle == NULL) {\n\t\tisc_nmhandle_setdata(handle, httpd, httpd_reset, httpd_put);\n\t\thttpd->handle = handle;\n\t} else {\n\t\tINSIST(httpd->handle == handle);\n\t}\n\theaderdata = isc_mem_get(httpdmgr->mctx, HTTP_SENDGROW);\n\tisc_buffer_init(&httpd->headerbuffer, headerdata, HTTP_SENDGROW);\n\tisc_buffer_clear(&httpd->headerbuffer);\n\tisc_buffer_initnull(&httpd->compbuffer);\n\tisc_buffer_clear(&httpd->compbuffer);\n\tisc_buffer_initnull(&httpd->bodybuffer);\n\tISC_LINK_INIT(httpd, link);\n\thttpd->magic = HTTPD_MAGIC;\n\thttpd->state = RECV;\n\tLOCK(&httpdmgr->lock);\n\tISC_LIST_APPEND(httpdmgr->running, httpd, link);\n\tUNLOCK(&httpdmgr->lock);\n\tisc_nmhandle_attach(httpd->handle, &httpd->readhandle);\n\tisc_nm_read(handle, httpd_request, httpdmgr);\n}", "target": 0}
{"code": "connection *connection_accept(server *srv, server_socket *srv_socket) {\n\tint cnt;\n\tsock_addr cnt_addr;\n\tsize_t cnt_len = sizeof(cnt_addr); \n\tif (srv->conns.used >= srv->max_conns) {\n\t\treturn NULL;\n\t}\n\tcnt = fdevent_accept_listenfd(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len);\n\tif (-1 == cnt) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n#if EWOULDBLOCK != EAGAIN\n\t\tcase EWOULDBLOCK:\n#endif\n\t\tcase EINTR:\n\t\tcase ECONNABORTED: \n\t\t\tbreak;\n\t\tcase EMFILE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_perror(srv->errh, __FILE__, __LINE__, \"accept failed\");\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\tif (sock_addr_get_family(&cnt_addr) != AF_UNIX) {\n\t\t\tnetwork_accept_tcp_nagle_disable(cnt);\n\t\t}\n\t\treturn connection_accepted(srv, srv_socket, &cnt_addr, cnt);\n\t}\n}", "target": 0}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)\n{\n    guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);\n    hashmanuf_t *manuf_value;\n    gchar *ret;\n    *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n    manuf_value = manuf_name_lookup(addr);\n    if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {\n        ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n    } else {\n        ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);\n    }\n    wmem_free(NULL, addr);\n    return ret;\n} ", "target": 1}
{"code": "yin_getplace_for_extcomplex_node(struct lyxml_elem *node, struct lys_ext_instance_complex *ext, LY_STMT stmt)\n{\n    struct lyext_substmt *info;\n    struct lys_node **snode, *siter;\n    snode = lys_ext_complex_get_substmt(stmt, ext, &info);\n    if (!snode) {\n        LOGVAL(ext->module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, node->name, node->parent->name);\n        return NULL;\n    }\n    if (info->cardinality < LY_STMT_CARD_SOME) {\n        LY_TREE_FOR(*snode, siter) {\n            if (stmt == lys_snode2stmt(siter->nodetype)) {\n                LOGVAL(ext->module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, node->name, node->parent->name);\n                return NULL;\n            }\n        }\n    }\n    return snode;\n}", "target": 0}
{"code": "static void test_prepare_insert_update()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  int        i;\n  const char *testcase[]= {\n    \"CREATE TABLE t1 (a INT, b INT, c INT, UNIQUE (A), UNIQUE(B))\",\n    \"INSERT t1 VALUES (1,2,10), (3,4,20)\",\n    \"INSERT t1 VALUES (5,6,30), (7,4,40), (8,9,60) ON DUPLICATE KEY UPDATE c=c+100\",\n    \"SELECT * FROM t1\",\n    \"INSERT t1 SET a=5 ON DUPLICATE KEY UPDATE b=0\",\n    \"SELECT * FROM t1\",\n    \"INSERT t1 VALUES (2,1,11), (7,4,40) ON DUPLICATE KEY UPDATE c=c+VALUES(a)\",\n    NULL};\n  const char **cur_query;\n  myheader(\"test_prepare_insert_update\");\n  for (cur_query= testcase; *cur_query; cur_query++)\n  {\n    char query[MAX_TEST_QUERY_LENGTH];\n    printf(\"\\nRunning query: %s\", *cur_query);\n    strmov(query, *cur_query);\n    stmt= mysql_simple_prepare(mysql, query);\n    check_stmt(stmt);\n    verify_param_count(stmt, 0);\n    rc= mysql_stmt_execute(stmt);\n    check_execute(stmt, rc);\n    if (!cur_query[1])\n    {\n      for (i=0; i < 3;i++)\n      {\n        printf(\"\\nExecuting last statement again\");\n        rc= mysql_stmt_execute(stmt);\n        check_execute(stmt, rc);\n        rc= mysql_stmt_execute(stmt);\n        check_execute(stmt, rc);\n      }\n    }\n    mysql_stmt_close(stmt);\n  }\n  rc= mysql_commit(mysql);\n  myquery(rc);\n}", "target": 0}
{"code": "int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\tpr_info(\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "SMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_flush_req *req;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\tunsigned int total_len;\n\tcifs_dbg(FYI, \"Flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t}\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}", "target": 1}
{"code": "void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {\n  if (!is_shared()) {\n    check_prohibited_package(name(), loader_data, CHECK);\n  }\n  if (is_shared() && _package_entry != NULL) {\n    if (MetaspaceShared::use_full_module_graph() && _package_entry == pkg_entry) {\n      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n      return;\n    } else {\n      _package_entry = NULL;\n    }\n  }\n  TempNewSymbol from_class_name =\n      (pkg_entry != NULL) ? NULL : ClassLoader::package_from_class_name(name());\n  Symbol* pkg_name;\n  if (pkg_entry != NULL) {\n    pkg_name = pkg_entry->name();\n  } else {\n    pkg_name = from_class_name;\n  }\n  if (pkg_name != NULL && loader_data != NULL) {\n    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n    if (_package_entry == NULL) {\n      if (!ModuleEntryTable::javabase_defined()) {\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n      DEBUG_ONLY(ResourceMark rm(THREAD));\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm(THREAD);\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm(THREAD);\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0}
{"code": "static void ide_atapi_cmd_reply(IDEState *s, int size, int max_size)\n{\n    if (size > max_size)\n        size = max_size;\n    s->lba = -1; \n    s->packet_transfer_size = size;\n    s->io_buffer_size = size;    \n    s->elementary_transfer_size = 0;\n    s->io_buffer_index = 0;\n    if (s->atapi_dma) {\n        bdrv_acct_start(s->bs, &s->acct, size, BDRV_ACCT_READ);\n        s->status = READY_STAT | SEEK_STAT | DRQ_STAT;\n        s->bus->dma->ops->start_dma(s->bus->dma, s,\n                                   ide_atapi_cmd_read_dma_cb);\n    } else {\n        s->status = READY_STAT | SEEK_STAT;\n        ide_atapi_cmd_reply_end(s);\n    }\n}", "target": 0}
{"code": "        std::string getExiv2ConfigPath()\n        {\n            std::string homedir;\n            std::string inifile;\n#if defined(_MSC_VER) || defined(__MINGW__)\n            char path[MAX_PATH];\n            if (SUCCEEDED(SHGetFolderPathA(nullptr, CSIDL_PROFILE, nullptr, 0, path))) {\n                homedir = std::string(path);\n                inifile = \"exiv2.ini\"      ;\n            }\n#else\n            struct passwd* pw = getpwuid(getuid());\n            homedir = std::string(pw?pw->pw_dir:\"\");\n            inifile = std::string(\".exiv2\");\n#endif\n            return homedir + EXV_SEPARATOR_CHR + inifile;\n        }", "target": 0}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "gst_mpegts_section_new (guint16 pid, guint8 * data, gsize data_size)\n{\n  GstMpegtsSection *res = NULL;\n  guint8 tmp;\n  guint8 table_id;\n  guint16 section_length;\n  section_length = GST_READ_UINT16_BE (data + 1) & 0x0FFF;\n  if (G_UNLIKELY (data_size < section_length + 3))\n    goto short_packet;\n  table_id = *data;\n  res = _gst_mpegts_section_init (pid, table_id);\n  res->data = data;\n  data++;\n  res->short_section = (*data & 0x80) == 0x00;\n  res->section_length = section_length + 3;\n  if (!res->short_section) {\n    res->crc = GST_READ_UINT32_BE (res->data + res->section_length - 4);\n    data += 2;\n    res->subtable_extension = GST_READ_UINT16_BE (data);\n    data += 2;\n    tmp = *data++;\n    res->version_number = tmp >> 1 & 0x1f;\n    res->current_next_indicator = tmp & 0x01;\n    res->section_number = *data++;\n    res->last_section_number = *data;\n  }\n  return res;\nshort_packet:\n  {\n    GST_WARNING\n        (\"PID 0x%04x section extends past provided data (got:%\" G_GSIZE_FORMAT\n        \", need:%d)\", pid, data_size, section_length + 3);\n    g_free (data);\n    return NULL;\n  }\n}", "target": 1}
{"code": "void SSH_Access::LogSSHMessage()\n{\n   const char *b;\n   int s;\n   pty_recv_buf->Get(&b,&s);\n   const char *eol=find_char(b,s,'\\n');\n   if(!eol)\n   {\n      if(pty_recv_buf->Eof())\n      {\n\t if(s>0)\n\t    LogRecv(4,b);\n\t LogError(0,_(\"Peer closed connection\"));\n      }\n      if(pty_recv_buf->Error())\n\t LogError(4,\"pty read: %s\",pty_recv_buf->ErrorText());\n      if(pty_recv_buf->Eof() || pty_recv_buf->Error()) {\n\t if(last_ssh_message && time_t(now)-last_ssh_message_time<4)\n\t    LogError(0,\"%s\",last_ssh_message.get());\n\t Disconnect(last_ssh_message);\n      }\n      return;\n   }\n   s=eol-b+1;\n   int chomp_cr=(s>=2 && b[s-2]=='\\r');\n   last_ssh_message.nset(b,s-1-chomp_cr);\n   last_ssh_message_time=now;\n   pty_recv_buf->Skip(s);\n   LogRecv(4,last_ssh_message);\n   if(last_ssh_message.begins_with(\"ssh: \"))\n      last_ssh_message.set(last_ssh_message+5);\n   if(!received_greeting && last_ssh_message.eq(greeting))\n      received_greeting=true;\n}", "target": 0}
{"code": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "static inline int http_parse_chunk_size(struct http_msg *msg)\n{\n\tconst struct buffer *buf = msg->chn->buf;\n\tconst char *ptr = b_ptr(buf, msg->next);\n\tconst char *ptr_old = ptr;\n\tconst char *end = buf->data + buf->size;\n\tconst char *stop = bi_end(buf);\n\tunsigned int chunk = 0;\n\twhile (1) {\n\t\tint c;\n\t\tif (ptr == stop)\n\t\t\treturn 0;\n\t\tc = hex2i(*ptr);\n\t\tif (c < 0) \n\t\t\tbreak;\n\t\tif (unlikely(++ptr >= end))\n\t\t\tptr = buf->data;\n\t\tif (chunk & 0xF8000000) \n\t\t\tgoto error;\n\t\tchunk = (chunk << 4) + c;\n\t}\n\tif (unlikely(ptr == ptr_old))\n\t\tgoto error;\n\twhile (http_is_spht[(unsigned char)*ptr]) {\n\t\tif (++ptr >= end)\n\t\t\tptr = buf->data;\n\t\tif (unlikely(ptr == stop))\n\t\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tif (likely(*ptr == '\\r')) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*ptr != '\\n')\n\t\t\t\tgoto error;\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*ptr == ';') {\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\t\t\twhile (!HTTP_IS_CRLF(*ptr)) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (unlikely(ptr < ptr_old))\n\t\tmsg->sov += buf->size;\n\tmsg->sov += ptr - ptr_old;\n\tmsg->next = buffer_count(buf, buf->p, ptr);\n\tmsg->chunk_len = chunk;\n\tmsg->body_len += chunk;\n\tmsg->msg_state = chunk ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\n\treturn 1;\n error:\n\tmsg->err_pos = buffer_count(buf, buf->p, ptr);\n\treturn -1;\n}", "target": 0}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,\n  const QuantumAny range)\n{\n  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));\n}", "target": 1}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": " DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)\n    : saml2md::DynamicMetadataProvider(e),\n         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),\n         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),\n         m_encoded(true), m_trust(nullptr)\n{\n    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);\n    if (child && child->hasChildNodes()) {\n        auto_ptr_char s(child->getFirstChild()->getNodeValue());\n        if (s.get() && *s.get()) {\n            m_subst = s.get();\n            m_encoded = XMLHelper::getAttrBool(child, true, encoded);\n            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);\n        }\n    }\n    if (m_subst.empty()) {\n        child = XMLHelper::getFirstChildElement(e, Regex);\n        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {\n            m_match = XMLHelper::getAttrString(child, nullptr, match);\n            auto_ptr_char repl(child->getFirstChild()->getNodeValue());\n            if (repl.get() && *repl.get())\n                m_regex = repl.get();\n        }\n    }\n    if (!m_ignoreTransport) {\n        child = XMLHelper::getFirstChildElement(e, _TrustEngine);\n        string t = XMLHelper::getAttrString(child, nullptr, _type);\n        if (!t.empty()) {\n            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);\n            if (!dynamic_cast<X509TrustEngine*>(trust)) {\n                delete trust;\n                throw ConfigurationException(\"DynamicMetadataProvider requires an X509TrustEngine plugin.\");\n            }\n            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));\n            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));\n        }\n        if (!m_trust.get() || !m_dummyCR.get())\n            throw ConfigurationException(\"DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true.\");\n    }\n}", "target": 1}
{"code": "static int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n  char\n    path[MagickPathExtent];\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}", "target": 0}
{"code": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}", "target": 1}
{"code": "  bool HasOverflowed() const {\n    StackGuard* stack_guard = isolate_->stack_guard();\n    return (reinterpret_cast<uintptr_t>(this) < stack_guard->climit()) &&\n           stack_guard->IsStackOverflow();\n  }", "target": 1}
{"code": "InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser& parser, TRAPS) {\n  const int size = InstanceKlass::size(parser.vtable_size(),\n                                       parser.itable_size(),\n                                       nonstatic_oop_map_size(parser.total_oop_map_count()),\n                                       parser.is_interface());\n  const Symbol* const class_name = parser.class_name();\n  assert(class_name != NULL, \"invariant\");\n  ClassLoaderData* loader_data = parser.loader_data();\n  assert(loader_data != NULL, \"invariant\");\n  InstanceKlass* ik;\n  if (REF_NONE == parser.reference_type()) {\n    if (class_name == vmSymbols::java_lang_Class()) {\n      ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n    }\n    else if (is_class_loader(class_name, parser)) {\n      ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n    } else {\n      ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);\n    }\n  } else {\n    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n  }\n  if (HAS_PENDING_EXCEPTION) {\n    return NULL;\n  }\n  return ik;\n}", "target": 0}
{"code": "static int do_one_set_err(struct sock *sk, struct netlink_set_err_data *p)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tint ret = 0;\n\tif (sk == p->exclude_sk)\n\t\tgoto out;\n\tif (!net_eq(sock_net(sk), sock_net(p->exclude_sk)))\n\t\tgoto out;\n\tif (nlk->portid == p->portid || p->group - 1 >= nlk->ngroups ||\n\t    !test_bit(p->group - 1, nlk->groups))\n\t\tgoto out;\n\tif (p->code == ENOBUFS && nlk->flags & NETLINK_F_RECV_NO_ENOBUFS) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tsk->sk_err = p->code;\n\tsk->sk_error_report(sk);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,\n\t\t\t const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\treturn -ENOPROTOOPT;\n}", "target": 0}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "TEST_F(HeaderToMetadataTest, BasicRequestDoubleHeadersTest) {\n  initializeFilter(request_config_yaml);\n  Http::TestRequestHeaderMapImpl incoming_headers{{\"X-VERSION\", \"foo\"}, {\"X-VERSION\", \"bar\"}};\n  std::map<std::string, std::string> expected = {{\"version\", \"foo,bar\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(\"envoy.lb\", MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(incoming_headers, false));\n  Http::MetadataMap metadata_map{{\"metadata\", \"metadata\"}};\n  EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->decodeMetadata(metadata_map));\n  Buffer::OwnedImpl data(\"data\");\n  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(data, false));\n  Http::TestRequestTrailerMapImpl incoming_trailers;\n  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(incoming_trailers));\n  filter_->onDestroy();\n}", "target": 0}
{"code": "static void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\tdisk_block_events(disk);\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}", "target": 0}
{"code": "close_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n \t\tpktinfo->ipi_ifindex = 0;\n \t\tpktinfo->ipi_spec_dst.s_addr = 0;\n \t}\n\tskb_dst_drop(skb);\n }", "target": 1}
{"code": "void *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr done = 0;\n    hwaddr l, xlat, base;\n    MemoryRegion *mr, *this_mr;\n    ram_addr_t raddr;\n    if (len == 0) {\n        return NULL;\n    }\n    l = len;\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            rcu_read_unlock();\n            return NULL;\n        }\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n        rcu_read_unlock();\n        *plen = l;\n        return bounce.buffer;\n    }\n    base = xlat;\n    raddr = memory_region_get_ram_addr(mr);\n    for (;;) {\n        len -= l;\n        addr += l;\n        done += l;\n        if (len == 0) {\n            break;\n        }\n        l = len;\n        this_mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            break;\n        }\n    }\n    memory_region_ref(mr);\n    rcu_read_unlock();\n    *plen = done;\n    return qemu_ram_ptr_length(raddr + base, plen);\n}", "target": 0}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "CellularNetwork::CellularNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  service_name_ = SafeString(service->name);\n  activation_state_ = service->activation_state;\n  network_technology_ = service->network_technology;\n  roaming_state_ = service->roaming_state;\n  restricted_pool_ = service->restricted_pool;\n  if (service->carrier_info) {\n    operator_name_ = SafeString(service->carrier_info->operator_name);\n    operator_code_ = SafeString(service->carrier_info->operator_code);\n    payment_url_ = SafeString(service->carrier_info->payment_url);\n  }\n  if (service->device_info) {\n    meid_ = SafeString(service->device_info->MEID);\n    imei_ = SafeString(service->device_info->IMEI);\n    imsi_ = SafeString(service->device_info->IMSI);\n    esn_ = SafeString(service->device_info->ESN);\n    mdn_ = SafeString(service->device_info->MDN);\n    min_ = SafeString(service->device_info->MIN);\n    model_id_ = SafeString(service->device_info->model_id);\n    manufacturer_ = SafeString(service->device_info->manufacturer);\n    firmware_revision_ = SafeString(service->device_info->firmware_revision);\n    hardware_revision_ = SafeString(service->device_info->hardware_revision);\n    last_update_ = SafeString(service->device_info->last_update);\n    prl_version_ = service->device_info->PRL_version;\n  }\n  type_ = TYPE_CELLULAR;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "    void Modify::delMetadatum(Exiv2::Image* pImage, const ModifyCmd& modifyCmd)\n    {\n        if (Params::instance().verbose_) {\n            std::cout << _(\"Del\") << \" \" << modifyCmd.key_ << std::endl;\n        }\n        Exiv2::ExifData& exifData = pImage->exifData();\n        Exiv2::IptcData& iptcData = pImage->iptcData();\n        Exiv2::XmpData& xmpData = pImage->xmpData();\n        if (modifyCmd.metadataId_ == exif) {\n            Exiv2::ExifData::iterator pos;\n            Exiv2::ExifKey exifKey = Exiv2::ExifKey(modifyCmd.key_);\n            while ((pos = exifData.findKey(exifKey)) != exifData.end()) {\n                exifData.erase(pos);\n            }\n        }\n        if (modifyCmd.metadataId_ == iptc) {\n            Exiv2::IptcData::iterator pos;\n            Exiv2::IptcKey iptcKey = Exiv2::IptcKey(modifyCmd.key_);\n            while ((pos = iptcData.findKey(iptcKey)) != iptcData.end()) {\n                iptcData.erase(pos);\n            }\n        }\n        if (modifyCmd.metadataId_ == xmp) {\n            Exiv2::XmpData::iterator pos;\n            Exiv2::XmpKey xmpKey = Exiv2::XmpKey(modifyCmd.key_);\n            if ((pos = xmpData.findKey(xmpKey)) != xmpData.end()) {\n                xmpData.eraseFamily(pos);\n            }\n        }\n    }", "target": 0}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "MagickExport MagickBooleanType GetImageEntropy(const Image *image,\n  double *entropy,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *entropy=channel_statistics[CompositePixelChannel].entropy;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}", "target": 0}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "uid_t session_info_uid_for_session(struct session_info *si, const char *session)\n{\n    uid_t ret = -1;\n    if (sd_session_get_uid(session, &ret) < 0) {\n        return -1;\n    }\n    return ret;\n}", "target": 0}
{"code": "void gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor || from->trueColor) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t}\n\tfor (y = 0; y < to->sy; y++) {\n\t\tfor (x = 0; x < to->sx; x++) {\n\t\t\tp = gdImageGetPixel(to, x, y);\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\txlate[p] = gdImageColorClosestAlpha (from, to->red[p], to->green[p], to->blue[p], to->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel(to, x, y, xlate[p]);\n\t\t}\n\t}\n\tfor (i = 0; i < from->colorsTotal; i++) {\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t}\n\tfor (i = from->colorsTotal; i < to->colorsTotal; i++) {\n\t\tto->open[i] = 1;\n\t}\n\tto->colorsTotal = from->colorsTotal;\n}", "target": 0}
{"code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }", "target": 1}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "swallow_until_crlf(int fd, uschar *base, int already, int capacity)\n{\nuschar *to = base + already;\nuschar *cr;\nint have = 0;\nint ret;\nint last = 0;\ncr = memchr(base, '\\r', already);\nif (cr != NULL)\n  {\n  if ((cr - base) < already - 1)\n    {\n    return 0;\n    }\n  last = 1;\n  }\nwhile (capacity > 0)\n  {\n  do { ret = recv(fd, to, 1, 0); } while (ret == -1 && errno == EINTR);\n  if (ret == -1)\n    return -1;\n  have++;\n  if (last)\n    return have;\n  if (*to == '\\r')\n    last = 1;\n  capacity--;\n  to++;\n  }\nerrno = EOVERFLOW;\nreturn -1;\n}", "target": 0}
{"code": "static void blk_mq_insert_requests(struct request_queue *q,\n\t\t\t\t     struct blk_mq_ctx *ctx,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     int depth,\n\t\t\t\t     bool from_schedule)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *current_ctx;\n\ttrace_block_unplug(q, depth, !from_schedule);\n\tcurrent_ctx = blk_mq_get_ctx(q);\n\tif (!cpu_online(ctx->cpu))\n\t\tctx = current_ctx;\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock(&ctx->lock);\n\twhile (!list_empty(list)) {\n\t\tstruct request *rq;\n\t\trq = list_first_entry(list, struct request, queuelist);\n\t\tlist_del_init(&rq->queuelist);\n\t\trq->mq_ctx = ctx;\n\t\t__blk_mq_insert_request(hctx, rq, false);\n\t}\n\tspin_unlock(&ctx->lock);\n\tblk_mq_run_hw_queue(hctx, from_schedule);\n\tblk_mq_put_ctx(current_ctx);\n}", "target": 0}
{"code": "init_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = join_session_keyring(name);\n error:\n\treturn ret;\n} ", "target": 1}
{"code": "DCTStream::DCTStream(Stream *strA, int colorXformA, Dict *dict, int recursion) : FilterStream(strA)\n{\n    colorXform = colorXformA;\n    if (dict != nullptr) {\n        Object obj = dict->lookup(\"Width\", recursion);\n        err.width = (obj.isInt() && obj.getInt() <= JPEG_MAX_DIMENSION) ? obj.getInt() : 0;\n        obj = dict->lookup(\"Height\", recursion);\n        err.height = (obj.isInt() && obj.getInt() <= JPEG_MAX_DIMENSION) ? obj.getInt() : 0;\n    } else\n        err.height = err.width = 0;\n    init();\n}", "target": 0}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "static int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *sr_skb;\n\tint len;\n\tif (unlikely(skb->len < SR_RX_OVERHEAD)) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\twhile (skb->len > SR_RX_OVERHEAD) {\n\t\tif (skb->data[0] != 0x40)\n\t\t\treturn 0;\n\t\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\t\tif (len > ETH_FRAME_LEN || len > skb->len)\n\t\t\treturn 0;\n\t\tif (skb->len == (len + SR_RX_OVERHEAD))\t{\n\t\t\tskb_pull(skb, 3);\n\t\t\tskb->len = len;\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tskb->truesize = len + sizeof(struct sk_buff);\n\t\t\treturn 2;\n\t\t}\n\t\tsr_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\t\tsr_skb->len = len;\n\t\tsr_skb->data = skb->data + 3;\n\t\tskb_set_tail_pointer(sr_skb, len);\n\t\tsr_skb->truesize = len + sizeof(struct sk_buff);\n\t\tusbnet_skb_return(dev, sr_skb);\n\t\tskb_pull(skb, len + SR_RX_OVERHEAD);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 1}
{"code": "void LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n    const QByteArray data = socket->readLine();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n    m_receivedIdentityPackets[socket].np = np;\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n        socket->startClientEncryption();\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}", "target": 1}
{"code": "newVar5(char *var,char *var2, char *var3,char *var4,char *var5)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; \n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(var5)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tstrcat(v->p.String,var5);\n\treturn v;\n}", "target": 0}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t             ret;\n    njs_value_t           *text, value, lvalue;\n    const u_char          *p, *end;\n    njs_json_parse_t      *parse, json_parse;\n    const njs_value_t     *reviver;\n    njs_string_prop_t     string;\n    njs_json_parse_ctx_t  ctx;\n    parse = &json_parse;\n    text = njs_lvalue_arg(&lvalue, args, nargs, 1);\n    if (njs_slow_path(!njs_is_string(text))) {\n        ret = njs_value_to_string(vm, text, text);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    (void) njs_string_prop(&string, text);\n    p = string.start;\n    end = p + string.size;\n    ctx.vm = vm;\n    ctx.pool = vm->mem_pool;\n    ctx.depth = NJS_JSON_MAX_DEPTH;\n    ctx.start = string.start;\n    ctx.end = end;\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p == end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected end of input\", p);\n        return NJS_ERROR;\n    }\n    p = njs_json_parse_value(&ctx, &value, p);\n    if (njs_slow_path(p == NULL)) {\n        return NJS_ERROR;\n    }\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p != end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected token\", p);\n        return NJS_ERROR;\n    }\n    reviver = njs_arg(args, nargs, 2);\n    if (njs_slow_path(njs_is_function(reviver) && njs_is_object(&value))) {\n        parse->function = njs_function(reviver);\n        parse->depth = 0;\n        return njs_json_parse_iterator(vm, parse, &value);\n    }\n    vm->retval = value;\n    return NJS_OK;\n}", "target": 1}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n \tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n \t\t\t\t\t  fm10k_driver_name);\n \tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 1}
{"code": " cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n        size_t count;\n        int m;\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                 return -2;\n                         break;\n                 }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n        m = cdf_file_property_info(ms, info, count, root_storage);\n         free(info);\n         return m == -1 ? -2 : m;\n}", "target": 0}
{"code": "static void encode_close(struct xdr_stream *xdr, const struct nfs_closeargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_CLOSE, decode_close_maxsz, hdr);\n\tencode_nfs4_seqid(xdr, arg->seqid);\n\tencode_nfs4_stateid(xdr, arg->stateid);\n}", "target": 0}
{"code": "aubio_filterbank_get_coeffs (const aubio_filterbank_t * f)\n{\n  return f->filters;\n}", "target": 0}
{"code": "static void flush_busy_ctxs(struct blk_mq_hw_ctx *hctx, struct list_head *list)\n{\n\tstruct blk_mq_ctx *ctx;\n\tint i;\n\tfor (i = 0; i < hctx->ctx_map.size; i++) {\n\t\tstruct blk_align_bitmap *bm = &hctx->ctx_map.map[i];\n\t\tunsigned int off, bit;\n\t\tif (!bm->word)\n\t\t\tcontinue;\n\t\tbit = 0;\n\t\toff = i * hctx->ctx_map.bits_per_word;\n\t\tdo {\n\t\t\tbit = find_next_bit(&bm->word, bm->depth, bit);\n\t\t\tif (bit >= bm->depth)\n\t\t\t\tbreak;\n\t\t\tctx = hctx->ctxs[bit + off];\n\t\t\tclear_bit(bit, &bm->word);\n\t\t\tspin_lock(&ctx->lock);\n\t\t\tlist_splice_tail_init(&ctx->rq_list, list);\n\t\t\tspin_unlock(&ctx->lock);\n\t\t\tbit++;\n\t\t} while (1);\n\t}\n}", "target": 0}
{"code": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)\n        continue;\n    if (i > INT_MAX/4)\n        goto err;\n    num = i + neg;\n    if (bn == NULL)\n        return (num);\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n    j = i;                      \n    m = 0;\n    h = 0;\n    while (j > 0) {\n        m = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            if ((c >= '0') && (c <= '9'))\n                k = c - '0';\n            else if ((c >= 'a') && (c <= 'f'))\n                k = c - 'a' + 10;\n            else if ((c >= 'A') && (c <= 'F'))\n                k = c - 'A' + 10;\n            else\n                k = 0;          \n            l = (l << 4) | k;\n            if (--m <= 0) {\n                ret->d[h++] = l;\n                break;\n            }\n        }\n        j -= (BN_BYTES * 2);\n    }\n    ret->top = h;\n    bn_correct_top(ret);\n    ret->neg = neg;\n    *bn = ret;\n    bn_check_top(ret);\n    return (num);\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return (0);\n}", "target": 0}
{"code": "win_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n}", "target": 0}
{"code": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  libraw_dng_stream(LibRaw_abstract_datastream *p)\n      : dng_stream((dng_abort_sniffer *)NULL, kBigBufferSize, 0),\n        parent_stream(p)\n  {\n    if (parent_stream)\n    {\n      off = parent_stream->tell();\n      parent_stream->seek(0UL, SEEK_SET); \n    }\n  }", "target": 0}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "header_match(uschar *name, BOOL has_addresses, BOOL cond, string_item *strings,\n  int count, ...)\n{\nva_list ap;\nstring_item *s;\nint i;\nint slen = Ustrlen(name);\nfor (s = strings; s != NULL; s = s->next)\n  {\n  if (one_pattern_match(name, slen, has_addresses, s->text)) return cond;\n  }\nva_start(ap, count);\nfor (i = 0; i < count; i++)\n  if (one_pattern_match(name, slen, has_addresses, va_arg(ap, uschar *)))\n    {\n    va_end(ap);\n    return cond;\n    }\nva_end(ap);\nreturn !cond;\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static const char *findattr(STANZA *s, const char *key)\n{\n    int i = s->numpairs;\n    PAIR *pp = s->pairs;\n    for ( ; --i >= 0; pp++)\n        if (strcasecmp(pp->key, key) == 0)\n            return pp->value;\n    return NULL;\n}", "target": 0}
{"code": "  char *strndup(const char *str, size_t size)\n  {\n    char *copy;\n    size_t len = strlen(str);\n    if (len > size)\n      len = size;\n    copy = (char *)REDIRECT_MALLOC(len + 1);\n    if (copy == NULL) {\n      errno = ENOMEM;\n      return NULL;\n    }\n    BCOPY(str, copy, len);\n    copy[len] = '\\0';\n    return copy;\n  }", "target": 0}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "redraw_buf_and_status_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n#ifdef FEAT_WILDMENU\n    if (wild_menu_showing != 0)\n\treturn;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    redraw_win_later(wp, type);\n\t    wp->w_redr_status = TRUE;\n\t}\n    }\n}", "target": 0}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n  hb_ot_layout_t *layout = &face->ot_layout;\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1}
{"code": "static void bnx2x_set_reset_done(struct bnx2x *bp)\n{\n\tu32 val;\n\tu32 bit = BP_PATH(bp) ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tval &= ~bit;\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}", "target": 0}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 1}
{"code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg, int off,\n\t\t\t       int size, bool strict_alignment_once)\n{\n\tbool strict = env->strict_alignment || strict_alignment_once;\n\tconst char *pointer_desc = \"\";\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_FLOW_KEYS:\n\t\tpointer_desc = \"flow keys \";\n\t\tbreak;\n\tcase PTR_TO_MAP_KEY:\n\t\tpointer_desc = \"key \";\n\t\tbreak;\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tstrict = true;\n\t\tbreak;\n\tcase PTR_TO_SOCKET:\n\t\tpointer_desc = \"sock \";\n\t\tbreak;\n\tcase PTR_TO_SOCK_COMMON:\n\t\tpointer_desc = \"sock_common \";\n\t\tbreak;\n\tcase PTR_TO_TCP_SOCK:\n\t\tpointer_desc = \"tcp_sock \";\n\t\tbreak;\n\tcase PTR_TO_XDP_SOCK:\n\t\tpointer_desc = \"xdp_sock \";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 0}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "kvm_pfn_t gfn_to_pfn_prot(struct kvm *kvm, gfn_t gfn, bool write_fault,\n\t\t      bool *writable)\n{\n\treturn __gfn_to_pfn_memslot(gfn_to_memslot(kvm, gfn), gfn, false, NULL,\n\t\t\t\t    write_fault, writable);\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}", "target": 0}
{"code": "void cql_server::response::write_string(std::string_view s)\n{\n    write_short(cast_if_fits<uint16_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "char* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; \n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}", "target": 0}
{"code": "PHP_FUNCTION(xml_parse_into_struct)\n{\n\txml_parser *parser;\n\tzval *pind, **xdata, **info = NULL;\n\tchar *data;\n\tint data_len, ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsZ|Z\", &pind, &data, &data_len, &xdata, &info) == FAILURE) {\n\t\treturn;\n\t}\n\tif (info) {\n\t\tzval_dtor(*info);\n\t\tarray_init(*info);\n\t}\n\tZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, \"XML Parser\", le_xml_parser);\n\tzval_dtor(*xdata);\n\tarray_init(*xdata);\n\tparser->data = *xdata;\n\tif (info) {\n\t\tparser->info = *info;\n\t}\n\tparser->level = 0;\n\tparser->ltags = safe_emalloc(XML_MAXLEVEL, sizeof(char *), 0);\n\tXML_SetDefaultHandler(parser->parser, _xml_defaultHandler);\n\tXML_SetElementHandler(parser->parser, _xml_startElementHandler, _xml_endElementHandler);\n\tXML_SetCharacterDataHandler(parser->parser, _xml_characterDataHandler);\n\tparser->isparsing = 1;\n\tret = XML_Parse(parser->parser, data, data_len, 1);\n\tparser->isparsing = 0;\n\tRETVAL_LONG(ret);\n}", "target": 0}
{"code": " void InputMethodBase::OnInputMethodChanged() const {\n   TextInputClient* client = GetTextInputClient();\n  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)\n     client->OnInputMethodChanged();\n }", "target": 1}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (from_ap && reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, GFP_KERNEL);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static int backref_match_at_nested_level(regex_t* reg,\n\t OnigStackType* top, OnigStackType* stk_base,\n\t int ignore_case, int case_fold_flag,\n\t int nest, int mem_num, UChar* memp, UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  OnigStackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n\tif (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n\t  pstart = k->u.mem.pstr;\n\t  if (pend != NULL_UCHARP) {\n\t    if (pend - pstart > send - *s) return 0; \n\t    p  = pstart;\n\t    ss = *s;\n\t    if (ignore_case != 0) {\n\t      if (string_cmp_ic(reg->enc, case_fold_flag,\n\t\t\t\tpstart, &ss, pend - pstart, send) == 0)\n\t\treturn 0; \n\t    }\n\t    else {\n\t      while (p < pend) {\n\t\tif (*p++ != *ss++) return 0; \n\t      }\n\t    }\n\t    *s = ss;\n\t    return 1;\n\t  }\n\t}\n      }\n      else if (k->type == STK_MEM_END) {\n\tif (mem_is_in_memp(k->u.mem.num, mem_num, memp)) {\n\t  pend = k->u.mem.pstr;\n\t}\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfacelessSurfaceImpl::OnMakeCurrent(GLContext* context) {\n  DCHECK(!context_ || context == context_);\n  context_ = context;\n  if (!fbo_) {\n    glGenFramebuffersEXT(1, &fbo_);\n    if (!fbo_)\n      return false;\n    glGenTextures(arraysize(textures_), textures_);\n    if (!CreatePixmaps())\n      return false;\n  }\n  BindFramebuffer();\n  glBindFramebufferEXT(GL_FRAMEBUFFER, fbo_);\n  return SurfacelessEGL::OnMakeCurrent(context);\n}", "target": 0}
{"code": "static void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}", "target": 0}
{"code": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static inline void DetectRunPrefilterPkt(\n    ThreadVars *tv,\n    DetectEngineCtx *de_ctx,\n    DetectEngineThreadCtx *det_ctx,\n    Packet *p,\n    DetectRunScratchpad *scratch\n)\n{\n    DetectPrefilterSetNonPrefilterList(p, det_ctx, scratch);\n    PacketCreateMask(p, &scratch->pkt_mask, scratch->alproto, scratch->app_decoder_events);\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_NONMPMLIST);\n    det_ctx->non_pf_id_cnt = 0;\n    if (likely(det_ctx->non_pf_store_cnt > 0)) {\n        DetectPrefilterBuildNonPrefilterList(det_ctx, scratch->pkt_mask, scratch->alproto);\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_NONMPMLIST);\n    Prefilter(det_ctx, scratch->sgh, p, scratch->flow_flags);\n    if (det_ctx->non_pf_store_cnt || det_ctx->pmq.rule_id_array_cnt) {\n        PACKET_PROFILING_DETECT_START(p, PROF_DETECT_PF_SORT2);\n        DetectPrefilterMergeSort(de_ctx, det_ctx);\n        PACKET_PROFILING_DETECT_END(p, PROF_DETECT_PF_SORT2);\n    }\n#ifdef PROFILING\n    if (tv) {\n        StatsAddUI64(tv, det_ctx->counter_mpm_list,\n                             (uint64_t)det_ctx->pmq.rule_id_array_cnt);\n        StatsAddUI64(tv, det_ctx->counter_nonmpm_list,\n                             (uint64_t)det_ctx->non_pf_store_cnt);\n        StatsAddUI64(tv, det_ctx->counter_fnonmpm_list,\n                             (uint64_t)det_ctx->non_pf_id_cnt);\n    }\n#endif\n}", "target": 0}
{"code": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\trowsperstrip, rows_to_read;\n    if( TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n\treturn (0);\n    }\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if( (row % rowsperstrip) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t\"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n\t\treturn (0);\n    }\n    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, 0, emsg)) {\n        img.row_offset = row;\n        img.col_offset = 0;\n        if( row + rowsperstrip > img.height )\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n\tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );\n\tTIFFRGBAImageEnd(&img);\n    } else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    return (ok);\n}", "target": 0}
{"code": "static int options_open_fs(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, options_seq_show, PDE(inode)->data);\n}", "target": 0}
{"code": "int git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source)\n{\n\tgit_treebuilder *bld;\n\tsize_t i, source_entries = DEFAULT_TREE_SIZE;\n\tassert(builder_p);\n\tbld = git__calloc(1, sizeof(git_treebuilder));\n\tGITERR_CHECK_ALLOC(bld);\n\tif (source != NULL)\n\t\tsource_entries = source->entries.length;\n\tif (git_vector_init(&bld->entries, source_entries, entry_sort_cmp) < 0)\n\t\tgoto on_error;\n\tif (source != NULL) {\n\t\tgit_tree_entry *entry_src;\n\t\tgit_vector_foreach(&source->entries, i, entry_src) {\n\t\t\tif (append_entry(\n\t\t\t\tbld, entry_src->filename,\n\t\t\t\t&entry_src->oid,\n\t\t\t\tentry_src->attr) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\t*builder_p = bld;\n\treturn 0;\non_error:\n\tgit_treebuilder_free(bld);\n\treturn -1;\n}", "target": 0}
{"code": "key_ref_t search_process_keyrings(struct key_type *type,\n\t\t\t\t  const void *description,\n\t\t\t\t  key_match_func_t match,\n\t\t\t\t  const struct cred *cred)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\tmight_sleep();\n\tkey_ref = search_my_process_keyrings(type, description, match,\n\t\t\t\t\t     false, cred);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\tif (cred->request_key_auth &&\n\t    cred == current_cred() &&\n\t    type != &key_type_request_key_auth\n\t    ) {\n\t\tdown_read(&cred->request_key_auth->sem);\n\t\tif (key_validate(cred->request_key_auth) == 0) {\n\t\t\trka = cred->request_key_auth->payload.data;\n\t\t\tkey_ref = search_process_keyrings(type, description,\n\t\t\t\t\t\t\t  match, rka->cred);\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\nfound:\n\treturn key_ref;\n}", "target": 0}
{"code": "ns_client_shuttingdown(ns_client_t *client) {\n\treturn (client->newstate == NS_CLIENTSTATE_FREED);\n}", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)\n{\n\tu64 mask;\n\treg->var_off = tnum_cast(reg->var_off, size);\n\tmask = ((u64)1 << (size * 8)) - 1;\n\tif ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {\n\t\treg->umin_value &= mask;\n\t\treg->umax_value &= mask;\n\t} else {\n\t\treg->umin_value = 0;\n\t\treg->umax_value = mask;\n\t}\n\treg->smin_value = reg->umin_value;\n\treg->smax_value = reg->umax_value;\n\tif (size >= 4)\n\t\treturn;\n\t__reg_combine_64_into_32(reg);\n}", "target": 0}
{"code": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n{\n#if DEBUG_AHCI\n    int i;\n    fprintf(stderr, \"fis:\");\n    for (i = 0; i < cmd_len; i++) {\n        if ((i & 0xf) == 0) {\n            fprintf(stderr, \"\\n%02x:\",i);\n        }\n        fprintf(stderr, \"%02x \",fis[i]);\n    }\n    fprintf(stderr, \"\\n\");\n#endif\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "GF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int decode_open_downgrade(struct xdr_stream *xdr, struct nfs_closeres *res)\n{\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_OPEN_DOWNGRADE);\n\tif (status != -EIO)\n\t\tnfs_increment_open_seqid(status, res->seqid);\n\tif (!status)\n\t\tstatus = decode_stateid(xdr, &res->stateid);\n\treturn status;\n}", "target": 0}
{"code": "AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  \n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n    if (ssidLength > MAX_SSID_LENGTH) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n    return AIRPDCAP_RET_SUCCESS;\n}", "target": 0}
{"code": "int tipc_nl_node_dump_monitor_peer(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tu32 prev_node = cb->args[1];\n\tu32 bearer_id = cb->args[2];\n\tint done = cb->args[0];\n\tstruct tipc_nl_msg msg;\n\tint err;\n\tif (!prev_node) {\n\t\tstruct nlattr **attrs = genl_dumpit_info(cb)->attrs;\n\t\tstruct nlattr *mon[TIPC_NLA_MON_MAX + 1];\n\t\tif (!attrs[TIPC_NLA_MON])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(mon, TIPC_NLA_MON_MAX,\n\t\t\t\t\t\t  attrs[TIPC_NLA_MON],\n\t\t\t\t\t\t  tipc_nl_monitor_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!mon[TIPC_NLA_MON_REF])\n\t\t\treturn -EINVAL;\n\t\tbearer_id = nla_get_u32(mon[TIPC_NLA_MON_REF]);\n\t\tif (bearer_id >= MAX_BEARERS)\n\t\t\treturn -EINVAL;\n\t}\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trtnl_lock();\n\terr = tipc_nl_add_monitor_peer(net, &msg, bearer_id, &prev_node);\n\tif (!err)\n\t\tdone = 1;\n\trtnl_unlock();\n\tcb->args[0] = done;\n\tcb->args[1] = prev_node;\n\tcb->args[2] = bearer_id;\n\treturn skb->len;\n}", "target": 0}
{"code": "int migrate_page(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page)\n{\n\tint rc;\n\tBUG_ON(PageWriteback(page));\t\n\trc = migrate_page_move_mapping(mapping, newpage, page);\n\tif (rc)\n\t\treturn rc;\n\tmigrate_page_copy(newpage, page);\n\treturn 0;\n}", "target": 0}
{"code": "Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)\n{\n  if (thd->locked_tables_mode != LTM_LOCK_TABLES)\n    return;\n  if (mdl_ticket)\n  {\n    thd->mdl_context.release_all_locks_for_name(mdl_ticket);\n  }\n  if (thd->lock->table_count == 0)\n    unlock_locked_tables(thd);\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "static ssize_t read_kmem(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t low_count, read, sz;\n\tchar *kbuf; \n\tint err = 0;\n\tread = 0;\n\tif (p < (unsigned long) high_memory) {\n\t\tlow_count = count;\n\t\tif (count > (unsigned long)high_memory - p)\n\t\t\tlow_count = (unsigned long)high_memory - p;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t\tif (p < PAGE_SIZE && low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n#endif\n\t\twhile (low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tkbuf = xlate_dev_kmem_ptr((void *)p);\n\t\t\tif (!virt_addr_valid(kbuf))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (copy_to_user(buf, kbuf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tkbuf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\twhile (count > 0) {\n\t\t\tsz = size_inside_page(p, count);\n\t\t\tif (!is_vmalloc_or_module_addr((void *)p)) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsz = vread(kbuf, (char *)p, sz);\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t\tif (copy_to_user(buf, kbuf, sz)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sz;\n\t\t\tbuf += sz;\n\t\t\tread += sz;\n\t\t\tp += sz;\n\t\t}\n\t\tfree_page((unsigned long)kbuf);\n\t}\n\t*ppos = p;\n\treturn read ? read : err;\n}", "target": 0}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }", "target": 1}
{"code": "Eina_Bool ewk_view_zoom_animated_set(Evas_Object* ewkView, float zoom, float duration, Evas_Coord centerX, Evas_Coord centerY)\n{\n    double now;\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->zoom_weak_set, false);\n    if (!priv->settings.zoomRange.userScalable) {\n        WRN(\"userScalable is false\");\n        return false;\n    }\n    if (zoom < priv->settings.zoomRange.minScale) {\n        WRN(\"zoom level is < %f : %f\", priv->settings.zoomRange.minScale, zoom);\n        return false;\n    }\n    if (zoom > priv->settings.zoomRange.maxScale) {\n        WRN(\"zoom level is > %f : %f\", priv->settings.zoomRange.maxScale, zoom);\n        return false;\n    }\n    if (priv->animatedZoom.animator)\n        priv->animatedZoom.zoom.start = _ewk_view_zoom_animated_current(priv);\n    else {\n        priv->animatedZoom.zoom.start = ewk_frame_page_zoom_get(smartData->main_frame);\n        _ewk_view_zoom_animation_start(smartData);\n    }\n    if (centerX < 0)\n        centerX = 0;\n    if (centerY < 0)\n        centerY = 0;\n    now = ecore_loop_time_get();\n    priv->animatedZoom.time.start = now;\n    priv->animatedZoom.time.end = now + duration;\n    priv->animatedZoom.time.duration = duration;\n    priv->animatedZoom.zoom.end = zoom;\n    priv->animatedZoom.zoom.range = (priv->animatedZoom.zoom.end - priv->animatedZoom.zoom.start);\n    priv->animatedZoom.center.x = centerX;\n    priv->animatedZoom.center.y = centerY;\n    smartData->animated_zoom.zoom.current = priv->animatedZoom.zoom.start;\n    smartData->animated_zoom.zoom.start = priv->animatedZoom.zoom.start;\n    smartData->animated_zoom.zoom.end = priv->animatedZoom.zoom.end;\n    return true;\n}", "target": 0}
{"code": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "vote_routerstatus_find_microdesc_hash(char *digest256_out,\n                                      const vote_routerstatus_t *vrs,\n                                      int method,\n                                      digest_algorithm_t alg)\n{\n  const vote_microdesc_hash_t *h;\n  char mstr[64];\n  size_t mlen;\n  char dstr[64];\n  tor_snprintf(mstr, sizeof(mstr), \"%d\", method);\n  mlen = strlen(mstr);\n  tor_snprintf(dstr, sizeof(dstr), \" %s=\",\n               crypto_digest_algorithm_get_name(alg));\n  for (h = vrs->microdesc; h; h = h->next) {\n    const char *cp = h->microdesc_hash_line;\n    size_t num_len;\n    while (1) {\n      num_len = strspn(cp, \"1234567890\");\n      if (num_len == mlen && fast_memeq(mstr, cp, mlen)) {\n        char buf[BASE64_DIGEST256_LEN+1];\n        cp = strstr(cp, dstr);\n        if (!cp)\n          return -1;\n        cp += strlen(dstr);\n        strlcpy(buf, cp, sizeof(buf));\n        return digest256_from_base64(digest256_out, buf);\n      }\n      if (num_len == 0 || cp[num_len] != ',')\n        break;\n      cp += num_len + 1;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "static void php_snmp_session_destructor(zend_resource *rsrc) \n{\n\tphp_snmp_session *session = (php_snmp_session *)rsrc->ptr;\n\tnetsnmp_session_free(&session);\n}", "target": 0}
{"code": "static void irda_connect_indication(void *instance, void *sap,\n\t\t\t\t    struct qos_info *qos, __u32 max_sdu_size,\n\t\t\t\t    __u8 max_header_size, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)\n{\n    int result;\n    if (handle == NULL || source == NULL || size == 0)\n    {\n        LogError(\"BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %lu\", handle, source, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if (handle->buffer == NULL)\n        {\n            if (BUFFER_safemalloc(handle, size) != 0 || handle->buffer == NULL)\n            {\n                LogError(\"Failure with BUFFER_safemalloc\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                (void)memcpy(handle->buffer, source, size);\n                result = 0;\n            }\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)realloc(handle->buffer, handle->size + size);\n            if (temp == NULL)\n            {\n                LogError(\"Failure reallocating temporary buffer\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                handle->buffer = temp;\n                (void)memcpy(&handle->buffer[handle->size], source, size);\n                handle->size += size;\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "snmp_oid_copy(uint32_t *dst, uint32_t *src)\n{\n  uint8_t i;\n  i = 0;\n  while(src[i] != ((uint32_t)-1)) {\n    dst[i] = src[i];\n    i++;\n  }\n  dst[i] = src[i];\n}", "target": 1}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"code": "cache_record_length(JOIN *join,uint idx)\n{\n  uint length=0;\n  JOIN_TAB **pos,**end;\n  for (pos=join->best_ref+join->const_tables,end=join->best_ref+idx ;\n       pos != end ;\n       pos++)\n  {\n    JOIN_TAB *join_tab= *pos;\n    length+= join_tab->get_used_fieldlength();\n  }\n  return length;\n}", "target": 0}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "static struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\n\t\t\t\t\t   union sctp_addr *addr,\n\t\t\t\t\t   int vparam_len)\n{\n\tsctp_addiphdr_t asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\tunion sctp_addr_param addrparam;\n\tint addrlen;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlength += addrlen;\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\tasconf.serial = htonl(asoc->addip_serial++);\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\treturn retval;\n}", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "uint_t aubio_tempo_set_delay(aubio_tempo_t * o, sint_t delay) {\n  o->delay = delay;\n  return AUBIO_OK;\n}", "target": 0}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n \tunsigned long flags;\n \tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n \t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n \tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n }", "target": 1}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "static av_always_inline int dnxhd_calc_ac_bits(DNXHDEncContext *ctx, int16_t *block, int last_index)\n{\n    int last_non_zero = 0;\n    int bits = 0;\n    int i, j, level;\n    for (i = 1; i <= last_index; i++) {\n        j = ctx->m.intra_scantable.permutated[i];\n        level = block[j];\n        if (level) {\n            int run_level = i - last_non_zero - 1;\n            bits += ctx->vlc_bits[(level<<1)|!!run_level]+ctx->run_bits[run_level];\n            last_non_zero = i;\n        }\n    }\n    return bits;\n}", "target": 0}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "GF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;", "target": 0}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "void free_pgtables(struct mmu_gather **tlb, struct vm_area_struct *vma,\n\t\tunsigned long floor, unsigned long ceiling)\n{\n\twhile (vma) {\n\t\tstruct vm_area_struct *next = vma->vm_next;\n\t\tunsigned long addr = vma->vm_start;\n\t\tanon_vma_unlink(vma);\n\t\tunlink_file_vma(vma);\n\t\tif (is_vm_hugetlb_page(vma)) {\n\t\t\thugetlb_free_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t} else {\n\t\t\twhile (next && next->vm_start <= vma->vm_end + PMD_SIZE\n\t\t\t       && !is_vm_hugetlb_page(next)) {\n\t\t\t\tvma = next;\n\t\t\t\tnext = vma->vm_next;\n\t\t\t\tanon_vma_unlink(vma);\n\t\t\t\tunlink_file_vma(vma);\n\t\t\t}\n\t\t\tfree_pgd_range(tlb, addr, vma->vm_end,\n\t\t\t\tfloor, next? next->vm_start: ceiling);\n\t\t}\n\t\tvma = next;\n\t}\n}", "target": 0}
{"code": "static BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\nbit_index >>= SLJIT_WORD_SHIFT;\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\nif (*byte & mask)\n  return FALSE;\n*byte |= mask;\nreturn TRUE;\n}", "target": 0}
{"code": "uint_t aubio_tempo_set_delay_ms(aubio_tempo_t * o, smpl_t delay) {\n  o->delay = 1000. * delay * o->samplerate;\n  return AUBIO_OK;\n}", "target": 0}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\terror = (*nproc)(priv, cookie, call_nests);\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\treturn error;\n}", "target": 0}
{"code": "PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"EXIF Support\", \"enabled\");\n\tphp_info_print_table_row(2, \"EXIF Version\", PHP_EXIF_VERSION);\n\tphp_info_print_table_row(2, \"Supported EXIF Version\", \"0220\");\n\tphp_info_print_table_row(2, \"Supported filetypes\", \"JPEG, TIFF\");\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"enabled\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"disabled\");\n\t}\n\tphp_info_print_table_row(2, \"Extended EXIF tag formats\", \"Canon, Casio, Fujifilm, Nikon, Olympus, Samsung, Panasonic, DJI, Sony, Pentax, Minolta, Sigma, Foveon, Kyocera, Ricoh, AGFA, Epson\");\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int log_access_ok(void __user *log_base, u64 addr, unsigned long sz)\n{\n\tu64 a = addr / VHOST_PAGE_SIZE / 8;\n\tif (a > ULONG_MAX - (unsigned long)log_base ||\n\t    a + (unsigned long)log_base > ULONG_MAX)\n\t\treturn 0;\n\treturn access_ok(VERIFY_WRITE, log_base + a,\n\t\t\t (sz + VHOST_PAGE_SIZE * 8 - 1) / VHOST_PAGE_SIZE / 8);\n}", "target": 0}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "  bool operator!=(const HeaderMap& rhs) const override { return HeaderMapImpl::operator!=(rhs); }", "target": 0}
{"code": "static void ati_cursor_define(ATIVGAState *s)\n{\n    uint8_t data[1024];\n    uint8_t *src;\n    int i, j, idx = 0;\n    if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) {\n        return; \n    }\n    src = s->vga.vram_ptr + s->regs.cur_offset -\n          (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16;\n    for (i = 0; i < 64; i++) {\n        for (j = 0; j < 8; j++, idx++) {\n            data[idx] = src[i * 16 + j];\n            data[512 + idx] = src[i * 16 + j + 8];\n        }\n    }\n    if (!s->cursor) {\n        s->cursor = cursor_alloc(64, 64);\n    }\n    cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0,\n                    &data[512], 1, &data[0]);\n    dpy_cursor_define(s->vga.con, s->cursor);\n}", "target": 1}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "static int exif_file_sections_add(image_info_type *ImageInfo, int type, size_t size, uchar *data)\n{\n\tfile_section    *tmp;\n\tint             count = ImageInfo->file.count;\n\ttmp = safe_erealloc(ImageInfo->file.list, (count+1), sizeof(file_section), 0);\n\tImageInfo->file.list = tmp;\n\tImageInfo->file.list[count].type = 0xFFFF;\n\tImageInfo->file.list[count].data = NULL;\n\tImageInfo->file.list[count].size = 0;\n\tImageInfo->file.count = count+1;\n\tif (!size) {\n\t\tdata = NULL;\n\t} else if (data == NULL) {\n\t\tdata = safe_emalloc(size, 1, 0);\n\t}\n\tImageInfo->file.list[count].type = type;\n\tImageInfo->file.list[count].data = data;\n\tImageInfo->file.list[count].size = size;\n\treturn count;\n}", "target": 0}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "   void FocusFirstNameField() {\n     LOG(WARNING) << \"Clicking on the tab.\";\n    ASSERT_NO_FATAL_FAILURE(ui_test_utils::ClickOnView(browser(),\n                                                       VIEW_ID_TAB_CONTAINER));\n    ASSERT_TRUE(ui_test_utils::IsViewFocused(browser(),\n                                             VIEW_ID_TAB_CONTAINER));\n     LOG(WARNING) << \"Focusing the first name field.\";\n     bool result = false;\n    ASSERT_TRUE(ui_test_utils::ExecuteJavaScriptAndExtractBool(\n        render_view_host(), L\"\",\n        L\"if (document.readyState === 'complete')\"\n        L\"  document.getElementById('firstname').focus();\"\n        L\"else\"\n        L\"  domAutomationController.send(false);\",\n        &result));\n    ASSERT_TRUE(result);\n  }", "target": 1}
{"code": "sanitize_filename (const char *file_name)\n{\n\tsize_t      prefix_len;\n\tchar const *p;\n\tif (file_name == NULL)\n\t\treturn NULL;\n\tprefix_len = 0;\n\tfor (p = file_name; *p; ) {\n\t\tif (ISDOT (p[0]) && ISDOT (p[1]) && (ISSLASH (p[2]) || !p[2]))\n\t\t\tprefix_len = p + 2 - file_name;\n\t\tdo {\n\t\t\tchar c = *p++;\n\t\t\tif (ISSLASH (c))\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (*p);\n\t}\n\tp = file_name + prefix_len;\n\twhile (ISSLASH (*p))\n\t\tp++;\n\treturn p;\n}", "target": 1}
{"code": "static int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 1}
{"code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 1}
{"code": "ShelfDelegate* Shell::GetShelfDelegate() {\n  if (!shelf_delegate_) {\n    shelf_model_.reset(new ShelfModel);\n    shelf_item_delegate_manager_.reset(\n        new ShelfItemDelegateManager(shelf_model_.get()));\n    shelf_delegate_.reset(delegate_->CreateShelfDelegate(shelf_model_.get()));\n    scoped_ptr<ShelfItemDelegate> controller(new AppListShelfItemDelegate);\n    int app_list_index = shelf_model_->GetItemIndexForType(TYPE_APP_LIST);\n    DCHECK_GE(app_list_index, 0);\n    ShelfID app_list_id = shelf_model_->items()[app_list_index].id;\n    DCHECK(app_list_id);\n    shelf_item_delegate_manager_->SetShelfItemDelegate(app_list_id,\n                                                       std::move(controller));\n    shelf_window_watcher_.reset(new ShelfWindowWatcher(\n        shelf_model_.get(), shelf_item_delegate_manager_.get()));\n  }\n  return shelf_delegate_.get();\n}", "target": 0}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}", "target": 1}
{"code": "static void cmd_authinfo_user(char *user)\n{\n    const char *p;\n    if (nntp_authstate) {\n\tprot_printf(nntp_out, \"502 Already authenticated\\r\\n\");\n\treturn;\n    }\n    if (!(nntp_starttls_done || (extprops_ssf > 1) ||\n\t  config_getswitch(IMAPOPT_ALLOWPLAINTEXT))) {\n\tprot_printf(nntp_out,\n\t\t    \"483 AUTHINFO USER command only available under a layer\\r\\n\");\n\treturn;\n    }\n    if (nntp_userid) {\n\tfree(nntp_userid);\n\tnntp_userid = NULL;\n    }\n    if (!(p = canonify_userid(user, NULL, NULL))) {\n\tprot_printf(nntp_out, \"481 Invalid user\\r\\n\");\n\tsyslog(LOG_NOTICE,\n\t       \"badlogin: %s plaintext %s invalid user\",\n\t       nntp_clienthost, beautify_string(user));\n    }\n    else {\n\tnntp_userid = xstrdup(p);\n\tprot_printf(nntp_out, \"381 Give AUTHINFO PASS command\\r\\n\");\n    }\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)\n{\n    path->incReserve(numPoints);\n    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),\n                 WebCoreFloatToSkScalar(points[0].y()));\n    for (size_t i = 1; i < numPoints; ++i) {\n         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),\n                      WebCoreFloatToSkScalar(points[i].y()));\n     }\n    path->setIsConvex(true);\n }", "target": 1}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "struct sk_buff *cfg80211_testmode_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen, 0, 0, gfp);\n}", "target": 0}
{"code": "    void Jp2Image::writeMetadata()\n    {\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "check_SET_VLAN_PCP(struct ofpact_vlan_pcp *a, struct ofpact_check_params *cp)\n{\n    ovs_be16 *tci = &cp->match->flow.vlans[0].tci;\n    a->flow_has_vlan = (*tci & htons(VLAN_CFI)) != 0;\n    if (!a->flow_has_vlan && !a->push_vlan_if_needed) {\n        inconsistent_match(&cp->usable_protocols);\n    }\n    *tci |= htons(VLAN_CFI);\n    return 0;\n}", "target": 0}
{"code": "cd_device_db_set_property (CdDeviceDb *ddb,\n\t\t\t   const gchar *device_id,\n\t\t\t   const gchar *property,\n\t\t\t   const gchar *value,\n\t\t\t   GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tgboolean ret = TRUE;\n\tgchar *error_msg = NULL;\n\tgchar *statement;\n\tgint rc;\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db != NULL, FALSE);\n\tg_debug (\"CdDeviceDb: add device property %s [%s=%s]\",\n\t\t device_id, property, value);\n\tstatement = sqlite3_mprintf (\"INSERT OR REPLACE INTO properties_v2 (device_id, property, value) \"\n\t\t\t\t     \"VALUES ('%q', '%q', '%q');\",\n\t\t\t\t     device_id, property, value);\n\trc = sqlite3_exec (priv->db, statement, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\nout:\n\tsqlite3_free (statement);\n\treturn ret;\n}", "target": 0}
{"code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}", "target": 1}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "separate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t\n\t    else\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#ifdef FEAT_EVAL\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#endif\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (!(eap->argt & EX_NOTRLCOM))\t\n\tdel_trailing_spaces(eap->arg);\n}", "target": 0}
{"code": "static void spl_array_unset_property(zval *object, zval *member, const zend_literal *key TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif ((intern->ar_flags & SPL_ARRAY_ARRAY_AS_PROPS) != 0\n\t&& !std_object_handlers.has_property(object, member, 2, key TSRMLS_CC)) {\n\t\tspl_array_unset_dimension(object, member TSRMLS_CC);\n\t\tspl_array_rewind(intern TSRMLS_CC); \n\t\treturn;\n\t}\n\tstd_object_handlers.unset_property(object, member, key TSRMLS_CC);\n} ", "target": 0}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,\n                                       uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "static MXFPackage* mxf_resolve_source_package(MXFContext *mxf, UID package_uid)\n{\n    MXFPackage *package = NULL;\n    int i;\n    for (i = 0; i < mxf->packages_count; i++) {\n        package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], SourcePackage);\n        if (!package)\n            continue;\n        if (!memcmp(package->package_uid, package_uid, 16))\n            return package;\n    }\n    return NULL;\n}", "target": 0}
{"code": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    {\n        LOCK(mempool.cs);\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}", "target": 1}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "static struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\treturn dev;\n}", "target": 0}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "static void exif_process_TIFF_in_JPEG(image_info_type *ImageInfo, char *CharBuf, size_t length, size_t displacement)\n{\n\tunsigned exif_value_2a, offset_of_ifd;\n\tif (memcmp(CharBuf, \"II\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 0;\n\t} else if (memcmp(CharBuf, \"MM\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 1;\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF alignment marker\");\n\t\treturn;\n\t}\n\tif (length < 8) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\texif_value_2a = php_ifd_get16u(CharBuf+2, ImageInfo->motorola_intel);\n\toffset_of_ifd = php_ifd_get32u(CharBuf+4, ImageInfo->motorola_intel);\n\tif (exif_value_2a != 0x2a || offset_of_ifd < 0x08) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\tif (offset_of_ifd > length) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid IFD start\");\n\t\treturn;\n\t}\n\tImageInfo->sections_found |= FOUND_IFD0;\n\texif_process_IFD_in_JPEG(ImageInfo, CharBuf+offset_of_ifd, CharBuf, length, displacement, SECTION_IFD0, 0);\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process TIFF in JPEG done\");\n#endif\n\tif (ImageInfo->FocalplaneXRes != 0) {\n\t\tImageInfo->CCDWidth = (float)(ImageInfo->ExifImageWidth * ImageInfo->FocalplaneUnits / ImageInfo->FocalplaneXRes);\n\t}\n}", "target": 0}
{"code": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\treturn ret;\n}", "target": 1}
{"code": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tif (pskb_may_pull(skb, 2)) {\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif \n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\treturn;\n\t}\n\tif (skb->len > 0)\n\t\t++ppp->dev->stats.rx_length_errors;\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}", "target": 0}
{"code": "join_read_record_no_init(JOIN_TAB *tab)\n{\n  Copy_field *save_copy, *save_copy_end;\n  save_copy=     tab->read_record.copy_field;\n  save_copy_end= tab->read_record.copy_field_end;\n  init_read_record(&tab->read_record, tab->join->thd, tab->table,\n\t\t   tab->select, tab->filesort_result, 1, 1, FALSE);\n  tab->read_record.copy_field=     save_copy;\n  tab->read_record.copy_field_end= save_copy_end;\n  tab->read_record.read_record= rr_sequential_and_unpack;\n  return (*tab->read_record.read_record)(&tab->read_record);\n}", "target": 0}
{"code": "static int selinux_netlbl_sock_setsid(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\tif (sksec->nlbl_state != NLBL_REQUIRE)\n\t\treturn 0;\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL)\n\t\treturn -ENOMEM;\n\trc = netlbl_sock_setattr(sk, secattr);\n\tswitch (rc) {\n\tcase 0:\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static bool io_wq_worker_affinity(struct io_worker *worker, void *data)\n{\n\tstruct online_data *od = data;\n\tif (od->online)\n\t\tcpumask_set_cpu(od->cpu, worker->wqe->cpu_mask);\n\telse\n\t\tcpumask_clear_cpu(od->cpu, worker->wqe->cpu_mask);\n\treturn false;\n}", "target": 0}
{"code": "int irssi_ssl_handshake(GIOChannel *handle)\n{\n\tGIOSSLChannel *chan = (GIOSSLChannel *)handle;\n\tint ret, err;\n\tX509 *cert;\n\tconst char *errstr;\n\tret = SSL_connect(chan->ssl);\n\tif (ret <= 0) {\n\t\terr = SSL_get_error(chan->ssl, ret);\n\t\tswitch (err) {\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\treturn 1;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\treturn 3;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", \"server closed connection\");\n\t\t\t\treturn -1;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tif (errstr == NULL && ret == -1)\n\t\t\t\t\terrstr = strerror(errno);\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");\n\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}", "target": 1}
{"code": "void PDFiumEngine::RotateClockwise() {\n  current_rotation_ = (current_rotation_ + 1) % 4;\n  RotateInternal();\n}", "target": 0}
{"code": "static void addrconf_dev_config(struct net_device *dev)\n{\n\tstruct in6_addr addr;\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tif ((dev->type != ARPHRD_ETHER) &&\n\t    (dev->type != ARPHRD_FDDI) &&\n\t    (dev->type != ARPHRD_ARCNET) &&\n\t    (dev->type != ARPHRD_INFINIBAND) &&\n\t    (dev->type != ARPHRD_IEEE802154) &&\n\t    (dev->type != ARPHRD_IEEE1394)) {\n\t\treturn;\n\t}\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev))\n\t\treturn;\n\tmemset(&addr, 0, sizeof(struct in6_addr));\n\taddr.s6_addr32[0] = htonl(0xFE800000);\n\tif (ipv6_generate_eui64(addr.s6_addr + 8, dev) == 0)\n\t\taddrconf_add_linklocal(idev, &addr);\n}", "target": 0}
{"code": "static void sp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\tdev->flags\t\t= 0;\n}", "target": 1}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n    }\n}", "target": 1}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n    const RunFromHostProxyCallback& callback) {\n  if (state_->run_called()) {\n    if (!callback.is_null())\n      callback.Run(PP_ERROR_FAILED);\n    return PP_ERROR_FAILED;\n  }\n  state_->set_run_called();\n  state_->set_run_callback(callback);\n  scoped_refptr<State> state_protector(state_);\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n     base::MessageLoop::current()->Run();\n   }\n  return state_protector->result();\n}", "target": 1}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushnull(J);\n}", "target": 1}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "int gnutls_x509_aki_set_cert_issuer(gnutls_x509_aki_t aki,\n\t\t\t\t    unsigned int san_type,\n\t\t\t\t    const gnutls_datum_t * san,\n\t\t\t\t    const char *othername_oid,\n\t\t\t\t    const gnutls_datum_t * serial)\n{\n\tint ret;\n\tgnutls_datum_t t_san, t_othername_oid = { NULL, 0 };\n\tret = _gnutls_set_datum(&aki->serial, serial->data, serial->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\taki->cert_issuer.names[aki->cert_issuer.size].type = san_type;\n\tret = _gnutls_set_datum(&t_san, san->data, san->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (othername_oid) {\n\t\tt_othername_oid.data = (uint8_t *) gnutls_strdup(othername_oid);\n\t\tif (t_othername_oid.data == NULL) {\n\t\t\tgnutls_free(t_san.data);\n\t\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\t\t}\n\t\tt_othername_oid.size = strlen(othername_oid);\n\t}\n\tret =\n\t    subject_alt_names_set(&aki->cert_issuer.names,\n\t\t\t\t  &aki->cert_issuer.size, san_type, &t_san,\n\t\t\t\t  (char *)t_othername_oid.data);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static size_t\nphp_mysqlnd_change_auth_response_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tMYSQLND_CONNECTION_STATE * connection_state = &conn->state;\n\tzend_uchar * const buffer = pfc->cmd_buffer.length >= packet->auth_data_len? pfc->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar * p = buffer + MYSQLND_HEADER_SIZE; \n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\t{\n\t\tconst size_t sent = pfc->data->m.send(pfc, vio, buffer, p - buffer - MYSQLND_HEADER_SIZE, stats, error_info);\n\t\tif (buffer != pfc->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tSET_CONNECTION_STATE(connection_state, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}", "target": 1}
{"code": "static const char* getenv_harder(pam_handle_t *handle, const char *key, const char *fallback) {\n        const char *v;\n        assert(handle);\n        assert(key);\n        v = pam_getenv(handle, key);\n        if (!isempty(v))\n                return v;\n        v = getenv(key);\n        if (!isempty(v))\n                return v;\n        return fallback;\n}", "target": 1}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tretval = new_size;\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "  friend H AbslHashValue(H h, const TensorKey& k) {\n    const uint8* d = static_cast<uint8*>(k.data());\n    size_t s = k.AllocatedBytes();\n    std::vector<uint8> vec;\n    vec.reserve(s);\n    for (int i = 0; i < s; i++) {\n      vec.push_back(d[i]);\n    }\n    return H::combine(std::move(h), s);\n  }", "target": 1}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "int nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}", "target": 1}
{"code": "ospf_router_lsa_links_examin\n(\n  struct router_lsa_link * link,\n  u_int16_t linkbytes,\n  const u_int16_t num_links\n)\n{\n  unsigned counted_links = 0, thislinklen;\n  while (linkbytes)\n  {\n    thislinklen = OSPF_ROUTER_LSA_LINK_SIZE + 4 * link->m[0].tos_count;\n    if (thislinklen > linkbytes)\n    {\n      if (IS_DEBUG_OSPF_PACKET (0, RECV))\n        zlog_debug (\"%s: length error in link block #%u\", __func__, counted_links);\n      return MSG_NG;\n    }\n    link = (struct router_lsa_link *)((caddr_t) link + thislinklen);\n    linkbytes -= thislinklen;\n    counted_links++;\n  }\n  if (counted_links != num_links)\n  {\n    if (IS_DEBUG_OSPF_PACKET (0, RECV))\n      zlog_debug (\"%s: %u link blocks declared, %u present\",\n                  __func__, num_links, counted_links);\n    return MSG_NG;\n  }\n  return MSG_OK;\n}", "target": 0}
{"code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}", "target": 1}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "bool BlobURLRequestJob::ReadFile(const BlobData::Item& item) {\n  DCHECK(stream_.get());\n  DCHECK(stream_->IsOpen());\n  DCHECK(read_buf_remaining_bytes_ >= bytes_to_read_);\n  int rv = stream_->Read(read_buf_->data() + read_buf_offset_,\n                         bytes_to_read_,\n                         &io_callback_);\n  if (rv == net::ERR_IO_PENDING) {\n    SetStatus(net::URLRequestStatus(net::URLRequestStatus::IO_PENDING, 0));\n    return false;\n  }\n  if (rv < 0) {\n    NotifyFailure(net::ERR_FAILED);\n    return false;\n  }\n  if (GetStatus().is_io_pending())\n    DidRead(rv);\n  else\n    AdvanceBytesRead(rv);\n  return true;\n}", "target": 0}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n \t\tif (err)\n \t\t\treturn err;\n \t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n \t\t\t\t       attrs[TIPC_NLA_SOCK],\n \t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 1}
{"code": "MenuCacheItem *menu_cache_find_item_by_id(MenuCache *cache, const char *id)\n{\n    MenuCacheItem *item = NULL;\n    MENU_CACHE_LOCK;\n    if (cache && id)\n        item = _scan_by_id(MENU_CACHE_ITEM(cache->root_dir), id);\n    if (item)\n        menu_cache_item_ref(item);\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n \t\treturn retval;\n \t}\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n \tmsq->q_stime = msq->q_rtime = 0;\n \tmsq->q_ctime = get_seconds();\n \tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n \tINIT_LIST_HEAD(&msq->q_receivers);\n \tINIT_LIST_HEAD(&msq->q_senders);\n \tipc_unlock_object(&msq->q_perm);\n \trcu_read_unlock();\n\treturn msq->q_perm.id;\n}", "target": 1}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "op2name(int opcode)\n{\n  int i;\n  for (i = 0; OpInfo[i].opcode >= 0; i++) {\n    if (opcode == OpInfo[i].opcode) return OpInfo[i].name;\n  }\n  return \"\";\n}", "target": 0}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n  if( nReg==0 ) return;\n#ifdef SQLITE_DEBUG\n  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n  for(i=0; i<pAggInfo->nColumn; i++){\n    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n  }\n  for(i=0; i<pAggInfo->nFunc; i++){\n    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n  }\n#endif\n  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      }\n    }\n  }\n}", "target": 0}
{"code": "status_t MPEG4Extractor::parseAC3SpecificBox(\n off64_t offset, uint16_t sampleRate) {\n uint32_t size;\n const uint32_t kAC3SpecificBoxSize = 11;\n if (!mDataSource->getUInt32(offset, &size) || size < kAC3SpecificBoxSize) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 block: cannot read specific box size\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n uint32_t type;\n if (!mDataSource->getUInt32(offset, &type) || type != FOURCC('d', 'a', 'c', '3')) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: header not dac3\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n const uint32_t kAC3SpecificBoxPayloadSize = 3;\n uint8_t chunk[kAC3SpecificBoxPayloadSize];\n if (mDataSource->readAt(offset, chunk, sizeof(chunk)) != sizeof(chunk)) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: bitstream fields\");\n return ERROR_MALFORMED;\n }\n ABitReader br(chunk, sizeof(chunk));\n static const unsigned channelCountTable[] = {2, 1, 2, 3, 3, 4, 4, 5};\n static const unsigned sampleRateTable[] = {48000, 44100, 32000};\n unsigned fscod = br.getBits(2);\n if (fscod == 3) {\n        ALOGE(\"Incorrect fscod (3) in AC3 header\");\n return ERROR_MALFORMED;\n }\n unsigned boxSampleRate = sampleRateTable[fscod];\n if (boxSampleRate != sampleRate) {\n        ALOGE(\"sample rate mismatch: boxSampleRate = %d, sampleRate = %d\",\n            boxSampleRate, sampleRate);\n return ERROR_MALFORMED;\n }\n unsigned bsid = br.getBits(5);\n if (bsid > 8) {\n        ALOGW(\"Incorrect bsid in AC3 header. Possibly E-AC-3?\");\n return ERROR_MALFORMED;\n }\n unsigned bsmod __unused = br.getBits(3);\n unsigned acmod = br.getBits(3);\n unsigned lfeon = br.getBits(1);\n unsigned channelCount = channelCountTable[acmod] + lfeon;\n if (mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n    mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);\n    mLastTrack->meta->setInt32(kKeyChannelCount, channelCount);\n    mLastTrack->meta->setInt32(kKeySampleRate, sampleRate);\n return OK;\n}", "target": 0}
{"code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "void fli_read_brun(FILE *f, s_fli_header *fli_header, unsigned char *framebuf)\n{\n\tunsigned short yc;\n\tunsigned char *pos;\n\tfor (yc=0; yc < fli_header->height; yc++) {\n\t\tunsigned short xc, pc, pcnt;\n\t\tpc=fli_read_char(f);\n\t\txc=0;\n\t\tpos=framebuf+(fli_header->width * yc);\n\t\tfor (pcnt=pc; pcnt>0; pcnt--) {\n\t\t\tunsigned short ps;\n\t\t\tps=fli_read_char(f);\n\t\t\tif (ps & 0x80) {\n\t\t\t\tunsigned short len;\n\t\t\t\tfor (len=-(signed char)ps; len>0; len--) {\n\t\t\t\t\tpos[xc++]=fli_read_char(f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned char val;\n\t\t\t\tval=fli_read_char(f);\n\t\t\t\tmemset(&(pos[xc]), val, ps);\n\t\t\t\txc+=ps;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "format_versions_list(config_line_t *ln)\n{\n  smartlist_t *versions;\n  char *result;\n  versions = smartlist_new();\n  for ( ; ln; ln = ln->next) {\n    smartlist_split_string(versions, ln->value, \",\",\n                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);\n  }\n  sort_version_list(versions, 1);\n  result = smartlist_join_strings(versions,\",\",0,NULL);\n  SMARTLIST_FOREACH(versions,char *,s,tor_free(s));\n  smartlist_free(versions);\n  return result;\n}", "target": 0}
{"code": "  TextureManager::TextureInfo* GetTextureInfoForTarget(GLenum target) {\n    TextureUnit& unit = texture_units_[active_texture_unit_];\n    TextureManager::TextureInfo* info = NULL;\n    switch (target) {\n      case GL_TEXTURE_2D:\n        info = unit.bound_texture_2d;\n        break;\n      case GL_TEXTURE_CUBE_MAP:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:\n        info = unit.bound_texture_cube_map;\n        break;\n      default:\n        NOTREACHED();\n        return NULL;\n    }\n    return (info && !info->IsDeleted()) ? info : NULL;\n  }", "target": 0}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 1}
{"code": "mptctl_replace_fw (unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t newFwSize;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\tmpt_free_fw_memory(ioc);\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}", "target": 1}
{"code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n  }\n  return(ret);\n}", "target": 1}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tstruct strbuf pathbuf;\n\tstrbuf_init(&pathbuf, dirlen+2+strlen(GITATTRIBUTES_FILE));\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tstrbuf_reset(&pathbuf);\n\t\t\tstrbuf_add(&pathbuf, path, dirlen);\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\t\t\tcp = strchr(pathbuf.buf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf.buf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf.buf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}", "target": 0}
{"code": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0}
{"code": "static void copy_sec_desc(const struct cifs_ntsd *pntsd,\n\t\t\t\tstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\n{\n\tstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\n\tstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\n\tpnntsd->revision = pntsd->revision;\n\tpnntsd->type = pntsd->type;\n\tpnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\n\tpnntsd->sacloffset = 0;\n\tpnntsd->osidoffset = cpu_to_le32(sidsoffset);\n\tpnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\n\towner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\tnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\n\tcifs_copy_sid(nowner_sid_ptr, owner_sid_ptr);\n\tgroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\n\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\tngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\n\t\t\t\t\tsizeof(struct cifs_sid));\n\tcifs_copy_sid(ngroup_sid_ptr, group_sid_ptr);\n\treturn;\n}", "target": 0}
{"code": "static u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\treturn hash ^ port;\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n     darray_append(expr->keysym_list.symsNumEntries, numEntries);\n     darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n     return expr;\n }", "target": 1}
{"code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\treturn 0;\n}", "target": 0}
{"code": "  virtual void ConnectToWifiNetwork(const WifiNetwork* network,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded())\n      return;\n    if (ConnectToNetworkWithCertInfo(network->service_path().c_str(),\n        password.empty() ? NULL : password.c_str(),\n        identity.empty() ? NULL : identity.c_str(),\n        certpath.empty() ? NULL : certpath.c_str())) {\n      WifiNetwork* wifi = GetWirelessNetworkByPath(\n          wifi_networks_, network->service_path());\n      if (wifi) {\n        wifi->set_passphrase(password);\n        wifi->set_identity(identity);\n        wifi->set_cert_path(certpath);\n        wifi->set_connecting(true);\n        wifi_ = wifi;\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "static uint32_t get_cmd(ESPState *s, uint32_t maxlen)\n{\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    uint32_t dmalen, n;\n    int target;\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n    if (s->dma) {\n        dmalen = MIN(esp_get_tc(s), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        if (s->dma_memory_read) {\n            s->dma_memory_read(s->dma_opaque, buf, dmalen);\n            fifo8_push_all(&s->cmdfifo, buf, dmalen);\n        } else {\n            if (esp_select(s) < 0) {\n                fifo8_reset(&s->cmdfifo);\n                return -1;\n            }\n            esp_raise_drq(s);\n            fifo8_reset(&s->cmdfifo);\n            return 0;\n        }\n    } else {\n        dmalen = MIN(fifo8_num_used(&s->fifo), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);\n        if (n >= 3) {\n            buf[0] = buf[2] >> 5;\n        }\n        fifo8_push_all(&s->cmdfifo, buf, n);\n    }\n    trace_esp_get_cmd(dmalen, target);\n    if (esp_select(s) < 0) {\n        fifo8_reset(&s->cmdfifo);\n        return -1;\n    }\n    return dmalen;\n}", "target": 1}
{"code": "static struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)\n{\n\tint node;\n\tstruct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);\n\tstruct kmem_cache_node *n;\n\tmemcpy(s, static_cache, kmem_cache->object_size);\n\t__flush_cpu_slab(s, smp_processor_id());\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tstruct page *p;\n\t\tlist_for_each_entry(p, &n->partial, slab_list)\n\t\t\tp->slab_cache = s;\n#ifdef CONFIG_SLUB_DEBUG\n\t\tlist_for_each_entry(p, &n->full, slab_list)\n\t\t\tp->slab_cache = s;\n#endif\n\t}\n\tslab_init_memcg_params(s);\n\tlist_add(&s->list, &slab_caches);\n\tmemcg_link_cache(s, NULL);\n\treturn s;\n}", "target": 0}
{"code": "lua_text_pattern::lua_text_pattern(const string &_pattern)\n    : translated(false), isvalid(true), pattern(_pattern),\n      lua_fn_name(new_fn_name())\n{\n}", "target": 0}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "void pickSlurp(sdbus::MethodCall& call) {\n    const std::string PICK_COLOR_CMD = \"grim -g \\\"$(slurp -p)\\\" -t ppm -\";\n    std::string       ppmColor       = execAndGet(PICK_COLOR_CMD.c_str());\n    ppmColor = std::regex_replace(ppmColor, std::regex(\"\\\\s+\"), std::string(\" \"));\n    if (!ppmColor.starts_with(\"P6 1 1 \")) {\n        Debug::log(ERR, \"grim did not return a PPM Image for us.\");\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    try {\n        std::string maxValString = ppmColor.substr(7, ppmColor.size());\n        maxValString             = maxValString.substr(0, maxValString.find(' '));\n        uint32_t maxVal          = std::stoi(maxValString);\n        double r, g, b;\n        if (maxVal < 256) {\n            std::string byteString = ppmColor.substr(11, 14);\n            r = (uint8_t)byteString[0] / (maxVal * 1.0);\n            g = (uint8_t)byteString[1] / (maxVal * 1.0);\n            b = (uint8_t)byteString[2] / (maxVal * 1.0);\n        } else {\n            std::string byteString = ppmColor.substr(11, 17);\n            r = ((byteString[0] << 8) | byteString[1]) / (maxVal * 1.0);\n            g = ((byteString[2] << 8) | byteString[3]) / (maxVal * 1.0);\n            b = ((byteString[4] << 8) | byteString[5]) / (maxVal * 1.0);\n        }\n        auto reply = call.createReply();\n        std::unordered_map<std::string, sdbus::Variant> results;\n        results[\"color\"] = sdbus::Struct(std::tuple{r, g, b});\n        reply << (uint32_t)0;\n        reply << results;\n        reply.send();\n    } catch (...) {\n        Debug::log(ERR, \"Converting PPM to RGB failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n}", "target": 1}
{"code": "_gnutls_x509_decode_string(unsigned int etype,\n\t\t\t   const uint8_t * der, size_t der_size,\n\t\t\t   gnutls_datum_t * output, unsigned allow_ber)\n{\n\tint ret;\n\tuint8_t *str;\n\tunsigned int str_size, len;\n\tgnutls_datum_t td;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tret =\n\t\t    asn1_decode_simple_ber(etype, der, der_size, &str, &str_size, NULL);\n\telse\n#endif\n\t\tret =\n\t\t    asn1_decode_simple_der(etype, der, der_size, (const uint8_t**)&str, &str_size);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(ret);\n\t\treturn ret;\n\t}\n\ttd.size = str_size;\n\ttd.data = gnutls_malloc(str_size + 1);\n\tif (td.data == NULL)\n\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\tmemcpy(td.data, str, str_size);\n\ttd.data[str_size] = 0;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tfree(str);\n#endif\n\tret = make_printable_string(etype, &td, output);\n\tif (ret == GNUTLS_E_INVALID_REQUEST) {\t\n\t\toutput->data = td.data;\n\t\toutput->size = td.size;\n\t\tret = 0;\n\t} else if (ret <= 0) {\n\t\t_gnutls_free_datum(&td);\n\t}\n\tif (etype != ASN1_ETYPE_OCTET_STRING) {\n\t\tif (output->data)\n\t\t\tlen = strlen((void *) output->data);\n\t\telse\n\t\t\tlen = 0;\n\t\tif (len != (size_t) output->size) {\n\t\t\t_gnutls_free_datum(output);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (n < 6) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    p = d = (unsigned char *)s->init_msg;\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 1}
{"code": "ZEND_API zend_bool ZEND_FASTCALL instanceof_function_ex(const zend_class_entry *instance_ce, const zend_class_entry *ce, zend_bool is_interface) \n{\n\tif (is_interface) {\n\t\tZEND_ASSERT(ce->ce_flags & ZEND_ACC_INTERFACE);\n\t\treturn instanceof_interface(instance_ce, ce);\n\t} else {\n\t\tZEND_ASSERT(!(ce->ce_flags & ZEND_ACC_INTERFACE));\n\t\treturn instanceof_class(instance_ce, ce);\n\t}\n}", "target": 0}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "static s32 adpt_send_nop(adpt_hba*pHba,u32 m)\n{\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 5*HZ;\n\twhile(m == EMPTY_QUEUE){\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif(m != EMPTY_QUEUE){\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_ERR \"%s: Timeout waiting for message frame!\\n\",pHba->name);\n\t\t\treturn 2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\n\twritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\n\twritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\n\twritel( 0,&msg[2]);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "static noinline int audit_inode_permission(struct inode *inode,\n\t\t\t\t\t   u32 perms, u32 audited, u32 denied,\n\t\t\t\t\t   int result)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tint rc;\n\tad.type = LSM_AUDIT_DATA_INODE;\n\tad.u.inode = inode;\n\trc = slow_avc_audit(&selinux_state,\n\t\t\t    current_sid(), isec->sid, isec->sclass, perms,\n\t\t\t    audited, denied, result, &ad);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}", "target": 0}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n    free(reply);\n    return xml;\n}", "target": 1}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "static void free_segment_list(struct playlist *pls)\n{\n    int i;\n    for (i = 0; i < pls->n_segments; i++) {\n        av_free(pls->segments[i]->key);\n        av_free(pls->segments[i]->url);\n        av_free(pls->segments[i]);\n    }\n    av_freep(&pls->segments);\n    pls->n_segments = 0;\n}", "target": 0}
{"code": "php_apache_sapi_read_post(char *buf, uint count_bytes TSRMLS_DC)\n{\n\tapr_size_t len, tlen=0;\n\tphp_struct *ctx = SG(server_context);\n\trequest_rec *r;\n\tapr_bucket_brigade *brigade;\n\tr = ctx->r;\n\tbrigade = ctx->brigade;\n\tlen = count_bytes;\n\twhile (ap_get_brigade(r->input_filters, brigade, AP_MODE_READBYTES, APR_BLOCK_READ, len) == APR_SUCCESS) {\n\t\tapr_brigade_flatten(brigade, buf, &len);\n\t\tapr_brigade_cleanup(brigade);\n\t\ttlen += len;\n\t\tif (tlen == count_bytes || !len) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len;\n\t\tlen = count_bytes - tlen;\n\t}\n\treturn tlen;\n}", "target": 0}
{"code": "void FIFOSampleBuffer::setChannels(int numChannels)\n{\n    uint usedBytes;\n    assert(numChannels > 0);\n    usedBytes = channels * samplesInBuffer;\n    channels = (uint)numChannels;\n    samplesInBuffer = usedBytes / channels;\n}", "target": 1}
{"code": "static const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { \n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}", "target": 0}
{"code": "vhost_user_set_features(struct virtio_net *dev, uint64_t features)\n{\n\tuint64_t vhost_features = 0;\n\trte_vhost_driver_get_features(dev->ifname, &vhost_features);\n\tif (features & ~vhost_features) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"(%d) received invalid negotiated features.\\n\",\n\t\t\tdev->vid);\n\t\treturn -1;\n\t}\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tif (dev->features == features)\n\t\t\treturn 0;\n\t\tif ((dev->features ^ features) & ~(1ULL << VHOST_F_LOG_ALL)) {\n\t\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\t\"(%d) features changed while device is running.\\n\",\n\t\t\t\tdev->vid);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dev->notify_ops->features_changed)\n\t\t\tdev->notify_ops->features_changed(dev->vid, features);\n\t}\n\tdev->features = features;\n\tif (dev->features &\n\t\t((1 << VIRTIO_NET_F_MRG_RXBUF) | (1ULL << VIRTIO_F_VERSION_1))) {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\t} else {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr);\n\t}\n\tLOG_DEBUG(VHOST_CONFIG,\n\t\t\"(%d) mergeable RX buffers %s, virtio 1 %s\\n\",\n\t\tdev->vid,\n\t\t(dev->features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ? \"on\" : \"off\",\n\t\t(dev->features & (1ULL << VIRTIO_F_VERSION_1)) ? \"on\" : \"off\");\n\tif ((dev->flags & VIRTIO_DEV_BUILTIN_VIRTIO_NET) &&\n\t    !(dev->features & (1ULL << VIRTIO_NET_F_MQ))) {\n\t\twhile (dev->nr_vring > 2) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvq = dev->virtqueue[--dev->nr_vring];\n\t\t\tif (!vq)\n\t\t\t\tcontinue;\n\t\t\tdev->virtqueue[dev->nr_vring] = NULL;\n\t\t\tcleanup_vq(vq, 1);\n\t\t\tfree_vq(vq);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "int ldb_match_message(struct ldb_context *ldb,\n\t\t      const struct ldb_message *msg,\n\t\t      const struct ldb_parse_tree *tree,\n\t\t      enum ldb_scope scope, bool *matched)\n{\n\tunsigned int i;\n\tint ret;\n\t*matched = false;\n\tif (scope != LDB_SCOPE_BASE && ldb_dn_is_special(msg->dn)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tswitch (tree->operation) {\n\tcase LDB_OP_AND:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (!*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_OR:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_NOT:\n\t\tret = ldb_match_message(ldb, msg, tree->u.isnot.child, scope, matched);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t*matched = ! *matched;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_EQUALITY:\n\t\treturn ldb_match_equality(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_SUBSTRING:\n\t\treturn ldb_match_substring(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_GREATER:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_GREATER, matched);\n\tcase LDB_OP_LESS:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_LESS, matched);\n\tcase LDB_OP_PRESENT:\n\t\treturn ldb_match_present(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_APPROX:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_APPROX, matched);\n\tcase LDB_OP_EXTENDED:\n\t\treturn ldb_match_extended(ldb, msg, tree, scope, matched);\n\t}\n\treturn LDB_ERR_INAPPROPRIATE_MATCHING;\n}", "target": 0}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "XdmcpGenerateKey (XdmAuthKeyPtr key)\n{\n #ifndef HAVE_ARC4RANDOM_BUF\n     long    lowbits, highbits;\n     srandom ((int)getpid() ^ time((Time_t *)0));\n    highbits = random ();\n     highbits = random ();\n     getbits (lowbits, key->data);\n     getbits (highbits, key->data + 4);\n#else\n     arc4random_buf(key->data, 8);\n#endif\n }", "target": 1}
{"code": "static void\nS_regdump_extflags(pTHX_ const char *lead, const U32 flags)\n{\n    int bit;\n    int set=0;\n    regex_charset cs;\n    ASSUME(REG_EXTFLAGS_NAME_SIZE <= sizeof(flags)*8);\n    for (bit=0; bit<REG_EXTFLAGS_NAME_SIZE; bit++) {\n        if (flags & (1<<bit)) {\n\t    if ((1<<bit) & RXf_PMf_CHARSET) {\t\n\t\tcontinue;\n\t    }\n            if (!set++ && lead)\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            Perl_re_printf( aTHX_  \"%s \", PL_reg_extflags_name[bit]);\n        }\n    }\n    if ((cs = get_regex_charset(flags)) != REGEX_DEPENDS_CHARSET) {\n            if (!set++ && lead) {\n                Perl_re_printf( aTHX_  \"%s\", lead);\n            }\n            switch (cs) {\n                case REGEX_UNICODE_CHARSET:\n                    Perl_re_printf( aTHX_  \"UNICODE\");\n                    break;\n                case REGEX_LOCALE_CHARSET:\n                    Perl_re_printf( aTHX_  \"LOCALE\");\n                    break;\n                case REGEX_ASCII_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-RESTRICTED\");\n                    break;\n                case REGEX_ASCII_MORE_RESTRICTED_CHARSET:\n                    Perl_re_printf( aTHX_  \"ASCII-MORE_RESTRICTED\");\n                    break;\n                default:\n                    Perl_re_printf( aTHX_  \"UNKNOWN CHARACTER SET\");\n                    break;\n            }\n    }\n    if (lead)  {\n        if (set)\n            Perl_re_printf( aTHX_  \"\\n\");\n        else\n            Perl_re_printf( aTHX_  \"%s[none-set]\\n\", lead);\n    }", "target": 0}
{"code": "static void flush_change(H264Context *h)\n{\n    int i, j;\n    h->outputed_poc          = h->next_outputed_poc = INT_MIN;\n    h->prev_interlaced_frame = 1;\n    idr(h);\n    h->prev_frame_num = -1;\n    if (h->cur_pic_ptr) {\n        h->cur_pic_ptr->reference = 0;\n        for (j=i=0; h->delayed_pic[i]; i++)\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n                h->delayed_pic[j++] = h->delayed_pic[i];\n        h->delayed_pic[j] = NULL;\n    }\n    h->first_field = 0;\n    memset(h->ref_list[0], 0, sizeof(h->ref_list[0]));\n    memset(h->ref_list[1], 0, sizeof(h->ref_list[1]));\n    memset(h->default_ref_list[0], 0, sizeof(h->default_ref_list[0]));\n    memset(h->default_ref_list[1], 0, sizeof(h->default_ref_list[1]));\n    ff_h264_reset_sei(h);\n    h->recovery_frame = -1;\n    h->frame_recovered = 0;\n    h->list_count = 0;\n    h->current_slice = 0;\n    h->mmco_reset = 1;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "bool EmbFile::save2(FILE *f) {\n  int c;\n  m_objStr.streamReset();\n  while ((c = m_objStr.streamGetChar()) != EOF) {\n    fputc(c, f);\n  }\n  return true;\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_destroy_session(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t struct nfs4_session *session)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = session->clp->cl_mvops->minor_version,\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_session(xdr, session, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "unsigned int get_random_int(void)\n{\n\treturn secure_ip_id((__force __be32)(current->pid + jiffies));\n}", "target": 1}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "bool ring_buffer_empty_cpu(struct ring_buffer *buffer, int cpu)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long flags;\n\tbool dolock;\n\tint ret;\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn true;\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\tret = rb_per_cpu_empty(cpu_buffer);\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}", "target": 0}
{"code": "static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);\n    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n  }\n}", "target": 0}
{"code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1}
{"code": "    CImg<T>& RGBtoHSV() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"RGBtoHSV(): Instance is not a RGB image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=256))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          R = (Tfloat)p1[N],\n          G = (Tfloat)p2[N],\n          B = (Tfloat)p3[N],\n          m = cimg::min(R,G,B),\n          M = cimg::max(R,G,B);\n        Tfloat H = 0, S = 0;\n        if (M!=m) {\n          const Tfloat\n            f = R==m?G - B:G==m?B - R:R - G,\n            i = R==m?3:G==m?5:1;\n          H = i - f/(M - m);\n          if (H>=6) H-=6;\n          H*=60;\n          S = (M - m)/M;\n        }\n        p1[N] = (T)cimg::cut(H,0,360);\n        p2[N] = (T)cimg::cut(S,0,1);\n        p3[N] = (T)cimg::cut(M/255,0,1);\n      }\n      return *this;", "target": 0}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "int sctp_auth_recv_cid(sctp_cid_t chunk, const struct sctp_association *asoc)\n{\n\tif (!sctp_auth_enable || !asoc)\n\t\treturn 0;\n\treturn __sctp_auth_cid(chunk,\n\t\t\t      (struct sctp_chunks_param *)asoc->c.auth_chunks);\n}", "target": 0}
{"code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\tslots->used_slots--;\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}", "target": 1}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n    currentBuffer.length = len;\n    wcb_->setSocket(socket_);\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }", "target": 1}
{"code": "static int switch_listening_mode(GDHCPClient *dhcp_client,\n\t\t\t\t\tListenMode listen_mode)\n{\n\tGIOChannel *listener_channel;\n\tint listener_sockfd;\n\tif (dhcp_client->listen_mode == listen_mode)\n\t\treturn 0;\n\tdebug(dhcp_client, \"switch listening mode (%d ==> %d)\",\n\t\t\t\tdhcp_client->listen_mode, listen_mode);\n\tif (dhcp_client->listen_mode != L_NONE) {\n\t\tif (dhcp_client->listener_watch > 0)\n\t\t\tg_source_remove(dhcp_client->listener_watch);\n\t\tdhcp_client->listen_mode = L_NONE;\n\t\tdhcp_client->listener_sockfd = -1;\n\t\tdhcp_client->listener_watch = 0;\n\t}\n\tif (listen_mode == L_NONE)\n\t\treturn 0;\n\tif (listen_mode == L2)\n\t\tlistener_sockfd = dhcp_l2_socket(dhcp_client->ifindex);\n\telse if (listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6)\n\t\t\tlistener_sockfd = dhcp_l3_socket(DHCPV6_CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET6);\n\t\telse\n\t\t\tlistener_sockfd = dhcp_l3_socket(CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET);\n\t} else if (listen_mode == L_ARP)\n\t\tlistener_sockfd = arp_socket(dhcp_client->ifindex);\n\telse\n\t\treturn -EIO;\n\tif (listener_sockfd < 0)\n\t\treturn -EIO;\n\tlistener_channel = g_io_channel_unix_new(listener_sockfd);\n\tif (!listener_channel) {\n\t\tclose(listener_sockfd);\n\t\treturn -EIO;\n\t}\n\tdhcp_client->listen_mode = listen_mode;\n\tdhcp_client->listener_sockfd = listener_sockfd;\n\tg_io_channel_set_close_on_unref(listener_channel, TRUE);\n\tdhcp_client->listener_watch =\n\t\t\tg_io_add_watch_full(listener_channel, G_PRIORITY_HIGH,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_ERR | G_IO_HUP,\n\t\t\t\t\t\tlistener_event, g_dhcp_client_ref(dhcp_client),\n\t\t\t\t\t\t\t\tlistener_watch_destroy);\n\tg_io_channel_unref(listener_channel);\n\treturn 0;\n}", "target": 0}
{"code": "  cid_parse_font_matrix( CID_Face     face,\n                         CID_Parser*  parser )\n  {\n    CID_FaceDict  dict;\n    FT_Face       root = (FT_Face)&face->root;\n    FT_Fixed      temp[6];\n    FT_Fixed      temp_scale;\n    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );\n       temp_scale = FT_ABS( temp[3] );\n        temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n      }\n      matrix->xx = temp[0];\n      matrix->yx = temp[1];\n      matrix->xy = temp[2];\n      matrix->yy = temp[3];\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n       }", "target": 1}
{"code": "SPL_METHOD(Array, append)\n{\n\tzval *value;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &value) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_array_iterator_append(getThis(), value TSRMLS_CC);\n} ", "target": 0}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "SV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;", "target": 0}
{"code": "_dbus_lookup_launchd_socket (DBusString *socket_path,\n                             const char *launchd_env_var,\n                             DBusError  *error)\n{\n#ifdef DBUS_ENABLE_LAUNCHD\n  char *argv[4];\n  int i;\n  _DBUS_ASSERT_ERROR_IS_CLEAR (error);\n  if (_dbus_check_setuid ())\n    {\n      dbus_set_error_const (error, DBUS_ERROR_NOT_SUPPORTED,\n                            \"Unable to find launchd socket when setuid\");\n      return FALSE;\n    }\n  i = 0;\n  argv[i] = \"launchctl\";\n  ++i;\n  argv[i] = \"getenv\";\n  ++i;\n  argv[i] = (char*)launchd_env_var;\n  ++i;\n  argv[i] = NULL;\n  ++i;\n  _dbus_assert (i == _DBUS_N_ELEMENTS (argv));\n  if (!_read_subprocess_line_argv(argv[0], TRUE, argv, socket_path, error))\n    {\n      return FALSE;\n    }\n  if (_dbus_string_get_length(socket_path) == 0)\n    {\n      return FALSE;\n    }\n  _dbus_string_shorten(socket_path, 1);\n  return TRUE;\n#else \n  dbus_set_error(error, DBUS_ERROR_NOT_SUPPORTED,\n                \"can't lookup socket from launchd; launchd support not compiled in\");\n  return FALSE;\n#endif\n}", "target": 0}
{"code": "static int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\tbool oom = true;\n\tint ret;\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t\toom = false;\n\t}\n\tpc = lookup_page_cgroup(page);\n\tret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &memcg, oom);\n\tif (ret == -ENOMEM)\n\t\treturn ret;\n\t__mem_cgroup_commit_charge(memcg, page, nr_pages, pc, ctype);\n\treturn 0;\n}", "target": 0}
{"code": "static const char *set_qualify_redirect_url(cmd_parms *cmd, void *d_, int flag)\n{\n    core_dir_config *d = d_;\n    d->qualify_redirect_url = flag ? AP_CORE_CONFIG_ON : AP_CORE_CONFIG_OFF;\n    return NULL;\n}", "target": 0}
{"code": "static void bnx2x_oem_event(struct bnx2x *bp, u32 event)\n{\n\tu32 cmd_ok, cmd_fail;\n\tif (event & DRV_STATUS_DCC_EVENT_MASK &&\n\t    event & DRV_STATUS_OEM_EVENT_MASK) {\n\t\tBNX2X_ERR(\"Received simultaneous events %08x\\n\", event);\n\t\treturn;\n\t}\n\tif (event & DRV_STATUS_DCC_EVENT_MASK) {\n\t\tcmd_fail = DRV_MSG_CODE_DCC_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_DCC_OK;\n\t} else  {\n\t\tcmd_fail = DRV_MSG_CODE_OEM_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_OEM_OK;\n\t}\n\tDP(BNX2X_MSG_MCP, \"oem_event 0x%x\\n\", event);\n\tif (event & (DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t     DRV_STATUS_OEM_DISABLE_ENABLE_PF)) {\n\t\tif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function disabled\\n\");\n\t\t\tbp->flags |= MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_disable(bp);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function enabled\\n\");\n\t\t\tbp->flags &= ~MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_enable(bp);\n\t\t}\n\t\tevent &= ~(DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t\t   DRV_STATUS_OEM_DISABLE_ENABLE_PF);\n\t}\n\tif (event & (DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t     DRV_STATUS_OEM_BANDWIDTH_ALLOCATION)) {\n\t\tbnx2x_config_mf_bw(bp);\n\t\tevent &= ~(DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t\t   DRV_STATUS_OEM_BANDWIDTH_ALLOCATION);\n\t}\n\tif (event)\n\t\tbnx2x_fw_command(bp, cmd_fail, 0);\n\telse\n\t\tbnx2x_fw_command(bp, cmd_ok, 0);\n}", "target": 0}
{"code": "EC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)\n{\n    EC_GROUP *group = NULL;\n    ECPKPARAMETERS *params = NULL;\n    if ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);\n        ECPKPARAMETERS_free(params);\n        return NULL;\n    }\n    if ((group = ec_asn1_pkparameters2group(params)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);\n        return NULL;\n    }\n    if (a && *a)\n        EC_GROUP_clear_free(*a);\n    if (a)\n        *a = group;\n    ECPKPARAMETERS_free(params);\n    return (group);\n}", "target": 0}
{"code": "bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {\n  assert(this != k, \"this should be handled by higher-level code\");\n  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();\n  InstanceKlass* cur_host = nest_host(icce, CHECK_false);\n  if (cur_host == NULL) {\n    return false;\n  }\n  Klass* k_nest_host = k->nest_host(icce, CHECK_false);\n  if (k_nest_host == NULL) {\n    return false;\n  }\n  bool access = (cur_host == k_nest_host);\n  if (log_is_enabled(Trace, class, nestmates)) {\n    ResourceMark rm(THREAD);\n    log_trace(class, nestmates)(\"Class %s does %shave nestmate access to %s\",\n                                this->external_name(),\n                                access ? \"\" : \"NOT \",\n                                k->external_name());\n  }\n  return access;\n}", "target": 0}
{"code": "process_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}", "target": 0}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "static int result(void)\n{\n\tint i;\n\tint status = 0;\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}", "target": 0}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "static int wcd9335_probe(struct wcd9335_codec *wcd)\n{\n\tstruct device *dev = wcd->dev;\n\tmemcpy(wcd->rx_chs, wcd9335_rx_chs, sizeof(wcd9335_rx_chs));\n\tmemcpy(wcd->tx_chs, wcd9335_tx_chs, sizeof(wcd9335_tx_chs));\n\twcd->sido_input_src = SIDO_SOURCE_INTERNAL;\n\twcd->sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;\n\treturn devm_snd_soc_register_component(dev, &wcd9335_component_drv,\n\t\t\t\t\t       wcd9335_slim_dais,\n\t\t\t\t\t       ARRAY_SIZE(wcd9335_slim_dais));\n}", "target": 0}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 1}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "    TiffCopier::TiffCopier(      TiffComponent*  pRoot,\n                                 uint32_t        root,\n                           const TiffHeaderBase* pHeader,\n                           const PrimaryGroups*  pPrimaryGroups)\n        : pRoot_(pRoot),\n          root_(root),\n          pHeader_(pHeader),\n          pPrimaryGroups_(pPrimaryGroups)\n    {\n        assert(pRoot_ != 0);\n        assert(pHeader_ != 0);\n        assert(pPrimaryGroups_ != 0);\n    }", "target": 0}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "void smp_process_local_nonce(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n switch (p_cb->selected_association_model) {\n case SMP_MODEL_SEC_CONN_JUSTWORKS:\n case SMP_MODEL_SEC_CONN_NUM_COMP:\n if (p_cb->role == HCI_ROLE_SLAVE) {\n        smp_calculate_local_commitment(p_cb);\n        smp_send_commitment(p_cb, NULL);\n        smp_set_state(SMP_STATE_WAIT_NONCE);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          SMP_TRACE_DEBUG(\n \"master in assoc mode = %d \"\n \"already rcvd slave commitment - race condition\",\n              p_cb->selected_association_model);\n          p_cb->flags &= ~SMP_PAIR_FLAG_HAVE_PEER_COMM;\n          smp_send_rand(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_PASSKEY_ENT:\n case SMP_MODEL_SEC_CONN_PASSKEY_DISP:\n      smp_calculate_local_commitment(p_cb);\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_commitment(p_cb, NULL);\n } else \n {\n if (p_cb->flags & SMP_PAIR_FLAG_HAVE_PEER_COMM) {\n          smp_send_commitment(p_cb, NULL);\n          smp_set_state(SMP_STATE_WAIT_NONCE);\n }\n }\n break;\n case SMP_MODEL_SEC_CONN_OOB:\n if (p_cb->role == HCI_ROLE_MASTER) {\n        smp_send_rand(p_cb, NULL);\n }\n      smp_set_state(SMP_STATE_WAIT_NONCE);\n break;\n default:\n      SMP_TRACE_ERROR(\"Association Model = %d is not used in LE SC\",\n                      p_cb->selected_association_model);\n break;\n }\n}", "target": 0}
{"code": "static const char *set_cgi_var(cmd_parms *cmd, void *d_,\n                               const char *var, const char *rule_)\n{\n    core_dir_config *d = d_;\n    char *rule = apr_pstrdup(cmd->pool, rule_);\n    ap_str_tolower(rule);\n    if (!strcmp(var, \"REQUEST_URI\")) {\n        if (strcmp(rule, \"current-uri\") && strcmp(rule, \"original-uri\")) {\n            return \"Valid rules for REQUEST_URI are 'current-uri' and 'original-uri'\";\n        }\n    }\n    else {\n        return apr_pstrcat(cmd->pool, \"Unrecognized CGI variable: \\\"\",\n                           var, \"\\\"\", NULL);\n    }\n    if (!d->cgi_var_rules) {\n        d->cgi_var_rules = apr_hash_make(cmd->pool);\n    }\n    apr_hash_set(d->cgi_var_rules, var, APR_HASH_KEY_STRING, rule);\n    return NULL;\n}", "target": 0}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "short LibRaw::KodakIllumMatrix(unsigned type, float *romm_camIllum)\n{\n  int c, j, romm_camTemp[9], romm_camScale[3];\n  if (type == 10)\n  {\n    for (j = 0; j < 9; j++)\n      ((float *)romm_camIllum)[j] = getreal(type);\n    return 1;\n  }\n  else if (type == 9)\n  {\n    FORC3\n    {\n      romm_camScale[c] = 0;\n      for (j = 0; j < 3; j++)\n      {\n        romm_camTemp[c * 3 + j] = get4();\n        romm_camScale[c] += romm_camTemp[c * 3 + j];\n      }\n    }\n    if ((romm_camScale[0] > 0x1fff) && (romm_camScale[1] > 0x1fff) &&\n        (romm_camScale[2] > 0x1fff))\n    {\n      FORC3 for (j = 0; j < 3; j++)((float *)romm_camIllum)[c * 3 + j] =\n          ((float)romm_camTemp[c * 3 + j]) / ((float)romm_camScale[c]);\n      return 1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 1}
{"code": "void RGWPutObj_ObjStore_S3::send_response()\n{\n  if (op_ret) {\n    set_req_state_err(s, op_ret);\n    dump_errno(s);\n  } else {\n    if (s->cct->_conf->rgw_s3_success_create_obj_status) {\n      op_ret = get_success_retcode(\n\ts->cct->_conf->rgw_s3_success_create_obj_status);\n      set_req_state_err(s, op_ret);\n    }\n    if (copy_source.empty()) {\n      dump_errno(s);\n      dump_etag(s, etag);\n      dump_content_length(s, 0);\n      dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n      for (auto &it : crypt_http_responses)\n        dump_header(s, it.first, it.second);\n    } else {\n      dump_errno(s);\n      dump_header_if_nonempty(s, \"x-amz-version-id\", version_id);\n      end_header(s, this, \"application/xml\");\n      dump_start(s);\n      struct tm tmp;\n      utime_t ut(mtime);\n      time_t secs = (time_t)ut.sec();\n      gmtime_r(&secs, &tmp);\n      char buf[TIME_BUF_SIZE];\n      s->formatter->open_object_section_in_ns(\"CopyPartResult\",\n          \"http:\n      if (strftime(buf, sizeof(buf), \"%Y-%m-%dT%T.000Z\", &tmp) > 0) {\n        s->formatter->dump_string(\"LastModified\", buf);\n      }\n      s->formatter->dump_string(\"ETag\", etag);\n      s->formatter->close_section();\n      rgw_flush_formatter_and_reset(s, s->formatter);\n      return;\n    }\n  }\n  if (append) {\n    if (op_ret == 0 || op_ret == -ERR_POSITION_NOT_EQUAL_TO_LENGTH) {\n      dump_header(s, \"x-rgw-next-append-position\", cur_accounted_size);\n    }\n  }\n  if (s->system_request && !real_clock::is_zero(mtime)) {\n    dump_epoch_header(s, \"Rgwx-Mtime\", mtime);\n  }\n  end_header(s, this);\n}", "target": 0}
{"code": "static int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo_flavor *sec_flavor;\n\tint status;\n\t__be32 *p;\n\tint i, num_flavors;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\tstatus = 0;\nout:\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "void forward_cancel_request(PgSocket *server)\n{\n\tbool res;\n\tPgSocket *req = first_socket(&server->pool->cancel_req_list);\n\tAssert(req != NULL && req->state == CL_CANCEL);\n\tAssert(server->state == SV_LOGIN);\n\tSEND_CancelRequest(res, server, req->cancel_key);\n\tchange_client_state(req, CL_JUSTFREE);\n}", "target": 0}
{"code": "Value ExpressionRegex::nextMatch(RegexExecutionState* regexState) const {\n    int execResult = execute(regexState);\n    if (execResult < 0) {\n        return Value(BSONNULL);\n    }\n    StringData input = *(regexState->input);\n    auto verifyBounds = [&input, this](auto startPos, auto limitPos, auto isCapture) {\n        if (startPos == -1 || limitPos == -1) {\n            massert(31304,\n                    str::stream() << \"Unexpected error occurred while executing \" << _opName\n                                  << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                    isCapture && startPos == -1 && limitPos == -1);\n            return;\n        }\n        massert(31305,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos,\n                (startPos >= 0 && static_cast<size_t>(startPos) <= input.size()));\n        massert(31306,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". limitPos: \" << limitPos,\n                (limitPos >= 0 && static_cast<size_t>(limitPos) <= input.size()));\n        massert(31307,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                startPos <= limitPos);\n    };\n    verifyBounds(regexState->capturesBuffer[0], regexState->capturesBuffer[1], false);\n    const int matchStartByteIndex = regexState->capturesBuffer[0];\n    StringData matchedStr =\n        input.substr(matchStartByteIndex, regexState->capturesBuffer[1] - matchStartByteIndex);\n    for (int byteIx = regexState->startBytePos; byteIx < matchStartByteIndex;\n         ++(regexState->startCodePointPos)) {\n        byteIx += getCodePointLength(input[byteIx]);\n    }\n    regexState->startBytePos = matchStartByteIndex;\n    std::vector<Value> captures;\n    captures.reserve(regexState->numCaptures);\n    for (int i = 0; i < regexState->numCaptures; ++i) {\n        const int start = regexState->capturesBuffer[2 * (i + 1)];\n        const int limit = regexState->capturesBuffer[2 * (i + 1) + 1];\n        verifyBounds(start, limit, true);\n        captures.push_back(start == -1 && limit == -1 ? Value(BSONNULL)\n                                                      : Value(input.substr(start, limit - start)));\n    }\n    MutableDocument match;\n    match.addField(\"match\", Value(matchedStr));\n    match.addField(\"idx\", Value(regexState->startCodePointPos));\n    match.addField(\"captures\", Value(captures));\n    return match.freezeToValue();\n}", "target": 0}
{"code": "rb_handle_timestamp(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t    struct rb_event_info *info)\n{\n\tWARN_ONCE(info->delta > (1ULL << 59),\n\t\t  KERN_WARNING \"Delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t  (unsigned long long)info->delta,\n\t\t  (unsigned long long)info->ts,\n\t\t  (unsigned long long)cpu_buffer->write_stamp,\n\t\t  sched_clock_stable() ? \"\" :\n\t\t  \"If you just came from a suspend/resume,\\n\"\n\t\t  \"please switch to the trace global clock:\\n\"\n\t\t  \"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\");\n\tinfo->add_timestamp = 1;\n}", "target": 0}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "left_is_superset(DTCollation *left, DTCollation *right)\n{\n  if (left->collation->state & MY_CS_UNICODE &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        (!(right->collation->state & MY_CS_UNICODE) ||\n         (left->collation->state & MY_CS_UNICODE_SUPPLEMENT &&\n          !(right->collation->state & MY_CS_UNICODE_SUPPLEMENT) &&\n          left->collation->mbmaxlen > right->collation->mbmaxlen &&\n          left->collation->mbminlen == right->collation->mbminlen)))))\n    return TRUE;\n  if (right->repertoire == MY_REPERTOIRE_ASCII &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        !(left->repertoire == MY_REPERTOIRE_ASCII))))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "setContext(XML_Parser parser, const XML_Char *context) {\n  DTD *const dtd = parser->m_dtd; \n  const XML_Char *s = context;\n  while (*context != XML_T('\\0')) {\n    if (*s == CONTEXT_SEP || *s == XML_T('\\0')) {\n      ENTITY *e;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      e = (ENTITY *)lookup(parser, &dtd->generalEntities,\n                           poolStart(&parser->m_tempPool), 0);\n      if (e)\n        e->open = XML_TRUE;\n      if (*s != XML_T('\\0'))\n        s++;\n      context = s;\n      poolDiscard(&parser->m_tempPool);\n    } else if (*s == XML_T(ASCII_EQUALS)) {\n      PREFIX *prefix;\n      if (poolLength(&parser->m_tempPool) == 0)\n        prefix = &dtd->defaultPrefix;\n      else {\n        if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n          return XML_FALSE;\n        prefix\n            = (PREFIX *)lookup(parser, &dtd->prefixes,\n                               poolStart(&parser->m_tempPool), sizeof(PREFIX));\n        if (! prefix)\n          return XML_FALSE;\n        if (prefix->name == poolStart(&parser->m_tempPool)) {\n          prefix->name = poolCopyString(&dtd->pool, prefix->name);\n          if (! prefix->name)\n            return XML_FALSE;\n        }\n        poolDiscard(&parser->m_tempPool);\n      }\n      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\\0');\n           context++)\n        if (! poolAppendChar(&parser->m_tempPool, *context))\n          return XML_FALSE;\n      if (! poolAppendChar(&parser->m_tempPool, XML_T('\\0')))\n        return XML_FALSE;\n      if (addBinding(parser, prefix, NULL, poolStart(&parser->m_tempPool),\n                     &parser->m_inheritedBindings)\n          != XML_ERROR_NONE)\n        return XML_FALSE;\n      poolDiscard(&parser->m_tempPool);\n      if (*context != XML_T('\\0'))\n        ++context;\n      s = context;\n    } else {\n      if (! poolAppendChar(&parser->m_tempPool, *s))\n        return XML_FALSE;\n      s++;\n    }\n  }\n  return XML_TRUE;\n}", "target": 0}
{"code": "int Hints::getPageObjectNum(int page)\n{\n    if ((page < 1) || (page > nPages)) {\n        return 0;\n    }\n    if (page - 1 > pageFirst) {\n        return pageObjectNum[page - 1];\n    } else if (page - 1 < pageFirst) {\n        return pageObjectNum[page];\n    } else {\n        return pageObjectNum[0];\n    }\n}", "target": 0}
{"code": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\t*cp = '\\0';\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {\n    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))\n        return(-1);\n    if (ctxt->instate == XML_PARSER_START_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_COMMENT) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_PI) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_END_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if ((ctxt->progressive == XML_PARSER_DTD) ||\n        (ctxt->instate == XML_PARSER_DTD)) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    return(1);\n}", "target": 0}
{"code": "    TiffComponent* TiffComponent::doAddPath(uint16_t  ,\n                                            TiffPath& ,\n                                            TiffComponent* const ,\n                                            TiffComponent::UniquePtr )\n    {\n        return this;\n    } ", "target": 0}
{"code": "ff_layout_ntop6_noscopeid(const struct sockaddr *sap, char *buf,\n\t\t\t  const int buflen)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr *addr = &sin6->sin6_addr;\n\tif (ipv6_addr_any(addr))\n\t\treturn snprintf(buf, buflen, \"::\");\n\tif (ipv6_addr_loopback(addr))\n\t\treturn snprintf(buf, buflen, \"::1\");\n\tif (ipv6_addr_v4mapped(addr))\n\t\treturn snprintf(buf, buflen, \"::ffff:%pI4\",\n\t\t\t\t\t&addr->s6_addr32[3]);\n\treturn snprintf(buf, buflen, \"%pI6c\", addr);\n}", "target": 0}
{"code": "void DelayedExecutor::delayedExecute(const QString &udi)\n{\n    Solid::Device device(udi);\n     QString exec = m_service.exec();\n     MacroExpander mx(device);\n    mx.expandMacros(exec);\n     KRun::runCommand(exec, QString(), m_service.icon(), 0);\n     deleteLater();\n}", "target": 1}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "writepid (const char* pidfile, pid_t pid)\n{\n\tFILE* f;\n\tif ((f = fopen(pidfile, \"w\")) ==  NULL ) {\n\t\tlog_err(\"cannot open pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t\treturn;\n\t}\n\tif(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {\n\t\tlog_err(\"cannot write to pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t}\n\tfclose(f);\n}", "target": 1}
{"code": "void MemBackendImpl::EvictIfNeeded() {\n  if (current_size_ <= max_size_)\n    return;\n  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);\n   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();\n   while (current_size_ > target_size && entry != lru_list_.end()) {\n     MemEntryImpl* to_doom = entry->value();\n    entry = entry->next();\n     if (!to_doom->InUse())\n       to_doom->Doom();\n   }\n}", "target": 1}
{"code": "device_linux_md_stop_authorized_cb (Daemon *daemon,\n                                    Device *device,\n                                    DBusGMethodInvocation *context,\n                                    const gchar *action_id,\n                                    guint num_user_data,\n                                    gpointer *user_data_elements)\n{\n  int n;\n  char *argv[10];\n  GError *error;\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--stop\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"LinuxMdStop\", TRUE, device, argv, NULL, linux_md_stop_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "void decompTest(tjhandle handle, unsigned char *jpegBuf,\n\tunsigned long jpegSize, int w, int h, int pf, char *basename, int subsamp,\n\tint flags)\n{\n\tint i, n=0;\n\ttjscalingfactor *sf=tjGetScalingFactors(&n);\n\tif(!sf || !n) _throwtj();\n\tfor(i=0; i<n; i++)\n\t{\n\t\tif(subsamp==TJSAMP_444 || subsamp==TJSAMP_GRAY ||\n\t\t\t(subsamp==TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==2 || sf[i].denom==1)) ||\n\t\t\t(subsamp!=TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==4 || sf[i].denom==2 || sf[i].denom==1)))\n\t\t\t_decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n\t\t\t\tflags, sf[i]);\n\t}\n\tbailout:\n\treturn;\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "MagickExport MagickBooleanType GetImageKurtosis(const Image *image,\n  double *kurtosis,double *skewness,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *kurtosis=channel_statistics[CompositePixelChannel].kurtosis;\n  *skewness=channel_statistics[CompositePixelChannel].skewness;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}", "target": 0}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "Eina_Bool ewk_view_setting_resizable_textareas_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.resizableTextareas != enable) {\n        priv->pageSettings->setTextAreasAreResizable(enable);\n        priv->settings.resizableTextareas = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_replace_recursive,\n                         const Variant& array1,\n                         const Variant& array2 ,\n                         const Array& args ) {\n  getCheckedArray(array1);\n  Array ret = Array::Create();\n  PointerSet seen;\n  php_array_replace_recursive(seen, false, ret, arr_array1);\n  assert(seen.empty());\n  if (UNLIKELY(array2.isNull() && args.empty())) {\n    return tvReturn(std::move(ret));\n  }\n  getCheckedArray(array2);\n  php_array_replace_recursive(seen, false, ret, arr_array2);\n  assert(seen.empty());\n  for (ArrayIter iter(args); iter; ++iter) {\n    const Variant& v = iter.secondRef();\n    getCheckedArray(v);\n    php_array_replace_recursive(seen, false, ret, arr_v);\n    assert(seen.empty());\n  }\n  return tvReturn(std::move(ret));\n}", "target": 0}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "static u32 vvc_ctb_to_tile_col_bd(VVCSliceInfo *si, u32 ctb_addr_x)\n{\n\tu32 i, tile_x = 0;\n\tu32 tile_col_bd_val = 0;\n\tfor (i=0; i <= si->pps->pic_width_in_ctbsY; i++) {\n\t\tif (i == tile_col_bd_val + si->pps->tile_cols_width_ctb[tile_x] ) {\n\t\t\ttile_col_bd_val += si->pps->tile_cols_width_ctb[tile_x];\n\t\t\ttile_x++;\n\t\t}\n\t\tif (ctb_addr_x == i) return tile_col_bd_val;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int blkid_probe_is_covered_by_pt(blkid_probe pr,\n\t\t\t\t uint64_t offset, uint64_t size)\n{\n\tblkid_probe prc = NULL;\n\tblkid_partlist ls = NULL;\n\tuint64_t start, end;\n\tint nparts, i, rc = 0;\n\tDBG(LOWPROBE, ul_debug(\n\t\t\"=> checking if off=%\"PRIu64\" size=%\"PRIu64\" covered by PT\",\n\t\toffset, size));\n\tif (pr->flags & BLKID_FL_NOSCAN_DEV)\n\t\tgoto done;\n\tprc = blkid_clone_probe(pr);\n\tif (!prc)\n\t\tgoto done;\n\tls = blkid_probe_get_partitions(prc);\n\tif (!ls)\n\t\tgoto done;\n\tnparts = blkid_partlist_numof_partitions(ls);\n\tif (!nparts)\n\t\tgoto done;\n\tend = (offset + size) >> 9;\n\tstart = offset >> 9;\n\tfor (i = 0; i < nparts; i++) {\n\t\tblkid_partition par = &ls->parts[i];\n\t\tif (par->start + par->size > (pr->size >> 9)) {\n\t\t\tDBG(LOWPROBE, ul_debug(\"partition #%d overflows \"\n\t\t\t\t\"device (off=%\" PRId64 \" size=%\" PRId64 \")\",\n\t\t\t\tpar->partno, par->start, par->size));\n\t\t\tgoto done;\n\t\t}\n\t}\n\tfor (i = 0; i < nparts; i++) {\n\t\tblkid_partition par = &ls->parts[i];\n\t\tif (start >= par->start && end <= par->start + par->size) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tblkid_free_probe(prc);\n\tDBG(LOWPROBE, ul_debug(\"<= %s covered by PT\", rc ? \"IS\" : \"NOT\"));\n\treturn rc;\n}", "target": 0}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}", "target": 1}
{"code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }", "target": 1}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "void MultiplySum(const size_t xsize,\n                 const pixel_type* const JXL_RESTRICT row_in,\n                 const pixel_type* const JXL_RESTRICT row_in_Y,\n                 const float factor, float* const JXL_RESTRICT row_out) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  \n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x) + Load(di, row_in_Y + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}", "target": 0}
{"code": "bool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  const bool status = proto.ParseFromString(s);\n  if (status) FromProto(proto);\n  return status;\n}", "target": 1}
{"code": "Variant array_search(const Variant& needle,\n                     const Variant& haystack,\n                     bool strict ) {\n  Variant ret = false;\n  auto ok = strict ?\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; }) :\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; });\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"array_search() expects parameter 2 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n  return ret;\n}", "target": 0}
{"code": "parse_UNROLL_XLATE(char *arg OVS_UNUSED,\n                   const struct ofpact_parse_params *pp OVS_UNUSED)\n{\n    return xasprintf(\"UNROLL is an internal action \"\n                     \"that shouldn't be used via OpenFlow\");\n}", "target": 0}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "static void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *x, void *addr, unsigned int offset)\n{\n\tvoid *prior;\n\tvoid **object = (void *)x;\n\tstruct kmem_cache_cpu *c;\n\tc = get_cpu_slab(s, raw_smp_processor_id());\n\tstat(c, FREE_SLOWPATH);\n\tslab_lock(page);\n\tif (unlikely(SlabDebug(page)))\n\t\tgoto debug;\nchecks_ok:\n\tprior = object[offset] = page->freelist;\n\tpage->freelist = object;\n\tpage->inuse--;\n\tif (unlikely(SlabFrozen(page))) {\n\t\tstat(c, FREE_FROZEN);\n\t\tgoto out_unlock;\n\t}\n\tif (unlikely(!page->inuse))\n\t\tgoto slab_empty;\n\tif (unlikely(!prior)) {\n\t\tadd_partial(get_node(s, page_to_nid(page)), page, 1);\n\t\tstat(c, FREE_ADD_PARTIAL);\n\t}\nout_unlock:\n\tslab_unlock(page);\n\treturn;\nslab_empty:\n\tif (prior) {\n\t\tremove_partial(s, page);\n\t\tstat(c, FREE_REMOVE_PARTIAL);\n\t}\n\tslab_unlock(page);\n\tstat(c, FREE_SLAB);\n\tdiscard_slab(s, page);\n\treturn;\ndebug:\n\tif (!free_debug_processing(s, page, x, addr))\n\t\tgoto out_unlock;\n\tgoto checks_ok;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NoSplitLimitedSortAsCommandBatchSize) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    params.options |= QueryPlannerParams::SPLIT_LIMITED_SORT;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQueryAsCommand(fromjson(\"{find: 'testns', filter: {a: 1}, sort: {b: 1}, batchSize: 3}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1}, node: {ixscan: \"\n        \"{filter: null, pattern: {b: 1}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {b: 1}, limit: 0, node: {sortKeyGen: {node: {fetch: {filter: null,\"\n        \"node: {ixscan: {pattern: {a: 1}}}}}}}}}\");\n}", "target": 0}
{"code": "void base64_decode_xmlrpc(struct buffer_st *bfr, const char *source, int length)\n{\n    int i;\n    int offset = 0;\n    int endoffile;\n    int count;\n    buffer_new(bfr);\n    for (i = 0; i < 255; i++) {\n\tdtable[i] = 0x80;\n    }\n    for (i = 'A'; i <= 'Z'; i++) {\n        dtable[i] = 0 + (i - 'A');\n    }\n    for (i = 'a'; i <= 'z'; i++) {\n        dtable[i] = 26 + (i - 'a');\n    }\n    for (i = '0'; i <= '9'; i++) {\n        dtable[i] = 52 + (i - '0');\n    }\n    dtable['+'] = 62;\n    dtable['/'] = 63;\n    dtable['='] = 0;\n    endoffile = 0;\n    while (1) {\n\tunsigned char a[4], b[4], o[3];\n\tfor (i = 0; i < 4; i++) {\n\t    int c;\n\t    while (1) {\n\t      c = *(source++);\n\t      offset++;\n\t      if (offset > length) endoffile = 1;\n\t      if (isspace(c) || c == '\\n' || c == '\\r') continue;\n\t      break;\n\t    }\n\t    if (endoffile) {\n\t\treturn;\n\t    }\n\t    if (dtable[c] & 0x80) {\n\t      i--;\n\t      continue;\n\t    }\n\t    a[i] = (unsigned char) c;\n\t    b[i] = (unsigned char) dtable[c];\n\t}\n\to[0] = (b[0] << 2) | (b[1] >> 4);\n\to[1] = (b[1] << 4) | (b[2] >> 2);\n\to[2] = (b[2] << 6) | b[3];\n        i = a[2] == '=' ? 1 : (a[3] == '=' ? 2 : 3);\n\tcount = 0;\n\twhile (count < i) {\n\t  buffer_add(bfr, o[count++]);\n\t}\n\tif (i < 3) {\n\t    return;\n\t}\n    }\n}", "target": 1}
{"code": "GF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n        if (cur->type == XML_NAMESPACE_DECL)\n            return (NULL);\n        ctxt->ancestor = cur->parent;\n    }\n    if (cur->type == XML_NAMESPACE_DECL)\n        return(NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;", "target": 0}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "int avrcp_set_volume(struct btd_device *dev, int8_t volume, bool notify)\n{\n\tstruct avrcp_server *server;\n\tstruct avrcp *session;\n\tuint8_t buf[AVRCP_HEADER_LENGTH + 1];\n\tstruct avrcp_header *pdu = (void *) buf;\n\tif (volume < 0)\n\t\treturn -EINVAL;\n\tserver = find_server(servers, device_get_adapter(dev));\n\tif (server == NULL)\n\t\treturn -EINVAL;\n\tsession = find_session(server->sessions, dev);\n\tif (session == NULL)\n\t\treturn -ENOTCONN;\n\tif (notify) {\n\t\tif (!session->target)\n\t\t\treturn -ENOTSUP;\n\t\treturn avrcp_event(session, AVRCP_EVENT_VOLUME_CHANGED,\n\t\t\t\t\t\t\t\t&volume);\n\t}\n\tif (!session->controller && !avrcp_event_registered(session,\n\t\t\t\t\tAVRCP_EVENT_VOLUME_CHANGED))\n\t\treturn -ENOTSUP;\n\tmemset(buf, 0, sizeof(buf));\n\tset_company_id(pdu->company_id, IEEEID_BTSIG);\n\tpdu->pdu_id = AVRCP_SET_ABSOLUTE_VOLUME;\n\tpdu->params[0] = volume;\n\tpdu->params_len = htons(1);\n\treturn avctp_send_vendordep_req(session->conn,\n\t\t\t\t\tAVC_CTYPE_CONTROL, AVC_SUBUNIT_PANEL,\n\t\t\t\t\tbuf, sizeof(buf),\n\t\t\t\t\tavrcp_handle_set_volume, session);\n}", "target": 0}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}", "target": 1}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "int x509_get_name( unsigned char **p, const unsigned char *end,\n                   x509_name *cur )\n{\n    int ret;\n    size_t len;\n    const unsigned char *end2;\n    x509_name *use;\n    if( ( ret = asn1_get_tag( p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SET ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n    end2 = end;\n    end  = *p + len;\n    use = cur;\n    do\n    {\n        if( ( ret = x509_get_attr_type_value( p, end, use ) ) != 0 )\n            return( ret );\n        if( *p != end )\n        {\n            use->next = (x509_name *) polarssl_malloc(\n                    sizeof( x509_name ) );\n            if( use->next == NULL )\n                return( POLARSSL_ERR_X509_MALLOC_FAILED );\n            memset( use->next, 0, sizeof( x509_name ) );\n            use = use->next;\n        }\n    }\n    while( *p != end );\n    if( *p == end2 )\n        return( 0 );\n    cur->next = (x509_name *) polarssl_malloc(\n         sizeof( x509_name ) );\n    if( cur->next == NULL )\n        return( POLARSSL_ERR_X509_MALLOC_FAILED );\n    memset( cur->next, 0, sizeof( x509_name ) );\n    return( x509_get_name( p, end2, cur->next ) );\n}", "target": 1}
{"code": "static struct fdtable *close_files(struct files_struct * files)\n{\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\treturn fdt;\n}", "target": 0}
{"code": "dodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\tif (xdh_sizeof + offset > size) {\n\t\treturn xdh_sizeof + offset;\n\t}\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val & DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}", "target": 0}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "static int nfs4_xdr_dec_rename(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t       struct nfs_renameres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_savefh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_rename(xdr, &res->old_cinfo, &res->new_cinfo);\nout:\n\treturn status;\n}", "target": 0}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 0}
{"code": "void LIRGenerator::do_ArrayCopy(Intrinsic* x) {\n  assert(x->number_of_arguments() == 5, \"wrong type\");\n  CodeEmitInfo* info = state_for(x, x->state());\n  LIRItem src(x->argument_at(0), this);\n  LIRItem src_pos(x->argument_at(1), this);\n  LIRItem dst(x->argument_at(2), this);\n  LIRItem dst_pos(x->argument_at(3), this);\n  LIRItem length(x->argument_at(4), this);\n#ifndef _LP64\n  src.load_item_force     (FrameMap::rcx_oop_opr);\n  src_pos.load_item_force (FrameMap::rdx_opr);\n  dst.load_item_force     (FrameMap::rax_oop_opr);\n  dst_pos.load_item_force (FrameMap::rbx_opr);\n  length.load_item_force  (FrameMap::rdi_opr);\n  LIR_Opr tmp =           (FrameMap::rsi_opr);\n#else\n  src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));\n  src_pos.load_item_force (FrameMap::as_opr(j_rarg1));\n  dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));\n  dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));\n  length.load_item_force  (FrameMap::as_opr(j_rarg4));\n  LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);\n#endif \n  set_no_result(x);\n  int flags;\n  ciArrayKlass* expected_type;\n  arraycopy_helper(x, &flags, &expected_type);\n  __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); \n}", "target": 0}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "gen_k( gcry_mpi_t p, int small_k )\n{\n  gcry_mpi_t k = mpi_alloc_secure( 0 );\n  gcry_mpi_t temp = mpi_alloc( mpi_get_nlimbs(p) );\n  gcry_mpi_t p_1 = mpi_copy(p);\n  unsigned int orig_nbits = mpi_get_nbits(p);\n  unsigned int nbits, nbytes;\n  char *rndbuf = NULL;\n  if (small_k)\n    {\n      nbits = wiener_map( orig_nbits ) * 3 / 2;\n      if( nbits >= orig_nbits )\n        BUG();\n    }\n  else\n    nbits = orig_nbits;\n  nbytes = (nbits+7)/8;\n  if( DBG_CIPHER )\n    log_debug(\"choosing a random k\\n\");\n  mpi_sub_ui( p_1, p, 1);\n  for(;;)\n    {\n      if( !rndbuf || nbits < 32 )\n        {\n          xfree(rndbuf);\n          rndbuf = _gcry_random_bytes_secure( nbytes, GCRY_STRONG_RANDOM );\n        }\n      else\n        {\n          char *pp = _gcry_random_bytes_secure( 4, GCRY_STRONG_RANDOM );\n          memcpy( rndbuf, pp, 4 );\n          xfree(pp);\n\t}\n      _gcry_mpi_set_buffer( k, rndbuf, nbytes, 0 );\n      for(;;)\n        {\n          if( !(mpi_cmp( k, p_1 ) < 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('+');\n              break; \n            }\n          if( !(mpi_cmp_ui( k, 0 ) > 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('-');\n              break; \n            }\n          if (mpi_gcd( temp, k, p_1 ))\n            goto found;  \n          mpi_add_ui( k, k, 1 );\n          if( DBG_CIPHER )\n            progress('.');\n\t}\n    }\n found:\n  xfree (rndbuf);\n  if( DBG_CIPHER )\n    progress('\\n');\n  mpi_free(p_1);\n  mpi_free(temp);\n  return k;\n}", "target": 0}
{"code": "resp_new (const char *head)\n{\n  const char *hdr;\n  int count, size;\n  struct response *resp = xnew0 (struct response);\n  resp->data = head;\n  if (*head == '\\0')\n    {\n      return resp;\n    }\n  size = count = 0;\n  hdr = head;\n  while (1)\n    {\n      DO_REALLOC (resp->headers, size, count + 1, const char *);\n      resp->headers[count++] = hdr;\n      if (!hdr[0] || (hdr[0] == '\\r' && hdr[1] == '\\n') || hdr[0] == '\\n')\n        break;\n      do\n        {\n          const char *end = strchr (hdr, '\\n');\n          if (end)\n            hdr = end + 1;\n          else\n            hdr += strlen (hdr);\n        }\n      while (*hdr == ' ' || *hdr == '\\t');\n    }\n  DO_REALLOC (resp->headers, size, count + 1, const char *);\n  resp->headers[count] = NULL;\n  return resp;\n}", "target": 1}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "make_outerjoin_info(JOIN *join)\n{\n  DBUG_ENTER(\"make_outerjoin_info\");\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    if (tab->bush_children)\n    {\n      if (setup_sj_materialization_part1(tab))\n        DBUG_RETURN(TRUE);\n      tab->table->reginfo.join_tab= tab;\n    }\n  }\n  for (tab= first_linear_tab(join, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab; \n       tab= next_linear_tab(join, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    TABLE_LIST *tbl= table->pos_in_table_list;\n    TABLE_LIST *embedding= tbl->embedding;\n    if (tbl->outer_join & (JOIN_TYPE_LEFT | JOIN_TYPE_RIGHT))\n    {\n      tab->last_inner= tab->first_inner= tab;\n      tab->on_expr_ref= &tbl->on_expr;\n      tab->cond_equal= tbl->cond_equal;\n      if (embedding && !embedding->is_active_sjm())\n        tab->first_upper= embedding->nested_join->first_nested;\n    }\n    else if (!embedding)\n      tab->table->reginfo.not_exists_optimize= 0;\n    for ( ; embedding ; embedding= embedding->embedding)\n    {\n      if (embedding->is_active_sjm())\n      {\n        break;\n      }\n      if (!(embedding->on_expr && embedding->outer_join))\n      {\n        tab->table->reginfo.not_exists_optimize= 0;\n        continue;\n      }\n      NESTED_JOIN *nested_join= embedding->nested_join;\n      if (!nested_join->counter)\n      {\n        nested_join->first_nested= tab;\n        tab->on_expr_ref= &embedding->on_expr;\n        tab->cond_equal= tbl->cond_equal;\n        if (embedding->embedding)\n          tab->first_upper= embedding->embedding->nested_join->first_nested;\n      }\n      if (!tab->first_inner)  \n        tab->first_inner= nested_join->first_nested;\n      if (++nested_join->counter < nested_join->n_tables)\n        break;\n      nested_join->first_nested->last_inner= tab;\n    }\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif \n  {\n    parser->m_processor = contentProcessor;\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}", "target": 1}
{"code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\tif (thread)\n\t\tCloseHandle (thread);\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\tg_free (this->name);\n}", "target": 1}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "ex_redraw(exarg_T *eap)\n{\n    int\t\tr = RedrawingDisabled;\n    int\t\tp = p_lz;\n    RedrawingDisabled = 0;\n    p_lz = FALSE;\n    validate_cursor();\n    update_topline();\n    update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);\n    if (need_maketitle)\n\tmaketitle();\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!gui.in_use)\n# endif\n\tresize_console_buf();\n#endif\n    RedrawingDisabled = r;\n    p_lz = p;\n    screen_stop_highlight();\n    msg_didout = FALSE;\n    msg_col = 0;\n    need_wait_return = FALSE;\n    if (State & CMDLINE)\n\tredrawcmdline();\n    out_flush();\n}", "target": 0}
{"code": "void usbredirparser_init(struct usbredirparser *parser_pub,\n    const char *version, uint32_t *caps, int caps_len, int flags)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usb_redir_hello_header hello = { { 0 }, };\n    parser->flags = (flags & ~usbredirparser_fl_no_hello);\n    if (parser->callb.alloc_lock_func) {\n        parser->lock = parser->callb.alloc_lock_func();\n    }\n    snprintf(hello.version, sizeof(hello.version), \"%s\", version);\n    if (caps_len > USB_REDIR_CAPS_SIZE) {\n        caps_len = USB_REDIR_CAPS_SIZE;\n    }\n    memcpy(parser->our_caps, caps, caps_len * sizeof(uint32_t));\n    if (!(flags & usbredirparser_fl_usb_host))\n        usbredirparser_caps_set_cap(parser->our_caps,\n                                    usb_redir_cap_device_disconnect_ack);\n    usbredirparser_verify_caps(parser, parser->our_caps, \"our\");\n    if (!(flags & usbredirparser_fl_no_hello))\n        usbredirparser_queue(parser_pub, usb_redir_hello, 0, &hello,\n                             (uint8_t *)parser->our_caps,\n                             USB_REDIR_CAPS_SIZE * sizeof(uint32_t));\n}", "target": 0}
{"code": "static int fdt_include_supernodes(struct fdt_region_state *info, int depth)\n{\n\tint base = fdt_off_dt_struct(info->fdt);\n\tint start, stop_at;\n\tint i;\n\tfor (i = 0; i <= depth; i++) {\n\t\tif (!info->stack[i].included) {\n\t\t\tstart = info->stack[i].offset;\n\t\t\tfdt_next_tag(info->fdt, start, &stop_at);\n\t\t\tif (fdt_add_region(info, base + start, stop_at - start))\n\t\t\t\treturn -1;\n\t\t\tinfo->stack[i].included = 1;\n\t\t\tinfo->can_merge = 1;\n\t\t}\n\t\tif (!info->stack[i].want)\n\t\t\tinfo->stack[i].want = WANT_NODES_ONLY;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static int btrfs_add_system_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *key,\n\t\t\t   struct btrfs_chunk *chunk, int item_size)\n{\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_disk_key disk_key;\n\tu32 array_size;\n\tu8 *ptr;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tif (array_size + item_size + sizeof(disk_key)\n\t\t\t> BTRFS_SYSTEM_CHUNK_ARRAY_SIZE) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EFBIG;\n\t}\n\tptr = super_copy->sys_chunk_array + array_size;\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\tmemcpy(ptr, &disk_key, sizeof(disk_key));\n\tptr += sizeof(disk_key);\n\tmemcpy(ptr, chunk, item_size);\n\titem_size += sizeof(disk_key);\n\tbtrfs_set_super_sys_array_size(super_copy, array_size + item_size);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tCATEnum cat_enum;\n\tchar *sep;\n\tcat_enum.dest = dest;\n\tcat_enum.import_flags = import_flags;\n\tcat_enum.force_fps = force_fps;\n\tcat_enum.frames_per_sample = frames_per_sample;\n\tcat_enum.tmp_dir = tmp_dir;\n\tcat_enum.force_cat = force_cat;\n \tcat_enum.align_timelines = align_timelines;\n \tcat_enum.allow_add_in_command = allow_add_in_command;\n \tstrcpy(cat_enum.szPath, fileName);\n \tsep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);\n \tif (!sep) sep = strrchr(cat_enum.szPath, '/');\n \tif (!sep) {\n \t\tstrcpy(cat_enum.szPath, \".\");\n \t\tstrcpy(cat_enum.szRad1, fileName);\n \t} else {\n \t\tstrcpy(cat_enum.szRad1, sep+1);\n \t\tsep[0] = 0;\n \t}\n \tsep = strchr(cat_enum.szRad1, '*');\n \tstrcpy(cat_enum.szRad2, sep+1);\n \tsep[0] = 0;\n \tsep = strchr(cat_enum.szRad2, '%');\n \tif (!sep) sep = strchr(cat_enum.szRad2, '#');\n \tif (!sep) sep = strchr(cat_enum.szRad2, ':');\n \tstrcpy(cat_enum.szOpt, \"\");\n \tif (sep) {\n \t\tstrcpy(cat_enum.szOpt, sep);\n \t\tsep[0] = 0;\n \t}\n\treturn gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);\n}", "target": 1}
{"code": "tagstack_push_items(win_T *wp, list_T *l)\n{\n    listitem_T\t*li;\n    dictitem_T\t*di;\n    dict_T\t*itemdict;\n    char_u\t*tagname;\n    pos_T\tmark;\n    int\t\tfnum;\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT || li->li_tv.vval.v_dict == NULL)\n\t    continue;\t\t\t\t\n\titemdict = li->li_tv.vval.v_dict;\n\tif ((di = dict_find(itemdict, (char_u *)\"from\", -1)) == NULL)\n\t    continue;\n\tif (list2fpos(&di->di_tv, &mark, &fnum, NULL, FALSE) != OK)\n\t    continue;\n\tif ((tagname = dict_get_string(itemdict, \"tagname\", TRUE)) == NULL)\n\t    continue;\n\tif (mark.col > 0)\n\t    mark.col--;\n\ttagstack_push_item(wp, tagname,\n\t\t(int)dict_get_number(itemdict, \"bufnr\"),\n\t\t(int)dict_get_number(itemdict, \"matchnr\") - 1,\n\t\tmark, fnum,\n\t\tdict_get_string(itemdict, \"user_data\", TRUE));\n    }\n}", "target": 0}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_last_notice) \n{\n\tzval *pgsql_link = NULL;\n\tPGconn *pg_link;\n\tint id = -1;\n\tphp_pgsql_notice *notice;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &pgsql_link) == FAILURE) {\n\t\treturn;\n\t}\n\tif (pgsql_link == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif ((notice = zend_hash_index_find_ptr(&PGG(notices), (zend_ulong)Z_RES_HANDLE_P(pgsql_link))) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(notice->message, notice->len);\n}", "target": 0}
{"code": "void luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  \n  white2gray(o);  \n  setage(o, G_OLD);  \n  g->allgc = o->next;  \n  o->next = g->fixedgc;  \n  g->fixedgc = o;\n}", "target": 0}
{"code": "static int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int snd_usb_apply_interface_quirk(struct snd_usb_audio *chip,\n\t\t\t\t  int iface,\n\t\t\t\t  int altno)\n{\n\tif (chip->usb_id == USB_ID(0x0763, 0x2003))\n\t\treturn audiophile_skip_setting_quirk(chip, iface, altno);\n\tif (chip->usb_id == USB_ID(0x0763, 0x2001))\n\t\treturn quattro_skip_setting_quirk(chip, iface, altno);\n\tif (chip->usb_id == USB_ID(0x0763, 0x2012))\n\t\treturn fasttrackpro_skip_setting_quirk(chip, iface, altno);\n\treturn 0;\n}", "target": 0}
{"code": "psf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\treturn ;\n} ", "target": 0}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "static bool is_maintenance_mode_cmd(struct kernel_ipmi_msg *msg)\n{\n\treturn (((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t\t && ((msg->cmd == IPMI_COLD_RESET_CMD)\n\t\t     || (msg->cmd == IPMI_WARM_RESET_CMD)))\n\t\t|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST));\n}", "target": 0}
{"code": "dirserv_should_launch_reachability_test(const routerinfo_t *ri,\n                                        const routerinfo_t *ri_old)\n{\n  if (!authdir_mode_handles_descs(get_options(), ri->purpose))\n    return 0;\n  if (!ri_old) {\n    return 1;\n  }\n  if (ri_old->is_hibernating && !ri->is_hibernating) {\n    return 1;\n  }\n  if (! routers_have_same_or_addrs(ri, ri_old)) {\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "    void TiffEncoder::add(\n        TiffComponent* pRootDir,\n        TiffComponent* pSourceDir,\n        uint32_t       root\n    )\n    {\n        assert(pRootDir != 0);\n        writeMethod_ = wmIntrusive;\n        pSourceTree_ = pSourceDir;\n        del_ = false;\n        ExifData::const_iterator posBo = exifData_.end();\n        for (ExifData::const_iterator i = exifData_.begin();\n             i != exifData_.end(); ++i) {\n            IfdId group = groupId(i->groupName());\n            if (group == mnId) {\n                if (i->tag() == 0x0002) {\n                    posBo = i;\n                }\n                continue;\n            }\n            if (isImageTag(i->tag(), group)) continue;\n            TiffPath tiffPath;\n            TiffCreator::getPath(tiffPath, i->tag(), group, root);\n            TiffComponent* tc = pRootDir->addPath(i->tag(), tiffPath, pRootDir);\n            TiffEntryBase* object = dynamic_cast<TiffEntryBase*>(tc);\n#ifdef DEBUG\n            if (object == 0) {\n                std::cerr << \"Warning: addPath() didn't add an entry for \"\n                          << i->groupName()\n                          << \" tag 0x\" << std::setw(4) << std::setfill('0')\n                          << std::hex << i->tag() << \"\\n\";\n            }\n#endif\n            if (object != 0) {\n                encodeTiffComponent(object, &(*i));\n            }\n        }\n        if (posBo == exifData_.end()) return;\n        TiffFinder finder(0x927c, exifId);\n        pRootDir->accept(finder);\n        TiffMnEntry* te = dynamic_cast<TiffMnEntry*>(finder.result());\n        if (te) {\n            TiffIfdMakernote* tim = dynamic_cast<TiffIfdMakernote*>(te->mn_);\n            if (tim) {\n                ByteOrder bo = stringToByteOrder(posBo->toString());\n                if (bo != invalidByteOrder) tim->setByteOrder(bo);\n            }\n        }\n    } ", "target": 0}
{"code": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\tpflac->ptr = NULL ;\n\treturn pflac->pos ;\n} ", "target": 1}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "string Print(const FunctionDef& fdef) {\n  string out;\n  const OpDef& sig = fdef.signature();\n  strings::StrAppend(&out, \"\\n\", sig.name());\n  if (sig.attr_size() > 0) {\n    strings::StrAppend(&out, \"[\");\n    for (int i = 0; i < sig.attr_size(); ++i) {\n      const auto& a = sig.attr(i);\n      if (i > 0) strings::StrAppend(&out, \", \");\n      if (a.type() == \"type\") {\n        strings::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n      } else {\n        strings::StrAppend(&out, a.name(), \":\", a.type());\n      }\n    }\n    strings::StrAppend(&out, \"]\");\n  }\n  strings::StrAppend(&out, \"(\");\n  for (int i = 0; i < sig.input_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.input_arg(i)));\n  }\n  strings::StrAppend(&out, \") -> (\");\n  for (int i = 0; i < sig.output_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.output_arg(i)));\n  }\n  strings::StrAppend(&out, \") {\\n\");\n  for (const auto& n : fdef.node_def()) {\n    strings::StrAppend(&out, \"  \", Print(n), \"\\n\");\n  }\n  for (const auto& cr : fdef.control_ret()) {\n    strings::StrAppend(&out, \"  @return \", cr.first, \" = \", cr.second, \"\\n\");\n  }\n  for (const auto& r : fdef.ret()) {\n    strings::StrAppend(&out, \"  return \", r.first, \" = \", r.second, \"\\n\");\n  }\n  strings::StrAppend(&out, \"}\\n\");\n  return out;\n}", "target": 0}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static void tipc_node_link_failover(struct tipc_node *n, struct tipc_link *l,\n\t\t\t\t    struct tipc_link *tnl,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tif (!tipc_link_is_up(tnl))\n\t\treturn;\n\tif (l && !tipc_link_is_reset(l))\n\t\treturn;\n\ttipc_link_fsm_evt(tnl, LINK_SYNCH_END_EVT);\n\ttipc_node_fsm_evt(n, NODE_SYNCH_END_EVT);\n\tn->sync_point = tipc_link_rcv_nxt(tnl) + (U16_MAX / 2 - 1);\n\ttipc_link_failover_prepare(l, tnl, xmitq);\n\tif (l)\n\t\ttipc_link_fsm_evt(l, LINK_FAILOVER_BEGIN_EVT);\n\ttipc_node_fsm_evt(n, NODE_FAILOVER_BEGIN_EVT);\n}", "target": 0}
{"code": "g_opendir(Char *str, glob_t *pglob)\n{\n    char buf[PATH_MAX];\n    if (!*str) {\n        buf[0] = '.';\n        buf[1] = 0;\n    } else {\n        if (g_Ctoc(str, buf, sizeof(buf))) {\n            return NULL;\n        }\n    }\n    if (pglob->gl_flags & GLOB_ALTDIRFUNC) {\n        return (*pglob->gl_opendir)(buf);\n    }\n    return opendir(buf);\n}", "target": 0}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    qemuMonitorUnregister(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 1}
{"code": "jd_to_nth_kday(VALUE jd, double sg,\n\t       VALUE *nth, int *rjd,\n\t       int *ry, int *rm, int *rn, int *rk)\n{\n    decode_jd(jd, nth, rjd);\n    c_jd_to_nth_kday(*rjd, sg, ry, rm, rn, rk);\n}", "target": 0}
{"code": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n     if (code == gs_error_undefinedresult) {\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }", "target": 1}
{"code": "static void FNAME(update_model)(CommonState *state, s_bucket * const bucket,\n                                const BYTE curval)\n{\n    SPICE_VERIFY(BPC >= 1);\n    spice_return_if_fail (bucket != NULL);\n    const unsigned int bpp = BPC;\n    COUNTER * const pcounters = bucket->pcounters;\n    unsigned int i;\n    unsigned int bestcode;\n    unsigned int bestcodelen;\n    bestcode = bpp - 1;\n    bestcodelen = (pcounters[bestcode] += FNAME(golomb_code_len)(curval, bestcode));\n    for (i = bpp - 2; i < bpp; i--) { \n        const unsigned int ithcodelen = (pcounters[i] += FNAME(golomb_code_len)(curval, i));\n        if (ithcodelen < bestcodelen) {\n            bestcode = i;\n            bestcodelen = ithcodelen;\n        }\n    }\n    bucket->bestcode = bestcode; \n    if (bestcodelen > state->wm_trigger) { \n        for (i = 0; i < bpp; i++) {\n            pcounters[i] >>= 1;\n        }\n    }\n}", "target": 0}
{"code": "dirserv_cache_measured_bw(const measured_bw_line_t *parsed_line,\n                          time_t as_of)\n{\n  mbw_cache_entry_t *e = NULL;\n  tor_assert(parsed_line);\n  if (!mbw_cache) mbw_cache = digestmap_new();\n  e = digestmap_get(mbw_cache, parsed_line->node_id);\n  if (e) {\n    if (as_of > e->as_of) {\n      e->mbw_kb = parsed_line->bw_kb;\n      e->as_of = as_of;\n    }\n  } else {\n    e = tor_malloc(sizeof(*e));\n    e->mbw_kb = parsed_line->bw_kb;\n    e->as_of = as_of;\n    digestmap_set(mbw_cache, parsed_line->node_id, e);\n  }\n}", "target": 0}
{"code": "static struct tipc_node *tipc_node_find_by_name(struct net *net,\n\t\t\t\t\t\tconst char *link_name,\n\t\t\t\t\t\tunsigned int *bearer_id)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_link *l;\n\tstruct tipc_node *n;\n\tstruct tipc_node *found_node = NULL;\n\tint i;\n\t*bearer_id = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_read_lock(n);\n\t\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\t\tl = n->links[i].link;\n\t\t\tif (l && !strcmp(tipc_link_name(l), link_name)) {\n\t\t\t\t*bearer_id = i;\n\t\t\t\tfound_node = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttipc_node_read_unlock(n);\n\t\tif (found_node)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn found_node;\n}", "target": 0}
{"code": "  void AddInput(int node_index, int output_node, int output_index) {\n    CHECK_LT(node_index, nodes_.size());\n    nodes_[node_index].data_inputs.push_back(\n        std::make_pair(output_node, output_index));\n  }", "target": 0}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n    return self;\n}", "target": 1}
{"code": "    DataLocId CiffComponent::dataLocation(uint16_t tag)\n    {\n        switch (tag & 0xc000) {\n        case 0x0000: return valueData;\n        case 0x4000: return directoryData;\n        default: throw Error(kerCorruptedMetadata);\n        }\n    } ", "target": 0}
{"code": "static int wcd9335_codec_lineout_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t   struct snd_kcontrol *kc, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\twcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_PRE_DAC,\n\t\t\t\t\tWCD_CLSH_STATE_LO, CLS_AB);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\twcd_clsh_ctrl_set_state(wcd->clsh_ctrl, WCD_CLSH_EVENT_POST_PA,\n\t\t\t\t\tWCD_CLSH_STATE_LO, CLS_AB);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}", "target": 0}
{"code": "double JOIN::get_examined_rows()\n{\n  double examined_rows;\n  double prev_fanout= 1;\n  double records;\n  JOIN_TAB *tab= first_breadth_first_tab();\n  JOIN_TAB *prev_tab= tab;\n  records= (double)tab->get_examined_rows();\n  while ((tab= next_breadth_first_tab(first_breadth_first_tab(),\n                                      top_join_tab_count, tab)))\n  {\n    prev_fanout= COST_MULT(prev_fanout, prev_tab->records_read);\n    records=\n      COST_ADD(records,\n               COST_MULT((double) (tab->get_examined_rows()), prev_fanout));\n    prev_tab= tab;\n  }\n  examined_rows= (double)\n    (records > (double) HA_ROWS_MAX ? HA_ROWS_MAX : (ha_rows) records);\n  return examined_rows;\n}", "target": 0}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n      free(p_cdtext_data);\n    }\n  }\n  return p_env->cdtext;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::OnDisplayBoundsChanged(\n    const gfx::Display& display) {\n  gfx::Screen* screen = gfx::Screen::GetScreenFor(window_);\n  if (display.id() == screen->GetDisplayNearestWindow(window_).id()) {\n    UpdateScreenInfo(window_);\n    current_cursor_.SetDisplayInfo(display);\n    UpdateCursorIfOverSelf();\n  }\n}", "target": 0}
{"code": "smb2_negotiate_rsize(struct cifs_tcon *tcon, struct smb3_fs_context *ctx)\n{\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize;\n\trsize = ctx->rsize ? ctx->rsize : CIFS_DEFAULT_IOSIZE;\n\trsize = min_t(unsigned int, rsize, server->max_read);\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\trsize = min_t(unsigned int, rsize, SMB2_MAX_BUFFER_SIZE);\n\treturn rsize;\n}", "target": 0}
{"code": "static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n                                          bool tso_enable)\n{\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n    uint16_t l3_proto;\n    l3_proto = eth_get_l3_proto(&pkt->vec[NET_TX_PKT_L2HDR_FRAG], 1,\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n    if (!tso_enable) {\n        goto func_exit;\n    }\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n                          pkt->l4proto);\nfunc_exit:\n    return rc;\n}", "target": 0}
{"code": "static RBinElfSymbol *Elf_(r_bin_elf_get_phdr_imports)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_imports) {\n\t\treturn bin->phdr_imports;\n\t}\n\tbin->phdr_imports = get_symbols_from_phdr (bin, R_BIN_ELF_IMPORTS);\n\treturn bin->phdr_imports;\n}", "target": 0}
{"code": "write_VD_terminator(struct archive_write *a)\n{\n\tunsigned char *bp;\n\tbp = wb_buffptr(a) -1;\n\tset_VD_bp(bp, VDT_TERMINATOR, 1);\n\tset_unused_field_bp(bp, 8, LOGICAL_BLOCK_SIZE);\n\treturn (wb_consume(a, LOGICAL_BLOCK_SIZE));\n}", "target": 0}
{"code": "static struct per_transfer *del_per_transfer(struct per_transfer *per)\n{\n  struct per_transfer *n;\n  struct per_transfer *p;\n  DEBUGASSERT(transfers);\n  DEBUGASSERT(transfersl);\n  DEBUGASSERT(per);\n  n = per->next;\n  p = per->prev;\n  if(p)\n    p->next = n;\n  else\n    transfers = n;\n  if(n)\n    n->prev = p;\n  else\n    transfersl = p;\n  free(per);\n  return n;\n}", "target": 0}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "static void blk_mq_exit_hw_queues(struct request_queue *q,\n\t\tstruct blk_mq_tag_set *set, int nr_queue)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned int i;\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (i == nr_queue)\n\t\t\tbreak;\n\t\tblk_mq_exit_hctx(q, set, hctx, i);\n\t}\n}", "target": 0}
{"code": "static inline uint8_t ok_read_uint8(ok_jpg_decoder *decoder) {\n    if (decoder->input_buffer_start == decoder->input_buffer_end) {\n        size_t len = decoder->input.read(decoder->input_user_data, decoder->input_buffer,\n                                         sizeof(decoder->input_buffer));\n        decoder->input_buffer_start = decoder->input_buffer;\n        decoder->input_buffer_end = decoder->input_buffer + len;\n        if (len == 0) {\n            return 0;\n        }\n    }\n    return *decoder->input_buffer_start++;\n}", "target": 0}
{"code": "PartitionInstallUdfChildHandles (\n  IN  EFI_DRIVER_BINDING_PROTOCOL  *This,\n  IN  EFI_HANDLE                   Handle,\n  IN  EFI_DISK_IO_PROTOCOL         *DiskIo,\n  IN  EFI_DISK_IO2_PROTOCOL        *DiskIo2,\n  IN  EFI_BLOCK_IO_PROTOCOL        *BlockIo,\n  IN  EFI_BLOCK_IO2_PROTOCOL       *BlockIo2,\n  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath\n  )\n{\n  UINT32                       RemainderByMediaBlockSize;\n  EFI_STATUS                   Status;\n  EFI_BLOCK_IO_MEDIA           *Media;\n  EFI_PARTITION_INFO_PROTOCOL  PartitionInfo;\n  EFI_LBA                      StartingLBA;\n  EFI_LBA                      EndingLBA;\n  BOOLEAN                      ChildCreated;\n  Media = BlockIo->Media;\n  ChildCreated = FALSE;\n  DivU64x32Remainder (\n    UDF_LOGICAL_SECTOR_SIZE,   \n    Media->BlockSize,          \n    &RemainderByMediaBlockSize \n    );\n  if (RemainderByMediaBlockSize != 0) {\n    return EFI_NOT_FOUND;\n  }\n  Status = PartitionInstallElToritoChildHandles (\n             This,\n             Handle,\n             DiskIo,\n             DiskIo2,\n             BlockIo,\n             BlockIo2,\n             DevicePath\n             );\n  if (!EFI_ERROR (Status)) {\n    DEBUG ((DEBUG_INFO, \"PartitionDxe: El Torito standard found on handle 0x%p.\\n\", Handle));\n    ChildCreated = TRUE;\n  }\n  Status = FindUdfFileSystem (BlockIo, DiskIo, &StartingLBA, &EndingLBA);\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : EFI_NOT_FOUND);\n  }\n  ZeroMem (&PartitionInfo, sizeof (EFI_PARTITION_INFO_PROTOCOL));\n  PartitionInfo.Revision = EFI_PARTITION_INFO_PROTOCOL_REVISION;\n  PartitionInfo.Type = PARTITION_TYPE_OTHER;\n  Status = PartitionInstallChildHandle (\n    This,\n    Handle,\n    DiskIo,\n    DiskIo2,\n    BlockIo,\n    BlockIo2,\n    DevicePath,\n    (EFI_DEVICE_PATH_PROTOCOL *)&gUdfDevicePath,\n    &PartitionInfo,\n    StartingLBA,\n    EndingLBA,\n    Media->BlockSize,\n    NULL\n    );\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : Status);\n  }\n  return EFI_SUCCESS;\n}", "target": 0}
{"code": "static void TIFFIgnoreTags(TIFF *tiff)\n{\n  char\n    *q;\n  const char\n    *p,\n    *tags;\n  Image\n   *image;\n  register ssize_t\n    i;\n  size_t\n    count;\n  TIFFFieldInfo\n    *ignore;\n  if (TIFFGetReadProc(tiff) != TIFFReadBlob)\n    return;\n  image=(Image *)TIFFClientdata(tiff);\n  tags=GetImageArtifact(image,\"tiff:ignore-tags\");\n  if (tags == (const char *) NULL)\n    return;\n  count=0;\n  p=tags;\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    (void) strtol(p,&q,10);\n    if (p == q)\n      return;\n    p=q;\n    count++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  if (count == 0)\n    return;\n  i=0;\n  p=tags;\n  ignore=(TIFFFieldInfo *) AcquireQuantumMemory(count,sizeof(*ignore));\n  if (ignore == (TIFFFieldInfo *) NULL)\n    return;\n  memset(ignore,0,count*sizeof(*ignore));\n  while (*p != '\\0')\n  {\n    while ((isspace((int) ((unsigned char) *p)) != 0))\n      p++;\n    ignore[i].field_tag=(ttag_t) strtol(p,&q,10);\n    p=q;\n    i++;\n    while ((isspace((int) ((unsigned char) *p)) != 0) || (*p == ','))\n      p++;\n  }\n  (void) TIFFMergeFieldInfo(tiff,ignore,(uint32) count);\n  ignore=(TIFFFieldInfo *) RelinquishMagickMemory(ignore);\n}", "target": 0}
{"code": "static void ulaw2linear_buf (const uint8_t *ulaw, int16_t *linear, int nsamples)\n{\n\tfor (int i=0; i < nsamples; i++)\n\t\tlinear[i] = _af_ulaw2linear(ulaw[i]);\n}", "target": 0}
{"code": "static void irda_connect_confirm(void *instance, void *sap,\n\t\t\t\t struct qos_info *qos,\n\t\t\t\t __u32 max_sdu_size, __u8 max_header_size,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n    sigpipe_ignore(conn->data, &pipe_st);\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}", "target": 1}
{"code": "get_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\t     const char *path, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\tcifs_dbg(FYI, \"get smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\toparms.tcon = tcon;\n\toparms.desired_access = READ_CONTROL;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = cifs_create_options(cifs_sb, 0) | OPEN_REPARSE_POINT;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\tif (info & SACL_SECINFO)\n\t\toparms.desired_access |= SYSTEM_SECURITY;\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t\t    info);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \treturn datagrams;\n}", "target": 1}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "GF_Err aprm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->enc_info, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->key_info, &pos);\n    return GF_OK;\n}", "target": 0}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "void APE::Properties::analyzeCurrent()\n{\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n  ByteVector header = d->file->readBlock(24);\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}", "target": 1}
{"code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "static void ff_layout_write_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tff_layout_write_record_layoutstats_done(&hdr->task, hdr);\n\tif (test_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags)) {\n\t\tff_layout_send_layouterror(hdr->lseg);\n\t\tff_layout_reset_write(hdr, true);\n\t} else if (test_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags))\n\t\tff_layout_reset_write(hdr, false);\n\tpnfs_generic_rw_release(data);\n}", "target": 0}
{"code": " double ConvolverNode::latencyTime() const\n {\n    return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n }", "target": 1}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    bool timeout = false;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            timeout = true;\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (!timeout && s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\tatomic_inc(&user->inotify_devs);\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n \tif (ret >= 0)\n \t\treturn ret;\n \tatomic_dec(&user->inotify_devs);\n out_free_uid:\n \tfree_uid(user);\n\treturn ret;\n}", "target": 1}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "parse_PUSH_VLAN(char *arg, const struct ofpact_parse_params *pp)\n{\n    struct ofpact_push_vlan *push_vlan;\n    uint16_t ethertype;\n    char *error;\n    *pp->usable_protocols &= OFPUTIL_P_OF11_UP;\n    error = str_to_u16(arg, \"ethertype\", &ethertype);\n    if (error) {\n        return error;\n    }\n    if (!eth_type_vlan(htons(ethertype))) {\n        return xasprintf(\"%s: not a valid VLAN ethertype\", arg);\n    }\n    push_vlan = ofpact_put_PUSH_VLAN(pp->ofpacts);\n    push_vlan->ethertype = htons(ethertype);\n    return NULL;\n}", "target": 0}
{"code": "void unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\tmutex_lock(&block_class_lock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tmutex_unlock(&block_class_lock);\n\tkfree(p);\n}", "target": 0}
{"code": "mrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n  switch (insn) {\n#define FETCH_Z() \n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}", "target": 0}
{"code": "_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {\n    TIFFSTATE *state = (TIFFSTATE *)hdata;\n    tsize_t to_read;\n    TRACE((\"_tiffReadProc: %d \\n\", (int)size));\n    dump_state(state);\n    to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);\n    TRACE((\"to_read: %d\\n\", (int)to_read));\n    _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);\n    state->loc += (toff_t)to_read;\n    TRACE((\"location: %u\\n\", (uint)state->loc));\n    return to_read;\n}", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": "static int snd_timer_dev_disconnect(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_del_init(&timer->device_list);\n\tlist_for_each_entry(ti, &timer->open_list_head, open_list) {\n\t\tif (ti->disconnect)\n\t\t\tti->disconnect(ti);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "void ChangeListLoader::LoadDirectoryIfNeededAfterGetEntry(\n    const base::FilePath& directory_path,\n    const FileOperationCallback& callback,\n    bool should_try_loading_parent,\n    const ResourceEntry* entry,\n    FileError error) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  if (error == FILE_ERROR_NOT_FOUND &&\n      should_try_loading_parent &&\n      util::GetDriveGrandRootPath().IsParent(directory_path)) {\n    LoadDirectoryIfNeeded(\n        directory_path.DirName(),\n        base::Bind(&ChangeListLoader::LoadDirectoryIfNeededAfterLoadParent,\n                   weak_ptr_factory_.GetWeakPtr(),\n                   directory_path,\n                   callback));\n    return;\n  }\n  if (error != FILE_ERROR_OK) {\n    callback.Run(error);\n    return;\n  }\n  if (!entry->file_info().is_directory()) {\n    callback.Run(FILE_ERROR_NOT_A_DIRECTORY);\n    return;\n  }\n  if (entry->local_id() == util::kDriveOtherDirLocalId) {\n    callback.Run(FILE_ERROR_OK);\n    return;\n  }\n  Load(DirectoryFetchInfo(entry->local_id(),\n                          entry->resource_id(),\n                          entry->directory_specific_info().changestamp()),\n       callback);\n}", "target": 0}
{"code": "pfkey_proto2satype(uint16_t proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\t\treturn SADB_SATYPE_AH;\n\tcase IPPROTO_ESP:\n\t\treturn SADB_SATYPE_ESP;\n\tcase IPPROTO_COMP:\n\t\treturn SADB_X_SATYPE_IPCOMP;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\t\ti++;\n\t}\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\treturn git_pkt_buffer_flush(buf);\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tfmode_t fmode,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct rpc_cred *cred,\n\t\t\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tfmode &= FMODE_READ|FMODE_WRITE|FMODE_EXEC;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, dentry, fmode, flags, sattr, cred,\n\t\t\t\t       &res, ctx_th);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 0}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n    size_t hash = 5381;\n    size_t c;\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n    return hash;\n}", "target": 1}
{"code": "static int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}", "target": 0}
{"code": "cgiSetArray(const char *name,\t\t\n            int        element,\t\t\n            const char *value)\t\t\n{\n  int\t\ti;\t\t\t\n  _cgi_var_t\t*var;\t\t\t\n  if (name == NULL || value == NULL || element < 0 || element > 100000)\n    return;\n  fprintf(stderr, \"DEBUG: cgiSetArray: %s[%d]=\\\"%s\\\"\\n\", name, element, value);\n  if ((var = cgi_find_variable(name)) == NULL)\n  {\n    cgi_add_variable(name, element, value);\n    cgi_sort_variables();\n  }\n  else\n  {\n    if (element >= var->avalues)\n    {\n      const char **temp;\t\t\n      temp = (const char **)realloc((void *)(var->values),\n                                    sizeof(char *) * (size_t)(element + 16));\n      if (!temp)\n        return;\n      var->avalues = element + 16;\n      var->values  = temp;\n    }\n    if (element >= var->nvalues)\n    {\n      for (i = var->nvalues; i < element; i ++)\n\tvar->values[i] = NULL;\n      var->nvalues = element + 1;\n    }\n    else if (var->values[element])\n      _cupsStrFree((char *)var->values[element]);\n    var->values[element] = _cupsStrAlloc(value);\n  }\n}", "target": 0}
{"code": "aspath_cmp_left (const struct aspath *aspath1, const struct aspath *aspath2)\n{\n  const struct assegment *seg1;\n  const struct assegment *seg2;\n  if (!(aspath1 && aspath2))\n    return 0;\n  seg1 = aspath1->segments;\n  seg2 = aspath2->segments;\n  if (!seg1 && !seg2)\n    return 1;\n  while (seg1 && ((seg1->type == AS_CONFED_SEQUENCE)\n\t\t  || (seg1->type == AS_CONFED_SET)))\n    seg1 = seg1->next;\n  while (seg2 && ((seg2->type == AS_CONFED_SEQUENCE)\n\t\t  || (seg2->type == AS_CONFED_SET)))\n    seg2 = seg2->next;\n  if (!(seg1 && seg2\n\t&& (seg1->type == AS_SEQUENCE) && (seg2->type == AS_SEQUENCE)))\n    return 0;\n  if (seg1->as[0] == seg2->as[0])\n    return 1;\n  return 0;\n}", "target": 0}
{"code": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n const size_t size = p->readInt32();\n const void* regionData = p->readInplace(size);\n if (regionData == NULL) {\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n    region->readFromMemory(regionData, size);\n     return reinterpret_cast<jlong>(region);\n }", "target": 1}
{"code": "static int vidioc_s_std(struct file *file, void *private_data, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n     int length;\n     length = strlen (filename);\n    if (length > 0)\n     {\n         if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n             return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "iasecc_pin_get_status(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data info;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for status\");\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = SC_PIN_CMD_GET_INFO;\n\tinfo.pin_type = data->pin_type;\n\tinfo.pin_reference = data->pin_reference;\n\trv = iso_ops->pin_cmd(card, &info, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"Failed to get PIN info\");\n\tdata->pin1.max_tries = info.pin1.max_tries;\n\tdata->pin1.tries_left = info.pin1.tries_left;\n\tdata->pin1.logged_in = info.pin1.logged_in;\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 0}
{"code": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n}", "target": 0}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[256];\n        sprintf(buf, \"conversion from %s to %s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "fz_rendering_intent_name(int ri)\n{\n\tif (ri >= 0 && ri < nelem(fz_intent_names))\n\t\treturn (char*)fz_intent_names[ri];\n\treturn \"RelativeColorimetric\";\n}", "target": 0}
{"code": "void ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\tqwInlineNotice->hide();\n\tadjustSize();\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\tdelete m_si;\n\tm_si = NULL;\n}", "target": 0}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n {\n \tstruct port *port;\n \tstruct scatterlist sg[1];\n \tif (unlikely(early_put_chars))\n \t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n \tif (!port)\n \t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n }", "target": 1}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "xsltGetKey(xsltTransformContextPtr ctxt, const xmlChar *name,\n\t   const xmlChar *nameURI, const xmlChar *value) {\n    xmlNodeSetPtr ret;\n    xsltKeyTablePtr table;\n    int init_table = 0;\n    if ((ctxt == NULL) || (name == NULL) || (value == NULL) ||\n\t(ctxt->document == NULL))\n\treturn(NULL);\n#ifdef WITH_XSLT_DEBUG_KEYS\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"Get key %s, value %s\\n\", name, value);\n#endif\n    if ((ctxt->document->nbKeysComputed < ctxt->nbKeys) &&\n        (ctxt->keyInitLevel == 0)) {\n\tif (xsltInitAllDocKeys(ctxt))\n\t    return(NULL);\n    }\nretry:\n    table = (xsltKeyTablePtr) ctxt->document->keys;\n    while (table != NULL) {\n\tif (((nameURI != NULL) == (table->nameURI != NULL)) &&\n\t    xmlStrEqual(table->name, name) &&\n\t    xmlStrEqual(table->nameURI, nameURI))\n\t{\n\t    ret = (xmlNodeSetPtr)xmlHashLookup(table->keys, value);\n\t    return(ret);\n\t}\n\ttable = table->next;\n    }\n    if ((ctxt->keyInitLevel != 0) && (init_table == 0)) {\n        xsltInitDocKeyTable(ctxt, name, nameURI);\n\tinit_table = 1;\n\tgoto retry;\n    }\n    return(NULL);\n}", "target": 0}
{"code": "static bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\treturn false;\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}", "target": 0}
{"code": "static void __unix_remove_socket(struct sock *sk)\n{\n\tsk_del_node_init(sk);\n}", "target": 0}
{"code": " */\nPHP_MINFO_FUNCTION(spl)\n{\n\tzval list;\n\tchar *strg;\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"SPL support\",        \"enabled\");\n\tINIT_PZVAL(&list);\n\tarray_init(&list);\n\tSPL_LIST_CLASSES(&list, 0, 1, ZEND_ACC_INTERFACE)\n\tstrg = estrdup(\"\");\n\tzend_hash_apply_with_argument(Z_ARRVAL_P(&list), (apply_func_arg_t)spl_build_class_list_string, &strg TSRMLS_CC);\n\tzval_dtor(&list);\n\tphp_info_print_table_row(2, \"Interfaces\", strg + 2);\n\tefree(strg);\n\tINIT_PZVAL(&list);\n\tarray_init(&list);\n\tSPL_LIST_CLASSES(&list, 0, -1, ZEND_ACC_INTERFACE)\n\tstrg = estrdup(\"\");\n\tzend_hash_apply_with_argument(Z_ARRVAL_P(&list), (apply_func_arg_t)spl_build_class_list_string, &strg TSRMLS_CC);\n\tzval_dtor(&list);\n\tphp_info_print_table_row(2, \"Classes\", strg + 2);\n\tefree(strg);\n\tphp_info_print_table_end();", "target": 0}
{"code": "static void __exit pptp_exit_module(void)\n{\n\tunregister_pppox_proto(PX_PROTO_PPTP);\n\tproto_unregister(&pptp_sk_proto);\n\tgre_del_protocol(&gre_pptp_protocol, GREPROTO_PPTP);\n\tvfree(callid_sock);\n}", "target": 0}
{"code": "bool setup_on_expr(THD *thd, TABLE_LIST *table, bool is_update)\n{\n  uchar buff[STACK_BUFF_ALLOC];\t\t\t\n  if (check_stack_overrun(thd, STACK_MIN_SIZE, buff))\n    return TRUE;\t\t\t\t\n  for(; table; table= table->next_local)\n  {\n    TABLE_LIST *embedded; \n    TABLE_LIST *embedding= table; \n    do\n    {\n      embedded= embedding;\n      if (embedded->on_expr)\n      {\n        thd->where=\"on clause\";\n        embedded->on_expr->mark_as_condition_AND_part(embedded);\n        if ((!embedded->on_expr->fixed &&\n             embedded->on_expr->fix_fields(thd, &embedded->on_expr)) ||\n            embedded->on_expr->check_cols(1))\n          return TRUE;\n      }\n      if (embedded->sj_subq_pred)\n      {\n        Item **left_expr= &embedded->sj_subq_pred->left_expr;\n        if (!(*left_expr)->fixed && (*left_expr)->fix_fields(thd, left_expr))\n          return TRUE;\n      }\n      embedding= embedded->embedding;\n    }\n    while (embedding &&\n           embedding->nested_join->join_list.head() == embedded);\n    if (table->is_merged_derived())\n    {\n      SELECT_LEX *select_lex= table->get_single_select();\n      setup_on_expr(thd, select_lex->get_table_list(), is_update);\n    }\n    if (is_update)\n    {\n      TABLE_LIST *view= table->top_table();\n      if (view->effective_with_check)\n      {\n        if (view->prepare_check_option(thd))\n          return TRUE;\n        thd->change_item_tree(&table->check_option, view->check_option);\n      }\n    }\n  }\n  return FALSE;\n}", "target": 0}
{"code": "static void avrcp_handle_media_player_list_num_items(struct avrcp *session,\n\t\t\t\tstruct avrcp_browsing_header *pdu)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tstruct get_total_number_of_items_rsp *rsp;\n\trsp = (void *)pdu->params;\n\trsp->status = AVRCP_STATUS_SUCCESS;\n\trsp->uid_counter = htons(player_get_uid_counter(player));\n\trsp->num_items = htonl(g_slist_length(session->server->players));\n\tpdu->param_len = htons(sizeof(*rsp));\n}", "target": 0}
{"code": "int phar_tar_setmetadata(zval *metadata, phar_entry_info *entry, char **error TSRMLS_DC) \n{\n\tphp_serialize_data_t metadata_hash;\n\tif (entry->metadata_str.c) {\n\t\tsmart_str_free(&entry->metadata_str);\n\t}\n\tentry->metadata_str.c = 0;\n\tentry->metadata_str.len = 0;\n\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\tphp_var_serialize(&entry->metadata_str, &metadata, &metadata_hash TSRMLS_CC);\n\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\tentry->uncompressed_filesize = entry->compressed_filesize = entry->metadata_str.len;\n\tif (entry->fp && entry->fp_type == PHAR_MOD) {\n\t\tphp_stream_close(entry->fp);\n\t}\n\tentry->fp_type = PHAR_MOD;\n\tentry->is_modified = 1;\n\tentry->fp = php_stream_fopen_tmpfile();\n\tentry->offset = entry->offset_abs = 0;\n\tif (entry->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn -1;\n\t}\n\tif (entry->metadata_str.len != php_stream_write(entry->fp, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\tspprintf(error, 0, \"phar tar error: unable to write metadata to magic metadata file \\\"%s\\\"\", entry->filename);\n\t\tzend_hash_del(&(entry->phar->manifest), entry->filename, entry->filename_len);\n\t\treturn ZEND_HASH_APPLY_STOP;\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}", "target": 0}
{"code": "int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,\n                     const bool bypass) {\n  local_status.set(wsrep::server_state::s_donor);\n  const char *method = msg.data();\n  size_t method_len = strlen(method);\n  const char *data = method + method_len + 1;\n  wsp::env env(NULL);\n  if (env.error()) {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n#if 0\n  while (!wsrep_is_SE_initialized()) {\n    sleep(1);\n    THD *applier_thd = static_cast<THD *>(recv_ctx);\n    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;\n  }\n#endif\n  int ret;\n  ret = sst_donate_other(method, data, current_gtid, bypass, env());\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "static int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n    return index;\n}", "target": 0}
{"code": "ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n   AddChildView(label_);\n   const auto buttons = delegate_ptr->GetButtons();\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {\n    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);\n    ok_button_->SetProminent(true);\n    if (delegate_ptr->OKButtonTriggersUACPrompt()) {\n      elevation_icon_setter_.reset(new ElevationIconSetter(\n          ok_button_,\n          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));\n    }\n  }\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {\n    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);\n    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)\n      cancel_button_->SetProminent(true);\n  }\n  link_ = CreateLink(delegate_ptr->GetLinkText(), this);\n  AddChildView(link_);\n}", "target": 1}
{"code": "int MockNetworkTransaction::RestartWithAuth(\n    const AuthCredentials& credentials,\n    const CompletionCallback& callback) {\n  if (!IsReadyToRestartForAuth())\n     return ERR_FAILED;\n   HttpRequestInfo auth_request_info = *request_;\n  auth_request_info.extra_headers.AddHeaderFromString(\"Authorization: Bar\");\n  return StartInternal(&auth_request_info, callback, BoundNetLog());\n}", "target": 1}
{"code": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tms = 0;\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\tdec->state = JPC_MT;\n\treturn 1;\n}", "target": 0}
{"code": "check_packet_auth(NTP_Packet *pkt, int length, int *has_auth, uint32_t *key_id)\n{\n  int i, remainder, ext_length;\n  unsigned char *data;\n  uint32_t id;\n  i = NTP_NORMAL_PACKET_LENGTH;\n  data = (void *)pkt;\n  while (1) {\n    remainder = length - i;\n    if (remainder >= NTP_MIN_MAC_LENGTH && remainder <= NTP_MAX_MAC_LENGTH) {\n      id = ntohl(*(uint32_t *)(data + i));\n      if (KEY_CheckAuth(id, (void *)pkt, i, (void *)(data + i + 4),\n                        remainder - 4)) {\n        if (key_id)\n          *key_id = id;\n        if (has_auth)\n          *has_auth = 1;\n        return 1;\n      }\n    }\n    if (remainder >= NTP_MIN_EXTENSION_LENGTH) {\n      ext_length = ntohs(*(uint16_t *)(data + i + 2));\n      if (ext_length >= NTP_MIN_EXTENSION_LENGTH &&\n          ext_length <= remainder && ext_length % 4 == 0) {\n        i += ext_length;\n        continue;\n      }\n    }\n    break;\n  }\n  if (has_auth)\n    *has_auth = remainder >= NTP_MIN_MAC_LENGTH;\n  return 0;\n}", "target": 0}
{"code": "static void virgl_resource_attach_backing(VirtIOGPU *g,\n                                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_attach_backing att_rb;\n    struct iovec *res_iovs;\n    int ret;\n    VIRTIO_GPU_FILL_CMD(att_rb);\n    trace_virtio_gpu_cmd_res_back_attach(att_rb.resource_id);\n    ret = virtio_gpu_create_mapping_iov(&att_rb, cmd, NULL, &res_iovs);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n         return;\n     }\n    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n                                       res_iovs, att_rb.nr_entries);\n }", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "bool Item_param::set_from_user_var(THD *thd, const user_var_entry *entry)\n{\n  DBUG_ENTER(\"Item_param::set_from_user_var\");\n  if (entry && entry->value)\n  {\n    item_result_type= entry->type;\n    unsigned_flag= entry->unsigned_flag;\n    if (limit_clause_param)\n    {\n      bool unused;\n      set_int(entry->val_int(&unused), MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      DBUG_RETURN(!unsigned_flag && value.integer < 0 ? 1 : 0);\n    }\n    switch (item_result_type) {\n    case REAL_RESULT:\n      set_double(*(double*)entry->value);\n      item_type= Item::REAL_ITEM;\n      param_type= MYSQL_TYPE_DOUBLE;\n      break;\n    case INT_RESULT:\n      set_int(*(longlong*)entry->value, MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      param_type= MYSQL_TYPE_LONGLONG;\n      break;\n    case STRING_RESULT:\n    {\n      CHARSET_INFO *fromcs= entry->collation.collation;\n      CHARSET_INFO *tocs= thd->variables.collation_connection;\n      uint32 dummy_offset;\n      value.cs_info.character_set_of_placeholder= fromcs;\n      value.cs_info.character_set_client= thd->variables.character_set_client;\n      value.cs_info.final_character_set_of_str_value=\n        String::needs_conversion(0, fromcs, tocs, &dummy_offset) ?\n        tocs : fromcs;\n      item_type= Item::STRING_ITEM;\n      param_type= MYSQL_TYPE_VARCHAR;\n      if (set_str((const char *)entry->value, entry->length))\n        DBUG_RETURN(1);\n      break;\n    }\n    case DECIMAL_RESULT:\n    {\n      const my_decimal *ent_value= (const my_decimal *)entry->value;\n      my_decimal2decimal(ent_value, &decimal_value);\n      state= DECIMAL_VALUE;\n      decimals= ent_value->frac;\n      max_length=\n        my_decimal_precision_to_length_no_truncation(ent_value->precision(),\n                                                     decimals, unsigned_flag);\n      item_type= Item::DECIMAL_ITEM;\n      param_type= MYSQL_TYPE_NEWDECIMAL;\n      break;\n    }\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n      set_null();\n    }\n  }\n  else\n    set_null();\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static bool manager_get_show_status(Manager *m, StatusType type) {\n        assert(m);\n        if (m->running_as != SYSTEMD_SYSTEM)\n                return false;\n        if (m->no_console_output)\n                return false;\n        if (!IN_SET(manager_state(m), MANAGER_INITIALIZING, MANAGER_STARTING, MANAGER_STOPPING))\n                return false;\n        if (type != STATUS_TYPE_EMERGENCY && manager_check_ask_password(m) > 0)\n                return false;\n        if (m->show_status > 0)\n                return true;\n        return plymouth_running();\n}", "target": 0}
{"code": "void WriteValue(Message* m, const Value* value, int recursion) {\n  bool result;\n  if (recursion > kMaxRecursionDepth) {\n    LOG(WARNING) << \"Max recursion depth hit in WriteValue.\";\n    return;\n  }\n  m->WriteInt(value->GetType());\n  switch (value->GetType()) {\n    case Value::TYPE_NULL:\n    break;\n    case Value::TYPE_BOOLEAN: {\n      bool val;\n      result = value->GetAsBoolean(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_INTEGER: {\n      int val;\n      result = value->GetAsInteger(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_DOUBLE: {\n      double val;\n      result = value->GetAsDouble(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_STRING: {\n      std::string val;\n      result = value->GetAsString(&val);\n      DCHECK(result);\n      WriteParam(m, val);\n      break;\n    }\n    case Value::TYPE_BINARY: {\n      const base::BinaryValue* binary =\n          static_cast<const base::BinaryValue*>(value);\n      m->WriteData(binary->GetBuffer(), static_cast<int>(binary->GetSize()));\n      break;\n    }\n    case Value::TYPE_DICTIONARY: {\n      const DictionaryValue* dict = static_cast<const DictionaryValue*>(value);\n      WriteParam(m, static_cast<int>(dict->size()));\n      for (DictionaryValue::key_iterator it = dict->begin_keys();\n           it != dict->end_keys(); ++it) {\n        const Value* subval;\n        if (dict->GetWithoutPathExpansion(*it, &subval)) {\n          WriteParam(m, *it);\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"DictionaryValue iterators are filthy liars.\";\n        }\n      }\n      break;\n    }\n    case Value::TYPE_LIST: {\n      const ListValue* list = static_cast<const ListValue*>(value);\n      WriteParam(m, static_cast<int>(list->GetSize()));\n      for (size_t i = 0; i < list->GetSize(); ++i) {\n        const Value* subval;\n        if (list->Get(i, &subval)) {\n          WriteValue(m, subval, recursion + 1);\n        } else {\n          NOTREACHED() << \"ListValue::GetSize is a filthy liar.\";\n        }\n      }\n      break;\n    }\n  }\n}", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n \t\t\tBIO_free(f);\n \t\t\tf = tbio;\n \t\t\t}\n\t\twhile (f != upto);\n \t\t}\n \telse\n \t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "void LibRaw::derror()\n{\n  if (!libraw_internal_data.unpacker_data.data_error && libraw_internal_data.internal_data.input) \n    {\n      if (libraw_internal_data.internal_data.input->eof())\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),-1);\n          throw LIBRAW_EXCEPTION_IO_EOF;\n        }\n      else\n        {\n          if(callbacks.data_cb)(*callbacks.data_cb)(callbacks.datacb_data,\n                                                    libraw_internal_data.internal_data.input->fname(),\n                                                    libraw_internal_data.internal_data.input->tell());\n          throw LIBRAW_EXCEPTION_IO_CORRUPT;\n        }\n    }\n  libraw_internal_data.unpacker_data.data_error++;\n}", "target": 0}
{"code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t u32 start_seq, u32 end_seq)\n{\n\tint in_sack, err;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn in_sack;\n}", "target": 0}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}", "target": 1}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "QPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    while (xref_offset)\n    {\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n    }\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n    this->m->deleted_objects.clear();\n}", "target": 1}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "static av_always_inline float flt16_even(float pf)\n{\n    union av_intfloat32 tmp;\n    tmp.f = pf;\n    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;\n    return tmp.f;\n}", "target": 0}
{"code": "static PassRefPtr<CSSValue> getPositionOffsetValue(RenderStyle* style, CSSPropertyID propertyID, RenderView* renderView)\n{\n    if (!style)\n        return 0;\n    Length l;\n    switch (propertyID) {\n        case CSSPropertyLeft:\n            l = style->left();\n            break;\n        case CSSPropertyRight:\n            l = style->right();\n            break;\n        case CSSPropertyTop:\n            l = style->top();\n            break;\n        case CSSPropertyBottom:\n            l = style->bottom();\n            break;\n        default:\n            return 0;\n    }\n    if (style->position() == AbsolutePosition || style->position() == FixedPosition) {\n        if (l.type() == WebCore::Fixed)\n            return zoomAdjustedPixelValue(l.value(), style);\n        else if (l.isViewportPercentage())\n            return zoomAdjustedPixelValue(valueForLength(l, 0, renderView), style);\n         return cssValuePool().createValue(l);\n     }\n    if (style->position() == RelativePosition)\n         return cssValuePool().createValue(l);\n     return cssValuePool().createIdentifierValue(CSSValueAuto);\n }", "target": 1}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "void SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "NAN_METHOD(TxnWrap::ctor) {\n    Nan::HandleScope scope;\n    EnvWrap *ew = Nan::ObjectWrap::Unwrap<EnvWrap>(Local<Object>::Cast(info[0]));\n    int flags = 0;\n    if (info[1]->IsObject()) {\n        Local<Object> options = Local<Object>::Cast(info[1]);\n        setFlagFromValue(&flags, MDB_RDONLY, \"readOnly\", false, options);\n    }\n    if (0 == (flags & MDB_RDONLY) && ew->currentWriteTxn != nullptr) {\n        return Nan::ThrowError(\"You have already opened a write transaction in the current process, can't open a second one.\");\n    }\n    MDB_txn *txn;\n    int rc = mdb_txn_begin(ew->env, nullptr, flags, &txn);\n    if (rc != 0) {\n        if (rc == EINVAL) {\n            return Nan::ThrowError(\"Invalid parameter, which on MacOS is often due to more transactions than available robust locked semaphors (see node-lmdb docs for more info)\");\n        }\n        return throwLmdbError(rc);\n    }\n    TxnWrap* tw = new TxnWrap(ew->env, txn);\n    tw->flags = flags;\n    tw->ew = ew;\n    tw->ew->Ref();\n    tw->Wrap(info.This());\n    if (0 == (flags & MDB_RDONLY)) {\n        ew->currentWriteTxn = tw;\n    }\n    else {\n        ew->readTxns.push_back(tw);\n    }\n    return info.GetReturnValue().Set(info.This());\n}", "target": 0}
{"code": "bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {\n  if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {\n    if (log_is_enabled(Trace, class, nestmates)) {\n      ResourceMark rm(THREAD);\n      log_trace(class, nestmates)(\"Checked nest membership of %s in non-nest-host class %s\",\n                                  k->external_name(), this->external_name());\n    }\n    return false;\n  }\n  if (log_is_enabled(Trace, class, nestmates)) {\n    ResourceMark rm(THREAD);\n    log_trace(class, nestmates)(\"Checking nest membership of %s in %s\",\n                                k->external_name(), this->external_name());\n  }\n  for (int i = 0; i < _nest_members->length(); i++) {\n    int cp_index = _nest_members->at(i);\n    Symbol* name = _constants->klass_name_at(cp_index);\n    if (name == k->name()) {\n      log_trace(class, nestmates)(\"- Found it at nest_members[%d] => cp[%d]\", i, cp_index);\n      if (!THREAD->can_call_java() && !_constants->tag_at(cp_index).is_klass()) {\n        log_trace(class, nestmates)(\"- validation required resolution in an unsuitable thread\");\n        return false;\n      }\n      Klass* k2 = _constants->klass_at(cp_index, CHECK_false);\n      if (k2 == k) {\n        log_trace(class, nestmates)(\"- class is listed as a nest member\");\n        return true;\n      } else {\n        log_trace(class, nestmates)(\" - klass comparison failed!\");\n        return false;\n      }\n    }\n  }\n  log_trace(class, nestmates)(\"- class is NOT a nest member!\");\n  return false;\n}", "target": 0}
{"code": "static int _make_remark(struct pwb_context *ctx,\n\t\t\tint type,\n\t\t\tconst char *text)\n{\n\tint retval = PAM_SUCCESS;\n\tstruct pam_message *pmsg[1], msg[1];\n\tstruct pam_response *resp;\n\tif (ctx->flags & WINBIND_SILENT) {\n\t\treturn PAM_SUCCESS;\n\t}\n\tpmsg[0] = &msg[0];\n\tmsg[0].msg = discard_const_p(char, text);\n\tmsg[0].msg_style = type;\n\tresp = NULL;\n\tretval = converse(ctx->pamh, 1, pmsg, &resp);\n\tif (resp) {\n\t\t_pam_drop_reply(resp, 1);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "int ImagingLibTiffEncodeInit(ImagingCodecState state, char *filename, int fp) {\n    TIFFSTATE *clientstate = (TIFFSTATE *)state->context;\n    int bufsize = 64*1024;\n    char *mode = \"w\";\n    TRACE((\"initing libtiff\\n\"));\n    TRACE((\"Filename %s, filepointer: %d \\n\", filename,  fp));\n    TRACE((\"State: count %d, state %d, x %d, y %d, ystep %d\\n\", state->count, state->state,\n           state->x, state->y, state->ystep));\n    TRACE((\"State: xsize %d, ysize %d, xoff %d, yoff %d \\n\", state->xsize, state->ysize,\n           state->xoff, state->yoff));\n    TRACE((\"State: bits %d, bytes %d \\n\", state->bits, state->bytes));\n    TRACE((\"State: context %p \\n\", state->context));\n    clientstate->loc = 0;\n    clientstate->size = 0;\n    clientstate->eof =0;\n    clientstate->data = 0;\n    clientstate->flrealloc = 0;\n    clientstate->fp = fp;\n    state->state = 0;\n    if (fp) {\n        TRACE((\"Opening using fd: %d for writing \\n\",clientstate->fp));\n        clientstate->tiff = TIFFFdOpen(clientstate->fp, filename, mode);\n    } else {\n        TRACE((\"Opening a buffer for writing \\n\"));\n        clientstate->data = malloc(bufsize);\n        clientstate->size = bufsize;\n        clientstate->flrealloc=1;\n        if (!clientstate->data) {\n            TRACE((\"Error, couldn't allocate a buffer of size %d\\n\", bufsize));\n            return 0;\n        }\n        clientstate->tiff = TIFFClientOpen(filename, mode,\n                                           (thandle_t) clientstate,\n                                           _tiffReadProc, _tiffWriteProc,\n                                           _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n                                           _tiffNullMapProc, _tiffUnmapProc); \n    }\n    if (!clientstate->tiff) {\n        TRACE((\"Error, couldn't open tiff file\\n\"));\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "void SyncManager::SyncInternal::ShutdownOnSyncThread() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  weak_ptr_factory_.InvalidateWeakPtrs();\n  js_mutation_event_observer_.InvalidateWeakPtrs();\n  scheduler_.reset();\n  SetJsEventHandler(WeakHandle<JsEventHandler>());\n  RemoveObserver(&js_sync_manager_observer_);\n  RemoveObserver(&debug_info_event_listener_);\n  if (sync_notifier_.get()) {\n    sync_notifier_->RemoveObserver(this);\n  }\n  sync_notifier_.reset();\n  if (connection_manager_.get()) {\n    connection_manager_->RemoveListener(this);\n  }\n  connection_manager_.reset();\n  net::NetworkChangeNotifier::RemoveIPAddressObserver(this);\n  observing_ip_address_changes_ = false;\n  if (initialized_ && dir_manager()) {\n    {\n      ReadTransaction trans(FROM_HERE, GetUserShare());\n      trans.GetCryptographer()->RemoveObserver(this);\n    }\n    dir_manager()->FinalSaveChangesForAll();\n    dir_manager()->Close(username_for_share());\n  }\n  share_.dir_manager.reset();\n  setup_for_test_mode_ = false;\n  change_delegate_ = NULL;\n  registrar_ = NULL;\n  initialized_ = false;\n  change_observer_.Reset();\n  weak_handle_this_.Reset();\n}", "target": 0}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "static void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,\n\t\t\t\tu64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\tpt_element_t *gptep = gw->prefetch_ptes;\n\tu64 *spte;\n\tint i;\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\tif (sp->role.direct)\n\t\treturn __direct_pte_prefetch(vcpu, sp, sptep);\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (spte == sptep)\n\t\t\tcontinue;\n\t\tif (is_shadow_present_pte(*spte))\n\t\t\tcontinue;\n\t\tif (!FNAME(prefetch_gpte)(vcpu, sp, spte, gptep[i], true))\n\t\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static void virtio_net_announce(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    if (n->announce_timer.round) {\n        return;\n    }\n    if (virtio_vdev_has_feature(vdev, VIRTIO_NET_F_GUEST_ANNOUNCE) &&\n        virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)) {\n            virtio_net_announce_notify(n);\n    }\n}", "target": 0}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "int btrfs_grow_device(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_device *device, u64 new_size)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_fs_devices *fs_devices;\n\tu64 old_total;\n\tu64 diff;\n\tif (!test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\treturn -EACCES;\n\tnew_size = round_down(new_size, fs_info->sectorsize);\n\tmutex_lock(&fs_info->chunk_mutex);\n\told_total = btrfs_super_total_bytes(super_copy);\n\tdiff = round_down(new_size - device->total_bytes, fs_info->sectorsize);\n\tif (new_size <= device->total_bytes ||\n\t    test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\treturn -EINVAL;\n\t}\n\tfs_devices = fs_info->fs_devices;\n\tbtrfs_set_super_total_bytes(super_copy,\n\t\t\tround_down(old_total + diff, fs_info->sectorsize));\n\tdevice->fs_devices->total_rw_bytes += diff;\n\tbtrfs_device_set_total_bytes(device, new_size);\n\tbtrfs_device_set_disk_total_bytes(device, new_size);\n\tbtrfs_clear_space_info_full(device->fs_info);\n\tif (list_empty(&device->resized_list))\n\t\tlist_add_tail(&device->resized_list,\n\t\t\t      &fs_devices->resized_devices);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn btrfs_update_device(trans, device);\n}", "target": 0}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static void write_pmc(int idx, unsigned long val)\n{\n\tswitch (idx) {\n\tcase 1:\n\t\tmtspr(SPRN_PMC1, val);\n\t\tbreak;\n\tcase 2:\n\t\tmtspr(SPRN_PMC2, val);\n\t\tbreak;\n\tcase 3:\n\t\tmtspr(SPRN_PMC3, val);\n\t\tbreak;\n\tcase 4:\n\t\tmtspr(SPRN_PMC4, val);\n\t\tbreak;\n\tcase 5:\n\t\tmtspr(SPRN_PMC5, val);\n\t\tbreak;\n\tcase 6:\n\t\tmtspr(SPRN_PMC6, val);\n\t\tbreak;\n#ifdef CONFIG_PPC64\n\tcase 7:\n\t\tmtspr(SPRN_PMC7, val);\n\t\tbreak;\n\tcase 8:\n\t\tmtspr(SPRN_PMC8, val);\n\t\tbreak;\n#endif \n\tdefault:\n\t\tprintk(KERN_ERR \"oops trying to write PMC%d\\n\", idx);\n\t}\n}", "target": 0}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "static void execlists_submit_request(struct i915_request *request)\n{\n\tstruct intel_engine_cs *engine = request->engine;\n\tunsigned long flags;\n\tspin_lock_irqsave(&engine->active.lock, flags);\n\tqueue_request(engine, &request->sched, rq_prio(request));\n\tGEM_BUG_ON(RB_EMPTY_ROOT(&engine->execlists.queue.rb_root));\n\tGEM_BUG_ON(list_empty(&request->sched.link));\n\tsubmit_queue(engine, request);\n\tspin_unlock_irqrestore(&engine->active.lock, flags);\n}", "target": 0}
{"code": "append_wild(char *to, char *end, const char *wild)\n{\n  end-=5;\t\t\t\t\t\n  if (wild && wild[0])\n  {\n    to=strmov(to,\" like '\");\n    while (*wild && to < end)\n    {\n      if (*wild == '\\\\' || *wild == '\\'')\n\t*to++='\\\\';\n      *to++= *wild++;\n    }\n    if (*wild)\t\t\t\t\t\n      *to++='%';\t\t\t\t\n    to[0]='\\'';\n    to[1]=0;\n  }\n}", "target": 0}
{"code": "destroy_one_secret (gpointer data)\n{\n \tchar *secret = (char *) data;\ng_message (\"%s: destroying %s\", __func__, secret);\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }", "target": 1}
{"code": "isdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 0}
{"code": "git_otype git_tree_entry_type(const git_tree_entry *entry)\n{\n\tassert(entry);\n\tif (S_ISGITLINK(entry->attr))\n\t\treturn GIT_OBJ_COMMIT;\n\telse if (S_ISDIR(entry->attr))\n\t\treturn GIT_OBJ_TREE;\n\telse\n\t\treturn GIT_OBJ_BLOB;\n}", "target": 0}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n \t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n \t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "ncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}", "target": 1}
{"code": "jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = NULL;\n  }\n  build_ycc_rgb_table(cinfo);\n}", "target": 1}
{"code": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\tcleanup_smi_msgs(intf);\n\tipmi_bmc_unregister(intf);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}", "target": 0}
{"code": "void BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tdecodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);\n\t\tframesRead += m_framesPerPacket;\n\t}\n\tm_track->nextfframe += framesRead;\n\tassert(tell() == m_track->fpos_next_frame);\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\tm_outChunk->frameCount = framesRead;\n}", "target": 1}
{"code": "de265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n    ctx->dpb.flush_reorder_buffer();\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n    return DE265_OK;\n  }\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n  de265_error err = DE265_OK;\n  bool did_work = false;\n  if (ctx->nal_parser.get_NAL_queue_length()) { \n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n  if (more) {\n    *more = (err==DE265_OK && did_work);\n  }\n  return err;\n}", "target": 0}
{"code": "static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\n{\n    PyObject *ret = NULL;\n    struct curl_slist *slist_start = slist;\n    ret = PyList_New((Py_ssize_t)0);\n    if (ret == NULL) goto error;\n    for ( ; slist != NULL; slist = slist->next) {\n        PyObject *v = NULL;\n        if (slist->data == NULL) {\n            v = Py_None; Py_INCREF(v);\n        } else {\n            v = PyText_FromString(slist->data);\n        }\n        if (v == NULL || PyList_Append(ret, v) != 0) {\n            Py_XDECREF(v);\n            goto error;\n        }\n        Py_DECREF(v);\n    }\n    if ((free_flags & 1) && slist_start)\n        curl_slist_free_all(slist_start);\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    if ((free_flags & 2) && slist_start)\n        curl_slist_free_all(slist_start);\n    return NULL;\n}", "target": 0}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "get_voting_schedule(const or_options_t *options, time_t now, int severity)\n{\n  int interval, vote_delay, dist_delay;\n  time_t start;\n  time_t end;\n  networkstatus_t *consensus;\n  voting_schedule_t *new_voting_schedule;\n  new_voting_schedule = tor_malloc_zero(sizeof(voting_schedule_t));\n  consensus = networkstatus_get_live_consensus(now);\n  if (consensus) {\n    interval = (int)( consensus->fresh_until - consensus->valid_after );\n    vote_delay = consensus->vote_seconds;\n    dist_delay = consensus->dist_seconds;\n  } else {\n    interval = options->TestingV3AuthInitialVotingInterval;\n    vote_delay = options->TestingV3AuthInitialVoteDelay;\n    dist_delay = options->TestingV3AuthInitialDistDelay;\n  }\n  tor_assert(interval > 0);\n  if (vote_delay + dist_delay > interval/2)\n    vote_delay = dist_delay = interval / 4;\n  start = new_voting_schedule->interval_starts =\n    dirvote_get_start_of_next_interval(now,interval,\n                                      options->TestingV3AuthVotingStartOffset);\n  end = dirvote_get_start_of_next_interval(start+1, interval,\n                                      options->TestingV3AuthVotingStartOffset);\n  tor_assert(end > start);\n  new_voting_schedule->fetch_missing_signatures = start - (dist_delay/2);\n  new_voting_schedule->voting_ends = start - dist_delay;\n  new_voting_schedule->fetch_missing_votes =\n    start - dist_delay - (vote_delay/2);\n  new_voting_schedule->voting_starts = start - dist_delay - vote_delay;\n  {\n    char tbuf[ISO_TIME_LEN+1];\n    format_iso_time(tbuf, new_voting_schedule->interval_starts);\n    tor_log(severity, LD_DIR,\"Choosing expected valid-after time as %s: \"\n            \"consensus_set=%d, interval=%d\",\n            tbuf, consensus?1:0, interval);\n  }\n  return new_voting_schedule;\n}", "target": 0}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "vte_terminal_find_charcell (VteTerminal *terminal, glong col, glong row)\n{\n\tVteRowData *rowdata;\n\tVteCell *ret = NULL;\n\tVteScreen *screen;\n\tg_assert(VTE_IS_TERMINAL(terminal));\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_contains (screen->row_data, row)) {\n\t\trowdata = _vte_ring_index_writable (screen->row_data, row);\n\t\tret = _vte_row_data_get_writable (rowdata, col);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "struct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc)\n{\n\tstruct file_list *flist = cur_flist;\n\tif (!flist && !(flist = first_flist))\n\t\tgoto not_found;\n\twhile (ndx < flist->ndx_start-1) {\n\t\tif (flist == first_flist)\n\t\t\tgoto not_found;\n\t\tflist = flist->prev;\n\t}\n\twhile (ndx >= flist->ndx_start + flist->used) {\n\t\tif (!(flist = flist->next))\n\t\t\tgoto not_found;\n\t}\n\treturn flist;\n  not_found:\n\tif (fatal_error_loc) {\n\t\tint first, last;\n\t\tif (first_flist) {\n\t\t\tfirst = first_flist->ndx_start - 1;\n\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tlast = -1;\n\t\t}\n\t\trprintf(FERROR,\n\t\t\t\"File-list index %d not in %d - %d (%s) [%s]\\n\",\n\t\t\tndx, first, last, fatal_error_loc, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void __spin_time_accum(u64 delta, u32 *array)\n{\n\tunsigned index;\n\tindex = ilog2(delta);\n\tcheck_zero();\n\tif (index < HISTO_BUCKETS)\n\t\tarray[index]++;\n\telse\n\t\tarray[HISTO_BUCKETS]++;\n}", "target": 0}
{"code": "void RemoveActionCallback(const ActionCallback& callback) {\n  DCHECK(g_task_runner.Get());\n   DCHECK(g_task_runner.Get()->BelongsToCurrentThread());\n   std::vector<ActionCallback>* callbacks = g_callbacks.Pointer();\n   for (size_t i = 0; i < callbacks->size(); ++i) {\n    if ((*callbacks)[i].Equals(callback)) {\n       callbacks->erase(callbacks->begin() + i);\n       return;\n     }\n  }\n}", "target": 1}
{"code": "template <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}", "target": 1}
{"code": "static size_t php_pgsql_fd_read(php_stream *stream, char *buf, size_t count) \n{\n\treturn 0;\n}", "target": 0}
{"code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  FlushRstStream();\n}", "target": 1}
{"code": "void GLES2DecoderTestBase::DoVertexAttribPointer(\n    GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset) {\n  EXPECT_CALL(*gl_,\n              VertexAttribPointer(index, size, type, GL_FALSE, stride,\n                                  BufferOffset(offset)))\n      .Times(1)\n      .RetiresOnSaturation();\n  VertexAttribPointer cmd;\n  cmd.Init(index, size, GL_FLOAT, GL_FALSE, stride, offset);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "PHPAPI void var_replace(php_unserialize_data_t *var_hashx, zval *ozval, zval *nzval)\n{\n\tzend_long i;\n\tvar_entries *var_hash = (*var_hashx)->first;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_replace(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(nzval));\n#endif\n\twhile (var_hash) {\n\t\tfor (i = 0; i < var_hash->used_slots; i++) {\n\t\t\tif (var_hash->data[i] == ozval) {\n\t\t\t\tvar_hash->data[i] = nzval;\n\t\t\t}\n\t\t}\n\t\tvar_hash = var_hash->next;\n\t}\n}", "target": 0}
{"code": "rb_insert_pages(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *pages = &cpu_buffer->new_pages;\n\tint retries, success;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tretries = 10;\n\tsuccess = 0;\n\twhile (retries--) {\n\t\tstruct list_head *head_page, *prev_page, *r;\n\t\tstruct list_head *last_page, *first_page;\n\t\tstruct list_head *head_page_with_bit;\n\t\thead_page = &rb_set_head_page(cpu_buffer)->list;\n\t\tif (!head_page)\n\t\t\tbreak;\n\t\tprev_page = head_page->prev;\n\t\tfirst_page = pages->next;\n\t\tlast_page  = pages->prev;\n\t\thead_page_with_bit = (struct list_head *)\n\t\t\t\t     ((unsigned long)head_page | RB_PAGE_HEAD);\n\t\tlast_page->next = head_page_with_bit;\n\t\tfirst_page->prev = prev_page;\n\t\tr = cmpxchg(&prev_page->next, head_page_with_bit, first_page);\n\t\tif (r == head_page_with_bit) {\n\t\t\thead_page->prev = last_page;\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (success)\n\t\tINIT_LIST_HEAD(pages);\n\tRB_WARN_ON(cpu_buffer, !success);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tif (!success) {\n\t\tstruct buffer_page *bpage, *tmp;\n\t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,\n\t\t\t\t\t list) {\n\t\t\tlist_del_init(&bpage->list);\n\t\t\tfree_buffer_page(bpage);\n\t\t}\n\t}\n\treturn success;\n}", "target": 0}
{"code": "rndset(unsigned long v)\n{\n\tregister uint32_t h;\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tregister uint32_t t;\n#endif\n\tstruct {\n\t\tstruct timeval tv;\n\t\tvoid *sp;\n\t\tuint32_t qh;\n\t\tpid_t pp;\n\t\tshort r;\n\t} z;\n#ifdef DEBUG\n\tmemset(&z, 0, sizeof(z));\n#endif\n\th = lcg_state;\n\tBAFHFinish_reg(h);\n\tBAFHUpdateMem_reg(h, &v, sizeof(v));\n\tmksh_TIME(z.tv);\n\tz.sp = &lcg_state;\n\tz.pp = procpid;\n\tz.r = (short)rndget();\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tt = qh_state;\n\tBAFHFinish_reg(t);\n\tz.qh = (t & 0xFFFF8000) | rndget();\n\tlcg_state = (t << 15) | rndget();\n\tt = h;\n\tBAFHUpdateMem_reg(t, &lcg_state, sizeof(lcg_state));\n\tBAFHFinish_reg(t);\n\tlcg_state = t;\n#if defined(arc4random_pushb_fast)\n\tarc4random_pushb_fast(&lcg_state, sizeof(lcg_state));\n\tlcg_state = arc4random();\n#else\n\tlcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));\n#endif\n\tBAFHUpdateMem_reg(h, &lcg_state, sizeof(lcg_state));\n#else\n\tz.qh = qh_state;\n#endif\n\tBAFHUpdateMem_reg(h, &z, sizeof(z));\n\tBAFHFinish_reg(h);\n\tlcg_state = h;\n}", "target": 0}
{"code": "generate_spc_link(cms_context *cms, SpcLink *slp, SpcLinkType link_type,\n\t\tvoid *link_data, size_t link_data_size)\n{\n\tSpcLink sl;\n\tmemset(&sl, '\\0', sizeof (sl));\n\tsl.type = link_type;\n\tswitch (sl.type) {\n\tcase SpcLinkTypeFile: {\n\t\tint rc = generate_spc_string(cms, &sl.file, link_data,\n\t\t\t\t\tlink_data_size);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tbreak;\n\t}\n\tcase SpcLinkTypeUrl:\n\t\tsl.url.type = siBuffer;\n\t\tsl.url.data = link_data;\n\t\tsl.url.len = link_data_size;\n\t\tbreak;\n\tdefault:\n\t\tcms->log(cms, LOG_ERR, \"Invalid SpcLinkType\");\n\t\treturn -1;\n\t};\n\tmemcpy(slp, &sl, sizeof (sl));\n\treturn 0;\n}", "target": 0}
{"code": "const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const FieldID*>(\n      offset + static_cast<const char*>(object));\n}", "target": 1}
{"code": "static void bnx2x_recovery_failed(struct bnx2x *bp)\n{\n\tnetdev_err(bp->dev, \"Recovery has failed. Power cycle is needed.\\n\");\n\tnetif_device_detach(bp->dev);\n\tbnx2x_set_reset_in_progress(bp);\n\tbnx2x_set_power_state(bp, PCI_D3hot);\n\tbp->recovery_state = BNX2X_RECOVERY_FAILED;\n\tsmp_mb();\n}", "target": 0}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "static int proc_uptime_read(char *buf, size_t size, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = (struct file_info *)fi->fh;\n\tlong int reaperage = getreaperage(fc->pid);;\n\tunsigned long int busytime = get_reaper_busy(fc->pid), idletime;\n\tchar *cache = d->buf;\n\tsize_t total_len = 0;\n\tif (offset){\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\t\tint left = d->size - offset;\n\t\ttotal_len = left > size ? size: left;\n\t\tmemcpy(buf, cache + offset, total_len);\n\t\treturn total_len;\n\t}\n\tidletime = reaperage - busytime;\n\tif (idletime > reaperage)\n\t\tidletime = reaperage;\n\ttotal_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);\n\tif (total_len < 0){\n\t\tperror(\"Error writing to cache\");\n\t\treturn 0;\n\t}\n\td->size = (int)total_len;\n\td->cached = 1;\n\tif (total_len > size) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}", "target": 0}
{"code": "luks_lock_wait_for_cleartext_device_removed_cb (Daemon *daemon,\n                                                const char *object_path,\n                                                gpointer user_data)\n{\n  Device *device;\n  LockEncryptionData *data = user_data;\n  device = daemon_local_find_by_object_path (daemon, object_path);\n  if (device == data->cleartext_device)\n    {\n      job_local_end (data->luks_device);\n      update_info (data->luks_device);\n      drain_pending_changes (data->luks_device, FALSE);\n      dbus_g_method_return (data->context);\n      g_signal_handler_disconnect (daemon, data->device_removed_signal_handler_id);\n      g_source_remove (data->device_removed_timeout_id);\n      lock_encryption_data_unref (data);\n    }\n}", "target": 0}
{"code": "uint32_t read32(uint8_t* arr, int pos,  int swapBytes)\n{\n    if(!swapBytes) {\n        return (arr[pos]   << 24) |\n               (arr[pos+1] << 16) |\n               (arr[pos+2] << 8) |\n                arr[pos+3];\n    }\n    return arr[pos] |\n           (arr[pos+1] << 8) |\n           (arr[pos+2] << 16) |\n           (arr[pos+3] << 24);\n}", "target": 0}
{"code": "static size_t php_zend_stream_fsizer(void *handle) \n{\n\tphp_stream_statbuf  ssb;\n\tif (php_stream_stat((php_stream*)handle, &ssb) == 0) {\n\t\treturn ssb.sb.st_size;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "krb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n    ret[princ_ent->old_key_len] = NULL;\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "    void registerMockedHttpURLLoad(const std::string& fileName)\n    {\n        URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8(fileName.c_str()));\n    }", "target": 0}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "static void write_cachehdr(const char *name, const char *contents,\n                           const char *raw __attribute__((unused)), void *rock)\n{\n    struct transaction_t *txn = (struct transaction_t *) rock;\n    const char **hdr, *hop_by_hop[] =\n        { \"connection\", \"content-length\", \"content-type\", \"date\", \"forwarded\",\n          \"keep-alive\", \"location\", \"status\", \"strict-transport-security\",\n          \"upgrade\", \"via\", NULL };\n    if (name[0] == ':') return;\n    for (hdr = hop_by_hop; *hdr; hdr++) {\n        if (!strcasecmp(name, *hdr)) return;\n    }\n    simple_hdr(txn, name, contents);\n}", "target": 0}
{"code": "_polkit_subject_get_cmdline (PolkitSubject *subject, gint *pid, gint *uid)\n{\n  PolkitSubject *process;\n  gchar *ret;\n  gchar *filename;\n  gchar *contents;\n  gsize contents_len;\n  GError *error;\n  guint n;\n  g_return_val_if_fail (subject != NULL, NULL);\n  error = NULL;\n  ret = NULL;\n  process = NULL;\n  filename = NULL;\n  contents = NULL;\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n   {\n      process = g_object_ref (subject);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject),\n                                                         NULL,\n                                                         &error);\n      if (process == NULL)\n        {\n          g_warning (\"Error getting process for system bus name `%s': %s\",\n                     polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject)),\n                     error->message);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  else\n    {\n      g_warning (\"Unknown subject type passed to guess_program_name()\");\n      goto out;\n    }\n  *pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (process));\n  *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  filename = g_strdup_printf (\"/proc/%d/cmdline\", *pid);\n  if (!g_file_get_contents (filename,\n                            &contents,\n                            &contents_len,\n                            &error))\n    {\n      g_warning (\"Error openeing `%s': %s\",\n                 filename,\n                 error->message);\n      g_error_free (error);\n      goto out;\n    }\n  for (n = 0; n < contents_len - 1; n++)\n    {\n      if (contents[n] == '\\0')\n        contents[n] = ' ';\n    }\n  ret = g_strdup (contents);\n  g_strstrip (ret);\n out:\n  g_free (filename);\n  g_free (contents);\n  if (process != NULL)\n    g_object_unref (process);\n  return ret;\n}", "target": 0}
{"code": "TxnWrap::TxnWrap(MDB_env *env, MDB_txn *txn) {\n    this->env = env;\n    this->txn = txn;\n    this->flags = 0;\n}", "target": 0}
{"code": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "GopherStateData::DelayAwareRead(GopherStateData *gopherState)\n{\n    const auto &conn = gopherState->serverConn;\n    if (!Comm::IsConnOpen(conn) || fd_table[conn->fd].closing()) {\n        debugs(10, 3, \"will not read from \" << conn);\n        return;\n    }\n    const auto amountToRead = gopherState->entry->bytesWanted(Range<size_t>(0, BUFSIZ));\n    if (amountToRead <= 0) {\n        AsyncCall::Pointer delayCall = asyncCall(10, 3, \"GopherStateData::DelayAwareRead\",\n                                       cbdataDialer(&GopherStateData::DelayAwareRead, gopherState));\n        gopherState->entry->mem().delayRead(delayCall);\n        return;\n    }\n    AsyncCall::Pointer readCall = commCbCall(5, 5, \"gopherReadReply\", CommIoCbPtrFun(gopherReadReply, gopherState));\n    comm_read(conn, gopherState->replybuf, amountToRead, readCall);\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}", "target": 0}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), len);\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 1}
{"code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}", "target": 1}
{"code": "static const char *set_limit_mem(cmd_parms *cmd, void *conf_,\n                                 const char *arg, const char * arg2)\n{\n    core_dir_config *conf = conf_;\n#if defined(RLIMIT_AS)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);\n#elif defined(RLIMIT_DATA)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);\n#elif defined(RLIMIT_VMEM)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);\n#endif\n    return NULL;\n}", "target": 0}
{"code": "DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": "gdk_pixbuf__bmp_image_begin_load(GdkPixbufModuleSizeFunc size_func,\n                                 GdkPixbufModulePreparedFunc prepared_func,\n\t\t\t\t GdkPixbufModuleUpdatedFunc updated_func,\n                                 gpointer user_data,\n                                 GError **error)\n{\n\tstruct bmp_progressive_state *context;\n\tcontext = g_new0(struct bmp_progressive_state, 1);\n\tcontext->size_func = size_func;\n\tcontext->prepared_func = prepared_func;\n\tcontext->updated_func = updated_func;\n\tcontext->user_data = user_data;\n\tcontext->read_state = READ_STATE_HEADERS;\n\tcontext->BufferSize = 26;\n\tcontext->BufferPadding = 0;\n\tcontext->buff = g_malloc(26);\n\tcontext->BufferDone = 0;\n\tcontext->Colormap = NULL;\n\tcontext->Lines = 0;\n\tcontext->Type = 0;\n\tmemset(&context->Header, 0, sizeof(struct headerpair));\n\tmemset(&context->compr, 0, sizeof(struct bmp_compression_state));\n\tcontext->pixbuf = NULL;\n\treturn (gpointer) context;\n}", "target": 0}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n{\t\t\t\t\n#define MAX_RUN_COUNT 15\n    int max_run = step * MAX_RUN_COUNT;\n    while (from < end) {\n        byte data = *from;\n        from += step;\n        if (data != *from || from == end) {\n            if (data >= 0xc0)\n                gp_fputc(0xc1, file);\n        } else {\n            const byte *start = from;\n            while ((from < end) && (*from == data))\n                from += step;\n            while (from - start >= max_run) {\n                gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                gp_fputc(data, file);\n                start += max_run;\n            }\n            if (from > start || data >= 0xc0)\n                gp_fputc((from - start) / step + 0xc1, file);\n        }\n        gp_fputc(data, file);\n    }\n#undef MAX_RUN_COUNT\n}", "target": 1}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "static int load_file(struct augeas *aug, struct lens *lens,\n                     const char *lens_name, char *filename) {\n    char *text = NULL;\n    const char *err_status = NULL;\n    struct tree *tree = NULL;\n    char *path = NULL;\n    struct lns_error *err = NULL;\n    struct span *span = NULL;\n    int result = -1, r, text_len = 0;\n    path = file_name_path(aug, filename);\n    ERR_NOMEM(path == NULL, aug);\n    r = add_file_info(aug, path, lens, lens_name, filename, false);\n    if (r < 0)\n        goto done;\n    text = xread_file(filename);\n    if (text == NULL) {\n        err_status = \"read_failed\";\n        goto done;\n    }\n    text_len = strlen(text);\n    text = append_newline(text, text_len);\n    struct info *info;\n    make_ref(info);\n    make_ref(info->filename);\n    info->filename->str = strdup(filename);\n    info->error = aug->error;\n    info->flags = aug->flags;\n    info->first_line = 1;\n    if (aug->flags & AUG_ENABLE_SPAN) {\n        span = make_span(info);\n        ERR_NOMEM(span == NULL, info);\n    }\n    tree = lns_get(info, lens, text, &err);\n    unref(info, info);\n    if (err != NULL) {\n        err_status = \"parse_failed\";\n        goto done;\n    }\n    tree_replace(aug, path, tree);\n    if (span != NULL && tree != NULL) {\n        tree->parent->span = span;\n        tree->parent->span->span_start = 0;\n        tree->parent->span->span_end = text_len;\n    }\n    tree = NULL;\n    result = 0;\n done:\n    store_error(aug, filename + strlen(aug->root) - 1, path, err_status,\n                errno, err, text);\n error:\n    free_lns_error(err);\n    free(path);\n    free_tree(tree);\n    free(text);\n    return result;\n}", "target": 0}
{"code": "static int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  \n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  \n    return 0;\n  }\n  else return iswhite(o);\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static int fts3ExprLocalHitsCb(\n  Fts3Expr *pExpr,                \n  int iPhrase,                    \n  void *pCtx                      \n){\n  int rc = SQLITE_OK;\n  MatchInfo *p = (MatchInfo *)pCtx;\n  int iStart = iPhrase * p->nCol * 3;\n  int i;\n  for(i=0; i<p->nCol && rc==SQLITE_OK; i++){\n    char *pCsr;\n    rc = sqlite3Fts3EvalPhrasePoslist(p->pCursor, pExpr, i, &pCsr);\n    if( pCsr ){\n      p->aMatchinfo[iStart+i*3] = fts3ColumnlistCount(&pCsr);\n    }else{\n      p->aMatchinfo[iStart+i*3] = 0;\n    }\n  }\n  return rc;\n}", "target": 0}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tunsigned long hashval;\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\treturn string(buf, end, \"(ptrval)\", spec);\n\t}\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n{\n\tuint16 num_updates;\n\tint i;\n\tin_uint16_le(s, num_updates);\t\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tprocess_bitmap_data(s);\n\t}\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "HMAC_SHA256_Init(struct HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n  unsigned char pad[64];\n  unsigned char khash[32];\n  const unsigned char * K = (unsigned char *) _K;\n  size_t i;\n  if (Klen > 64) {\n    SHA256_Init(&ctx->ictx);\n    scrypt_SHA256_Update(&ctx->ictx, K, Klen);\n    scrypt_SHA256_Final(khash, &ctx->ictx);\n    K = khash;\n    Klen = 32;\n  }\n  SHA256_Init(&ctx->ictx);\n  memset(pad, 0x36, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->ictx, pad, 64);\n  SHA256_Init(&ctx->octx);\n  memset(pad, 0x5c, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->octx, pad, 64);\n  memset(khash, 0, 32);\n}", "target": 1}
{"code": "cardos_put_data_oci(sc_card_t *card,\n\t\t\tstruct sc_cardctl_cardos_obj_info *args)\n{\n\tsc_apdu_t\tapdu;\n\tint\t\tr;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tmemset(&apdu, 0, sizeof(apdu));\n\tapdu.cse = SC_APDU_CASE_3_SHORT;\n\tapdu.cla = 0x00;\n\tapdu.ins = 0xda;\n\tapdu.p1  = 0x01;\n\tapdu.p2  = 0x6e;\n\tapdu.lc  = args->len;\n\tapdu.data = args->data;\n\tapdu.datalen = args->len;\n\tr = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"Card returned error\");\n\tLOG_FUNC_RETURN(card->ctx, r);\n}", "target": 0}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "njs_string_to_number(const njs_value_t *value, njs_bool_t parse_float)\n{\n    double             num;\n    njs_bool_t         minus;\n    const u_char       *p, *start, *end;\n    njs_string_prop_t  string;\n    const size_t  infinity = njs_length(\"Infinity\");\n    (void) njs_string_trim(value, &string, NJS_TRIM_START);\n    p = string.start;\n    end = p + string.size;\n    if (p == end) {\n        return parse_float ? NAN : 0.0;\n    }\n    minus = 0;\n    if (*p == '+') {\n        p++;\n    } else if (*p == '-') {\n        p++;\n        minus = 1;\n    }\n    if (p == end) {\n        return NAN;\n    }\n    if (!parse_float\n        && p + 2 < end && p[0] == '0' && (p[1] == 'x' || p[1] == 'X'))\n    {\n        p += 2;\n        num = njs_number_hex_parse(&p, end, 0);\n    } else {\n        start = p;\n        num = njs_number_dec_parse(&p, end, 0);\n        if (p == start) {\n            if (p + infinity > end || memcmp(p, \"Infinity\", infinity) != 0) {\n                return NAN;\n            }\n            num = INFINITY;\n            p += infinity;\n        }\n    }\n    if (!parse_float) {\n        while (p < end) {\n            if (*p != ' ' && *p != '\\t') {\n                return NAN;\n            }\n            p++;\n        }\n    }\n    return minus ? -num : num;\n}", "target": 0}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "int PpapiPluginMain(const content::MainFunctionParams& parameters) {\n  const CommandLine& command_line = parameters.command_line;\n#if defined(OS_WIN)\n  g_target_services = parameters.sandbox_info->target_services;\n#endif\n  if (command_line.HasSwitch(switches::kPpapiStartupDialog)) {\n    if (g_target_services)\n      base::debug::WaitForDebugger(2*60, false);\n    else\n       ChildProcess::WaitForDebugger(\"Ppapi\");\n   }\n  if (command_line.HasSwitch(switches::kLang)) {\n    std::string locale = command_line.GetSwitchValueASCII(switches::kLang);\n    base::i18n::SetICUDefaultLocale(locale);\n  }\n   MessageLoop main_message_loop;\n   base::PlatformThread::SetName(\"CrPPAPIMain\");\n#if defined(OS_LINUX)\n  content::InitializeSandbox();\n#endif\n  ChildProcess ppapi_process;\n  ppapi_process.set_main_thread(\n      new PpapiThread(parameters.command_line, false));  \n  main_message_loop.Run();\n  return 0;\n}", "target": 0}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "static int fsmReadLink(const char *path,\n\t\t       char *buf, size_t bufsize, size_t *linklen)\n{\n    ssize_t llen = readlink(path, buf, bufsize - 1);\n    int rc = RPMERR_READLINK_FAILED;\n    if (_fsm_debug) {\n        rpmlog(RPMLOG_DEBUG, \" %8s (%s, buf, %d) %s\\n\",\n\t       __func__,\n               path, (int)(bufsize -1), (llen < 0 ? strerror(errno) : \"\"));\n    }\n    if (llen >= 0) {\n\tbuf[llen] = '\\0';\n\trc = 0;\n\t*linklen = llen;\n    }\n    return rc;\n}", "target": 0}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "static void sock_def_readable(struct sock *sk, int len)\n{\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_sleep && waitqueue_active(sk->sk_sleep))\n\t\twake_up_interruptible_sync(sk->sk_sleep);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\tread_unlock(&sk->sk_callback_lock);\n}", "target": 0}
{"code": "static pid_t get_task_reaper_pid(pid_t task)\n{\n\tint sock[2];\n\tpid_t pid;\n\tpid_t ret = -1;\n\tchar v = '0';\n\tstruct ucred cred;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\treturn -1;\n\t}\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out;\n\tif (!pid) {\n\t\tclose(sock[1]);\n\t\twrite_task_init_pid_exit(sock[0], task);\n\t}\n\tif (!recv_creds(sock[1], &cred, &v))\n\t\tgoto out;\n\tret = cred.pid;\nout:\n\tclose(sock[0]);\n\tclose(sock[1]);\n\treturn ret;\n}", "target": 0}
{"code": "static int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}", "target": 0}
{"code": "static void build_group_mask(struct sched_domain *sd, struct sched_group *sg)\n{\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\tfor_each_cpu(i, span) {\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\t\tcpumask_set_cpu(i, sched_group_mask(sg));\n\t}\n}", "target": 0}
{"code": "static int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\terr = nla_parse_nested(kdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t       tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t       nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int idr_get_empty_slot(struct idr *idp, int starting_id,\n\t\t\t      struct idr_layer **pa)\n{\n\tstruct idr_layer *p, *new;\n\tint layers, v, id;\n\tunsigned long flags;\n\tid = starting_id;\nbuild_up:\n\tp = idp->top;\n\tlayers = idp->layers;\n\tif (unlikely(!p)) {\n\t\tif (!(p = get_from_free_list(idp)))\n\t\t\treturn -1;\n\t\tp->layer = 0;\n\t\tlayers = 1;\n\t}\n\twhile ((layers < (MAX_LEVEL - 1)) && (id >= (1 << (layers*IDR_BITS)))) {\n\t\tlayers++;\n\t\tif (!p->count) {\n\t\t\tp->layer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(new = get_from_free_list(idp))) {\n\t\t\tspin_lock_irqsave(&idp->lock, flags);\n\t\t\tfor (new = p; p && p != idp->top; new = p) {\n\t\t\t\tp = p->ary[0];\n\t\t\t\tnew->ary[0] = NULL;\n\t\t\t\tnew->bitmap = new->count = 0;\n\t\t\t\t__move_to_free_list(idp, new);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&idp->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t\tnew->ary[0] = p;\n\t\tnew->count = 1;\n\t\tnew->layer = layers-1;\n\t\tif (p->bitmap == IDR_FULL)\n\t\t\t__set_bit(0, &new->bitmap);\n\t\tp = new;\n\t}\n\trcu_assign_pointer(idp->top, p);\n\tidp->layers = layers;\n\tv = sub_alloc(idp, &id, pa);\n\tif (v == IDR_NEED_TO_GROW)\n\t\tgoto build_up;\n\treturn(v);\n}", "target": 0}
{"code": "static ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *buffer, *name;\n\tint buffer_len, name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\",\n\t\t\t&name, &name_len, &buffer, &buffer_len) == FAILURE) {\n\t\treturn;\n\t}\n\tze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(buffer_len + 1);\n\tmemcpy(ze_obj->buffers[pos], buffer, buffer_len + 1);\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], buffer_len, 0);\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (zip_add(intern, name, zs) != -1) {\n\t\tRETURN_TRUE;\n\t}\nfail:\n\tzip_source_free(zs);\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "static void rx_queue_get_ownership(struct kobject *kobj,\n\t\t\t\t   kuid_t *uid, kgid_t *gid)\n{\n\tconst struct net *net = rx_queue_namespace(kobj);\n\tnet_ns_get_ownership(net, uid, gid);", "target": 0}
{"code": "static void ashtech_event_hook(struct gps_device_t *session, event_t event)\n{\n    if (session->context->readonly)\n\treturn;\n    if (event == event_wakeup)\n\t(void)nmea_send(session, \"$PASHQ,RID\");\n    if (event == event_identified) {\n\t(void)nmea_send(session, \"$PASHS,WAS,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,ALL,A,OFF\");\n#ifdef __future__\n\t(void)nmea_send(session, \"$PASHS,NME,POS,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,SAT,A,ON\");\n#else\n\t(void)nmea_send(session, \"$PASHS,NME,GGA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSV,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,RMC,A,ON\");\n#endif\n\t(void)nmea_send(session, \"$PASHS,NME,ZDA,A,ON\");\n    }\n}", "target": 0}
{"code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}", "target": 1}
{"code": "static int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n    ambisonic_order = avio_rb32(pb);\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    return 0;\n}", "target": 0}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "sg_release(struct inode *inode, struct file *filp)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, \"sg_release\\n\"));\n\tmutex_lock(&sdp->open_rel_lock);\n\tscsi_autopm_put_device(sdp->device);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n\tsdp->open_cnt--;\n\tif (sdp->exclude) {\n\t\tsdp->exclude = false;\n\t\twake_up_interruptible_all(&sdp->open_wait);\n\t} else if (0 == sdp->open_cnt) {\n\t\twake_up_interruptible(&sdp->open_wait);\n\t}\n\tmutex_unlock(&sdp->open_rel_lock);\n\treturn 0;\n}", "target": 0}
{"code": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord(\n    scoped_refptr<VideoFrame> input_frame,\n    scoped_refptr<VideoFrame> output_frame,\n    int quality,\n    int32_t task_id,\n    BitstreamBuffer* exif_buffer)\n    : input_frame(input_frame),\n       output_frame(output_frame),\n       quality(quality),\n       task_id(task_id),\n      output_shm(base::SharedMemoryHandle(), 0, true),  \n       exif_shm(nullptr) {\n   if (exif_buffer) {\n     exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),\n                                             exif_buffer->size(), false));\n    exif_offset = exif_buffer->offset();\n  }\n}", "target": 1}
{"code": "ns_client_isself(dns_view_t *myview, dns_tsigkey_t *mykey,\n\t\t isc_sockaddr_t *srcaddr, isc_sockaddr_t *dstaddr,\n\t\t dns_rdataclass_t rdclass, void *arg)\n{\n\tdns_view_t *view;\n\tdns_tsigkey_t *key = NULL;\n\tdns_name_t *tsig = NULL;\n\tisc_netaddr_t netsrc;\n\tisc_netaddr_t netdst;\n\tUNUSED(arg);\n\tif (ns_g_server->interfacemgr == NULL)\n\t\treturn (true);\n\tif (!ns_interfacemgr_listeningon(ns_g_server->interfacemgr, dstaddr))\n\t\treturn (false);\n\tisc_netaddr_fromsockaddr(&netsrc, srcaddr);\n\tisc_netaddr_fromsockaddr(&netdst, dstaddr);\n\tfor (view = ISC_LIST_HEAD(ns_g_server->viewlist);\n\t     view != NULL;\n\t     view = ISC_LIST_NEXT(view, link)) {\n\t\tif (view->matchrecursiveonly)\n\t\t\tcontinue;\n\t\tif (rdclass != view->rdclass)\n\t\t\tcontinue;\n\t\tif (mykey != NULL) {\n\t\t\tbool match;\n\t\t\tisc_result_t result;\n\t\t\tresult = dns_view_gettsig(view, &mykey->name, &key);\n\t\t\tif (result != ISC_R_SUCCESS)\n\t\t\t\tcontinue;\n\t\t\tmatch = dst_key_compare(mykey->key, key->key);\n\t\t\tdns_tsigkey_detach(&key);\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\t\t\ttsig = dns_tsigkey_identity(mykey);\n\t\t}\n\t\tif (allowed(&netsrc, tsig, NULL, 0, NULL,\n\t\t\t    view->matchclients) &&\n\t\t    allowed(&netdst, tsig, NULL, 0, NULL,\n\t\t\t    view->matchdestinations))\n\t\t\tbreak;\n\t}\n\treturn (view == myview);\n}", "target": 0}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n \tu16 qid = nvmet_fc_getqueueid(connection_id);\n \tunsigned long flags;\n \tspin_lock_irqsave(&tgtport->lock, flags);\n \tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n \t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 1}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "TfLiteStatus GatherNd(const TfLiteTensor* params, const TfLiteTensor* indices,\n                      TfLiteTensor* output) {\n  reference_ops::GatherNd(\n      GetTensorShape(params), GetTensorData<ParamsT>(params),\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(output), GetTensorData<ParamsT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "int RGWHandler_REST_S3Website::error_handler(int err_no,\n\t\t\t\t\t    string* error_content) {\n  int new_err_no = -1;\n  rgw_http_errors::const_iterator r = rgw_http_s3_errors.find(err_no > 0 ? err_no : -err_no);\n  int http_error_code = -1;\n  if (r != rgw_http_s3_errors.end()) {\n    http_error_code = r->second.first;\n  }\n  ldpp_dout(s, 10) << \"RGWHandler_REST_S3Website::error_handler err_no=\" << err_no << \" http_ret=\" << http_error_code << dendl;\n  RGWBWRoutingRule rrule;\n  bool should_redirect =\n    s->bucket_info.website_conf.should_redirect(original_object_name,\n                                                http_error_code, &rrule);\n  if (should_redirect) {\n    const string& hostname = s->info.env->get(\"HTTP_HOST\", \"\");\n    const string& protocol =\n      (s->info.env->get(\"SERVER_PORT_SECURE\") ? \"https\" : \"http\");\n    int redirect_code = 0;\n    rrule.apply_rule(protocol, hostname, original_object_name,\n                     &s->redirect, &redirect_code);\n    if (redirect_code > 0)\n      s->err.http_ret = redirect_code; \n    ldpp_dout(s, 10) << \"error handler redirect code=\" << redirect_code\n\t\t      << \" proto+host:\" << protocol << \":\n\t\t      << \" -> \" << s->redirect << dendl;\n    return -ERR_WEBSITE_REDIRECT;\n  } else if (err_no == -ERR_WEBSITE_REDIRECT) {\n  } else if (!s->bucket_info.website_conf.error_doc.empty()) {\n    new_err_no = RGWHandler_REST_S3Website::serve_errordoc(http_error_code, s->bucket_info.website_conf.error_doc);\n    if (new_err_no && new_err_no != -1) {\n      err_no = new_err_no;\n    }\n  } else {\n    ldpp_dout(s, 20) << \"No special error handling today!\" << dendl;\n  }\n  return err_no;\n}", "target": 0}
{"code": "sync_path (struct url *u)\n{\n  char *newpath, *efile, *edir;\n  xfree (u->path);\n  edir = url_escape_dir (u->dir);\n  efile = url_escape_1 (u->file, urlchr_unsafe | urlchr_reserved, 1);\n  if (!*edir)\n    newpath = xstrdup (efile);\n  else\n    {\n      int dirlen = strlen (edir);\n      int filelen = strlen (efile);\n      char *p = newpath = xmalloc (dirlen + 1 + filelen + 1);\n      memcpy (p, edir, dirlen);\n      p += dirlen;\n      *p++ = '/';\n      memcpy (p, efile, filelen);\n      p += filelen;\n      *p = '\\0';\n    }\n  u->path = newpath;\n  if (edir != u->dir)\n    xfree (edir);\n  if (efile != u->file)\n    xfree (efile);\n  xfree (u->url);\n  u->url = url_string (u, URL_AUTH_SHOW);\n}", "target": 0}
{"code": "static int connection_handle_write(request_st * const r, connection * const con) {\n\tif (con->is_writable <= 0) return CON_STATE_WRITE;\n\tint rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);\n\tswitch (rc) {\n\tcase 0:\n\t\tif (r->resp_body_finished) {\n\t\t\tconnection_set_state(r, CON_STATE_RESPONSE_END);\n\t\t\treturn CON_STATE_RESPONSE_END;\n\t\t}\n\t\tbreak;\n\tcase -1: \n\t\tlog_error(r->conf.errh, __FILE__, __LINE__,\n\t\t  \"connection closed: write failed on fd %d\", con->fd);\n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase -2: \n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase 1:\n\t\tif (con->write_queue->bytes_out)\n\t\t\tcon->is_writable = 0;\n\t\tbreak;\n\t}\n\treturn CON_STATE_WRITE; \n}", "target": 0}
{"code": "static char *get_pid_cgroup(pid_t pid, const char *contrl)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tchar *answer = NULL;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tconst char *h = find_mounted_controller(contrl);\n\tif (!h)\n\t\treturn NULL;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn NULL;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn NULL;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, h) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tdo {\n\t\t\tanswer = strdup(c2);\n\t\t} while (!answer);\n\t\tbreak;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "static int mxf_parse_package_comments(MXFContext *mxf, AVDictionary **pm, MXFPackage *package)\n{\n    MXFTaggedValue *tag;\n    int size, i;\n    char *key = NULL;\n    for (i = 0; i < package->comment_count; i++) {\n        tag = mxf_resolve_strong_ref(mxf, &package->comment_refs[i], TaggedValue);\n        if (!tag || !tag->name || !tag->value)\n            continue;\n        size = strlen(tag->name) + 8 + 1;\n        key = av_mallocz(size);\n        if (!key)\n            return AVERROR(ENOMEM);\n        snprintf(key, size, \"comment_%s\", tag->name);\n        av_dict_set(pm, key, tag->value, AV_DICT_DONT_STRDUP_KEY);\n    }\n    return 0;\n}", "target": 0}
{"code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n    if (!s || !s->orig_buf)\n        goto read_end;\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n        if (!acb)\n            continue;\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\nread_end:\n    return realsize;\n}", "target": 1}
{"code": "void Splash::pipeRunAAMono8(SplashPipe *pipe) {\n  Guchar aSrc, aDest, alpha2, aResult;\n  SplashColor cDest;\n  Guchar cResult0;\n  cDest[0] = *pipe->destColorPtr;\n  aDest = *pipe->destAlphaPtr;\n  aSrc = div255(pipe->aInput * pipe->shape);\n  aResult = aSrc + aDest - div255(aSrc * aDest);\n  alpha2 = aResult;\n  if (alpha2 == 0) {\n    cResult0 = 0;\n  } else {\n    cResult0 = state->grayTransfer[(Guchar)(((alpha2 - aSrc) * cDest[0] +\n\t\t\t\t\t     aSrc * pipe->cSrc[0]) / alpha2)];\n  }\n  *pipe->destColorPtr++ = cResult0;\n  *pipe->destAlphaPtr++ = aResult;\n  ++pipe->x;\n}", "target": 0}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 1}
{"code": "static void start_request(GDHCPClient *dhcp_client)\n{\n\tdebug(dhcp_client, \"start request (retries %d)\",\n\t\t\t\t\tdhcp_client->retry_times);\n\tif (dhcp_client->retry_times == REQUEST_RETRIES) {\n\t\tif (dhcp_client->no_lease_cb)\n\t\t\tdhcp_client->no_lease_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->no_lease_data);\n\t\treturn;\n\t}\n\tif (dhcp_client->retry_times == 0) {\n\t\tdhcp_client->state = REQUESTING;\n\t\tswitch_listening_mode(dhcp_client, L2);\n\t}\n\tsend_request(dhcp_client);\n\tdhcp_client->timeout = g_timeout_add_seconds_full(G_PRIORITY_HIGH,\n\t\t\t\t\t\t\tREQUEST_TIMEOUT,\n\t\t\t\t\t\t\trequest_timeout,\n\t\t\t\t\t\t\tdhcp_client,\n\t\t\t\t\t\t\tNULL);\n}", "target": 0}
{"code": "int VP8LDecodeImage(VP8LDecoder* const dec) {\n  VP8Io* io = NULL;\n  WebPDecParams* params = NULL;\n  if (dec == NULL) return 0;\n  assert(dec->hdr_.huffman_tables_ != NULL);\n  assert(dec->hdr_.htree_groups_ != NULL);\n  assert(dec->hdr_.num_htree_groups_ > 0);\n  io = dec->io_;\n  assert(io != NULL);\n  params = (WebPDecParams*)io->opaque;\n  assert(params != NULL);\n  if (dec->state_ != READ_DATA) {\n    dec->output_ = params->output;\n    assert(dec->output_ != NULL);\n    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;\n#if !defined(WEBP_REDUCE_SIZE)\n    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;\n#else\n    if (io->use_scaling) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n#endif\n    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {\n      WebPInitAlphaProcessing();\n    }\n    if (!WebPIsRGBMode(dec->output_->colorspace)) {\n      WebPInitConvertARGBToYUV();\n      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();\n    }\n    if (dec->incremental_) {\n      if (dec->hdr_.color_cache_size_ > 0 &&\n          dec->hdr_.saved_color_cache_.colors_ == NULL) {\n        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,\n                                dec->hdr_.color_cache_.hash_bits_)) {\n          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n          goto Err;\n        }\n      }\n    }\n    dec->state_ = READ_DATA;\n  }\n  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                       io->crop_bottom, ProcessRows)) {\n    goto Err;\n  }\n  params->last_y = dec->last_out_row_;\n  return 1;\n Err:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}", "target": 1}
{"code": "cmd_getinfo (assuan_context_t ctx, char *line)\n{\n  int rc = 0;\n  if (!strcmp (line, \"version\"))\n    {\n      const char *s = VERSION;\n      rc = assuan_send_data (ctx, s, strlen (s));\n    }\n  else if (!strcmp (line, \"pid\"))\n    {\n      char numbuf[50];\n      snprintf (numbuf, sizeof numbuf, \"%lu\", (unsigned long)getpid ());\n      rc = assuan_send_data (ctx, numbuf, strlen (numbuf));\n    }\n  else if (!strcmp (line, \"socket_name\"))\n    {\n      const char *s = scd_get_socket_name ();\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = gpg_error (GPG_ERR_NO_DATA);\n    }\n  else if (!strcmp (line, \"status\"))\n    {\n      ctrl_t ctrl = assuan_get_pointer (ctx);\n      int vrdr = ctrl->server_local->vreader_idx;\n      char flag = 'r';\n      if (!ctrl->server_local->card_removed && vrdr != -1)\n\t{\n\t  struct vreader_s *vr;\n\t  if (!(vrdr >= 0 && vrdr < DIM(vreader_table)))\n\t    BUG ();\n\t  vr = &vreader_table[vrdr];\n\t  if (vr->valid && vr->any && (vr->status & 1))\n\t    flag = 'u';\n\t}\n      rc = assuan_send_data (ctx, &flag, 1);\n    }\n  else if (!strcmp (line, \"reader_list\"))\n    {\n#ifdef HAVE_LIBUSB\n      char *s = ccid_get_reader_list ();\n#else\n      char *s = NULL;\n#endif\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = gpg_error (GPG_ERR_NO_DATA);\n      xfree (s);\n    }\n  else if (!strcmp (line, \"deny_admin\"))\n    rc = opt.allow_admin? gpg_error (GPG_ERR_GENERAL) : 0;\n  else if (!strcmp (line, \"app_list\"))\n    {\n      char *s = get_supported_applications ();\n      if (s)\n        rc = assuan_send_data (ctx, s, strlen (s));\n      else\n        rc = 0;\n      xfree (s);\n    }\n  else\n    rc = set_error (GPG_ERR_ASS_PARAMETER, \"unknown value for WHAT\");\n  return rc;\n}", "target": 0}
{"code": "  UpdatePersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      int new_quota,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota_, 0);\n  }", "target": 0}
{"code": "static void print_liveness(struct bpf_verifier_env *env,\n\t\t\t   enum bpf_reg_liveness live)\n{\n\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))\n\t    verbose(env, \"_\");\n\tif (live & REG_LIVE_READ)\n\t\tverbose(env, \"r\");\n\tif (live & REG_LIVE_WRITTEN)\n\t\tverbose(env, \"w\");\n\tif (live & REG_LIVE_DONE)\n\t\tverbose(env, \"D\");\n}", "target": 0}
{"code": "fill_yin_revision(struct lys_module *module, struct lyxml_elem *yin, struct lys_revision *rev,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *next, *child;\n    const char *value;\n    GETVAL(ctx, value, yin, \"date\");\n    if (lyp_check_date(ctx, value)) {\n        goto error;\n    }\n    memcpy(rev->date, value, LY_REV_SIZE - 1);\n    LY_TREE_FOR_SAFE(yin->child, next, child) {\n        if (!child->ns) {\n            continue;\n        } else if (strcmp(child->ns->value, LY_NSYIN)) {\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_SELF, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"description\")) {\n            if (rev->dsc) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_DESCRIPTION, 0, unres)) {\n                goto error;\n            }\n            rev->dsc = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->dsc) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"reference\")) {\n            if (rev->ref) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_REFERENCE, 0, unres)) {\n                goto error;\n            }\n            rev->ref = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->ref) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, child->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n  register ssize_t\n    x;\n  ssize_t\n    center,\n    y;\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}", "target": 0}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\tif (!idtv_info_valid)\n\t\treturn;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static void *conncache_add_bundle(struct conncache *connc,\n                                  char *key,\n                                  struct connectbundle *bundle)\n{\n  return Curl_hash_add(&connc->hash, key, strlen(key), bundle);\n}", "target": 0}
{"code": "ReverbConvolverStage::ReverbConvolverStage(const float* impulseResponse, size_t, size_t reverbTotalLatency, size_t stageOffset, size_t stageLength,\n                                           size_t fftSize, size_t renderPhase, size_t renderSliceSize, ReverbAccumulationBuffer* accumulationBuffer, bool directMode)\n    : m_accumulationBuffer(accumulationBuffer)\n    , m_accumulationReadIndex(0)\n    , m_inputReadIndex(0)\n    , m_directMode(directMode)\n{\n    ASSERT(impulseResponse);\n    ASSERT(accumulationBuffer);\n    if (!m_directMode) {\n        m_fftKernel = adoptPtr(new FFTFrame(fftSize));\n         m_fftKernel->doPaddedFFT(impulseResponse + stageOffset, stageLength);\n         m_fftConvolver = adoptPtr(new FFTConvolver(fftSize));\n     } else {\n         m_directKernel = adoptPtr(new AudioFloatArray(fftSize / 2));\n        m_directKernel->copyToRange(impulseResponse + stageOffset, 0, fftSize / 2);\n         m_directConvolver = adoptPtr(new DirectConvolver(renderSliceSize));\n     }\n     m_temporaryBuffer.allocate(renderSliceSize);\n    size_t totalDelay = stageOffset + reverbTotalLatency;\n    size_t halfSize = fftSize / 2;\n    if (!m_directMode) {\n        ASSERT(totalDelay >= halfSize);\n        if (totalDelay >= halfSize)\n            totalDelay -= halfSize;\n    }\n    int maxPreDelayLength = std::min(halfSize, totalDelay);\n    m_preDelayLength = totalDelay > 0 ? renderPhase % maxPreDelayLength : 0;\n    if (m_preDelayLength > totalDelay)\n        m_preDelayLength = 0;\n    m_postDelayLength = totalDelay - m_preDelayLength;\n    m_preReadWriteIndex = 0;\n    m_framesProcessed = 0; \n    size_t delayBufferSize = m_preDelayLength < fftSize ? fftSize : m_preDelayLength;\n    delayBufferSize = delayBufferSize < renderSliceSize ? renderSliceSize : delayBufferSize;\n    m_preDelayBuffer.allocate(delayBufferSize);\n}", "target": 1}
{"code": "GF_Box *trun_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackFragmentRunBox, GF_ISOM_BOX_TYPE_TRUN);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "newVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}", "target": 0}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "my_pipe_sig_handler(int sig __attribute__((unused)))\n{\n  DBUG_PRINT(\"info\",(\"Hit by signal %d\",sig));\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  (void) signal(SIGPIPE, my_pipe_sig_handler);\n#endif\n}", "target": 0}
{"code": "unsigned get_next_char(ASS_Renderer *render_priv, char **str)\n{\n    char *p = *str;\n    unsigned chr;\n    if (*p == '\\t') {\n        ++p;\n        *str = p;\n        return ' ';\n    }\n    if (*p == '\\\\') {\n        if ((p[1] == 'N') || ((p[1] == 'n') &&\n                              (render_priv->state.wrap_style == 2))) {\n            p += 2;\n            *str = p;\n            return '\\n';\n        } else if (p[1] == 'n') {\n            p += 2;\n            *str = p;\n            return ' ';\n        } else if (p[1] == 'h') {\n            p += 2;\n            *str = p;\n            return NBSP;\n        } else if (p[1] == '{') {\n            p += 2;\n            *str = p;\n            return '{';\n        } else if (p[1] == '}') {\n            p += 2;\n            *str = p;\n            return '}';\n        }\n    }\n    chr = ass_utf8_get_char((char **) &p);\n    *str = p;\n    return chr;\n}", "target": 0}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "rdpsnd_register_drivers(char *options)\n{\n\tstruct audio_driver **reg;\n\treg = &drivers;\n#if defined(RDPSND_ALSA)\n\t*reg = alsa_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SUN)\n\t*reg = sun_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_OSS)\n\t*reg = oss_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_SGI)\n\t*reg = sgi_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n#if defined(RDPSND_LIBAO)\n\t*reg = libao_register(options);\n\tassert(*reg);\n\treg = &((*reg)->next);\n#endif\n\t*reg = NULL;\n}", "target": 0}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n \tfree(name);\n \treturn 0;\n}", "target": 1}
{"code": "int tcp_ctl(struct socket *so)\n{\n    Slirp *slirp = so->slirp;\n    struct sbuf *sb = &so->so_snd;\n    struct gfwd_list *ex_ptr;\n    DEBUG_CALL(\"tcp_ctl\");\n    DEBUG_ARG(\"so = %p\", so);\n    if (so->so_faddr.s_addr != slirp->vhost_addr.s_addr) {\n        for (ex_ptr = slirp->guestfwd_list; ex_ptr; ex_ptr = ex_ptr->ex_next) {\n            if (ex_ptr->ex_fport == so->so_fport &&\n                so->so_faddr.s_addr == ex_ptr->ex_addr.s_addr) {\n                if (ex_ptr->write_cb) {\n                    so->s = -1;\n                    so->guestfwd = ex_ptr;\n                    return 1;\n                }\n                DEBUG_MISC(\" executing %s\", ex_ptr->ex_exec);\n                if (ex_ptr->ex_unix)\n                    return open_unix(so, ex_ptr->ex_unix);\n                else\n                    return fork_exec(so, ex_ptr->ex_exec);\n            }\n        }\n    }\n    sb->sb_cc =\n        snprintf(sb->sb_wptr, sb->sb_datalen - (sb->sb_wptr - sb->sb_data),\n                 \"Error: No application configured.\\r\\n\");\n    sb->sb_wptr += sb->sb_cc;\n    return 0;\n}", "target": 0}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "mm_answer_sessid(int socket, Buffer *m)\n{\n\tint i;\n\tdebug3(\"%s entering\", __func__);\n\tif (buffer_len(m) != 16)\n\t\tfatal(\"%s: bad ssh1 session id\", __func__);\n\tfor (i = 0; i < 16; i++)\n\t\tsession_id[i] = buffer_get_char(m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "void print_2fun(FILE* outfile, LibRaw& MyCoolRawProcessor, std::string& fn)\n{\n\tfprintf(outfile, \"\n\tif (C.cam_mul[0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'As shot' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %.3f\", C.cam_mul[c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Auto][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Auto' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Auto][c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Measured][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Measured' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Measured][c]);\n\t}\n\tfprintf(outfile, \"\\n\\n\");\n}", "target": 0}
{"code": " void HTMLImportsController::Dispose() {\n  for (const auto& loader : loaders_)\n    loader->Dispose();\n  loaders_.clear();\n   if (root_) {\n     root_->Dispose();\n    root_.Clear();\n  }\n}", "target": 1}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n  register const double\n    *p;\n  register double\n    *q;\n  register ssize_t\n    i;\n  size_t\n    n;\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}", "target": 1}
{"code": "buf_pos_init(const buf_t *buf, buf_pos_t *out)\n{\n  out->chunk = buf->head;\n  out->pos = 0;\n  out->chunk_pos = 0;\n}", "target": 0}
{"code": "ProtoValidationTypeString(const ServiceValidationResultsType t)\n{\n   switch (t) {\n   case VALIDATION_RESULTS_TYPE_NAMEPASSWORD:\n      return VGAUTH_USERHANDLE_TYPE_NAMEPASSWORD;\n   case VALIDATION_RESULTS_TYPE_SSPI:\n      return VGAUTH_USERHANDLE_TYPE_SSPI;\n   case VALIDATION_RESULTS_TYPE_SAML:\n      return VGAUTH_USERHANDLE_TYPE_SAML;\n   case VALIDATION_RESULTS_TYPE_SAML_INFO_ONLY:\n      return VGAUTH_USERHANDLE_TYPE_SAML_INFO_ONLY;\n   case VALIDATION_RESULTS_TYPE_UNKNOWN:\n   default:\n      ASSERT(0);\n      Warning(\"%s: Tried to convert a validationType of %d to a string\\n\",\n              __FUNCTION__, t);\n      return \"<UNKNOWN>\";\n   }\n}", "target": 0}
{"code": "int GfxUnivariateShading::getColor(double t, GfxColor *color)\n{\n    double out[gfxColorMaxComps];\n    int nComps;\n    if (likely(getNFuncs() >= 1)) {\n        nComps = getNFuncs() * funcs[0]->getOutputSize();\n    }\n    if (unlikely(getNFuncs() < 1 || nComps > gfxColorMaxComps)) {\n        clearGfxColor(color);\n        return gfxColorMaxComps;\n    }\n    if (cacheSize > 0) {\n        double x, ix, *l, *u, *upper;\n        if (cacheBounds[lastMatch - 1] >= t) {\n            upper = std::lower_bound(cacheBounds, cacheBounds + lastMatch - 1, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        } else if (cacheBounds[lastMatch] < t) {\n            upper = std::lower_bound(cacheBounds + lastMatch + 1, cacheBounds + cacheSize, t);\n            lastMatch = upper - cacheBounds;\n            lastMatch = std::min<int>(std::max<int>(1, lastMatch), cacheSize - 1);\n        }\n        x = (t - cacheBounds[lastMatch - 1]) * cacheCoeff[lastMatch];\n        ix = 1.0 - x;\n        u = cacheValues + lastMatch * nComps;\n        l = u - nComps;\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = ix * l[i] + x * u[i];\n        }\n    } else {\n        for (int i = 0; i < nComps; ++i) {\n            out[i] = 0;\n        }\n        for (int i = 0; i < getNFuncs(); ++i) {\n            if (funcs[i]->getInputSize() != 1) {\n                error(errSyntaxWarning, -1, \"Invalid shading function (input != 1)\");\n                break;\n            }\n            funcs[i]->transform(&t, &out[i]);\n        }\n    }\n    for (int i = 0; i < nComps; ++i) {\n        color->c[i] = dblToCol(out[i]);\n    }\n    return nComps;\n}", "target": 0}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "atoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}", "target": 0}
{"code": "cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_close(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t       struct nfs_closeargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_close(xdr, args, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "CLua &CLua::get_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    _getregistry(ls, \"__clua\");\n    CLua *vm = clua_get_lightuserdata<CLua>(ls, -1);\n    if (!vm)\n        luaL_error(ls, \"Could not find matching clua for lua state\");\n    return *vm;\n}", "target": 0}
{"code": "  UpstreamWrapper(const StreamInfo::StreamInfo& info) : info_(info) {}", "target": 0}
{"code": "void promote_select_describe_flag_if_needed(LEX *lex)\n{\n  if (lex->describe)\n  {\n    lex->select_lex.options |= SELECT_DESCRIBE;\n  }\n}", "target": 0}
{"code": "xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n    xmlCtxtReset(ctxt);\n    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n\treturn(NULL);\n    }\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}", "target": 0}
{"code": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "status_t Parcel::readUtf8FromUtf16(std::string* str) const {\n size_t utf16Size = 0;\n const char16_t* src = readString16Inplace(&utf16Size);\n if (!src) {\n return UNEXPECTED_NULL;\n }\n if (utf16Size == 0u) {\n        str->clear();\n        return NO_ERROR;\n     }\n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);\n    if (utf8Size < 0) {\n         return BAD_VALUE;\n     }\n    str->resize(utf8Size + 1);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]));\n     str->resize(utf8Size);\n     return NO_ERROR;\n }", "target": 1}
{"code": "static void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n    }\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->trace_enable = AP_TRACE_UNSET;\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->async_filter = 0;\n    return (void *)conf;\n}", "target": 0}
{"code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\t\tg_object_unref (destination);\n\t\treturn;\n\t}\n\tif (odata->edata->file_list != NULL) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}", "target": 1}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "bool TabsCaptureVisibleTabFunction::RunImpl() {\n  PrefService* service = profile()->GetPrefs();\n  if (service->GetBoolean(prefs::kDisableScreenshots)) {\n    error_ = keys::kScreenshotsDisabled;\n    return false;\n  }\n  WebContents* web_contents = NULL;\n  if (!GetTabToCapture(&web_contents))\n    return false;\n  image_format_ = FORMAT_JPEG;  \n  image_quality_ = kDefaultQuality;  \n  if (HasOptionalArgument(1)) {\n    DictionaryValue* options = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));\n    if (options->HasKey(keys::kFormatKey)) {\n      std::string format;\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetString(keys::kFormatKey, &format));\n      if (format == keys::kFormatValueJpeg) {\n        image_format_ = FORMAT_JPEG;\n      } else if (format == keys::kFormatValuePng) {\n        image_format_ = FORMAT_PNG;\n      } else {\n        EXTENSION_FUNCTION_VALIDATE(0);\n      }\n    }\n    if (options->HasKey(keys::kQualityKey)) {\n      EXTENSION_FUNCTION_VALIDATE(\n          options->GetInteger(keys::kQualityKey, &image_quality_));\n     }\n   }\n  if (!GetExtension()->CanCaptureVisiblePage(\n        web_contents->GetURL(),\n        SessionID::IdForTab(web_contents),\n        &error_)) {\n     return false;\n   }\n  RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  content::RenderWidgetHostView* view = render_view_host->GetView();\n  if (!view) {\n    error_ = keys::kInternalVisibleTabCaptureError;\n    return false;\n  }\n  render_view_host->CopyFromBackingStore(\n      gfx::Rect(),\n      view->GetViewBounds().size(),\n      base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,\n                 this));\n  return true;\n}", "target": 1}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "util_write_callback(int flags, char *ptr, size_t size, size_t nmemb, void *stream)\n{\n    CurlObject *self;\n    PyObject *arglist;\n    PyObject *result = NULL;\n    size_t ret = 0;     \n    PyObject *cb;\n    int total_size;\n    PYCURL_DECLARE_THREAD_STATE;\n    self = (CurlObject *)stream;\n    if (!PYCURL_ACQUIRE_THREAD())\n        return ret;\n    cb = flags ? self->h_cb : self->w_cb;\n    if (cb == NULL)\n        goto silent_error;\n    if (size <= 0 || nmemb <= 0)\n        goto done;\n    total_size = (int)(size * nmemb);\n    if (total_size < 0 || (size_t)total_size / size != nmemb) {\n        PyErr_SetString(ErrorObject, \"integer overflow in write callback\");\n        goto verbose_error;\n    }\n#if PY_MAJOR_VERSION >= 3\n    arglist = Py_BuildValue(\"(y#)\", ptr, total_size);\n#else\n    arglist = Py_BuildValue(\"(s#)\", ptr, total_size);\n#endif\n    if (arglist == NULL)\n        goto verbose_error;\n    result = PyEval_CallObject(cb, arglist);\n    Py_DECREF(arglist);\n    if (result == NULL)\n        goto verbose_error;\n    if (result == Py_None) {\n        ret = total_size;           \n    }\n    else if (PyInt_Check(result) || PyLong_Check(result)) {\n        ret = (size_t) PyLong_AsLong(result);\n    }\n    else {\n        PyErr_SetString(ErrorObject, \"write callback must return int or None\");\n        goto verbose_error;\n    }\ndone:\nsilent_error:\n    Py_XDECREF(result);\n    PYCURL_RELEASE_THREAD();\n    return ret;\nverbose_error:\n    PyErr_Print();\n    goto silent_error;\n}", "target": 0}
{"code": "buf_add_chunk_with_capacity(buf_t *buf, size_t capacity, int capped)\n{\n  chunk_t *chunk;\n  struct timeval now;\n  if (CHUNK_ALLOC_SIZE(capacity) < buf->default_chunk_size) {\n    chunk = chunk_new_with_alloc_size(buf->default_chunk_size);\n  } else if (capped && CHUNK_ALLOC_SIZE(capacity) > MAX_CHUNK_ALLOC) {\n    chunk = chunk_new_with_alloc_size(MAX_CHUNK_ALLOC);\n  } else {\n    chunk = chunk_new_with_alloc_size(preferred_chunk_size(capacity));\n  }\n  tor_gettimeofday_cached_monotonic(&now);\n  chunk->inserted_time = (uint32_t)tv_to_msec(&now);\n  if (buf->tail) {\n    tor_assert(buf->head);\n    buf->tail->next = chunk;\n    buf->tail = chunk;\n  } else {\n    tor_assert(!buf->head);\n    buf->head = buf->tail = chunk;\n  }\n  check();\n  return chunk;\n}", "target": 0}
{"code": "static int sc_pkcs15emu_sc_hsm_add_dcod(sc_pkcs15_card_t * p15card, u8 id) {\n\tsc_card_t *card = p15card->card;\n\tsc_pkcs15_data_info_t *data_info;\n\tsc_pkcs15_object_t data_obj;\n\tu8 fid[2];\n\tu8 efbin[512];\n\tconst u8 *ptr;\n\tsize_t len;\n\tint r;\n\tfid[0] = DCOD_PREFIX;\n\tfid[1] = id;\n\tlen = sizeof efbin;\n\tr = read_file(p15card, fid, efbin, &len, 1);\n\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.DCOD\");\n\tptr = efbin;\n\tmemset(&data_obj, 0, sizeof(data_obj));\n\tr = sc_pkcs15_decode_dodf_entry(p15card, &data_obj, &ptr, &len);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode optional EF.DCOD\");\n\tdata_info = (sc_pkcs15_data_info_t *)data_obj.data;\n\tr = sc_pkcs15emu_add_data_object(p15card, &data_obj, data_info);\n\tLOG_TEST_RET(card->ctx, r, \"Could not add data object to framework\");\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "cdf_unpack_header(cdf_header_t *h, char *buf)\n{\n\tsize_t i;\n\tsize_t len = 0;\n\tCDF_UNPACK(h->h_magic);\n\tCDF_UNPACKA(h->h_uuid);\n\tCDF_UNPACK(h->h_revision);\n\tCDF_UNPACK(h->h_version);\n\tCDF_UNPACK(h->h_byte_order);\n\tCDF_UNPACK(h->h_sec_size_p2);\n\tCDF_UNPACK(h->h_short_sec_size_p2);\n\tCDF_UNPACKA(h->h_unused0);\n\tCDF_UNPACK(h->h_num_sectors_in_sat);\n\tCDF_UNPACK(h->h_secid_first_directory);\n\tCDF_UNPACKA(h->h_unused1);\n\tCDF_UNPACK(h->h_min_size_standard_stream);\n\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n\t\tCDF_UNPACK(h->h_master_sat[i]);\n}", "target": 0}
{"code": "void _WM_do_control_channel_pan(struct _mdi *mdi, struct _event_data *data) {\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pan = data->data.value;\n    _WM_AdjustChannelVolumes(mdi, ch);\n}", "target": 0}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static const void *netdev_queue_namespace(struct kobject *kobj)\n{\n\tstruct netdev_queue *queue = to_netdev_queue(kobj);\n\tstruct device *dev = &queue->dev->dev;\n\tconst void *ns = NULL;\n\tif (dev->class && dev->class->ns_type)\n\t\tns = dev->class->namespace(dev);\n\treturn ns;", "target": 0}
{"code": "static void __init set_osi_linux(unsigned int enable)\n{\n\tif (osi_linux.enable != enable)\n\t\tosi_linux.enable = enable;\n\tif (osi_linux.enable)\n\t\tacpi_osi_setup(\"Linux\");\n\telse\n\t\tacpi_osi_setup(\"!Linux\");\n\treturn;\n}", "target": 0}
{"code": "MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n    return(tolower_l(c,c_locale));\n #endif\n  return(tolower(c));\n }", "target": 1}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "passIsKeyword (const char *token)\n{\n  int k;\n  int length = strlen (token);\n  int ch = passLine.chars[passLinepos + length + 1];\n  if (((ch | 32) >= 'a' && (ch | 32) <= 'z') || (ch >= '0' && ch <= '9'))\n    return 0;\n  for (k = 0; k < length && passLine.chars[passLinepos + k + 1]\n       == (widechar) token[k]; k++);\n  if (k == length)\n    {\n      passLinepos += length + 1;\n      return 1;\n    }\n  return 0;\n}", "target": 0}
{"code": "void crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n \t\t} else {\n \t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n \t\t}\n \t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n \tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n \tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n \t\tchunk->singleton = 0;\n \t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n \t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n \t\t\treturn range_within(rold, rcur) &&\n \t\t\t       tnum_in(rold->var_off, rcur->var_off);\n \t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n \t\t}\n \tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "ex_sleep(exarg_T *eap)\n{\n    int\t\tn;\n    long\tlen;\n    if (cursor_valid())\n    {\n\tn = W_WINROW(curwin) + curwin->w_wrow - msg_scrolled;\n\tif (n >= 0)\n\t    windgoto(n, curwin->w_wincol + curwin->w_wcol);\n    }\n    len = eap->line2;\n    switch (*eap->arg)\n    {\n\tcase 'm': break;\n\tcase NUL: len *= 1000L; break;\n\tdefault: semsg(_(e_invalid_argument_str), eap->arg); return;\n    }\n    do_sleep(len, eap->forceit);\n}", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n \t\tif (args->flags & ATTR_CREATE)\n \t\t\treturn retval;\n \t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n \t}\n \tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "void ChangeListLoader::UpdateAboutResourceAfterGetAbout(\n    const google_apis::AboutResourceCallback& callback,\n    google_apis::GDataErrorCode status,\n    scoped_ptr<google_apis::AboutResource> about_resource) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  FileError error = GDataToFileError(status);\n  if (error == FILE_ERROR_OK) {\n    if (cached_about_resource_ &&\n        cached_about_resource_->largest_change_id() >\n        about_resource->largest_change_id()) {\n      LOG(WARNING) << \"Local cached about resource is fresher than server, \"\n                   << \"local = \" << cached_about_resource_->largest_change_id()\n                   << \", server = \" << about_resource->largest_change_id();\n    }\n    cached_about_resource_.reset(\n        new google_apis::AboutResource(*about_resource));\n  }\n  callback.Run(status, about_resource.Pass());\n}", "target": 0}
{"code": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t\n\tif (length > 2) {\t\t\t\t\n\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n\t}\n\tif (length > 4) {\t\t\t\t\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n\t}\n}", "target": 1}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 1}
{"code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "    bool Converter::prepareIptcTarget(const char* to, bool force)\n    {\n        Exiv2::IptcData::iterator pos = iptcData_->findKey(IptcKey(to));\n        if (pos == iptcData_->end()) return true;\n        if (!overwrite_ && !force) return false;\n        while ((pos = iptcData_->findKey(IptcKey(to))) != iptcData_->end()) {\n            iptcData_->erase(pos);\n        }\n        return true;\n    }", "target": 0}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\n{\n  int Result = RESULT_SUCCESS;\n  try\n  {\n    std::unique_ptr<TStrings> Arguments(new TStringList());\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\n    {\n      Abort();\n    }\n    else\n    {\n      if (Arguments->Count < 1)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\n      }\n      else if (Arguments->Count < 2)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\n      }\n      else\n      {\n        TFileMasks Mask(Arguments->Strings[0]);\n        Arguments->Delete(0);\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\n        int Matches = 0;\n        int Changes = 0;\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\n        {\n          TSessionData * Data = StoredSessions->Sessions[Index];\n          if (!Data->IsWorkspace &&\n              Mask.Matches(Data->Name, false, false))\n          {\n            Matches++;\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\n            OriginalData->CopyDataNoRecrypt(Data);\n            Data->ApplyRawSettings(OptionsStorage.get());\n            bool Changed = !OriginalData->IsSame(Data, false);\n            if (Changed)\n            {\n              Changes++;\n            }\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\n          }\n        }\n        StoredSessions->Save(false, true); \n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\n      }\n    }\n  }\n  catch (Exception & E)\n  {\n    Result = HandleException(Console, E);\n  }\n  Console->WaitBeforeExit();\n  return Result;\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "ImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); \n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        ImagingError_Clear();\n    }\n    return ImagingNewArray(mode, xsize, ysize);\n}", "target": 1}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "static int checksum_setup(struct net_device *dev, struct sk_buff *skb)\n{\n\tbool recalculate_partial_csum = false;\n\tif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\n\t\tstruct netfront_info *np = netdev_priv(dev);\n\t\tatomic_inc(&np->rx_gso_checksum_fixup);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\trecalculate_partial_csum = true;\n\t}\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\treturn skb_checksum_setup(skb, recalculate_partial_csum);\n}", "target": 0}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "static void alloc_stmt_fields(MYSQL_STMT *stmt)\n{\n  MYSQL_FIELD *fields, *field, *end;\n  MEM_ROOT *fields_mem_root= &stmt->extension->fields_mem_root;\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ASSERT(stmt->field_count);\n  free_root(fields_mem_root, MYF(0));\n  if (!(stmt->fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,\n\t\t\t\t\t\t sizeof(MYSQL_FIELD) *\n\t\t\t\t\t\t stmt->field_count)) ||\n      !(stmt->bind= (MYSQL_BIND *) alloc_root(fields_mem_root,\n\t\t\t\t\t      sizeof(MYSQL_BIND) *\n\t\t\t\t\t      stmt->field_count)))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    return;\n  }\n  for (fields= mysql->fields, end= fields+stmt->field_count,\n\t field= stmt->fields;\n       field && fields < end; fields++, field++)\n  {\n    *field= *fields; \n    field->catalog=   strmake_root(fields_mem_root,\n                                   fields->catalog,\n                                   fields->catalog_length);\n    field->db=        strmake_root(fields_mem_root,\n                                   fields->db,\n                                   fields->db_length);\n    field->table=     strmake_root(fields_mem_root,\n                                   fields->table,\n                                   fields->table_length);\n    field->org_table= strmake_root(fields_mem_root,\n                                   fields->org_table,\n                                   fields->org_table_length);\n    field->name=      strmake_root(fields_mem_root,\n                                   fields->name,\n                                   fields->name_length);\n    field->org_name=  strmake_root(fields_mem_root,\n                                   fields->org_name,\n                                   fields->org_name_length);\n    if (fields->def)\n    {\n      field->def= strmake_root(fields_mem_root,\n                               fields->def,\n                               fields->def_length);\n      field->def_length= fields->def_length;\n    }\n    else\n    {\n      field->def= NULL;\n      field->def_length= 0;\n    }\n    field->extension= 0; \n    field->max_length= 0; \n  }\n}", "target": 0}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n    REQUEST(xReq);\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n    return (SendConnSetup(client, reason));\n}", "target": 1}
{"code": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "bool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n  vlog.debug(\"Process security message (session %p)\", session);\n  if (!session) {\n    initGlobal();\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n    os->writeU8(1);\n    os->flush();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  vlog.debug(\"Handshake completed\");\n  sc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "static void do_tx_packet(lan9118_state *s)\n{\n    int n;\n    uint32_t status;\n    if (s->phy_control & 0x4000)  {\n        lan9118_receive(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    } else {\n        qemu_send_packet(qemu_get_queue(s->nic), s->txp->data, s->txp->len);\n    }\n    s->txp->fifo_used = 0;\n    if (s->tx_status_fifo_used == 512) {\n        return;\n    }\n    status = s->txp->cmd_b & 0xffff0000u;\n    DPRINTF(\"Sent packet tag:%04x len %d\\n\", status >> 16, s->txp->len);\n    n = (s->tx_status_fifo_head + s->tx_status_fifo_used) & 511;\n    s->tx_status_fifo[n] = status;\n    s->tx_status_fifo_used++;\n    if (s->tx_status_fifo_used == 512) {\n        s->int_sts |= TSFF_INT;\n    }\n}", "target": 1}
{"code": "rb_reg_last_match(VALUE match)\n{\n    return rb_reg_nth_match(0, match);\n}", "target": 0}
{"code": "void http_return_srv_error(struct session *s, struct stream_interface *si)\n{\n\tint err_type = si->err_type;\n\tif (err_type & SI_ET_QUEUE_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse \n\t\thttp_server_error(s, si, SN_ERR_INTERNAL, SN_FINST_C,\n\t\t\t\t  500, http_error_message(s, HTTP_ERR_500));\n}", "target": 0}
{"code": "  QInt8() {}", "target": 1}
{"code": "ZEND_API zend_extension *zend_get_extension(const char *extension_name)\n{\n\tzend_llist_element *element;\n\tfor (element = zend_extensions.head; element; element = element->next) {\n\t\tzend_extension *extension = (zend_extension *) element->data;\n\t\tif (!strcmp(extension->name, extension_name)) {\n\t\t\treturn extension;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "Browser::CreateParams Browser::CreateParams::CreateForApp(\n    const std::string& app_name,\n    bool trusted_source,\n    const gfx::Rect& window_bounds,\n    Profile* profile) {\n  DCHECK(!app_name.empty());\n  CreateParams params(TYPE_POPUP, profile);\n  params.app_name = app_name;\n  params.trusted_source = trusted_source;\n  params.initial_bounds = window_bounds;\n  return params;\n}", "target": 0}
{"code": "static int snd_timer_register_system(void)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_system_private *priv;\n\tint err;\n\terr = snd_timer_global_new(\"system\", SNDRV_TIMER_GLOBAL_SYSTEM, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"system timer\");\n\ttimer->hw = snd_timer_system;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tsnd_timer_free(timer);\n\t\treturn -ENOMEM;\n\t}\n\tsetup_timer(&priv->tlist, snd_timer_s_function, (unsigned long) timer);\n\ttimer->private_data = priv;\n\ttimer->private_free = snd_timer_free_system;\n\treturn snd_timer_global_register(timer);\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "static int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EINVAL, opt;\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = get_user(opt, (int __user *)optval);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 0}
{"code": "int rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void Document::InitContentSecurityPolicy(\n    ContentSecurityPolicy* csp,\n     const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n  if (policy_to_inherit) {\n    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  } else if (frame_) {\n    Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                  : frame_->Client()->Opener();\n    if (inherit_from && frame_ != inherit_from) {\n      DCHECK(inherit_from->GetSecurityContext() &&\n             inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n      policy_to_inherit =\n          inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n      if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n          url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")) {\n        GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n      }\n    }\n  }\n   if (policy_to_inherit && IsPluginDocument())\n     GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n  GetContentSecurityPolicy()->BindToExecutionContext(this);\n }", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "put_negResult(unsigned char **buf_out, OM_uint32 negResult,\n\t      unsigned int buflen)\n{\n\tif (buflen < 3)\n\t\treturn (-1);\n\t*(*buf_out)++ = ENUMERATED;\n\t*(*buf_out)++ = ENUMERATION_LENGTH;\n\t*(*buf_out)++ = (unsigned char) negResult;\n\treturn (0);\n}", "target": 0}
{"code": "elf_core_copy_task_xfpregs(struct task_struct *t, elf_fpxregset_t *xfpu)\n{\n\tstruct pt_regs *regs = task_pt_regs(t);\n\tif (!tsk_used_math(t))\n\t\treturn 0;\n\tif (t == current)\n\t\tunlazy_fpu(t); \n\tmemcpy(xfpu, &t->thread.i387.fxsave, sizeof(elf_fpxregset_t));\n\txfpu->fcs = regs->cs; \n\txfpu->fos = t->thread.ds;  \n\treturn 1;\n}", "target": 0}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "static int avrcp_target_server_probe(struct btd_profile *p,\n\t\t\t\t\t\tstruct btd_adapter *adapter)\n{\n\tsdp_record_t *record;\n\tstruct avrcp_server *server;\n\tDBG(\"path %s\", adapter_get_path(adapter));\n\tserver = find_server(servers, adapter);\n\tif (server != NULL)\n\t\tgoto done;\n\tserver = avrcp_server_register(adapter);\n\tif (server == NULL)\n\t\treturn -EPROTONOSUPPORT;\ndone:\n\trecord = avrcp_tg_record();\n\tif (!record) {\n\t\terror(\"Unable to allocate new service record\");\n\t\tavrcp_target_server_remove(p, adapter);\n\t\treturn -1;\n\t}\n\tif (adapter_service_add(adapter, record) < 0) {\n\t\terror(\"Unable to register AVRCP target service record\");\n\t\tavrcp_target_server_remove(p, adapter);\n\t\tsdp_record_free(record);\n\t\treturn -1;\n\t}\n\tserver->tg_record_id = record->handle;\n\treturn 0;\n}", "target": 0}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "ExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif \n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\tSoapError(h, 401, \"Invalid Action\");\n}", "target": 0}
{"code": "static void write_response(ESPState *s)\n{\n    uint32_t n;\n    trace_esp_write_response(s->status);\n    fifo8_reset(&s->fifo);\n    esp_fifo_push(s, s->status);\n    esp_fifo_push(s, 0);\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque,\n                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        s->ti_size = 2;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "vhost_user_set_owner(struct virtio_net **pdev __rte_unused,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": " void ahci_uninit(AHCIState *s)\n {\n     g_free(s->dev);\n }", "target": 1}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    FileContainerFree(s->files_ts);\n    FileContainerFree(s->files_tc);\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "void ogs_nas_5gs_mobile_identity_guti_to_nas_guti(\n        ogs_nas_5gs_mobile_identity_guti_t *mobile_identity_guti,\n        ogs_nas_5gs_guti_t *nas_guti)\n{\n    ogs_assert(mobile_identity_guti);\n    ogs_assert(nas_guti);\n    memset(nas_guti, 0, sizeof(*nas_guti));\n    memcpy(&nas_guti->nas_plmn_id,\n            &mobile_identity_guti->nas_plmn_id, OGS_PLMN_ID_LEN);\n    memcpy(&nas_guti->amf_id,\n            &mobile_identity_guti->amf_id, sizeof(ogs_amf_id_t));\n    nas_guti->m_tmsi = be32toh(mobile_identity_guti->m_tmsi);\n}", "target": 0}
{"code": "sg_finish_rem_req(Sg_request *srp)\n{\n\tint ret = 0;\n\tSg_fd *sfp = srp->parentfp;\n\tSg_scatter_hold *req_schp = &srp->data;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_finish_rem_req: res_used=%d\\n\",\n\t\t\t\t      (int) srp->res_used));\n\tif (srp->bio)\n\t\tret = blk_rq_unmap_user(srp->bio);\n\tif (srp->rq) {\n\t\tscsi_req_free_cmd(scsi_req(srp->rq));\n\t\tblk_put_request(srp->rq);\n\t}\n\tif (srp->res_used)\n\t\tsg_unlink_reserve(sfp, srp);\n\telse\n\t\tsg_remove_scat(sfp, req_schp);\n\treturn ret;\n}", "target": 0}
{"code": "    template<typename t, typename to>\n    static float __draw_object3d(const CImgList<t>& opacities, const unsigned int n_primitive, CImg<to>& opacity) {\n      if (n_primitive>=opacities._width || opacities[n_primitive].is_empty()) { opacity.assign(); return 1; }\n      if (opacities[n_primitive].size()==1) { opacity.assign(); return opacities(n_primitive,0); }\n      opacity.assign(opacities[n_primitive],true);\n      return 1.0f;", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n \t\tnode = blk->bp->b_addr;\n \t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n \t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n \t\t\tbreak;\n \t\tblk->hashval = lasthash;\n \t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n    return schema.detach();\n  }", "target": 1}
{"code": "static int __init setup_slub_debug(char *str)\n{\n\tslub_debug = DEBUG_DEFAULT_FLAGS;\n\tif (*str++ != '=' || !*str)\n\t\tgoto out;\n\tif (*str == ',')\n\t\tgoto check_slabs;\n\tslub_debug = 0;\n\tif (*str == '-')\n\t\tgoto out;\n\tfor (; *str && *str != ','; str++) {\n\t\tswitch (tolower(*str)) {\n\t\tcase 'f':\n\t\t\tslub_debug |= SLAB_CONSISTENCY_CHECKS;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tslub_debug |= SLAB_RED_ZONE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tslub_debug |= SLAB_POISON;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tslub_debug |= SLAB_STORE_USER;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tslub_debug |= SLAB_TRACE;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tslub_debug |= SLAB_FAILSLAB;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdisable_higher_order_debug = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"slub_debug option '%c' unknown. skipped\\n\",\n\t\t\t       *str);\n\t\t}\n\t}\ncheck_slabs:\n\tif (*str == ',')\n\t\tslub_debug_slabs = str + 1;\nout:\n\tif ((static_branch_unlikely(&init_on_alloc) ||\n\t     static_branch_unlikely(&init_on_free)) &&\n\t    (slub_debug & SLAB_POISON))\n\t\tpr_info(\"mem auto-init: SLAB_POISON will take precedence over init_on_alloc/init_on_free\\n\");\n\treturn 1;\n}", "target": 0}
{"code": "rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)\n{\n  rfbProtocolVersionMsg pv;\n  int major,minor;\n  char tmphost[250];\n  int tmphostlen;\n#ifdef LIBVNCSERVER_IPv6\n  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);\n  if (client->sock == -1)\n#endif\n  {\n    unsigned int host;\n    if (!StringToIPAddr(repeaterHost, &host)) {\n      rfbClientLog(\"Couldn't convert '%s' to host address\\n\", repeaterHost);\n      return FALSE;\n    }\n    client->sock = ConnectClientToTcpAddr(host, repeaterPort);\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC repeater\\n\");\n    return FALSE;\n  }\n  if (!SetNonBlocking(client->sock))\n    return FALSE;\n  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))\n    return FALSE;\n  pv[sz_rfbProtocolVersionMsg] = 0;\n  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {\n    rfbClientLog(\"Not a valid VNC repeater (%s)\\n\",pv);\n    return FALSE;\n  }\n  rfbClientLog(\"Connected to VNC repeater, using protocol version %d.%d\\n\", major, minor);\n  tmphostlen = snprintf(tmphost, sizeof(tmphost), \"%s:%d\", destHost, destPort);\n  if(tmphostlen < 0 || tmphostlen >= (int)sizeof(tmphost))\n    return FALSE; \n  if (!WriteToRFBServer(client, tmphost, tmphostlen + 1))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "LogFilePrep(const char *fname, const char *backup, const char *idstring)\n{\n    char *logFileName = NULL;\n    if (asprintf(&logFileName, fname, idstring) == -1)\n        FatalError(\"Cannot allocate space for the log file name\\n\");\n    if (backup && *backup) {\n        struct stat buf;\n        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {\n            char *suffix;\n            char *oldLog;\n            if ((asprintf(&suffix, backup, idstring) == -1) ||\n                (asprintf(&oldLog, \"%s%s\", logFileName, suffix) == -1)) {\n                FatalError(\"Cannot allocate space for the log file name\\n\");\n            }\n            free(suffix);\n            if (rename(logFileName, oldLog) == -1) {\n                FatalError(\"Cannot move old log file \\\"%s\\\" to \\\"%s\\\"\\n\",\n                           logFileName, oldLog);\n            }\n            free(oldLog);\n        }\n    }\n    else {\n        if (remove(logFileName) != 0 && errno != ENOENT) {\n            FatalError(\"Cannot remove old log file \\\"%s\\\": %s\\n\",\n                       logFileName, strerror(errno));\n        }\n    }\n    return logFileName;\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_private_key_usage_period(const gnutls_datum_t * ext,\n\t\t\t\t\t\t time_t * activation,\n\t\t\t\t\t\t time_t * expiration)\n{\n\tint result, ret;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tresult = asn1_create_element\n\t    (_gnutls_get_pkix(), \"PKIX1.PrivateKeyUsagePeriod\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (activation)\n\t\t*activation = _gnutls_x509_get_time(c2, \"notBefore\", 1);\n\tif (expiration)\n\t\t*expiration = _gnutls_x509_get_time(c2, \"notAfter\", 1);\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n \t\treturn -ENOSYS;\n \tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n \t\t\treturn -EINVAL;\n \t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tfree_vpid(vmx->nested.vpid02);\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tif (vmx->nested.pi_desc_page) {\n\t\tkunmap(vmx->nested.pi_desc_page);\n\t\tnested_release_page(vmx->nested.pi_desc_page);\n\t\tvmx->nested.pi_desc_page = NULL;\n\t\tvmx->nested.pi_desc = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static void nvme_select_iocs(NvmeCtrl *n)\n{\n    NvmeNamespace *ns;\n    int i;\n    for (i = 1; i <= NVME_MAX_NAMESPACES; i++) {\n        ns = nvme_ns(n, i);\n        if (!ns) {\n            continue;\n        }\n        nvme_select_iocs_ns(n, ns);\n    }\n}", "target": 0}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "GF_Err gf_filter_add_event_listener(GF_Filter *filter, GF_FSEventListener *el)\n{\n\tGF_Err e;\n\tif (!filter || !filter->session || !el || !el->on_event) return GF_BAD_PARAM;\n\twhile (filter->session->in_event_listener) gf_sleep(1);\n\tgf_mx_p(filter->session->evt_mx);\n\tif (!filter->session->event_listeners) {\n\t\tfilter->session->event_listeners = gf_list_new();\n\t}\n\te = gf_list_add(filter->session->event_listeners, el);\n\tgf_mx_v(filter->session->evt_mx);\n\treturn e;\n}", "target": 0}
{"code": "free_tabpage(tabpage_T *tp)\n{\n    int idx;\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_TEXT_PROP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n    vim_free(tp->tp_localdir);\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n    vim_free(tp);\n}", "target": 0}
{"code": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushboolean(J, 0);\n}", "target": 1}
{"code": "void InstanceKlass::check_prohibited_package(Symbol* class_name,\n                                             ClassLoaderData* loader_data,\n                                             TRAPS) {\n  if (!loader_data->is_boot_class_loader_data() &&\n      !loader_data->is_platform_class_loader_data() &&\n      class_name != NULL && class_name->utf8_length() >= 5) {\n    ResourceMark rm(THREAD);\n    bool prohibited;\n    const u1* base = class_name->base();\n    if ((base[0] | base[1] | base[2] | base[3] | base[4]) & 0x80) {\n      prohibited = is_prohibited_package_slow(class_name);\n    } else {\n      char* name = class_name->as_C_string();\n      prohibited = (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '/');\n    }\n    if (prohibited) {\n      TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n      assert(pkg_name != NULL, \"Error in parsing package name starting with 'java/'\");\n      char* name = pkg_name->as_C_string();\n      const char* class_loader_name = loader_data->loader_name_and_id();\n      StringUtils::replace_no_expand(name, \"/\", \".\");\n      const char* msg_text1 = \"Class loader (instance of): \";\n      const char* msg_text2 = \" tried to load prohibited package name: \";\n      size_t len = strlen(msg_text1) + strlen(class_loader_name) + strlen(msg_text2) + strlen(name) + 1;\n      char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);\n      jio_snprintf(message, len, \"%s%s%s%s\", msg_text1, class_loader_name, msg_text2, name);\n      THROW_MSG(vmSymbols::java_lang_SecurityException(), message);\n    }\n  }\n  return;\n}", "target": 0}
{"code": "void CallInfo::print() {\n  ResourceMark rm;\n  const char* kindstr;\n  switch (_call_kind) {\n  case direct_call: kindstr = \"direct\";  break;\n  case vtable_call: kindstr = \"vtable\";  break;\n  case itable_call: kindstr = \"itable\";  break;\n  default         : kindstr = \"unknown\"; break;\n  }\n  tty->print_cr(\"Call %s@%d %s\", kindstr, _call_index,\n                _resolved_method.is_null() ? \"(none)\" : _resolved_method->name_and_sig_as_C_string());\n}", "target": 0}
{"code": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   const struct iovec *payload_iov,\n\t\t\t\t   unsigned ioc,\n\t\t\t\t   size_t plen,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tvoid *payload;\n\tlong ret;\n\tbool vm = false;\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\trka = instkey->payload.data;\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (payload_iov) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tvm = true;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\t\tret = copy_from_user_iovec(payload, payload_iov, ioc);\n\t\tif (ret < 0)\n\t\t\tgoto error2;\n\t}\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\tkey_put(dest_keyring);\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\nerror2:\n\tif (!vm)\n\t\tkfree(payload);\n\telse\n\t\tvfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static CURLcode transfer_per_config(struct GlobalConfig *global,\n                                    struct OperationConfig *config,\n                                    CURLSH *share,\n                                    bool *added)\n{\n  CURLcode result = CURLE_OK;\n  bool capath_from_env;\n  *added = FALSE;\n  if(!config->url_list || !config->url_list->url) {\n    helpf(global->errors, \"no URL specified!\\n\");\n    return CURLE_FAILED_INIT;\n  }\n  capath_from_env = false;\n  if(!config->cacert &&\n     !config->capath &&\n     (!config->insecure_ok || (config->doh_url && !config->doh_insecure_ok))) {\n    CURL *curltls = curl_easy_init();\n    struct curl_tlssessioninfo *tls_backend_info = NULL;\n    result = curl_easy_getinfo(curltls, CURLINFO_TLS_SSL_PTR,\n                               &tls_backend_info);\n    if(result)\n      return result;\n    if(tls_backend_info->backend != CURLSSLBACKEND_SCHANNEL) {\n      char *env;\n      env = curlx_getenv(\"CURL_CA_BUNDLE\");\n      if(env) {\n        config->cacert = strdup(env);\n        if(!config->cacert) {\n          curl_free(env);\n          errorf(global, \"out of memory\\n\");\n          return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else {\n        env = curlx_getenv(\"SSL_CERT_DIR\");\n        if(env) {\n          config->capath = strdup(env);\n          if(!config->capath) {\n            curl_free(env);\n            helpf(global->errors, \"out of memory\\n\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n          capath_from_env = true;\n        }\n        else {\n          env = curlx_getenv(\"SSL_CERT_FILE\");\n          if(env) {\n            config->cacert = strdup(env);\n            if(!config->cacert) {\n              curl_free(env);\n              errorf(global, \"out of memory\\n\");\n              return CURLE_OUT_OF_MEMORY;\n            }\n          }\n        }\n      }\n      if(env)\n        curl_free(env);\n#ifdef WIN32\n      else {\n        result = FindWin32CACert(config, tls_backend_info->backend,\n                                 TEXT(\"curl-ca-bundle.crt\"));\n      }\n#endif\n    }\n    curl_easy_cleanup(curltls);\n  }\n  if(!result)\n    result = single_transfer(global, config, share, capath_from_env, added);\n  return result;\n}", "target": 0}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n     }\n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n    }\n    while (len >= 4) {\n         DOBIG4;\n         len -= 4;\n     }\n    buf4++;\n     buf = (const unsigned char FAR *)buf4;\n     if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": " ZEND_METHOD(CURLFile, __wakeup)\n {\n       zend_update_property_string(curl_CURLFile_class, getThis(), \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n        zend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n }", "target": 1}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "TEST_P(RBACIntegrationTest, DeniedWithPrefixRule) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) { cfg.mutable_normalize_path()->set_value(false); });\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PREFIX_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/foo/../bar\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "static void containerKeysIntersectHelper(const req::ptr<c_Set>& st,\n                                         TypedValue* containers,\n                                         int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  bool isKey = isArrayType(containers[0].m_type);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, !isKey);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    isKey = isArrayType(containers[pos].m_type);\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      updateIntersectMapHelper(mp, c, pos, strTv, !isKey);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}", "target": 0}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "static int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}", "target": 0}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n \tgpio_dev = platform_get_drvdata(pdev);\n \tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n \treturn 0;\n }", "target": 1}
{"code": "make_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n  ns[1] = absent;\n  ns[3] = step_one; \n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n  if (possessive != 0) {\n    x = node_new_enclosure(ENCLOSURE_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n  ns[1] = x; ns[2] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, NST_SUPER);\n  *node = x;\n  return ONIG_NORMAL;\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}", "target": 0}
{"code": "void LightProcess::runShadow(int fdin, int fdout) {\n  FILE *fin = fdopen(fdin, \"r\");\n  FILE *fout = fdopen(fdout, \"w\");\n  char buf[BUFFER_SIZE];\n  pollfd pfd[1];\n  pfd[0].fd = fdin;\n  pfd[0].events = POLLIN;\n  while (true) {\n    int ret = poll(pfd, 1, -1);\n    if (ret < 0 && errno == EINTR) {\n      continue;\n    }\n    if (pfd[0].revents & POLLIN) {\n      if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n      if (strncmp(buf, \"exit\", 4) == 0) {\n        Logger::Info(\"LightProcess exiting upon request\");\n        break;\n      } else if (strncmp(buf, \"popen\", 5) == 0) {\n        do_popen(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"pclose\", 6) == 0) {\n        do_pclose(fin, fout);\n      } else if (strncmp(buf, \"proc_open\", 9) == 0) {\n        do_proc_open(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"waitpid\", 7) == 0) {\n        do_waitpid(fin, fout);\n      } else if (strncmp(buf, \"change_user\", 11) == 0) {\n        do_change_user(fin, fout);\n      } else if (buf[0]) {\n        Logger::Info(\"LightProcess got invalid command: %.20s\", buf);\n      }\n    } else if (pfd[0].revents & POLLHUP) {\n      Logger::Error(\"Lost parent, LightProcess exiting\");\n      break;\n    }\n  }\n  fclose(fin);\n  fclose(fout);\n  ::close(m_afdt_fd);\n  remove(m_afdtFilename.c_str());\n  _Exit(0);\n}", "target": 1}
{"code": "int ssh_scp_accept_request(ssh_scp scp)\n{\n    char buffer[] = {0x00};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_READ_REQUESTED) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_deny_request called under invalid state\");\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_write(scp->channel, buffer, 1);\n    if (rc == SSH_ERROR) {\n        return SSH_ERROR;\n    }\n    if (scp->request_type == SSH_SCP_REQUEST_NEWFILE) {\n        scp->state = SSH_SCP_READ_READING;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 0}
{"code": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    ncq_tfs->used = 0;\n }", "target": 0}
{"code": "static mp_obj_t int_to_bytes(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    mp_int_t len = mp_obj_get_int(args[1]);\n    if (len < 0) {\n        mp_raise_ValueError(NULL);\n    }\n    bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    byte *data = (byte *)vstr.buf;\n    memset(data, 0, len);\n    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n    if (!mp_obj_is_small_int(args[0])) {\n        mp_obj_int_to_bytes_impl(args[0], big_endian, len, data);\n    } else\n    #endif\n    {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        size_t l = MIN((size_t)len, sizeof(val));\n        mp_binary_set_int(l, big_endian, data + (big_endian ? (len - l) : 0), val);\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}", "target": 1}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 1}
{"code": "  InstanceFeatureDimKey(const int32_t instance, const int32_t feature_dim)\n      : instance(instance), feature_dim(feature_dim) {}", "target": 0}
{"code": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);\n        result->alias.size = size;\n        if (size == 0)\n        {\n            result->alias.buffer = NULL;\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)(result + 1);\n            (void)memcpy(temp, source, size);\n            result->alias.buffer = temp;\n        }\n        result->buffer_type = CONSTBUFFER_TYPE_COPIED;\n    }\n    return result;\n}", "target": 1}
{"code": "static int decode_attr_maxname(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *maxname)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*maxname = 1024;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_MAXNAME - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_MAXNAME)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\t*maxname = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_MAXNAME;\n\t}\n\tdprintk(\"%s: maxname=%u\\n\", __func__, *maxname);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "writeDataError(instanceData *pData, cJSON **pReplyRoot, uchar *reqmsg)\n{\n\tchar *rendered = NULL;\n\tcJSON *errRoot;\n\tcJSON *req;\n\tcJSON *replyRoot = *pReplyRoot;\n\tsize_t toWrite;\n\tssize_t wrRet;\n\tchar errStr[1024];\n\tDEFiRet;\n\tif(pData->errorFile == NULL) {\n\t\tDBGPRINTF(\"omelasticsearch: no local error logger defined - \"\n\t\t          \"ignoring ES error information\\n\");\n\t\tFINALIZE;\n\t}\n\tif(pData->fdErrFile == -1) {\n\t\tpData->fdErrFile = open((char*)pData->errorFile,\n\t\t\t\t\tO_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,\n\t\t\t\t\tS_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);\n\t\tif(pData->fdErrFile == -1) {\n\t\t\trs_strerror_r(errno, errStr, sizeof(errStr));\n\t\t\tDBGPRINTF(\"omelasticsearch: error opening error file: %s\\n\", errStr);\n\t\t\tABORT_FINALIZE(RS_RET_ERR);\n\t\t}\n\t}\n\tif((req=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(req, \"url\", cJSON_CreateString((char*)pData->restURL));\n\tcJSON_AddItemToObject(req, \"postdata\", cJSON_CreateString((char*)reqmsg));\n\tif((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(errRoot, \"request\", req);\n\tcJSON_AddItemToObject(errRoot, \"reply\", replyRoot);\n\trendered = cJSON_Print(errRoot);\n\tDBGPRINTF(\"omelasticsearch: error record: '%s'\\n\", rendered);\n\ttoWrite = strlen(rendered);\n\twrRet = write(pData->fdErrFile, rendered, toWrite);\n\tif(wrRet != (ssize_t) toWrite) {\n\t\tDBGPRINTF(\"omelasticsearch: error %d writing error file, write returns %lld\\n\",\n\t\t\t  errno, (long long) wrRet);\n\t}\n\tfree(rendered);\n\tcJSON_Delete(errRoot);\n\t*pReplyRoot = NULL; \nfinalize_it:\n\tif(rendered != NULL)\n\t\tfree(rendered);\n\tRETiRet;\n}", "target": 1}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n \tif (skb->ip_summed != CHECKSUM_COMPLETE)\n \t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n \tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n }", "target": 1}
{"code": "    void CrwMap::decodeArray(const CiffComponent& ciffComponent,\n                             const CrwMapping*    pCrwMapping,\n                                   Image&         image,\n                                   ByteOrder      byteOrder)\n    {\n        if (ciffComponent.typeId() != unsignedShort) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n        long aperture = 0;\n        long shutterSpeed = 0;\n        IfdId ifdId = ifdIdNotSet;\n        switch (pCrwMapping->tag_) {\n        case 0x0001: ifdId = canonCsId; break;\n        case 0x0004: ifdId = canonSiId; break;\n        case 0x000f: ifdId = canonCfId; break;\n        case 0x0012: ifdId = canonPiId; break;\n        }\n        assert(ifdId != ifdIdNotSet);\n        std::string groupName(Internal::groupName(ifdId));\n        uint16_t c = 1;\n        while (uint32_t(c)*2 < ciffComponent.size()) {\n            uint16_t n = 1;\n            ExifKey key(c, groupName);\n            UShortValue value;\n            if (ifdId == canonCsId && c == 23 && ciffComponent.size() > 50) n = 3;\n            value.read(ciffComponent.pData() + c*2, n*2, byteOrder);\n            image.exifData().add(key, &value);\n            if (ifdId == canonSiId && c == 21) aperture = value.toLong();\n            if (ifdId == canonSiId && c == 22) shutterSpeed = value.toLong();\n            c += n;\n        }\n        if (ifdId == canonSiId) {\n            float f = fnumber(canonEv(aperture));\n            Rational r = floatToRationalCast(f);\n            URational ur(r.first, r.second);\n            URationalValue fn;\n            fn.value_.push_back(ur);\n            image.exifData().add(ExifKey(\"Exif.Photo.FNumber\"), &fn);\n            ur = exposureTime(canonEv(shutterSpeed));\n            URationalValue et;\n            et.value_.push_back(ur);\n            image.exifData().add(ExifKey(\"Exif.Photo.ExposureTime\"), &et);\n        }\n    } ", "target": 0}
{"code": "static void register_page_bootmem_info_section(unsigned long start_pfn)\n{\n\tunsigned long *usemap, mapsize, section_nr, i;\n\tstruct mem_section *ms;\n\tstruct page *page, *memmap;\n\tif (!pfn_valid(start_pfn))\n\t\treturn;\n\tsection_nr = pfn_to_section_nr(start_pfn);\n\tms = __nr_to_section(section_nr);\n\tmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\n\tpage = virt_to_page(memmap);\n\tmapsize = sizeof(struct page) * PAGES_PER_SECTION;\n\tmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, SECTION_INFO);\n\tusemap = __nr_to_section(section_nr)->pageblock_flags;\n\tpage = virt_to_page(usemap);\n\tmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\n\tfor (i = 0; i < mapsize; i++, page++)\n\t\tget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\n}", "target": 0}
{"code": "void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif \n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}", "target": 1}
{"code": "prefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\treturn 0;\n}", "target": 0}
{"code": "static void flush_dpb(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n    for (i = 0; i <= MAX_DELAYED_PIC_COUNT; i++) {\n        if (h->delayed_pic[i])\n            h->delayed_pic[i]->reference = 0;\n        h->delayed_pic[i] = NULL;\n    }\n    flush_change(h);\n    if (h->DPB)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n    h->cur_pic_ptr = NULL;\n    unref_picture(h, &h->cur_pic);\n    h->mb_x = h->mb_y = 0;\n    h->parse_context.state             = -1;\n    h->parse_context.frame_start_found = 0;\n    h->parse_context.overread          = 0;\n    h->parse_context.overread_index    = 0;\n    h->parse_context.index             = 0;\n    h->parse_context.last_index        = 0;\n    free_tables(h, 1);\n    h->context_initialized = 0;\n}", "target": 0}
{"code": "ModuleExport size_t RegisterWMFImage(void)\n{\n  MagickInfo\n    *entry;\n  entry = AcquireMagickInfo(\"WMF\",\"WMZ\",\"Compressed Windows Meta File\");\n#if defined(MAGICKCORE_SANS_DELEGATE) || defined(MAGICKCORE_WMF_DELEGATE)\n  entry->decoder=ReadWMFImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"WMF\",\"WMF\",\"Windows Meta File\");\n#if defined(MAGICKCORE_SANS_DELEGATE) || defined(MAGICKCORE_WMF_DELEGATE)\n  entry->decoder=ReadWMFImage;\n#endif\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "extractDirName(const StaticString &path) {\n\tchar *path_copy = strdup(path.c_str());\n\tchar *result = dirname(path_copy);\n\tstring result_string(result);\n\tfree(path_copy);\n\treturn result_string;\n}", "target": 0}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static inline vm_fault_t hugetlb_handle_userfault(struct vm_area_struct *vma,\n\t\t\t\t\t\t  struct address_space *mapping,\n\t\t\t\t\t\t  pgoff_t idx,\n\t\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t\t  unsigned long haddr,\n\t\t\t\t\t\t  unsigned long reason)\n{\n\tvm_fault_t ret;\n\tu32 hash;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = haddr,\n\t\t.flags = flags,\n\t};\n\thash = hugetlb_fault_mutex_hash(mapping, idx);\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\ti_mmap_unlock_read(mapping);\n\tret = handle_userfault(&vmf, reason);\n\ti_mmap_lock_read(mapping);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\treturn ret;\n}", "target": 0}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "    bool wc2mb(UINT cp, std::string& str)\n    {\n        if (str.empty())\n            return true;\n        if (str.size() & 1) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Size \" << str.size() << \" of input string is not even.\\n\";\n#endif\n            return false;\n        }\n        int len = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, 0, 0, 0, 0);\n        if (len == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to determine required size of output buffer.\\n\";\n#endif\n            return false;\n        }\n        std::vector<std::string::value_type> out;\n        out.reserve(len);\n        int ret = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, (LPSTR)out.data(), len, 0, 0);\n        if (ret == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to convert the input string to a multi byte string.\\n\";\n#endif\n            return false;\n        }\n        str.assign(out.data(), static_cast<size_t>(len));\n        return true;\n    }", "target": 0}
{"code": "std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}", "target": 1}
{"code": "static long vhost_net_reset_owner(struct vhost_net *n)\n{\n\tstruct socket *tx_sock = NULL;\n\tstruct socket *rx_sock = NULL;\n\tlong err;\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\terr = vhost_dev_reset_owner(&n->dev);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\treturn err;\n}", "target": 0}
{"code": "static void selinux_task_to_inode(struct task_struct *p,\n\t\t\t\t  struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = task_sid(p);\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}", "target": 0}
{"code": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n    explicit_bzero(des_pass, sizeof(des_pass));\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}", "target": 1}
{"code": "    void CiffComponent::doPrint(std::ostream&      os,\n                                ByteOrder          byteOrder,\n                                const std::string& prefix) const\n    {\n        os << prefix\n           << _(\"tag\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << tagId()\n           << \", \" << _(\"dir\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << dir()\n           << \", \" << _(\"type\") << \" = \" << TypeInfo::typeName(typeId())\n           << \", \" << _(\"size\") << \" = \" << std::dec << size_\n           << \", \" << _(\"offset\") << \" = \" << offset_ << \"\\n\";\n        Value::UniquePtr value;\n        if (typeId() != directory) {\n            value = Value::create(typeId());\n            value->read(pData_, size_, byteOrder);\n            if (value->size() < 100) {\n                os << prefix << *value << \"\\n\";\n            }\n        }\n    } ", "target": 0}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n \t\treturn;\n \ttimer = &pit->pit_state.timer;\n \tif (hrtimer_cancel(timer))\n \t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n }", "target": 1}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "        Header readHeader(BasicIo& io)\n        {\n            byte header[2];\n            io.read(header, 2);\n            ByteOrder byteOrder = invalidByteOrder;\n            if (header[0] == 'I' && header[1] == 'I')\n                byteOrder = littleEndian;\n            else if (header[0] == 'M' && header[1] == 'M')\n                byteOrder = bigEndian;\n            if (byteOrder == invalidByteOrder)\n                return Header();\n            byte version[2];\n            io.read(version, 2);\n            const uint16_t magic = getUShort(version, byteOrder);\n            if (magic != 0x2A && magic != 0x2B)\n                return Header();\n            Header result;\n            if (magic == 0x2A)\n            {\n                byte buffer[4];\n                io.read(buffer, 4);\n                const uint32_t offset = getULong(buffer, byteOrder);\n                result = Header(byteOrder, magic, 4, offset);\n            }\n            else\n            {\n                byte buffer[8];\n                io.read(buffer, 2);\n                const int size = getUShort(buffer, byteOrder);\n                assert(size == 8);\n                io.read(buffer, 2); \n                io.read(buffer, 8);\n                const uint64_t offset = getULongLong(buffer, byteOrder);\n                result = Header(byteOrder, magic, size, offset);\n            }\n            return result;\n        }", "target": 1}
{"code": "onig_scan(regex_t* reg, const UChar* str, const UChar* end,\n\t  OnigRegion* region, OnigOptionType option,\n\t  int (*scan_callback)(OnigPosition, OnigPosition, OnigRegion*, void*),\n\t  void* callback_arg)\n{\n  OnigPosition r;\n  OnigPosition n;\n  int rs;\n  const UChar* start;\n  n = 0;\n  start = str;\n  while (1) {\n    r = onig_search(reg, str, end, start, end, region, option);\n    if (r >= 0) {\n      rs = scan_callback(n, r, region, callback_arg);\n      n++;\n      if (rs != 0)\n\treturn rs;\n      if (region->end[0] == start - str)\n\tstart++;\n      else\n\tstart = str + region->end[0];\n      if (start > end)\n\tbreak;\n    }\n    else if (r == ONIG_MISMATCH) {\n      break;\n    }\n    else { \n      return r;\n    }\n  }\n  return n;\n}", "target": 0}
{"code": "static int vhost_vdpa_map(struct vhost_vdpa *v, u64 iova,\n\t\t\t  u64 size, u64 pa, u32 perm, void *opaque)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tint r = 0;\n\tr = vhost_iotlb_add_range_ctx(dev->iotlb, iova, iova + size - 1,\n\t\t\t\t      pa, perm, opaque);\n\tif (r)\n\t\treturn r;\n\tif (ops->dma_map) {\n\t\tr = ops->dma_map(vdpa, iova, size, pa, perm, opaque);\n\t} else if (ops->set_map) {\n\t\tif (!v->in_batch)\n\t\t\tr = ops->set_map(vdpa, dev->iotlb);\n\t} else {\n\t\tr = iommu_map(v->domain, iova, pa, size,\n\t\t\t      perm_to_iommu_flags(perm));\n\t}\n\tif (r) {\n\t\tvhost_iotlb_del_range(dev->iotlb, iova, iova + size - 1);\n\t\treturn r;\n\t}\n\tif (!vdpa->use_va)\n\t\tatomic64_add(PFN_DOWN(size), &dev->mm->pinned_vm);\n\treturn 0;\n}", "target": 0}
{"code": "router_append_dirobj_signature(char *buf, size_t buf_len, const char *digest,\n                               size_t digest_len, crypto_pk_t *private_key)\n{\n  size_t sig_len, s_len;\n  char *sig = router_get_dirobj_signature(digest, digest_len, private_key);\n  if (!sig) {\n    log_warn(LD_BUG, \"No signature generated\");\n    return -1;\n  }\n  sig_len = strlen(sig);\n  s_len = strlen(buf);\n  if (sig_len + s_len + 1 > buf_len) {\n    log_warn(LD_BUG, \"Not enough room for signature\");\n    tor_free(sig);\n    return -1;\n  }\n  memcpy(buf+s_len, sig, sig_len+1);\n  return 0;\n}", "target": 0}
{"code": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\tfree_pages -= (1 << order) - 1;\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n#ifdef CONFIG_CMA\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\tif (!order)\n\t\treturn true;\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static void nvme_format_bh(void *opaque)\n{\n    NvmeFormatAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    uint32_t dw10 = le32_to_cpu(req->cmd.cdw10);\n    uint8_t lbaf = dw10 & 0xf;\n    uint8_t pi = (dw10 >> 5) & 0x7;\n    uint16_t status;\n    int i;\n    if (iocb->ret < 0) {\n        goto done;\n    }\n    if (iocb->broadcast) {\n        for (i = iocb->nsid + 1; i <= NVME_MAX_NAMESPACES; i++) {\n            iocb->ns = nvme_ns(n, i);\n            if (iocb->ns) {\n                iocb->nsid = i;\n                break;\n            }\n        }\n    }\n    if (!iocb->ns) {\n        goto done;\n    }\n    status = nvme_format_check(iocb->ns, lbaf, pi);\n    if (status) {\n        req->status = status;\n        goto done;\n    }\n    iocb->ns->status = NVME_FORMAT_IN_PROGRESS;\n    nvme_format_ns_cb(iocb, 0);\n    return;\ndone:\n    qemu_bh_delete(iocb->bh);\n    iocb->bh = NULL;\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n    qemu_aio_unref(iocb);\n}", "target": 0}
{"code": "parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(work, rndr, data + i, end - i);\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\treturn skip;\n}", "target": 0}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<Tfloat> get_blur_guided(const CImg<t>& guide, const float radius, const float regularization) const {\n      if (!is_sameXYZ(guide))\n        throw CImgArgumentException(_cimg_instance\n                                    \"blur_guided(): Invalid size for specified guide image (%u,%u,%u,%u,%p).\",\n                                    cimg_instance,\n                                    guide._width,guide._height,guide._depth,guide._spectrum,guide._data);\n      if (is_empty() || !radius) return *this;\n      const int _radius = radius>=0?(int)radius:(int)(-radius*cimg::max(_width,_height,_depth)/100);\n      float _regularization = regularization;\n      if (regularization<0) {\n        T edge_min, edge_max = guide.max_min(edge_min);\n        if (edge_min==edge_max) return *this;\n        _regularization = -regularization*(edge_max - edge_min)/100;\n      }\n      _regularization = std::max(_regularization,0.01f);\n      const unsigned int psize = (unsigned int)(1 + 2*_radius);\n      const CImg<uintT> N = CImg<uintT>(_width,_height,_depth,1,1)._blur_guided(psize);\n      CImg<Tfloat>\n        mean_I = CImg<Tfloat>(guide,false)._blur_guided(psize).div(N),\n        mean_p = CImg<Tfloat>(*this,false)._blur_guided(psize).div(N),\n        cov_Ip = CImg<Tfloat>(*this,false).mul(guide)._blur_guided(psize).div(N)-=mean_p.get_mul(mean_I),\n        var_I = CImg<Tfloat>(guide,false).sqr()._blur_guided(psize).div(N)-=mean_I.get_sqr(),\n        &a = cov_Ip.div(var_I+=_regularization),\n        &b = mean_p-=a.get_mul(mean_I);\n      a._blur_guided(psize).div(N);\n      b._blur_guided(psize).div(N);\n      return a.mul(guide)+=b;", "target": 0}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "bool is_free_buddy_page(struct page *page)\n{\n\tstruct zone *zone = page_zone(page);\n\tunsigned long pfn = page_to_pfn(page);\n\tunsigned long flags;\n\tunsigned int order;\n\tspin_lock_irqsave(&zone->lock, flags);\n\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\tstruct page *page_head = page - (pfn & ((1 << order) - 1));\n\t\tif (PageBuddy(page_head) && page_order(page_head) >= order)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&zone->lock, flags);\n\treturn order < MAX_ORDER;\n}", "target": 0}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "static inline void CoefficientsToAffineArgs(double *coeff)\n{\n  double tmp[4];  \n  tmp[0]=coeff[3]; tmp[1]=coeff[1]; tmp[2]=coeff[4]; tmp[3]=coeff[2];\n  coeff[1]=tmp[0]; coeff[2]=tmp[1]; coeff[3]=tmp[2]; coeff[4]=tmp[3];\n}", "target": 0}
{"code": "void PDFiumEngine::GetAllScreenRectsUnion(std::vector<PDFiumRange>* rect_range,\n                                          const pp::Point& offset_point,\n                                          std::vector<pp::Rect>* rect_vector) {\n  for (auto& range : *rect_range) {\n    pp::Rect result_rect;\n    std::vector<pp::Rect> rects =\n        range.GetScreenRects(offset_point, current_zoom_, current_rotation_);\n    for (const auto& rect : rects)\n      result_rect = result_rect.Union(rect);\n    rect_vector->push_back(result_rect);\n  }\n}", "target": 0}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "target": 1}
{"code": "static int create_autodetect_quirk(struct snd_usb_audio *chip,\n\t\t\t\t   struct usb_interface *iface,\n\t\t\t\t   struct usb_driver *driver)\n{\n\tint err;\n\terr = create_auto_pcm_quirk(chip, iface, driver);\n\tif (err == -ENODEV)\n\t\terr = create_auto_midi_quirk(chip, iface, driver);\n\treturn err;\n}", "target": 0}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n \t}\n \thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n \tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 1}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\tstatus = valid_csum(rom_desc, buffer);\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}", "target": 0}
{"code": "static inline int get_b_cbp(MpegEncContext *s, int16_t block[6][64],\n                            int motion_x, int motion_y, int mb_type)\n{\n    int cbp = 0, i;\n    if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n        int score        = 0;\n        const int lambda = s->lambda2 >> (FF_LAMBDA_SHIFT - 6);\n        for (i = 0; i < 6; i++) {\n            if (s->coded_score[i] < 0) {\n                score += s->coded_score[i];\n                cbp   |= 1 << (5 - i);\n            }\n        }\n        if (cbp) {\n            int zero_score = -6;\n            if ((motion_x | motion_y | s->dquant | mb_type) == 0)\n                zero_score -= 4;  \n            zero_score *= lambda;\n            if (zero_score <= score)\n                cbp = 0;\n        }\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0 && ((cbp >> (5 - i)) & 1) == 0) {\n                s->block_last_index[i] = -1;\n                s->bdsp.clear_block(s->block[i]);\n            }\n        }\n    } else {\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0)\n                cbp |= 1 << (5 - i);\n        }\n    }\n    return cbp;\n}", "target": 0}
{"code": "static void vmci_transport_peer_attach_cb(u32 sub_id,\n\t\t\t\t\t  const struct vmci_event_data *e_data,\n\t\t\t\t\t  void *client_data)\n{\n\tstruct sock *sk = client_data;\n\tconst struct vmci_event_payload_qp *e_payload;\n\tstruct vsock_sock *vsk;\n\te_payload = vmci_event_data_const_payload(e_data);\n\tvsk = vsock_sk(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tif (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,\n\t\t\t\t e_payload->handle)) {\n\t\tgoto out;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n}", "target": 0}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static noinline void __schedule_bug(struct task_struct *prev)\n{\n\tif (oops_in_progress)\n\t\treturn;\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}", "target": 0}
{"code": "get_indent_str(\n    char_u\t*ptr,\n    int\t\tts,\n    int\t\tlist) \n{\n    int\t\tcount = 0;\n    for ( ; *ptr; ++ptr)\n    {\n\tif (*ptr == TAB)\n\t{\n\t    if (!list || curwin->w_lcs_chars.tab1)\n\t\tcount += ts - (count % ts);\n\t    else\n\t\tcount += ptr2cells(ptr);\n\t}\n\telse if (*ptr == ' ')\n\t    ++count;\t\t\n\telse\n\t    break;\n    }\n    return count;\n}", "target": 0}
{"code": "Value ExpressionDateFromParts::evaluate(const Document& root, Variables* variables) const {\n    long long hour, minute, second, millisecond;\n    if (!evaluateNumberWithDefaultAndBounds(root, _hour.get(), \"hour\"_sd, 0, &hour, variables) ||\n        !evaluateNumberWithDefaultAndBounds(\n            root, _minute.get(), \"minute\"_sd, 0, &minute, variables) ||\n        !evaluateNumberWithDefault(root, _second.get(), \"second\"_sd, 0, &second, variables) ||\n        !evaluateNumberWithDefault(\n            root, _millisecond.get(), \"millisecond\"_sd, 0, &millisecond, variables)) {\n        return Value(BSONNULL);\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_year) {\n        long long year, month, day;\n        if (!evaluateNumberWithDefault(root, _year.get(), \"year\"_sd, 1970, &year, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _month.get(), \"month\"_sd, 1, &month, variables) ||\n            !evaluateNumberWithDefaultAndBounds(root, _day.get(), \"day\"_sd, 1, &day, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(40523,\n                str::stream() << \"'year' must evaluate to an integer in the range \" << 1 << \" to \"\n                              << 9999 << \", found \" << year,\n                year >= 1 && year <= 9999);\n        return Value(\n            timeZone->createFromDateParts(year, month, day, hour, minute, second, millisecond));\n    }\n    if (_isoWeekYear) {\n        long long isoWeekYear, isoWeek, isoDayOfWeek;\n        if (!evaluateNumberWithDefault(\n                root, _isoWeekYear.get(), \"isoWeekYear\"_sd, 1970, &isoWeekYear, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoWeek.get(), \"isoWeek\"_sd, 1, &isoWeek, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoDayOfWeek.get(), \"isoDayOfWeek\"_sd, 1, &isoDayOfWeek, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(31095,\n                str::stream() << \"'isoWeekYear' must evaluate to an integer in the range \" << 1\n                              << \" to \" << 9999 << \", found \" << isoWeekYear,\n                isoWeekYear >= 1 && isoWeekYear <= 9999);\n        return Value(timeZone->createFromIso8601DateParts(\n            isoWeekYear, isoWeek, isoDayOfWeek, hour, minute, second, millisecond));\n    }\n    MONGO_UNREACHABLE;\n}", "target": 0}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "xfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen = args->valuelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\ttrace_xfs_attr_rmtval_get(args);\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}", "target": 1}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "void WasmBinaryBuilder::readTableDeclarations() {\n  BYN_TRACE(\"== readTableDeclarations\\n\");\n  auto numTables = getU32LEB();\n  for (size_t i = 0; i < numTables; i++) {\n    auto elemType = getType();\n    if (!elemType.isRef()) {\n      throwError(\"Table type must be a reference type\");\n    }\n    auto table = Builder::makeTable(Name::fromInt(i), elemType);\n    bool is_shared;\n    Type indexType;\n    getResizableLimits(\n      table->initial, table->max, is_shared, indexType, Table::kUnlimitedSize);\n    if (is_shared) {\n      throwError(\"Tables may not be shared\");\n    }\n    if (indexType == Type::i64) {\n      throwError(\"Tables may not be 64-bit\");\n    }\n    tables.push_back(std::move(table));\n  }\n}", "target": 0}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,\n  uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t\n  height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tlong size;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tsize = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\treturn cmpt;\n}", "target": 1}
{"code": "static int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tif (inet_sk(sk)->inet_daddr) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t is_udplite);\n\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb(skb);\n\t\ttrace_udp_fail_queue_rcv_skb(rc, sk);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int snd_usb_novation_boot_quirk(struct usb_device *dev)\n{\n\tusb_set_interface(dev, 0, 1);\n\treturn 0;\n}", "target": 0}
{"code": "MenuCache* menu_cache_lookup( const char* menu_name )\n{\n    MenuCache* cache;\n    MENU_CACHE_LOCK;\n#if !GLIB_CHECK_VERSION(2, 32, 0)\n    if(!sync_run_mutex)\n        sync_run_mutex = g_mutex_new();\n    if(!sync_run_cond)\n        sync_run_cond = g_cond_new();\n#endif\n    if( G_UNLIKELY( ! hash ) )\n        hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL );\n    else\n    {\n        cache = (MenuCache*)g_hash_table_lookup(hash, menu_name);\n        if( cache )\n        {\n            menu_cache_ref(cache);\n            MENU_CACHE_UNLOCK;\n            return cache;\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    cache = menu_cache_create(menu_name);\n    cache->cancellable = g_cancellable_new();\n#if GLIB_CHECK_VERSION(2, 32, 0)\n    cache->thr = g_thread_new(menu_name, menu_cache_loader_thread, cache);\n#else\n    cache->thr = g_thread_create(menu_cache_loader_thread, cache, TRUE, NULL);\n#endif\n    return cache;\n}", "target": 0}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}", "target": 1}
{"code": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 1}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n \t}\n \treturn GF_OK;\n }", "target": 1}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "smb3_receive_transform(struct TCP_Server_Info *server,\n\t\t       struct mid_q_entry **mids, char **bufs, int *num_mids)\n{\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tunsigned int orig_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tif (pdu_length < sizeof(struct smb2_transform_hdr) +\n\t\t\t\t\t\tsizeof(struct smb2_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is too small (%u)\\n\",\n\t\t\t pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length < orig_len + sizeof(struct smb2_transform_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is broken\\n\");\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server)) {\n\t\treturn receive_encrypted_read(server, &mids[0], num_mids);\n\t}\n\treturn receive_encrypted_standard(server, mids, bufs, num_mids);\n}", "target": 0}
{"code": "struct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn key;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tops->get_idt(ctxt, &dt);\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->_eip = eip;\n\treturn rc;\n}", "target": 0}
{"code": "static int __init parse_acpi(char *arg)\n{\n\tif (!arg)\n\t\treturn -EINVAL;\n\tif (strcmp(arg, \"off\") == 0) {\n\t\tdisable_acpi();\n\t}\n\telse if (strcmp(arg, \"force\") == 0) {\n\t\tacpi_force = 1;\n\t\tacpi_ht = 1;\n\t\tacpi_disabled = 0;\n\t}\n\telse if (strcmp(arg, \"strict\") == 0) {\n\t\tacpi_strict = 1;\n\t}\n\telse if (strcmp(arg, \"ht\") == 0) {\n\t\tif (!acpi_force)\n\t\t\tdisable_acpi();\n\t\tacpi_ht = 1;\n\t}\n\telse if (strcmp(arg, \"noirq\") == 0) {\n\t\tacpi_noirq_set();\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& indices = ctx->input(0);\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& dense_shape = ctx->input(2);\n    const Tensor& size_t = ctx->input(3);\n    const auto weights = ctx->input(4).flat<T>();\n    const int64_t weights_size = weights.size();\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    bool is_1d = dense_shape.NumElements() == 1;\n    Tensor* out_t;\n    functor::SetZeroFunctor<Device, T> fill;\n    if (is_1d) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({size}), &out_t));\n      auto out = out_t->flat<T>();\n      fill(ctx->eigen_device<Device>(), out);\n      if (binary_output_) {\n        OP_REQUIRES_OK(ctx,\n                       functor::BincountFunctor<Device, Tidx, T, true>::Compute(\n                           ctx, values, weights, out, size));\n      } else {\n        OP_REQUIRES_OK(\n            ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(\n                     ctx, values, weights, out, size));\n      }\n    } else {\n      const auto shape = dense_shape.flat<int64_t>();\n      const int64_t num_rows = shape(0);\n      OP_REQUIRES_OK(\n          ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n      const auto out = out_t->matrix<T>();\n      fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n      const auto indices_mat = indices.matrix<int64_t>();\n      for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {\n        const int64_t batch = indices_mat(i, 0);\n        const Tidx bin = values(i);\n        if (bin < size) {\n          if (binary_output_) {\n            out(batch, bin) = T(1);\n          } else {\n            if (weights_size) {\n              out(batch, bin) += weights(i);\n            } else {\n              out(batch, bin) += T(1);\n            }\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "    ByteOrder TiffParser::decode(\n              ExifData& exifData,\n              IptcData& iptcData,\n              XmpData&  xmpData,\n        const byte*     pData,\n              uint32_t  size\n    )\n    {\n        return TiffParserWorker::decode(exifData,\n                                        iptcData,\n                                        xmpData,\n                                        pData,\n                                        size,\n                                        Tag::root,\n                                        TiffMapping::findDecoder);\n    } ", "target": 0}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "void RootWindow::OnWindowTransformed(Window* window, bool contained_mouse) {\n  if (contained_mouse ||\n      (window->IsVisible() &&\n       window->ContainsPointInRoot(last_mouse_location_))) {\n    PostMouseMoveEventAfterWindowChange();\n  }\n}", "target": 0}
{"code": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n    if (ctx->encrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n    b = ctx->cipher->block_size;\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n    OPENSSL_assert(b <= sizeof(ctx->final));\n    if (ctx->final_used) {\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n    if (fix_len)\n        *outl += b;\n    return 1;\n}", "target": 1}
{"code": "static optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n  } else if (t == TokenID::CanonicalUser) {\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}", "target": 1}
{"code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}", "target": 1}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n                      X509 **pissuer, int *pscore, unsigned int *preasons,\n                      STACK_OF(X509_CRL) *crls)\n{\n    int i, crl_score, best_score = *pscore;\n    unsigned int reasons, best_reasons = 0;\n    X509 *x = ctx->current_cert;\n    X509_CRL *crl, *best_crl = NULL;\n    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n        if (crl_score < best_score)\n             continue;\n        if (crl_score == best_score) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n                continue;\n            if (day <= 0 && sec <= 0)\n                continue;\n        }\n        best_crl = crl;\n        best_crl_issuer = crl_issuer;\n        best_score = crl_score;\n        best_reasons = reasons;\n    }\n    if (best_crl) {\n        if (*pcrl)\n            X509_CRL_free(*pcrl);\n        *pcrl = best_crl;\n        *pissuer = best_crl_issuer;\n        *pscore = best_score;\n        *preasons = best_reasons;\n        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);\n        if (*pdcrl) {\n            X509_CRL_free(*pdcrl);\n            *pdcrl = NULL;\n        }\n        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);\n    }\n    if (best_score >= CRL_SCORE_VALID)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end, UChar* lower,\n\t      OnigEncoding enc)\n{\n  int len;\n  const UChar* p = *pp;\n  if (ONIGENC_IS_MBC_ASCII(p)) {\n    *lower = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n    (*pp)++;\n    return 1;\n  }\n  else {\n    int i;\n    len = mbc_enc_len(p, end, enc);\n    for (i = 0; i < len; i++) {\n      *lower++ = *p++;\n    }\n    (*pp) += len;\n    return len; \n  }\n}", "target": 0}
{"code": "rb_reg_nth_match(int nth, VALUE match)\n{\n    VALUE str;\n    long start, end, len;\n    struct re_registers *regs;\n    if (NIL_P(match)) return Qnil;\n    match_check(match);\n    regs = RMATCH_REGS(match);\n    if (nth >= regs->num_regs) {\n\treturn Qnil;\n    }\n    if (nth < 0) {\n\tnth += regs->num_regs;\n\tif (nth <= 0) return Qnil;\n    }\n    start = BEG(nth);\n    if (start == -1) return Qnil;\n    end = END(nth);\n    len = end - start;\n    str = rb_str_subseq(RMATCH(match)->str, start, len);\n    OBJ_INFECT(str, match);\n    return str;\n}", "target": 0}
{"code": "static int iommu_init_domains(struct intel_iommu *iommu)\n{\n\tu32 ndomains, nlongs;\n\tsize_t size;\n\tndomains = cap_ndoms(iommu->cap);\n\tpr_debug(\"%s: Number of Domains supported <%d>\\n\",\n\t\t iommu->name, ndomains);\n\tnlongs = BITS_TO_LONGS(ndomains);\n\tspin_lock_init(&iommu->lock);\n\tiommu->domain_ids = kcalloc(nlongs, sizeof(unsigned long), GFP_KERNEL);\n\tif (!iommu->domain_ids) {\n\t\tpr_err(\"%s: Allocating domain id array failed\\n\",\n\t\t       iommu->name);\n\t\treturn -ENOMEM;\n\t}\n\tsize = (ALIGN(ndomains, 256) >> 8) * sizeof(struct dmar_domain **);\n\tiommu->domains = kzalloc(size, GFP_KERNEL);\n\tif (iommu->domains) {\n\t\tsize = 256 * sizeof(struct dmar_domain *);\n\t\tiommu->domains[0] = kzalloc(size, GFP_KERNEL);\n\t}\n\tif (!iommu->domains || !iommu->domains[0]) {\n\t\tpr_err(\"%s: Allocating domain array failed\\n\",\n\t\t       iommu->name);\n\t\tkfree(iommu->domain_ids);\n\t\tkfree(iommu->domains);\n\t\tiommu->domain_ids = NULL;\n\t\tiommu->domains    = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tset_bit(0, iommu->domain_ids);\n\treturn 0;\n}", "target": 0}
{"code": "void decode_prediction_unit(base_context* ctx,\n                            const slice_segment_header* shdr,\n                            de265_image* img,\n                            const PBMotionCoding& motion,\n                            int xC,int yC, int xB,int yB, int nCS, int nPbW,int nPbH, int partIdx)\n{\n  logtrace(LogMotion,\"decode_prediction_unit POC=%d %d;%d %dx%d\\n\",\n           img->PicOrderCntVal, xC+xB,yC+yB, nPbW,nPbH);\n  PBMotion vi;\n  motion_vectors_and_ref_indices(ctx, shdr, img, motion,\n                                 xC,yC, xB,yB, nCS, nPbW,nPbH, partIdx, &vi);\n  generate_inter_prediction_samples(ctx,shdr, img, xC,yC, xB,yB, nCS, nPbW,nPbH, &vi);\n  img->set_mv_info(xC+xB,yC+yB,nPbW,nPbH, vi);\n}", "target": 0}
{"code": "      _cimg_math_parser(const _cimg_math_parser& mp):\n        mem(mp.mem),code(mp.code),p_code_end(mp.p_code_end),p_break(mp.p_break),\n        imgin(mp.imgin),listin(mp.listin),imgout(mp.imgout),listout(mp.listout),img_stats(mp.img_stats),\n        list_stats(mp.list_stats),list_median(mp.list_median),debug_indent(0),result_dim(mp.result_dim),\n        break_type(0),constcache_size(0),is_parallelizable(mp.is_parallelizable),is_fill(mp.is_fill),\n        need_input_copy(mp.need_input_copy), result(mem._data + (mp.result - mp.mem._data)),calling_function(0) {\n#ifdef cimg_use_openmp\n        mem[17] = omp_get_thread_num();\n#endif\n        opcode.assign();\n        opcode._is_shared = true;", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "static bool imap_client_input_next_cmd(struct client *_client)\n{\n\tstruct imap_client *client = (struct imap_client *)_client;\n\tconst struct imap_arg *args;\n\tbool parsed;\n\tint ret;\n\tif (strcasecmp(client->cmd_name, \"AUTHENTICATE\") == 0) {\n\t\tret = cmd_authenticate(client, &parsed);\n\t\tif (ret == 0 && !parsed)\n\t\t\treturn FALSE;\n\t} else if (strcasecmp(client->cmd_name, \"ID\") == 0) {\n\t\tret = cmd_id(client);\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tif (ret < 0)\n\t\t\tret = 1; \n\t} else {\n\t\tret = client_parse_command(client, &args);\n\t\tif (ret < 0)\n\t\t\treturn TRUE;\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tret = *client->cmd_tag == '\\0' ? -1 :\n\t\t\tclient_command_execute(client, client->cmd_name, args);\n\t}\n\tclient->cmd_finished = TRUE;\n\tif (ret == -2 && strcasecmp(client->cmd_tag, \"LOGIN\") == 0) {\n\t\tclient_send_reply(&client->common, IMAP_CMD_REPLY_BAD,\n\t\t\t\"First parameter in line is IMAP's command tag, \"\n\t\t\t\"not the command name. Add that before the command, \"\n\t\t\t\"like: a login user pass\");\n\t} else if (ret < 0) {\n\t\tif (!client_invalid_command(client))\n\t\t\treturn FALSE;\n\t}\n\treturn ret != 0 && !client->common.destroyed;\n}", "target": 0}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "write_os2_header (j_decompress_ptr cinfo, bmp_dest_ptr dest)\n{\n  char bmpfileheader[14];\n  char bmpcoreheader[12];\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n  if (cinfo->out_color_space == JCS_RGB ||\n      (cinfo->out_color_space >= JCS_EXT_RGB &&\n       cinfo->out_color_space <= JCS_EXT_ARGB)) {\n    if (cinfo->quantize_colors) {\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  headersize = 14 + 12 + cmap_entries * 3; \n  bfSize = headersize + (long) dest->row_width * (long) cinfo->output_height;\n  MEMZERO(bmpfileheader, sizeof(bmpfileheader));\n  MEMZERO(bmpcoreheader, sizeof(bmpcoreheader));\n  bmpfileheader[0] = 0x42;      \n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); \n  PUT_4B(bmpfileheader, 10, headersize); \n  PUT_2B(bmpcoreheader, 0, 12); \n  PUT_2B(bmpcoreheader, 4, cinfo->output_width); \n  PUT_2B(bmpcoreheader, 6, cinfo->output_height); \n  PUT_2B(bmpcoreheader, 8, 1);  \n  PUT_2B(bmpcoreheader, 10, bits_per_pixel); \n  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t) 14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (JFWRITE(dest->pub.output_file, bmpcoreheader, 12) != (size_t) 12)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 3);\n}", "target": 0}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 1}
{"code": "bool Virtual_tmp_table::add(List<Spvar_definition> &field_list)\n{\n  Spvar_definition *cdef;            \n  List_iterator_fast<Spvar_definition> it(field_list);\n  DBUG_ENTER(\"Virtual_tmp_table::add\");\n  while ((cdef= it++))\n  {\n    Field *tmp;\n    Record_addr addr(f_maybe_null(cdef->pack_flag));\n    if (!(tmp= cdef->make_field(s, in_use->mem_root, &addr, &cdef->field_name)))\n      DBUG_RETURN(true);\n    add(tmp);\n  }\n  DBUG_RETURN(false);\n}", "target": 0}
{"code": "fmtint(int64 value, char type, int forcesign, int leftjust,\n\t   int minlen, int zpad, int precision, int pointflag,\n\t   PrintfTarget *target)\n{\n\tuint64\t\tbase;\n\tint\t\t\tdosign;\n\tconst char *cvt = \"0123456789abcdef\";\n\tint\t\t\tsignvalue = 0;\n\tchar\t\tconvert[64];\n\tint\t\t\tvallen = 0;\n\tint\t\t\tpadlen = 0;\t\t\n\tint\t\t\tzeropad;\t\t\n\tswitch (type)\n\t{\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tbase = 10;\n\t\t\tdosign = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tbase = 10;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcvt = \"0123456789ABCDEF\";\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t\t\t\n\t}\n\tif (dosign && adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tif (value == 0 && pointflag && precision == 0)\n\t\tvallen = 0;\n\telse\n\t{\n\t\tuint64\t\tuvalue = (uint64) value;\n\t\tdo\n\t\t{\n\t\t\tconvert[vallen++] = cvt[uvalue % base];\n\t\t\tuvalue = uvalue / base;\n\t\t} while (uvalue);\n\t}\n\tzeropad = Max(0, precision - vallen);\n\tadjust_padlen(minlen, vallen + zeropad, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\twhile (zeropad-- > 0)\n\t\tdopr_outch('0', target);\n\twhile (vallen > 0)\n\t\tdopr_outch(convert[--vallen], target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}", "target": 0}
{"code": "void calc_group_buffer(TMP_TABLE_PARAM *param, ORDER *group)\n{\n  uint key_length=0, parts=0, null_parts=0;\n  for (; group ; group=group->next)\n  {\n    Item *group_item= *group->item;\n    Field *field= group_item->get_tmp_table_field();\n    if (field)\n    {\n      enum_field_types type;\n      if ((type= field->type()) == MYSQL_TYPE_BLOB)\n\tkey_length+=MAX_BLOB_WIDTH;\t\t\n      else if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_VAR_STRING)\n        key_length+= field->field_length + HA_KEY_BLOB_LENGTH;\n      else if (type == MYSQL_TYPE_BIT)\n      {\n        key_length+= 8;                         \n      }\n      else\n\tkey_length+= field->pack_length();\n    }\n    else\n    { \n      switch (group_item->cmp_type()) {\n      case REAL_RESULT:\n        key_length+= sizeof(double);\n        break;\n      case INT_RESULT:\n        key_length+= sizeof(longlong);\n        break;\n      case DECIMAL_RESULT:\n        key_length+= my_decimal_get_binary_size(group_item->max_length - \n                                                (group_item->decimals ? 1 : 0),\n                                                group_item->decimals);\n        break;\n      case TIME_RESULT:\n      {\n        key_length+= 8;\n        break;\n      }\n      case STRING_RESULT:\n      {\n        enum enum_field_types type= group_item->field_type();\n        if (type == MYSQL_TYPE_BLOB)\n          key_length+= MAX_BLOB_WIDTH;\t\t\n        else\n        {\n          key_length+= group_item->max_length + HA_KEY_BLOB_LENGTH;\n        }\n        break;\n      }\n      default:\n        DBUG_ASSERT(0);\n        my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATAL));\n      }\n    }\n    parts++;\n    if (group_item->maybe_null)\n      null_parts++;\n  }\n  param->group_length= key_length + null_parts;\n  param->group_parts= parts;\n  param->group_null_parts= null_parts;\n}", "target": 0}
{"code": "struct rdma_cm_id *rdma_res_to_id(struct rdma_restrack_entry *res)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(res, struct rdma_id_private, res);\n\treturn &id_priv->id;\n}", "target": 0}
{"code": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}", "target": 1}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,\n                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)\n{\n  unsigned error = 0;\n  ucvector data;\n  size_t i, textsize = strlen(textstring);\n  ucvector_init(&data);\n  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);\n  if(i < 1 || i > 79) return 89; \n  ucvector_push_back(&data, 0); \n  ucvector_push_back(&data, compressed ? 1 : 0); \n  ucvector_push_back(&data, 0); \n  for(i = 0; langtag[i] != 0; i++) ucvector_push_back(&data, (unsigned char)langtag[i]);\n  ucvector_push_back(&data, 0); \n  for(i = 0; transkey[i] != 0; i++) ucvector_push_back(&data, (unsigned char)transkey[i]);\n  ucvector_push_back(&data, 0); \n  if(compressed)\n  {\n    ucvector compressed_data;\n    ucvector_init(&compressed_data);\n    error = zlib_compress(&compressed_data.data, &compressed_data.size,\n                          (unsigned char*)textstring, textsize, zlibsettings);\n    if(!error)\n    {\n      for(i = 0; i < compressed_data.size; i++) ucvector_push_back(&data, compressed_data.data[i]);\n    }\n    ucvector_cleanup(&compressed_data);\n  }\n  else \n  {\n    for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&data, (unsigned char)textstring[i]);\n  }\n  if(!error) error = addChunk(out, \"iTXt\", data.data, data.size);\n  ucvector_cleanup(&data);\n  return error;\n}", "target": 0}
{"code": "PHP_FUNCTION(grapheme_strlen)\n{\n\tunsigned char* string;\n\tint string_len;\n\tUChar* ustring = NULL;\n\tint ustring_len = 0;\n\tint ret_len;\n\tUErrorCode status;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", (char **)&string, &string_len) == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strlen: unable to parse input param\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tret_len = grapheme_ascii_check(string, string_len);\n\tif ( ret_len >= 0 )\n\t\tRETURN_LONG(ret_len);\n\tstatus = U_ZERO_ERROR;\n\tintl_convert_utf8_to_utf16(&ustring, &ustring_len, (char*) string, string_len, &status );\n\tif ( U_FAILURE( status ) ) {\n\t\tintl_error_set_code( NULL, status TSRMLS_CC );\n\t\tintl_error_set_custom_msg( NULL, \"Error converting input string to UTF-16\", 0 TSRMLS_CC );\n\t\tif (ustring) {\n\t\t\tefree( ustring );\n\t\t}\n\t\tRETURN_NULL();\n\t}\n\tret_len = grapheme_split_string(ustring, ustring_len, NULL, 0 TSRMLS_CC );\n\tif (ustring) {\n\t\tefree( ustring );\n\t}\n\tif (ret_len >= 0) {\n\t\tRETVAL_LONG(ret_len);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n}", "target": 0}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "\tTEST_METHOD(8) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation0 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation1 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation2 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tServerInstanceDir::GenerationPtr generation3 = dir.newGeneration(true, \"nobody\", nobodyGroup, 0, 0);\n\t\tgeneration2.reset();\n\t\tensure_equals(dir.getNewestGeneration()->getNumber(), 3u);\n\t\tgeneration3.reset();\n\t\tensure_equals(dir.getNewestGeneration()->getNumber(), 1u);\n\t}", "target": 0}
{"code": "static int fuse_push_module(struct fuse *f, const char *module,\n                            struct fuse_args *args)\n{\n    struct fuse_fs *newfs;\n    struct fuse_module *m = fuse_get_module(module);\n    struct fuse_fs *fs[2];\n    fs[0] = f->fs;\n    fs[1] = NULL;\n    if (!m)\n        return -1;\n    newfs = m->factory(args, fs);\n    if (!newfs) {\n        fuse_put_module(m);\n        return -1;\n    }\n    newfs->m = m;\n    f->fs = newfs;\n    return 0;\n}", "target": 0}
{"code": "    DWORD FileIo::Impl::winNumberOfLinks() const\n    {\n        DWORD nlink = 1;\n        HANDLE hFd = (HANDLE)_get_osfhandle(fileno(fp_));\n        if (hFd != INVALID_HANDLE_VALUE) {\n            typedef BOOL (WINAPI * GetFileInformationByHandle_t)(HANDLE, LPBY_HANDLE_FILE_INFORMATION);\n            HMODULE hKernel = ::GetModuleHandleA(\"kernel32.dll\");\n            if (hKernel) {\n                GetFileInformationByHandle_t pfcn_GetFileInformationByHandle = (GetFileInformationByHandle_t)GetProcAddress(hKernel, \"GetFileInformationByHandle\");\n                if (pfcn_GetFileInformationByHandle) {\n                    BY_HANDLE_FILE_INFORMATION fi = {0,0,0,0,0,0,0,0,0,0,0,0,0};\n                    if (pfcn_GetFileInformationByHandle(hFd, &fi)) {\n                        nlink = fi.nNumberOfLinks;\n                    }\n#ifdef DEBUG\n                    else EXV_DEBUG << \"GetFileInformationByHandle failed\\n\";\n#endif\n                }\n#ifdef DEBUG\n                else EXV_DEBUG << \"GetProcAddress(hKernel, \\\"GetFileInformationByHandle\\\") failed\\n\";\n#endif\n            }\n#ifdef DEBUG\n            else EXV_DEBUG << \"GetModuleHandleA(\\\"kernel32.dll\\\") failed\\n\";\n#endif\n        }\n#ifdef DEBUG\n        else EXV_DEBUG << \"_get_osfhandle failed: INVALID_HANDLE_VALUE\\n\";\n#endif\n        return nlink;\n    } ", "target": 0}
{"code": "static void dma_pte_free_pagetable(struct dmar_domain *domain,\n\t\t\t\t   unsigned long start_pfn,\n\t\t\t\t   unsigned long last_pfn,\n\t\t\t\t   int retain_level)\n{\n\tBUG_ON(!domain_pfn_supported(domain, start_pfn));\n\tBUG_ON(!domain_pfn_supported(domain, last_pfn));\n\tBUG_ON(start_pfn > last_pfn);\n\tdma_pte_clear_range(domain, start_pfn, last_pfn);\n\tdma_pte_free_level(domain, agaw_to_level(domain->agaw), retain_level,\n\t\t\t   domain->pgd, 0, start_pfn, last_pfn);\n\tif (start_pfn == 0 && last_pfn == DOMAIN_MAX_PFN(domain->gaw)) {\n\t\tfree_pgtable_page(domain->pgd);\n\t\tdomain->pgd = NULL;\n\t}\n}", "target": 0}
{"code": "static int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_openargs *o_arg = &data->o_arg;\n\tstruct nfs_openres *o_res = &data->o_res;\n\tint status;\n\tstatus = nfs4_run_open_task(data, 0);\n\tif (!data->rpc_done)\n\t\treturn status;\n\tif (status != 0) {\n\t\tif (status == -NFS4ERR_BADNAME &&\n\t\t\t\t!(o_arg->open_flags & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\treturn status;\n\t}\n\tnfs_fattr_map_and_free_names(server, &data->f_attr);\n\tif (o_arg->open_flags & O_CREAT)\n\t\tupdate_changeattr(dir, &o_res->cinfo);\n\tif ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n\t\tserver->caps &= ~NFS_CAP_POSIX_LOCK;\n\tif(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\tif (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n\t\t_nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n\treturn 0;\n}", "target": 0}
{"code": "static int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\tp = strnchr(name, IFNAMSIZ, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\tsnprintf(set->name, sizeof(set->name), name, min + n);\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!strcmp(set->name, i->name))\n\t\t\treturn -ENFILE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ddxGiveUp(enum ExitCode error)\n{\n    int i;\n    xf86VGAarbiterFini();\n#ifdef XF86PM\n    if (xf86OSPMClose)\n        xf86OSPMClose();\n    xf86OSPMClose = NULL;\n#endif\n    for (i = 0; i < xf86NumScreens; i++) {\n        xf86Screens[i]->vtSema = FALSE;\n    }\n#ifdef XFreeXDGA\n    DGAShutdown();\n#endif\n    if (xorgHWOpenConsole)\n        xf86CloseConsole();\n    systemd_logind_fini();\n    dbus_core_fini();\n    xf86CloseLog(error);\n    if (xf86Info.caughtSignal)\n        OsAbort();\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": " void ChromeContentBrowserClient::OpenURL(\n    content::BrowserContext* browser_context,\n     const content::OpenURLParams& params,\n    const base::Callback<void(content::WebContents*)>& callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n #if defined(OS_ANDROID)\n   ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,\n                                               callback);\n#else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.user_gesture = params.user_gesture;\n  Navigate(&nav_params);\n  callback.Run(nav_params.navigated_or_inserted_contents);\n#endif\n}", "target": 1}
{"code": "void TDStretch::setChannels(int numChannels)\n{\n    assert(numChannels > 0);\n    if (channels == numChannels) return;\n    channels = numChannels;\n    inputBuffer.setChannels(channels);\n    outputBuffer.setChannels(channels);\n    overlapLength=0;\n    setParameters(sampleRate);\n}", "target": 1}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "pushvar(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushvar*\\n\");\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = 'v'; \n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}", "target": 0}
{"code": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}", "target": 1}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "bool _af_filehandle_can_read (AFfilehandle file)\n{\n\tif (file->access != _AF_READ_ACCESS)\n\t{\n\t\t_af_error(AF_BAD_NOREADACC, \"file not opened for read access\");\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void mce_setup(struct mce *m)\n{\n\tmemset(m, 0, sizeof(struct mce));\n\tm->cpu = m->extcpu = smp_processor_id();\n\tm->time = get_seconds();\n\tm->cpuvendor = boot_cpu_data.x86_vendor;\n\tm->cpuid = cpuid_eax(1);\n\tm->socketid = cpu_data(m->extcpu).phys_proc_id;\n\tm->apicid = cpu_data(m->extcpu).initial_apicid;\n\trdmsrl(MSR_IA32_MCG_CAP, m->mcgcap);\n\tif (this_cpu_has(X86_FEATURE_INTEL_PPIN))\n\t\trdmsrl(MSR_PPIN, m->ppin);\n\tm->microcode = boot_cpu_data.microcode;\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "void HeaderToMetadataFilter::setDecoderFilterCallbacks(\n    Http::StreamDecoderFilterCallbacks& callbacks) {\n  decoder_callbacks_ = &callbacks;\n}", "target": 0}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "static void sev_es_sync_from_ghcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct ghcb *ghcb = svm->ghcb;\n\tu64 exit_code;\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs[VCPU_REGS_RAX] = ghcb_get_rax_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RBX] = ghcb_get_rbx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RCX] = ghcb_get_rcx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RDX] = ghcb_get_rdx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RSI] = ghcb_get_rsi_if_valid(ghcb);\n\tsvm->vmcb->save.cpl = ghcb_get_cpl_if_valid(ghcb);\n\tif (ghcb_xcr0_is_valid(ghcb)) {\n\t\tvcpu->arch.xcr0 = ghcb_get_xcr0(ghcb);\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t}\n\texit_code = ghcb_get_sw_exit_code(ghcb);\n\tcontrol->exit_code = lower_32_bits(exit_code);\n\tcontrol->exit_code_hi = upper_32_bits(exit_code);\n\tcontrol->exit_info_1 = ghcb_get_sw_exit_info_1(ghcb);\n\tcontrol->exit_info_2 = ghcb_get_sw_exit_info_2(ghcb);\n\tmemset(ghcb->save.valid_bitmap, 0, sizeof(ghcb->save.valid_bitmap));\n}", "target": 0}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "void compute_part_of_sort_key_for_equals(JOIN *join, TABLE *table,\n                                         Item_field *item_field,\n                                         key_map *col_keys)\n{\n  col_keys->clear_all();\n  col_keys->merge(item_field->field->part_of_sortkey);\n  if (!optimizer_flag(join->thd, OPTIMIZER_SWITCH_ORDERBY_EQ_PROP))\n    return;\n  Item_equal *item_eq= NULL;\n  if (item_field->item_equal)\n  {\n    item_eq= item_field->item_equal;\n  }\n  else\n  {\n    if (!join->cond_equal)\n      return;\n    table_map needed_tbl_map= item_field->used_tables() | table->map;\n    List_iterator<Item_equal> li(join->cond_equal->current_level);\n    Item_equal *cur_item_eq;\n    while ((cur_item_eq= li++))\n    {\n      if ((cur_item_eq->used_tables() & needed_tbl_map) &&\n          cur_item_eq->contains(item_field->field))\n      {\n        item_eq= cur_item_eq;\n        item_field->item_equal= item_eq; \n        break;\n      }\n    }\n  }\n  if (item_eq)\n  {\n    Item_equal_fields_iterator it(*item_eq);\n    Item *item;\n    while ((item= it++))\n    {\n      if (item->type() == Item::FIELD_ITEM &&\n          ((Item_field*)item)->field->table == table)\n      {\n        col_keys->merge(((Item_field*)item)->field->part_of_sortkey);\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": " int BrowserNonClientFrameViewAura::NonClientTopBorderHeight(\n     bool force_restored) const {\n   if (frame()->widget_delegate() &&\n       frame()->widget_delegate()->ShouldShowWindowTitle()) {\n     return close_button_->bounds().bottom();\n   }\n  if (!frame()->IsMaximized() || force_restored)\n    return kTabstripTopSpacingRestored;\n  return kTabstripTopSpacingMaximized;\n }", "target": 1}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "TEST_F(LoaderTest, InvalidExportPath) {\n  SavedModelBundle bundle;\n  RunOptions run_options;\n  SessionOptions session_options;\n  const string export_dir =\n      io::JoinPath(testing::TensorFlowSrcRoot(), \"missing-path\");\n  Status st = LoadSavedModel(session_options, run_options, export_dir,\n                             {kSavedModelTagServe}, &bundle);\n  EXPECT_FALSE(st.ok());\n}", "target": 0}
{"code": "static void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}", "target": 0}
{"code": "static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n    if (err != NULL) {\n        return err;\n    }\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n    part = ap_strstr_c(arg, \":\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { \n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n    cmd->server->port = port;\n    return NULL;\n}", "target": 0}
{"code": "int spl_object_storage_contains(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) \n{\n\tint hash_len, found;\n\tchar *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);\n\tif (!hash) {\n\t\treturn 0;\n\t}\n\tfound = zend_hash_exists(&intern->storage, hash, hash_len);\n\tspl_object_storage_free_hash(intern, hash);\n\treturn found;\n} ", "target": 0}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void vnc_client_cache_addr(VncState *client)\n{\n    Error *err = NULL;\n    client->info = g_malloc0(sizeof(*client->info));\n    vnc_init_basic_info_from_remote_addr(client->sioc,\n                                         qapi_VncClientInfo_base(client->info),\n                                         &err);\n    client->info->websocket = client->websocket;\n    if (err) {\n        qapi_free_VncClientInfo(client->info);\n        client->info = NULL;\n        error_free(err);\n    }\n}", "target": 0}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_ctl_elem_info_user(struct snd_ctl_file *ctl,\n\t\t\t\t  struct snd_ctl_elem_info __user *_info)\n{\n\tstruct snd_ctl_elem_info info;\n\tint result;\n\tif (copy_from_user(&info, _info, sizeof(info)))\n\t\treturn -EFAULT;\n\tsnd_power_lock(ctl->card);\n\tresult = snd_power_wait(ctl->card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_info(ctl, &info);\n\tsnd_power_unlock(ctl->card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_info, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\treturn result;\n}", "target": 0}
{"code": "void __init shm_init(void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}", "target": 0}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "xmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}", "target": 0}
{"code": "void *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "GF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "ppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tu32 seq = skb->sequence;\n\tskb_queue_walk(list, p) {\n\t\tif (seq_before(seq, p->sequence))\n\t\t\tbreak;\n\t}\n\t__skb_queue_before(list, p, skb);\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 1}
{"code": "bgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n    if (tptr == pptr + len) {\n        return 2;\n    }\ntrunc:\n   return 4;\n}", "target": 0}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n \t}\n \treturn err;\n}", "target": 1}
{"code": "static void init_vmcs_shadow_fields(void)\n{\n\tint i, j;\n\tfor (i = j = 0; i < max_shadow_read_write_fields; i++) {\n\t\tswitch (shadow_read_write_fields[i]) {\n\t\tcase GUEST_BNDCFGS:\n\t\t\tif (!vmx_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (j < i)\n\t\t\tshadow_read_write_fields[j] =\n\t\t\t\tshadow_read_write_fields[i];\n\t\tj++;\n\t}\n\tmax_shadow_read_write_fields = j;\n\tfor (i = 0; i < max_shadow_read_write_fields; i++) {\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmwrite_bitmap);\n\t\tclear_bit(shadow_read_write_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n\t}\n\tfor (i = 0; i < max_shadow_read_only_fields; i++)\n\t\tclear_bit(shadow_read_only_fields[i],\n\t\t\t  vmx_vmread_bitmap);\n}", "target": 0}
{"code": "httpd_addheader(isc_httpd_t *httpd, const char *name, const char *val) {\n\tisc_result_t result;\n\tunsigned int needlen;\n\tREQUIRE(VALID_HTTPD(httpd));\n\tneedlen = strlen(name); \n\tif (val != NULL) {\n\t\tneedlen += 2 + strlen(val); \n\t}\n\tneedlen += 2; \n\twhile (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {\n\t\tresult = grow_headerspace(httpd);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\treturn (result);\n\t\t}\n\t}\n\tif (val != NULL) {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s: %s\\r\\n\",\n\t\t\t\t\t  name, val));\n\t} else {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s\\r\\n\",\n\t\t\t\t\t  name));\n\t}\n}", "target": 0}
{"code": "bool AffiliationFetcher::ParseResponse(\n    AffiliationFetcherDelegate::Result* result) const {\n  std::string serialized_response;\n  if (!fetcher_->GetResponseAsString(&serialized_response)) {\n    NOTREACHED();\n  }\n  affiliation_pb::LookupAffiliationResponse response;\n  if (!response.ParseFromString(serialized_response))\n    return false;\n  result->reserve(requested_facet_uris_.size());\n  std::map<FacetURI, size_t> facet_uri_to_class_index;\n  for (int i = 0; i < response.affiliation_size(); ++i) {\n    const affiliation_pb::Affiliation& equivalence_class(\n        response.affiliation(i));\n     AffiliatedFacets affiliated_uris;\n     for (int j = 0; j < equivalence_class.facet_size(); ++j) {\n      const std::string& uri_spec(equivalence_class.facet(j));\n       FacetURI uri = FacetURI::FromPotentiallyInvalidSpec(uri_spec);\n       if (!uri.is_valid())\n        continue;\n      affiliated_uris.push_back(uri);\n    }\n    if (affiliated_uris.empty())\n      continue;\n    for (const FacetURI& uri : affiliated_uris) {\n      if (!facet_uri_to_class_index.count(uri))\n        facet_uri_to_class_index[uri] = result->size();\n      if (facet_uri_to_class_index[uri] !=\n          facet_uri_to_class_index[affiliated_uris[0]]) {\n        return false;\n      }\n    }\n    if (facet_uri_to_class_index[affiliated_uris[0]] == result->size())\n      result->push_back(affiliated_uris);\n  }\n  for (const FacetURI& uri : requested_facet_uris_) {\n    if (!facet_uri_to_class_index.count(uri))\n      result->push_back(AffiliatedFacets(1, uri));\n  }\n  return true;\n}", "target": 1}
{"code": "zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static void fts3ReversePoslist(char *pStart, char **ppPoslist){\n  char *p = &(*ppPoslist)[-2];\n  char c = 0;\n  while( p>pStart && (c=*p--)==0 );\n  while( p>pStart && (*p & 0x80) | c ){ \n    c = *p--; \n  }\n  if( p>pStart ){ p = &p[2]; }\n  while( *p++&0x80 );\n  *ppPoslist = p;\n}", "target": 0}
{"code": "PHP_FUNCTION(snmp_set_valueretrieval)\n{\n\tzend_long method;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &method) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (method >= 0 && method <= (SNMP_VALUE_LIBRARY|SNMP_VALUE_PLAIN|SNMP_VALUE_OBJECT)) {\n\t\t\tSNMP_G(valueretrieval) = method;\n\t\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL, E_WARNING, \"Unknown SNMP value retrieval method '%pd'\", method);\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": " static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n {\n \tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n }", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static int ftp_send_command(struct connectdata *conn, const char *message, ...)\n{\n  int ftp_code;\n  ssize_t nread = 0;\n  va_list args;\n  char print_buffer[50];\n  va_start(args, message);\n  mvsnprintf(print_buffer, sizeof(print_buffer), message, args);\n  va_end(args);\n  if(Curl_ftpsend(conn, print_buffer)) {\n    ftp_code = -1;\n  }\n  else {\n    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))\n      ftp_code = -1;\n  }\n  (void)nread; \n  return ftp_code;\n}", "target": 0}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n \tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n \t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n \t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n \t\treturn -EINVAL;\n \treturn cdrom_slot_status(cdi, arg);\n }", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n    if( (*p) + len > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                     \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == 1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 1}
{"code": "int compat_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_getsockopt != NULL)\n\t\t\treturn udp_prot.compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname == MCAST_MSFILTER)\n\t\treturn compat_mc_getsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_getsockopt);\n\terr = do_ipv6_getsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t MSG_CMSG_COMPAT);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\terr = compat_nf_getsockopt(sk, PF_INET6, optname, optval, &len);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}", "target": 0}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n \t\t\tifr->ifr_settings.size = size; \n \t\t\treturn -ENOBUFS;\n \t\t}\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 1}
{"code": "static void cma_set_rep_event_data(struct rdma_cm_event *event,\n\t\t\t\t   const struct ib_cm_rep_event_param *rep_data,\n\t\t\t\t   void *private_data)\n{\n\tevent->param.conn.private_data = private_data;\n\tevent->param.conn.private_data_len = IB_CM_REP_PRIVATE_DATA_SIZE;\n\tevent->param.conn.responder_resources = rep_data->responder_resources;\n\tevent->param.conn.initiator_depth = rep_data->initiator_depth;\n\tevent->param.conn.flow_control = rep_data->flow_control;\n\tevent->param.conn.rnr_retry_count = rep_data->rnr_retry_count;\n\tevent->param.conn.srq = rep_data->srq;\n\tevent->param.conn.qp_num = rep_data->remote_qpn;\n\tevent->ece.vendor_id = rep_data->ece.vendor_id;\n\tevent->ece.attr_mod = rep_data->ece.attr_mod;\n}", "target": 0}
{"code": "MagickPrivate size_t GetOptimalKernelWidth2D(const double radius,\n  const double sigma)\n{\n  double\n    alpha,\n    beta,\n    gamma,\n    normalize,\n    value;\n  size_t\n    width;\n  ssize_t\n    j,\n    u,\n    v;\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (radius > MagickEpsilon)\n    return((size_t) (2.0*ceil(radius)+1.0));\n  gamma=fabs(sigma);\n  if (gamma <= MagickEpsilon)\n    return(3UL);\n  alpha=PerceptibleReciprocal(2.0*gamma*gamma);\n  beta=(double) PerceptibleReciprocal((double) Magick2PI*gamma*gamma);\n  for (width=5; ; )\n  {\n    normalize=0.0;\n    j=(ssize_t) (width-1)/2;\n    for (v=(-j); v <= j; v++)\n      for (u=(-j); u <= j; u++)\n        normalize+=exp(-((double) (u*u+v*v))*alpha)*beta;\n    value=exp(-((double) (j*j))*alpha)*beta/normalize;\n    if ((value < QuantumScale) || (value < MagickEpsilon))\n      break;\n    width+=2;\n  }\n  return((size_t) (width-2));\n}", "target": 0}
{"code": "GF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}", "target": 0}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "static int propagate_liveness_reg(struct bpf_verifier_env *env,\n\t\t\t\t  struct bpf_reg_state *reg,\n\t\t\t\t  struct bpf_reg_state *parent_reg)\n{\n\tu8 parent_flag = parent_reg->live & REG_LIVE_READ;\n\tu8 flag = reg->live & REG_LIVE_READ;\n\tint err;\n\tif (parent_flag == REG_LIVE_READ64 ||\n\t    !flag ||\n\t    parent_flag == flag)\n\t\treturn 0;\n\terr = mark_reg_read(env, reg, parent_reg, flag);\n\tif (err)\n\t\treturn err;\n\treturn flag;\n}", "target": 0}
{"code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\tbuf->tr = tr;\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\treturn 0;\n}", "target": 1}
{"code": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\"The cross-origin image at \" +\n                                       url.ElidedString() +\n                                       \" may not be loaded.\");\n     return false;\n   }\n   return true;\n}", "target": 1}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n \t\t\t\tgpiod_put(pin->gpiod);\n \t\t\t\tlist_del(&pin->list);\n \t\t\t\tkfree(pin);\n \t\t\t} else {\n \t\t\t\tpin->request_count--;\n \t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "vba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf)\n\t\t\t\tfree(buf);\n\t\t\tbreak;\n\t\t}\n\t\tret++;\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "ins_apply_autocmds(event_T event)\n{\n    varnumber_T\ttick = CHANGEDTICK(curbuf);\n    int r;\n    r = apply_autocmds(event, NULL, NULL, FALSE, curbuf);\n    if (tick != CHANGEDTICK(curbuf))\n\tu_save(curwin->w_cursor.lnum, (linenr_T)(curwin->w_cursor.lnum + 1));\n    return r;\n}", "target": 0}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK_EQ(-1, mapped_file_);\n  if (options.size == 0) return false;\n  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))\n    return false;\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  FILE *fp;\n  bool fix_size = true;\n  FilePath path;\n  if (options.name == NULL || options.name->empty()) {\n    DCHECK(!options.open_existing);\n    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);\n    if (fp) {\n      if (unlink(path.value().c_str()))\n        PLOG(WARNING) << \"unlink\";\n    }\n  } else {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n    fp = file_util::OpenFile(path, \"w+x\");\n    if (fp == NULL && options.open_existing) {\n      fp = file_util::OpenFile(path, \"a+\");\n       fix_size = false;\n     }\n   }\n   if (fp && fix_size) {\n    struct stat stat;\n    if (fstat(fileno(fp), &stat) != 0) {\n      file_util::CloseFile(fp);\n      return false;\n    }\n    const size_t current_size = stat.st_size;\n    if (current_size != options.size) {\n      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {\n        file_util::CloseFile(fp);\n        return false;\n      }\n    }\n    requested_size_ = options.size;\n  }\n  if (fp == NULL) {\n#if !defined(OS_MACOSX)\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n    FilePath dir = path.DirName();\n    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {\n      PLOG(ERROR) << \"Unable to access(W_OK|X_OK) \" << dir.value();\n      if (dir.value() == \"/dev/shm\") {\n        LOG(FATAL) << \"This is frequently caused by incorrect permissions on \"\n                   << \"/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix.\";\n      }\n    }\n#else\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n#endif\n    return false;\n  }\n  return PrepareMapFile(fp);\n}", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "bool IsDrag(const POINT& origin, const POINT& current) {\n  return views::View::ExceededDragThreshold(current.x - origin.x,\n                                            current.y - origin.y);\n}", "target": 0}
{"code": "static void madvise_cold_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end)\n{\n\tstruct madvise_walk_private walk_private = {\n\t\t.pageout = false,\n\t\t.tlb = tlb,\n\t};\n\ttlb_start_vma(tlb, vma);\n\twalk_page_range(vma->vm_mm, addr, end, &cold_walk_ops, &walk_private);\n\ttlb_end_vma(tlb, vma);\n}", "target": 0}
{"code": "static void wcd9335_codec_hph_mode_config(struct snd_soc_component *component,\n\t\t\t\t\t  int event, int mode)\n{\n\tswitch (mode) {\n\tcase CLS_H_LP:\n\t\twcd9335_codec_hph_lp_config(component, event);\n\t\tbreak;\n\tcase CLS_H_LOHIFI:\n\t\twcd9335_codec_hph_lohifi_config(component, event);\n\t\tbreak;\n\tcase CLS_H_HIFI:\n\t\twcd9335_codec_hph_hifi_config(component, event);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static __forceinline void draw_line(float *output, int x0, int y0, int x1, int y1, int n)\n{\n   int dy = y1 - y0;\n   int adx = x1 - x0;\n   int ady = abs(dy);\n   int base;\n   int x=x0,y=y0;\n   int err = 0;\n   int sy;\n#ifdef STB_VORBIS_DIVIDE_TABLE\n   if (adx < DIVTAB_DENOM && ady < DIVTAB_NUMER) {\n      if (dy < 0) {\n         base = -integer_divide_table[ady][adx];\n         sy = base-1;\n      } else {\n         base =  integer_divide_table[ady][adx];\n         sy = base+1;\n      }\n   } else {\n      base = dy / adx;\n      if (dy < 0)\n         sy = base - 1;\n      else\n         sy = base+1;\n   }\n#else\n   base = dy / adx;\n   if (dy < 0)\n      sy = base - 1;\n   else\n      sy = base+1;\n#endif\n    ady -= abs(base) * adx;\n    if (x1 > n) x1 = n;\n    if (x < x1) {\n      LINE_OP(output[x], inverse_db_table[y]);\n       for (++x; x < x1; ++x) {\n          err += ady;\n          if (err >= adx) {\n             err -= adx;\n             y += sy;\n          } else\n             y += base;\n         LINE_OP(output[x], inverse_db_table[y]);\n       }\n    }\n }", "target": 1}
{"code": "void AXTree::PopulateOrderedSetItems(const AXNode* ordered_set,\n                                     const AXNode* local_parent,\n                                     std::vector<const AXNode*>& items,\n                                     bool node_is_radio_button) const {\n  if (!(ordered_set == local_parent)) {\n    if (local_parent->data().role == ordered_set->data().role)\n      return;\n  }\n   for (int i = 0; i < local_parent->child_count(); ++i) {\n     const AXNode* child = local_parent->GetUnignoredChildAtIndex(i);\n     if (node_is_radio_button &&\n         child->data().role == ax::mojom::Role::kRadioButton)\n      items.push_back(child);\n    if (!node_is_radio_button && child->SetRoleMatchesItemRole(ordered_set))\n      items.push_back(child);\n    if (child->data().role == ax::mojom::Role::kGenericContainer ||\n        child->data().role == ax::mojom::Role::kIgnored) {\n      PopulateOrderedSetItems(ordered_set, child, items, node_is_radio_button);\n    }\n  }\n}", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 1}
{"code": "  size_t recv_body(char* buf, size_t max) override {\n    auto& message = parser.get();\n    auto& body_remaining = message.body();\n    body_remaining.data = buf;\n    body_remaining.size = max;\n    while (body_remaining.size && !parser.is_done()) {\n      boost::system::error_code ec;\n      http::async_read_some(stream, buffer, parser, yield[ec]);\n      if (ec == http::error::partial_message ||\n          ec == http::error::need_buffer) {\n        break;\n      }\n      if (ec) {\n        ldout(cct, 4) << \"failed to read body: \" << ec.message() << dendl;\n        throw rgw::io::Exception(ec.value(), std::system_category());\n      }\n    }\n    return max - body_remaining.size;\n  }", "target": 1}
{"code": "struct sock *ax25_get_socket(ax25_address *my_addr, ax25_address *dest_addr,\n\tint type)\n{\n\tstruct sock *sk = NULL;\n\tax25_cb *s;\n\tspin_lock(&ax25_list_lock);\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->sk && !ax25cmp(&s->source_addr, my_addr) &&\n\t\t    !ax25cmp(&s->dest_addr, dest_addr) &&\n\t\t    s->sk->sk_type == type) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ax25_list_lock);\n\treturn sk;\n}", "target": 0}
{"code": "static int gaff_init(struct hid_device *hid)\n{\n\tstruct gaff_device *gaff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct list_head *report_ptr = report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport_ptr = report_ptr->next;\n\treport = list_entry(report_ptr, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 6) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tgaff = kzalloc(sizeof(struct gaff_device), GFP_KERNEL);\n\tif (!gaff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, gaff, hid_gaff_play);\n\tif (error) {\n\t\tkfree(gaff);\n\t\treturn error;\n\t}\n\tgaff->report = report;\n\tgaff->report->field[0]->value[0] = 0x51;\n\tgaff->report->field[0]->value[1] = 0x00;\n\tgaff->report->field[0]->value[2] = 0x00;\n\tgaff->report->field[0]->value[3] = 0x00;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\tgaff->report->field[0]->value[0] = 0xfa;\n\tgaff->report->field[0]->value[1] = 0xfe;\n\thid_hw_request(hid, gaff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for GreenAsia 0x12 devices by Lukasz Lubojanski <lukasz@lubojanski.info>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == 0xF2) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xD3;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xF3;\n      }\n    }\n    else if (code == 0xB5) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xCC;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xEC;\n      }\n    }\n    else if (code == 0xC0 || code == 0xE0 || code == 0xB6)\n      ;\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_CP1253_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 0xDC)\n\tcode = 0xA2;\n      else if (code >= 0xDD && code <= 0xDF)\n\tcode -= 0x25;\n      else if (code == 0xFC)\n\tcode = 0xBC;\n      else if (code == 0xFD || code == 0xFE)\n\tcode -= 0x3F;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "static void set_seg_override(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tctxt->has_seg_override = true;\n\tctxt->seg_override = seg;\n}", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "void php_gd_error(const char *format, ...)\n{\n\tva_list args;\n\tTSRMLS_FETCH();\n\tva_start(args, format);\n\tphp_verror(NULL, \"\", E_WARNING, format, args TSRMLS_CC);\n\tva_end(args);\n}", "target": 0}
{"code": "gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdMalloc(sizeof(gdImage));\n\tmemset(im, 0, sizeof(gdImage));\n\tim->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "guardfraction_file_parse_guard_line(const char *guard_line,\n                                    smartlist_t *vote_routerstatuses,\n                                    char **err_msg)\n{\n  char guard_id[DIGEST_LEN];\n  uint32_t guardfraction;\n  char *inputs_tmp = NULL;\n  int num_ok = 1;\n  smartlist_t *sl = smartlist_new();\n  int retval = -1;\n  tor_assert(err_msg);\n  smartlist_split_string(sl, guard_line, \" \",\n                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 3);\n  if (smartlist_len(sl) < 3) {\n    tor_asprintf(err_msg, \"bad line '%s'\", guard_line);\n    goto done;\n  }\n  inputs_tmp = smartlist_get(sl, 0);\n  if (strlen(inputs_tmp) != HEX_DIGEST_LEN ||\n      base16_decode(guard_id, DIGEST_LEN,\n                    inputs_tmp, HEX_DIGEST_LEN) != DIGEST_LEN) {\n    tor_asprintf(err_msg, \"bad digest '%s'\", inputs_tmp);\n    goto done;\n  }\n  inputs_tmp = smartlist_get(sl, 1);\n  guardfraction =\n    (uint32_t) tor_parse_long(inputs_tmp, 10, 0, 100, &num_ok, NULL);\n  if (!num_ok) {\n    tor_asprintf(err_msg, \"wrong percentage '%s'\", inputs_tmp);\n    goto done;\n  }\n  if (vote_routerstatuses) {\n    retval = guardfraction_line_apply(guard_id, guardfraction,\n                                      vote_routerstatuses);\n  } else {\n    retval = 0; \n  }\n done:\n  SMARTLIST_FOREACH(sl, char *, cp, tor_free(cp));\n  smartlist_free(sl);\n  return retval;\n}", "target": 0}
{"code": "input_parse(struct window_pane *wp)\n{\n\tstruct input_ctx\t\t*ictx = wp->ictx;\n\tconst struct input_transition\t*itr;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tu_char\t\t\t\t*buf;\n\tsize_t\t\t\t\t len, off;\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\treturn;\n\twp->window->flags |= WINDOW_ACTIVITY;\n\twp->window->flags &= ~WINDOW_SILENCE;\n\tif (gettimeofday(&wp->window->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tif (wp->mode == NULL)\n\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\tictx->wp = wp;\n\tbuf = EVBUFFER_DATA(evb);\n\tlen = EVBUFFER_LENGTH(evb);\n\tnotify_input(wp, evb);\n\toff = 0;\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\t\tlog_debug(\"%s: '%c' %s\", __func__, ictx->ch, ictx->state->name);\n\t\titr = ictx->state->transitions;\n\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\tif (ictx->ch >= itr->first && ictx->ch <= itr->last)\n\t\t\t\tbreak;\n\t\t\titr++;\n\t\t}\n\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\tfatalx(\"No transition from state!\");\n\t\t}\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(wp, itr);\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n\tscreen_write_stop(&ictx->ctx);\n\tevbuffer_drain(evb, len);\n}", "target": 0}
{"code": "ProcListFonts(ClientPtr client)\n{\n    REQUEST(xListFontsReq);\n    REQUEST_FIXED_SIZE(xListFontsReq, stuff->nbytes);\n    return ListFonts(client, (unsigned char *) &stuff[1], stuff->nbytes,\n                     stuff->maxNames);\n}", "target": 0}
{"code": "static inline long put_compat_itimerval(struct compat_itimerval __user *o,\n\t\tstruct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}", "target": 0}
{"code": "static ImageLoader::BypassMainWorldBehavior shouldBypassMainWorldCSP(\n    ImageLoader* loader) {\n  DCHECK(loader);\n  DCHECK(loader->element());\n  if (loader->element()->document().frame() &&\n      loader->element()\n          ->document()\n          .frame()\n          ->script()\n          .shouldBypassMainWorldCSP())\n    return ImageLoader::BypassMainWorldCSP;\n  return ImageLoader::DoNotBypassMainWorldCSP;\n}", "target": 0}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)\n{\n    int result;\n    if (handle == NULL)\n    {\n        LogError(\"Failure: handle is invalid.\");\n        result = MU_FAILURE;\n    }\n    else if (enlargeSize == 0)\n    {\n        LogError(\"Failure: enlargeSize size is 0.\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b = (BUFFER*)handle;\n        unsigned char* temp = (unsigned char*)realloc(b->buffer, b->size + enlargeSize);\n        if (temp == NULL)\n        {\n            LogError(\"Failure: allocating temp buffer.\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            b->buffer = temp;\n            b->size += enlargeSize;\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "static int inet6_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t     struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv6_devconf *devconf;\n\tstruct inet6_dev *in6_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv6_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv6.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv6.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (dev == NULL)\n\t\t\tgoto errout;\n\t\tin6_dev = __in6_dev_get(dev);\n\t\tif (in6_dev == NULL)\n\t\t\tgoto errout;\n\t\tdevconf = &in6_dev->cnf;\n\t\tbreak;\n\t}\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet6_netconf_msgsize_devconf(-1), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = inet6_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\t NETLINK_CB(in_skb).portid,\n\t\t\t\t\t nlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\t -1);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}", "target": 0}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n     return 0;\n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n       return 0;\n     text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n       return 0;\n   }\n  *escaped_char = escaped_char_value(text);\n  return 1;\n}", "target": 1}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)\n{\n  struct ospf_header *ospfh;\n  unsigned char digest[OSPF_AUTH_MD5_SIZE];\n  MD5_CTX ctx;\n  void *ibuf;\n  u_int32_t t;\n  struct crypt_key *ck;\n  const u_int8_t *auth_key;\n  ibuf = STREAM_DATA (op->s);\n  ospfh = (struct ospf_header *) ibuf;\n  if (ntohs (ospfh->auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)\n    return 0;\n  t = (time(NULL) & 0xFFFFFFFF);\n  if (t > oi->crypt_seqnum)\n    oi->crypt_seqnum = t;\n  else\n    oi->crypt_seqnum++;\n  ospfh->u.crypt.crypt_seqnum = htonl (oi->crypt_seqnum); \n  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    auth_key = (const u_int8_t *) \"\";\n  else\n    {\n      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));\n      auth_key = ck->auth_key;\n    }\n  memset(&ctx, 0, sizeof(ctx));\n  MD5Init(&ctx);\n  MD5Update(&ctx, ibuf, ntohs (ospfh->length));\n  MD5Update(&ctx, auth_key, OSPF_AUTH_MD5_SIZE);\n  MD5Final(digest, &ctx);\n  stream_put (op->s, digest, OSPF_AUTH_MD5_SIZE);\n  op->length = ntohs (ospfh->length) + OSPF_AUTH_MD5_SIZE;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn(\"ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u\",\n\t      (u_long)stream_get_endp(op->s), op->length);\n  return OSPF_AUTH_MD5_SIZE;\n}", "target": 0}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "status_t Camera3Device::createDefaultRequest(int templateId,\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n return OK;\n}", "target": 1}
{"code": "static int packet_dev_mc(struct net_device *dev, struct packet_mclist *i,\n\t\t\t int what)\n{\n\tswitch (i->type) {\n\tcase PACKET_MR_MULTICAST:\n\t\tif (i->alen != dev->addr_len)\n\t\t\treturn -EINVAL;\n\t\tif (what > 0)\n\t\t\treturn dev_mc_add(dev, i->addr);\n\t\telse\n\t\t\treturn dev_mc_del(dev, i->addr);\n\t\tbreak;\n\tcase PACKET_MR_PROMISC:\n\t\treturn dev_set_promiscuity(dev, what);\n\tcase PACKET_MR_ALLMULTI:\n\t\treturn dev_set_allmulti(dev, what);\n\tcase PACKET_MR_UNICAST:\n\t\tif (i->alen != dev->addr_len)\n\t\t\treturn -EINVAL;\n\t\tif (what > 0)\n\t\t\treturn dev_uc_add(dev, i->addr);\n\t\telse\n\t\t\treturn dev_uc_del(dev, i->addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void vmx_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\tif (!reinject && is_guest_mode(vcpu) &&\n\t    nested_vmx_check_exception(vcpu, nr))\n\t\treturn;\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, nr, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n}", "target": 0}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static bool vsock_in_connected_table(struct vsock_sock *vsk)\n{\n\tbool ret;\n\tspin_lock_bh(&vsock_table_lock);\n\tret = __vsock_in_connected_table(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n\treturn ret;\n}", "target": 0}
{"code": "Status FunctionLibraryDefinition::AddGradientDefHelper(const GradientDef& grad,\n                                                       bool* added) {\n  *added = false;\n  string* entry = &func_grad_[grad.function_name()];\n  if (!entry->empty()) {\n    if (*entry != grad.gradient_func()) {\n      return errors::InvalidArgument(\n          \"Cannot assign gradient function '\", grad.gradient_func(), \"' to '\",\n          grad.function_name(), \"' because it already has gradient function \",\n          \"'\", *entry, \"'\");\n    }\n    return Status::OK();\n  }\n  *entry = grad.gradient_func();\n  *added = true;\n  return Status::OK();\n}", "target": 0}
{"code": "SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\tmsg = spnego_key->payload.data[0];\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}", "target": 0}
{"code": "  Each_Obj Parser::parse_each_directive()\n  {\n    stack.push_back(Scope::Control);\n    ParserState each_source_position = pstate;\n    bool root = block_stack.back()->is_root();\n    std::vector<std::string> vars;\n    lex_variable();\n    vars.push_back(Util::normalize_underscores(lexed));\n    while (lex< exactly<','> >()) {\n      if (!lex< variable >()) error(\"@each directive requires an iteration variable\");\n      vars.push_back(Util::normalize_underscores(lexed));\n    }\n    if (!lex< kwd_in >()) error(\"expected 'in' keyword in @each directive\");\n    Expression_Obj list = parse_list();\n    Block_Obj body = parse_block(root);\n    stack.pop_back();\n    return SASS_MEMORY_NEW(Each, each_source_position, vars, list, body);\n  }", "target": 0}
{"code": "static inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}", "target": 0}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n    if (h.isPercent())\n       return computeContentBoxLogicalHeight(h.calcValue(containingBlock()->availableLogicalHeight()));\n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n    return containingBlock()->availableLogicalHeight();\n}", "target": 1}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "static int wait_phy_eeprom_ready(struct usbnet *dev, int phy)\n{\n\tint i;\n\tfor (i = 0; i < SR_SHARE_TIMEOUT; i++) {\n\t\tu8 tmp = 0;\n\t\tint ret;\n\t\tudelay(1);\n\t\tret = sr_read_reg(dev, SR_EPCR, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(tmp & EPCR_ERRE))\n\t\t\treturn 0;\n\t}\n\tnetdev_err(dev->net, \"%s write timed out!\\n\", phy ? \"phy\" : \"eeprom\");\n\treturn -EIO;\n}", "target": 0}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "isdn_net_getphones(isdn_net_ioctl_phone *phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "static void terminate(int sig)\n{\n    unlink(socket_file);\n    exit(0);\n}", "target": 0}
{"code": "status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {\n     ALOGV(\"setNextPlayer\");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n     mNextClient = c;\n     if (c != NULL) {\n if (mAudioOutput != NULL) {\n            mAudioOutput->setNextOutput(c->mAudioOutput);\n } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {\n            ALOGE(\"no current audio output\");\n }\n if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {\n            mPlayer->setNextPlayer(mNextClient->getPlayer());\n }\n }\n return OK;\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_solve(const CImg<t>& A) const {\n      return CImg<_cimg_Ttfloat>(*this,false).solve(A);", "target": 0}
{"code": "static bool getFileSizeFromFindData(const WIN32_FIND_DATAW& findData, long long& size)\n{\n    ULARGE_INTEGER fileSize;\n    fileSize.HighPart = findData.nFileSizeHigh;\n    fileSize.LowPart = findData.nFileSizeLow;\n    if (fileSize.QuadPart > static_cast<ULONGLONG>(std::numeric_limits<long long>::max()))\n        return false;\n    size = fileSize.QuadPart;\n    return true;\n}", "target": 0}
{"code": "int vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\tstruct file *file_out, loff_t pos_out, u64 len)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tint ret;\n\tif (inode_in->i_sb != inode_out->i_sb ||\n\t    file_in->f_path.mnt != file_out->f_path.mnt)\n\t\treturn -EXDEV;\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND) ||\n\t    !file_in->f_op->clone_file_range)\n\t\treturn -EBADF;\n\tret = clone_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\tret = clone_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\tif (pos_in + len > i_size_read(inode_in))\n\t\treturn -EINVAL;\n\tret = mnt_want_write_file(file_out);\n\tif (ret)\n\t\treturn ret;\n\tret = file_in->f_op->clone_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len);\n\tif (!ret) {\n\t\tfsnotify_access(file_in);\n\t\tfsnotify_modify(file_out);\n\t}\n\tmnt_drop_write_file(file_out);\n\treturn ret;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static void mark_reg_unknown(struct bpf_verifier_env *env,\n\t\t\t     struct bpf_reg_state *regs, u32 regno)\n{\n\tif (WARN_ON(regno >= MAX_BPF_REG)) {\n\t\tverbose(env, \"mark_reg_unknown(regs, %u)\\n\", regno);\n\t\tfor (regno = 0; regno < BPF_REG_FP; regno++)\n\t\t\t__mark_reg_not_init(env, regs + regno);\n\t\treturn;\n\t}\n\t__mark_reg_unknown(env, regs + regno);\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "    **/\n    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {\n      return (pos<0 || pos>=(int)_width)?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);", "target": 0}
{"code": "try_flatedecode(unsigned char *buf, off_t real_len, off_t calculated_len, int fout, cli_ctx *ctx)\n{\n\tint ret = cli_checklimits(\"cli_pdf\", ctx, real_len, 0, 0);\n\tif (ret==CL_CLEAN && flatedecode(buf, real_len, fout, ctx) == CL_SUCCESS)\n\t\treturn CL_CLEAN;\n\tif(real_len == calculated_len) {\n\t\tcli_dbgmsg(\"cli_pdf: Bad compression in flate stream\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\tif(cli_checklimits(\"cli_pdf\", ctx, calculated_len, 0, 0)!=CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tret = flatedecode(buf, calculated_len, fout, ctx);\n\tif(ret == CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tcli_dbgmsg(\"cli_pdf: Bad compressed block length in flate stream\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "static void cma_leave_mc_groups(struct rdma_id_private *id_priv)\n{\n\tstruct cma_multicast *mc;\n\twhile (!list_empty(&id_priv->mc_list)) {\n\t\tmc = list_first_entry(&id_priv->mc_list, struct cma_multicast,\n\t\t\t\t      list);\n\t\tlist_del(&mc->list);\n\t\tdestroy_mc(id_priv, mc);\n\t}\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "blkid_loff_t blkid_parttable_get_offset(blkid_parttable tab)\n{\n\treturn (blkid_loff_t)tab->offset;\n}", "target": 0}
{"code": "ztype(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref tnref;\n    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);\n    if (code < 0)\n        return code;\n    if (!r_has_type(&tnref, t_name)) {\n         check_op(2);\n         {                       \n            if (op[-1].value.pstruct != 0x00) {\n             const char *sname =\n                 gs_struct_type_name_string(gs_object_type(imemory,\n                                                           op[-1].value.pstruct));\n            int code = name_ref(imemory, (const byte *)sname, strlen(sname),\n                                (ref *) (op - 1), 0);\n            if (code < 0)\n                return code;\n            } else\n                return_error(gs_error_stackunderflow);\n        }\n        r_set_attrs(op - 1, a_executable);\n    } else {\n        ref_assign(op - 1, &tnref);\n    }\n    pop(1);\n    return 0;\n}", "target": 1}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "int parse_sa_P_opt(char *argv[], int *opt, unsigned int *flags, struct activity *act[])\n{\n\tint p;\n\tp = get_activity_position(act, A_CPU, EXIT_IF_NOT_FOUND);\n\tif (argv[++(*opt)]) {\n\t\tif (parse_values(argv[*opt], act[p]->bitmap->b_array,\n\t\t\t     act[p]->bitmap->b_size, K_LOWERALL))\n\t\t\treturn 1;\n\t\t(*opt)++;\n\t\t*flags |= S_F_OPTION_P;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(sb))))\n\t\treturn;\n\ttrace_ext4_error(sb, function, line);\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\text4_unlock_group(sb, grp);\n\text4_commit_super(sb, 1);\n\text4_handle_error(sb);\n\text4_lock_group(sb, grp);\n\treturn;\n}", "target": 0}
{"code": "static bool ok_inflater_compressed_block(ok_inflater *inflater) {\n    const bool is_fixed = inflater->state == OK_INFLATER_STATE_READING_FIXED_COMPRESSED_BLOCK;\n    const ok_inflater_huffman_tree *literal_tree =\n        (is_fixed ? inflater->fixed_literal_huffman : inflater->literal_huffman);\n    const ok_inflater_huffman_tree *distance_tree =\n        (is_fixed ? inflater->fixed_distance_huffman : inflater->distance_huffman);\n    size_t max_write = ok_inflater_can_write_total(inflater);\n    const uint16_t *tree_lookup_table = literal_tree->lookup_table;\n    const unsigned int tree_bits = literal_tree->bits;\n    while (max_write > 0) {\n        int value = ok_inflater_decode_literal(inflater, tree_lookup_table, tree_bits);\n        if (value < 0) {\n            return false;\n        } else if (value < 256) {\n            ok_inflater_write_byte(inflater, (uint8_t)value);\n            max_write--;\n        } else if (value == 256) {\n            inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n            return true;\n        } else if (value < 286) {\n            inflater->huffman_code = value - 257;\n            inflater->state_count = -1;\n            inflater->state_distance = -1;\n            if (ok_inflater_distance_with_tree(inflater, distance_tree)) {\n                max_write = ok_inflater_can_write_total(inflater);\n            } else {\n                if (is_fixed) {\n                    inflater->state = OK_INFLATER_STATE_READING_FIXED_DISTANCE;\n                } else {\n                    inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE;\n                }\n                return false;\n            }\n        } else {\n            ok_inflater_error(inflater, \"Invalid inflater literal\");\n            return false;\n        }\n    }\n    return false;\n}", "target": 0}
{"code": "void HeaderUtility::stripPortFromHost(RequestHeaderMap& headers, uint32_t listener_port) {\n  if (headers.getMethodValue() == Http::Headers::get().MethodValues.Connect) {\n    return;\n  }\n  const absl::string_view original_host = headers.getHostValue();\n  const absl::string_view::size_type port_start = original_host.rfind(':');\n  if (port_start == absl::string_view::npos) {\n    return;\n  }\n  const auto v6_end_index = original_host.rfind(\"]\");\n  if (v6_end_index == absl::string_view::npos || v6_end_index < port_start) {\n    if ((port_start + 1) > original_host.size()) {\n      return;\n    }\n    const absl::string_view port_str = original_host.substr(port_start + 1);\n    uint32_t port = 0;\n    if (!absl::SimpleAtoi(port_str, &port)) {\n      return;\n    }\n    if (port != listener_port) {\n      return;\n    }\n    const absl::string_view host = original_host.substr(0, port_start);\n    headers.setHost(host);\n  }\n}", "target": 0}
{"code": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "archive_read_support_format_zip_streamable(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tstruct zip *zip;\n\tint r;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_zip\");\n\tzip = (struct zip *)calloc(1, sizeof(*zip));\n\tif (zip == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate zip data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tzip->process_mac_extensions = 0;\n\tzip->has_encrypted_entries = ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW;\n\tzip->crc32func = real_crc32;\n\tr = __archive_read_register_format(a,\n\t    zip,\n\t    \"zip\",\n\t    archive_read_format_zip_streamable_bid,\n\t    archive_read_format_zip_options,\n\t    archive_read_format_zip_streamable_read_header,\n\t    archive_read_format_zip_read_data,\n\t    archive_read_format_zip_read_data_skip_streamable,\n\t    NULL,\n\t    archive_read_format_zip_cleanup,\n\t    archive_read_support_format_zip_capabilities_streamable,\n\t    archive_read_format_zip_has_encrypted_entries);\n\tif (r != ARCHIVE_OK)\n\t\tfree(zip);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "gboolean tcmulib_callback(GIOChannel *source,\n\t\t\t  GIOCondition condition,\n\t\t\t  gpointer data)\n{\n\tstruct tcmulib_context *ctx = data;\n\ttcmulib_master_fd_ready(ctx);\n\treturn TRUE;\n}", "target": 0}
{"code": "void PDFiumEngine::Paint(const pp::Rect& rect,\n                         pp::ImageData* image_data,\n                         std::vector<pp::Rect>* ready,\n                         std::vector<pp::Rect>* pending) {\n  DCHECK(image_data);\n  DCHECK(ready);\n  DCHECK(pending);\n  pp::Rect leftover = rect;\n  for (size_t i = 0; i < visible_pages_.size(); ++i) {\n    int index = visible_pages_[i];\n    pp::Rect page_rect = pages_[index]->rect();\n    pp::Rect page_rect_in_screen = GetPageScreenRect(index);\n    pp::Rect dirty_in_screen = page_rect_in_screen.Intersect(leftover);\n    if (dirty_in_screen.IsEmpty())\n      continue;\n    if (i == 0) {\n      pp::Rect blank_space_in_screen = dirty_in_screen;\n      blank_space_in_screen.set_y(0);\n      blank_space_in_screen.set_height(dirty_in_screen.y());\n      leftover = leftover.Subtract(blank_space_in_screen);\n    }\n    leftover = leftover.Subtract(dirty_in_screen);\n    if (pages_[index]->available()) {\n      int progressive = GetProgressiveIndex(index);\n      if (progressive != -1) {\n        DCHECK_GE(progressive, 0);\n        DCHECK_LT(static_cast<size_t>(progressive), progressive_paints_.size());\n        if (progressive_paints_[progressive].rect != dirty_in_screen) {\n          pending->push_back(dirty_in_screen);\n          continue;\n        }\n      }\n      if (progressive == -1) {\n        progressive = StartPaint(index, dirty_in_screen);\n        progressive_paint_timeout_ = kMaxInitialProgressivePaintTimeMs;\n      } else {\n        progressive_paint_timeout_ = kMaxProgressivePaintTimeMs;\n      }\n      progressive_paints_[progressive].painted_ = true;\n      if (ContinuePaint(progressive, image_data)) {\n        FinishPaint(progressive, image_data);\n        ready->push_back(dirty_in_screen);\n      } else {\n        pending->push_back(dirty_in_screen);\n      }\n    } else {\n      PaintUnavailablePage(index, dirty_in_screen, image_data);\n      ready->push_back(dirty_in_screen);\n    }\n  }\n}", "target": 0}
{"code": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\nunlock:\n\trelease_sock(sk);\n\treturn err ?: len;\n}", "target": 1}
{"code": "static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){\n  int i;\n  Select *pNew;\n  Select *pX;\n  sqlite3 *db;\n  struct ExprList_item *a;\n  SrcList *pNewSrc;\n  Parse *pParse;\n  Token dummy;\n  if( p->pPrior==0 ) return WRC_Continue;\n  if( p->pOrderBy==0 ) return WRC_Continue;\n  for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}\n  if( pX==0 ) return WRC_Continue;\n  a = p->pOrderBy->a;\n  for(i=p->pOrderBy->nExpr-1; i>=0; i--){\n    if( a[i].pExpr->flags & EP_Collate ) break;\n  }\n  if( i<0 ) return WRC_Continue;\n  pParse = pWalker->pParse;\n  db = pParse->db;\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n  if( pNew==0 ) return WRC_Abort;\n  memset(&dummy, 0, sizeof(dummy));\n  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);\n  if( pNewSrc==0 ) return WRC_Abort;\n  *pNew = *p;\n  p->pSrc = pNewSrc;\n  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));\n  p->op = TK_SELECT;\n  p->pWhere = 0;\n  pNew->pGroupBy = 0;\n  pNew->pHaving = 0;\n  pNew->pOrderBy = 0;\n  p->pPrior = 0;\n  p->pNext = 0;\n  p->pWith = 0;\n  p->selFlags &= ~SF_Compound;\n  assert( (p->selFlags & SF_Converted)==0 );\n  p->selFlags |= SF_Converted;\n  assert( pNew->pPrior!=0 );\n  pNew->pPrior->pNext = pNew;\n  pNew->pLimit = 0;\n  return WRC_Continue;\n}", "target": 0}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT64) *(l_src_data++);\n                opj_write_double(l_dest_data,l_temp);\n                l_dest_data+=sizeof(OPJ_FLOAT64);\n        }\n}", "target": 0}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "ExprResolveEnum(struct xkb_context *ctx, const ExprDef *expr,\n                unsigned int *val_rtrn, const LookupEntry *values)\n{\n    if (expr->expr.op != EXPR_IDENT) {\n        log_err(ctx, \"Found a %s where an enumerated value was expected\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n    }\n    if (!SimpleLookup(ctx, values, expr->ident.ident, EXPR_TYPE_INT,\n                      val_rtrn)) {\n        log_err(ctx, \"Illegal identifier %s; expected one of:\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        while (values && values->name)\n        {\n            log_err(ctx, \"\\t%s\\n\", values->name);\n            values++;\n        }\n        return false;\n    }\n    return true;\n}", "target": 0}
{"code": " void HTMLFormControlElement::updateVisibleValidationMessage() {\n   Page* page = document().page();\n  if (!page)\n     return;\n   String message;\n   if (layoutObject() && willValidate())\n    message = validationMessage().stripWhiteSpace();\n  m_hasValidationMessage = true;\n  ValidationMessageClient* client = &page->validationMessageClient();\n  TextDirection messageDir = LTR;\n  TextDirection subMessageDir = LTR;\n  String subMessage = validationSubMessage().stripWhiteSpace();\n  if (message.isEmpty())\n    client->hideValidationMessage(*this);\n  else\n    findCustomValidationMessageTextDirection(message, messageDir, subMessage,\n                                             subMessageDir);\n  client->showValidationMessage(*this, message, messageDir, subMessage,\n                                subMessageDir);\n}", "target": 1}
{"code": "static int md_domain_init(struct dmar_domain *domain, int guest_width)\n{\n\tint adjust_width;\n\tinit_iova_domain(&domain->iovad, VTD_PAGE_SIZE, IOVA_START_PFN);\n\tdomain_reserve_special_ranges(domain);\n\tdomain->gaw = guest_width;\n\tadjust_width = guestwidth_to_adjustwidth(guest_width);\n\tdomain->agaw = width_to_agaw(adjust_width);\n\tdomain->iommu_coherency = 0;\n\tdomain->iommu_snooping = 0;\n\tdomain->iommu_superpage = 0;\n\tdomain->max_addr = 0;\n\tdomain->pgd = (struct dma_pte *)alloc_pgtable_page(domain->nid);\n\tif (!domain->pgd)\n\t\treturn -ENOMEM;\n\tdomain_flush_cache(domain, domain->pgd, PAGE_SIZE);\n\treturn 0;\n}", "target": 0}
{"code": "static int io_wqe_worker(void *data)\n{\n\tstruct io_worker *worker = data;\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tstruct io_wq *wq = wqe->wq;\n\tbool last_timeout = false;\n\tchar buf[TASK_COMM_LEN];\n\tworker->flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);\n\tsnprintf(buf, sizeof(buf), \"iou-wrk-%d\", wq->task->pid);\n\tset_task_comm(current, buf);\n\twhile (!test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\tlong ret;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\nloop:\n\t\traw_spin_lock(&wqe->lock);\n\t\tif (io_acct_run_queue(acct)) {\n\t\t\tio_worker_handle_work(worker);\n\t\t\tgoto loop;\n\t\t}\n\t\tif (last_timeout && acct->nr_workers > 1) {\n\t\t\traw_spin_unlock(&wqe->lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tlast_timeout = false;\n\t\t__io_worker_idle(wqe, worker);\n\t\traw_spin_unlock(&wqe->lock);\n\t\tif (io_flush_signals())\n\t\t\tcontinue;\n\t\tret = schedule_timeout(WORKER_IDLE_TIMEOUT);\n\t\tif (signal_pending(current)) {\n\t\t\tstruct ksignal ksig;\n\t\t\tif (!get_signal(&ksig))\n\t\t\t\tcontinue;\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tlast_timeout = !ret;\n\t}\n\tif (test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\traw_spin_lock(&wqe->lock);\n\t\tio_worker_handle_work(worker);\n\t}\n\tio_worker_exit(worker);\n\treturn 0;\n}", "target": 0}
{"code": "send_client_notifications (void)\n{\n  struct {\n    pid_t pid;\n#ifdef HAVE_W32_SYSTEM\n    HANDLE handle;\n#else\n    int signo;\n#endif\n  } killed[50];\n  int killidx = 0;\n  int kidx;\n  struct server_local_s *sl;\n  for (sl=session_list; sl; sl = sl->next_session)\n    {\n      if (sl->event_signal && sl->assuan_ctx)\n        {\n          pid_t pid = assuan_get_pid (sl->assuan_ctx);\n#ifdef HAVE_W32_SYSTEM\n          HANDLE handle = (void *)sl->event_signal;\n          for (kidx=0; kidx < killidx; kidx++)\n            if (killed[kidx].pid == pid\n                && killed[kidx].handle == handle)\n              break;\n          if (kidx < killidx)\n            log_info (\"event %lx (%p) already triggered for client %d\\n\",\n                      sl->event_signal, handle, (int)pid);\n          else\n            {\n              log_info (\"triggering event %lx (%p) for client %d\\n\",\n                        sl->event_signal, handle, (int)pid);\n              if (!SetEvent (handle))\n                log_error (\"SetEvent(%lx) failed: %s\\n\",\n                           sl->event_signal, w32_strerror (-1));\n              if (killidx < DIM (killed))\n                {\n                  killed[killidx].pid = pid;\n                  killed[killidx].handle = handle;\n                  killidx++;\n                }\n            }\n#else \n          int signo = sl->event_signal;\n          if (pid != (pid_t)(-1) && pid && signo > 0)\n            {\n              for (kidx=0; kidx < killidx; kidx++)\n                if (killed[kidx].pid == pid\n                    && killed[kidx].signo == signo)\n                  break;\n              if (kidx < killidx)\n                log_info (\"signal %d already sent to client %d\\n\",\n                          signo, (int)pid);\n              else\n                {\n                  log_info (\"sending signal %d to client %d\\n\",\n                            signo, (int)pid);\n                  kill (pid, signo);\n                  if (killidx < DIM (killed))\n                    {\n                      killed[killidx].pid = pid;\n                      killed[killidx].signo = signo;\n                      killidx++;\n                    }\n                }\n            }\n#endif \n        }\n    }\n}", "target": 0}
{"code": "_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n    D((\"Called.\"));\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n    D((\"Config file name is: %s\", file));\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n      _clean_var(var);\n    }  \n    (void) fclose(conf);\n    _clean_var(var);        \n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}", "target": 0}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\tif (start < 0)\n\t\tstart = 0;\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\tif (end < 0)\n\t\tend = 0;\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\tcount = vgacon_scrollback_cur->cnt - start;\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\tif (count) {\n\t\tint copysize;\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\t\tcount *= c->vc_size_row;\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}", "target": 1}
{"code": "static int vhost_worker(void *data)\n{\n\tstruct vhost_dev *dev = data;\n\tstruct vhost_work *work = NULL;\n\tunsigned uninitialized_var(seq);\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(USER_DS);\n\tuse_mm(dev->mm);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\twork->done_seq = seq;\n\t\t\tif (work->flushing)\n\t\t\t\twake_up_all(&work->done);\n\t\t}\n\t\tif (kthread_should_stop()) {\n\t\t\tspin_unlock_irq(&dev->work_lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tif (!list_empty(&dev->work_list)) {\n\t\t\twork = list_first_entry(&dev->work_list,\n\t\t\t\t\t\tstruct vhost_work, node);\n\t\t\tlist_del_init(&work->node);\n\t\t\tseq = work->queue_seq;\n\t\t} else\n\t\t\twork = NULL;\n\t\tspin_unlock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\twork->fn(work);\n\t\t\tif (need_resched())\n\t\t\t\tschedule();\n\t\t} else\n\t\t\tschedule();\n\t}\n\tunuse_mm(dev->mm);\n\tset_fs(oldfs);\n\treturn 0;\n}", "target": 0}
{"code": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}", "target": 1}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}", "target": 0}
{"code": "static void bpf_map_ptr_store(struct bpf_insn_aux_data *aux,\n\t\t\t      const struct bpf_map *map, bool unpriv)\n{\n\tBUILD_BUG_ON((unsigned long)BPF_MAP_PTR_POISON & BPF_MAP_PTR_UNPRIV);\n\tunpriv |= bpf_map_ptr_unpriv(aux);\n\taux->map_ptr_state = (unsigned long)map |\n\t\t\t     (unpriv ? BPF_MAP_PTR_UNPRIV : 0UL);\n}", "target": 0}
{"code": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}", "target": 1}
{"code": "static void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}", "target": 0}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "bool task_blocks_signal(pid_t pid, int signal)\n{\n\tint ret;\n\tchar status[__PROC_STATUS_LEN];\n\tFILE *f;\n\tuint64_t sigblk = 0, one = 1;\n\tsize_t n = 0;\n\tbool bret = false;\n\tchar *line = NULL;\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\t\tif (strncmp(line, \"SigBlk:\", 7))\n\t\t\tcontinue;\n\t\tnumstr = lxc_trim_whitespace_in_place(line + 7);\n\t\tret = lxc_safe_uint64(numstr, &sigblk, 16);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (sigblk & (one << (signal - 1)))\n\t\tbret = true;\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}", "target": 0}
{"code": "bool ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk) {\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tif (skb2)\n\t\t\tping_queue_rcv_skb(sk, skb2);\n\t\tsock_put(sk);\n\t\treturn true;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\treturn false;\n}", "target": 0}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}", "target": 1}
{"code": "TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)\n{\n\tuint64 m;\n\tassert(sizeof(uint64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedLong8\",\"LONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,1,8,&m));\n}", "target": 0}
{"code": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}", "target": 0}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "PassRefPtr<Attr> Element::setAttributeNode(Attr* attrNode, ExceptionCode& ec)\n{\n    if (!attrNode) {\n        ec = TYPE_MISMATCH_ERR;\n        return 0;\n    }\n    RefPtr<Attr> oldAttrNode = attrIfExists(attrNode->qualifiedName());\n    if (oldAttrNode.get() == attrNode)\n        return attrNode; \n    if (attrNode->ownerElement()) {\n        ec = INUSE_ATTRIBUTE_ERR;\n        return 0;\n    }\n    synchronizeAllAttributes();\n    UniqueElementData* elementData = ensureUniqueElementData();\n    size_t index = elementData->getAttributeItemIndex(attrNode->qualifiedName());\n    if (index != notFound) {\n        if (oldAttrNode)\n            detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData->attributeItem(index)->value());\n        else\n            oldAttrNode = Attr::create(document(), attrNode->qualifiedName(), elementData->attributeItem(index)->value());\n    }\n     setAttributeInternal(index, attrNode->qualifiedName(), attrNode->value(), NotInSynchronizationOfLazyAttribute);\n     attrNode->attachToElement(this);\n     ensureAttrNodeListForElement(this)->append(attrNode);\n     return oldAttrNode.release();\n}", "target": 1}
{"code": "void XMLTokenizer::endElementNs()\n{\n    if (m_parserStopped)\n        return;\n    if (m_parserPaused) {\n        m_pendingCallbacks->appendEndElementNSCallback();\n        return;\n    }\n    exitText();\n    Node* n = m_currentNode;\n    RefPtr<Node> parent = n->parentNode();\n    n->finishParsingChildren();\n    if (!n->isElementNode() || !m_view) {\n        setCurrentNode(parent.get());\n        return;\n    }\n    Element* element = static_cast<Element*>(n);\n    ScriptElement* scriptElement = toScriptElement(element);\n    if (!scriptElement) {\n        setCurrentNode(parent.get());\n        return;\n    }\n    ASSERT(!m_pendingScript);\n    m_requestingScript = true;\n    String scriptHref = scriptElement->sourceAttributeValue();\n    if (!scriptHref.isEmpty()) {\n        String scriptCharset = scriptElement->scriptCharset();\n        if ((m_pendingScript = m_doc->docLoader()->requestScript(scriptHref, scriptCharset))) {\n            m_scriptElement = element;\n            m_pendingScript->addClient(this);\n            if (m_pendingScript)\n                pauseParsing();\n        } else \n            m_scriptElement = 0;\n    } else\n        m_view->frame()->loader()->executeScript(ScriptSourceCode(scriptElement->scriptContent(), m_doc->url(), m_scriptStartLine));\n    m_requestingScript = false;\n    setCurrentNode(parent.get());\n}", "target": 0}
{"code": "static int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\trcu_read_lock();\n\tif (!lock_task_sighand(task,&flags)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\trcu_read_unlock();\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\treturn count;\n}", "target": 0}
{"code": "MenuCacheNotifyId menu_cache_add_reload_notify(MenuCache* cache, MenuCacheReloadNotify func, gpointer user_data)\n{\n    GSList* l = g_slist_alloc();\n    CacheReloadNotifier* n = g_slice_new(CacheReloadNotifier);\n    gboolean is_first;\n    n->func = func;\n    n->user_data = user_data;\n    l->data = n;\n    MENU_CACHE_LOCK;\n    is_first = (cache->root_dir == NULL && cache->notifiers == NULL);\n    cache->notifiers = g_slist_concat( cache->notifiers, l );\n    if(is_first && cache->reload_id == 0)\n        cache->reload_id = g_idle_add_full(G_PRIORITY_HIGH_IDLE,\n                                           menu_cache_reload_idle,\n                                           menu_cache_ref(cache),\n                                           (GDestroyNotify)menu_cache_unref);\n    MENU_CACHE_UNLOCK;\n    return (MenuCacheNotifyId)l;\n}", "target": 0}
{"code": "regional_alloc(struct regional *r, size_t size)\n{\n\tsize_t a = ALIGN_UP(size, ALIGNMENT);\n\tvoid *s;\n\tif(a > REGIONAL_LARGE_OBJECT_SIZE) {\n\t\ts = malloc(ALIGNMENT + size);\n\t\tif(!s) return NULL;\n\t\tr->total_large += ALIGNMENT+size;\n\t\t*(char**)s = r->large_list;\n\t\tr->large_list = (char*)s;\n\t\treturn (char*)s+ALIGNMENT;\n\t}\n\tif(a > r->available) {\n\t\ts = malloc(REGIONAL_CHUNK_SIZE);\n\t\tif(!s) return NULL;\n\t\t*(char**)s = r->next;\n\t\tr->next = (char*)s;\n\t\tr->data = (char*)s + ALIGNMENT;\n\t\tr->available = REGIONAL_CHUNK_SIZE - ALIGNMENT;\n\t}\n\tr->available -= a;\n\ts = r->data;\n\tr->data += a;\n\treturn s;\n}", "target": 1}
{"code": "void btrfs_assign_next_active_device(struct btrfs_device *device,\n\t\t\t\t     struct btrfs_device *this_dev)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_device *next_device;\n\tif (this_dev)\n\t\tnext_device = this_dev;\n\telse\n\t\tnext_device = btrfs_find_next_active_device(fs_info->fs_devices,\n\t\t\t\t\t\t\t\tdevice);\n\tASSERT(next_device);\n\tif (fs_info->sb->s_bdev &&\n\t\t\t(fs_info->sb->s_bdev == device->bdev))\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n}", "target": 0}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": " void DevToolsWindow::InspectedContentsClosing() {\n   web_contents_->GetRenderViewHost()->ClosePage();\n }", "target": 1}
{"code": "static int sanitize_err(struct bpf_verifier_env *env,\n\t\t\tconst struct bpf_insn *insn, int reason,\n\t\t\tconst struct bpf_reg_state *off_reg,\n\t\t\tconst struct bpf_reg_state *dst_reg)\n{\n\tstatic const char *err = \"pointer arithmetic with it prohibited for !root\";\n\tconst char *op = BPF_OP(insn->code) == BPF_ADD ? \"add\" : \"sub\";\n\tu32 dst = insn->dst_reg, src = insn->src_reg;\n\tswitch (reason) {\n\tcase REASON_BOUNDS:\n\t\tverbose(env, \"R%d has unknown scalar with mixed signed bounds, %s\\n\",\n\t\t\toff_reg == dst_reg ? dst : src, err);\n\t\tbreak;\n\tcase REASON_TYPE:\n\t\tverbose(env, \"R%d has pointer with unsupported alu operation, %s\\n\",\n\t\t\toff_reg == dst_reg ? src : dst, err);\n\t\tbreak;\n\tcase REASON_PATHS:\n\t\tverbose(env, \"R%d tried to %s from different maps, paths or scalars, %s\\n\",\n\t\t\tdst, op, err);\n\t\tbreak;\n\tcase REASON_LIMIT:\n\t\tverbose(env, \"R%d tried to %s beyond pointer bounds, %s\\n\",\n\t\t\tdst, op, err);\n\t\tbreak;\n\tcase REASON_STACK:\n\t\tverbose(env, \"R%d could not be pushed for speculative verification, %s\\n\",\n\t\t\tdst, err);\n\t\tbreak;\n\tdefault:\n\t\tverbose(env, \"verifier internal error: unknown reason (%d)\\n\",\n\t\t\treason);\n\t\tbreak;\n\t}\n\treturn -EACCES;\n}", "target": 0}
{"code": "sasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "device_drive_poll_media_authorized_cb (Daemon *daemon,\n                                       Device *device,\n                                       DBusGMethodInvocation *context,\n                                       const gchar *action_id,\n                                       guint num_user_data,\n                                       gpointer *user_data_elements)\n{\n  int n;\n  char *argv[16];\n  n = 0;\n  argv[n++] = \"udisks-helper-drive-poll\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  if (!job_new (context, \"DrivePollMedia\", FALSE, device, argv, NULL, drive_poll_media_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "yang_check_rpc_action(struct lys_module *module, struct lys_node_rpc_action *rpc, struct lys_node **child,\n                      int options, struct unres_schema *unres)\n{\n    struct lys_node *node;\n    if (rpc->nodetype == LYS_ACTION) {\n        for (node = rpc->parent; node; node = lys_parent(node)) {\n            if ((node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF))\n                    || ((node->nodetype == LYS_LIST) && !((struct lys_node_list *)node)->keys)) {\n                LOGVAL(module->ctx, LYE_INPAR, LY_VLOG_LYS, rpc->parent, strnodetype(node->nodetype), \"action\");\n                goto error;\n            }\n        }\n    }\n    if (yang_check_typedef(module, (struct lys_node *)rpc, unres)) {\n        goto error;\n    }\n    if (yang_check_iffeatures(module, NULL, rpc, RPC_KEYWORD, unres)) {\n        goto error;\n    }\n    if (yang_check_nodes(module, (struct lys_node *)rpc, *child, options | LYS_PARSE_OPT_CFG_IGNORE, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static void sigchld_reaper(void) {\n\tWAIT_T waiter;\n\tPID_T pid;\n\tdo {\n\t\tpid = waitpid(-1, &waiter, WNOHANG);\n\t\tswitch (pid) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no children\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tcase 0:\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no dead kids\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tDebug(DPROC,\n\t\t\t\t(\"[%ld] sigchld...pid #%ld died, stat=%d\\n\",\n\t\t\t\t\t(long) getpid(), (long) pid, WEXITSTATUS(waiter)))\n\t\t\t\tbreak;\n\t\t}\n\t} while (pid > 0);\n}", "target": 0}
{"code": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct inode *inode;\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\terror = ERR_PTR(-ENOENT);\n\tinode = NULL;\n\tif (!task)\n\t\tgoto out_no_task;\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}", "target": 0}
{"code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\treturn prop;\n}", "target": 1}
{"code": "sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)\n{\n\tsg_io_hdr_t *hp = &srp->header;\n\tint err = 0, err2;\n\tint len;\n\tif (in_compat_syscall()) {\n\t\tif (count < sizeof(struct compat_sg_io_hdr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (count < SZ_SG_IO_HDR) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\thp->sb_len_wr = 0;\n\tif ((hp->mx_sb_len > 0) && hp->sbp) {\n\t\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t\t    (DRIVER_SENSE & hp->driver_status)) {\n\t\t\tint sb_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tsb_len = (hp->mx_sb_len > sb_len) ? sb_len : hp->mx_sb_len;\n\t\t\tlen = 8 + (int) srp->sense_b[7];\t\n\t\t\tlen = (len > sb_len) ? sb_len : len;\n\t\t\tif (copy_to_user(hp->sbp, srp->sense_b, len)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thp->sb_len_wr = len;\n\t\t}\n\t}\n\tif (hp->masked_status || hp->host_status || hp->driver_status)\n\t\thp->info |= SG_INFO_CHECK;\n\terr = put_sg_io_hdr(hp, buf);\nerr_out:\n\terr2 = sg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\treturn err ? : err2 ? : count;\n}", "target": 0}
{"code": "static char *exif_get_sectionlist(int sectionlist)\n{\n\tint i, len, ml = 0;\n\tchar *sections;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tml += strlen(exif_get_sectionname(i))+2;\n\t}\n\tsections = safe_emalloc(ml, 1, 1);\n\tsections[0] = '\\0';\n\tlen = 0;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tif (sectionlist&(1<<i)) {\n\t\t\tsnprintf(sections+len, ml-len, \"%s, \", exif_get_sectionname(i));\n\t\t\tlen = strlen(sections);\n\t\t}\n\t}\n\tif (len>2)\n\t\tsections[len-2] = '\\0';\n\treturn sections;\n}", "target": 0}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void spl_pqueue_it_get_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC) \n{\n\tspl_heap_it  *iterator = (spl_heap_it *)iter;\n\tzval        **element  = (zval **)&iterator->object->heap->elements[0];\n\tif (iterator->object->heap->flags & SPL_HEAP_CORRUPTED) {\n\t\tzend_throw_exception(spl_ce_RuntimeException, \"Heap is corrupted, heap properties are no longer ensured.\", 0 TSRMLS_CC);\n\t\treturn;\n\t}\n\tif (iterator->object->heap->count == 0 || !*element) {\n\t\t*data = NULL;\n\t} else {\n\t\t*data = spl_pqueue_extract_helper(element, iterator->object->flags);\n\t\tif (!*data) {\n\t\t\tzend_error(E_RECOVERABLE_ERROR, \"Unable to extract from the PriorityQueue node\");\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\treturn -EINVAL;\n\tif (!error)\n\t\terror = size;\n\treturn error;\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "int unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n        assert(n);\n        assert(ret);\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n        assert_se(p);\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 0}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "static void io_init_new_worker(struct io_wqe *wqe, struct io_worker *worker,\n\t\t\t       struct task_struct *tsk)\n{\n\ttsk->pf_io_worker = worker;\n\tworker->task = tsk;\n\tset_cpus_allowed_ptr(tsk, wqe->cpu_mask);\n\ttsk->flags |= PF_NO_SETAFFINITY;\n\traw_spin_lock(&wqe->lock);\n\thlist_nulls_add_head_rcu(&worker->nulls_node, &wqe->free_list);\n\tlist_add_tail_rcu(&worker->all_list, &wqe->all_list);\n\tworker->flags |= IO_WORKER_F_FREE;\n\traw_spin_unlock(&wqe->lock);\n\twake_up_new_task(tsk);\n}", "target": 0}
{"code": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\treturn 0;\n}", "target": 1}
{"code": "static unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\trv = ldisc_data->buf;\n\tmb();\n\tldisc_data->buf_free = true;\n\ttty_schedule_flip(speakup_tty->port);\n\treturn rv;\n}", "target": 0}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n {\n \tstruct snd_msnd *chip = dev_id;\n \tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n \t}\n \tinb(chip->io + HP_RXL);\n \treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "njs_string_prototype_match(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_str_t             string;\n    njs_int_t             ret;\n    njs_value_t           arguments[2];\n    njs_regexp_pattern_t  *pattern;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arguments[1] = args[0];\n    string.start = NULL;\n    string.length = 0;\n    if (nargs > 1) {\n        if (njs_is_regexp(&args[1])) {\n            pattern = njs_regexp_pattern(&args[1]);\n            if (pattern->global) {\n                return njs_string_match_multiple(vm, args, pattern);\n            }\n            arguments[0] = args[1];\n            goto match;\n        }\n        if (!njs_is_string(&args[1])) {\n            if (!njs_is_undefined(&args[1])) {\n                ret = njs_value_to_string(vm, &args[1], &args[1]);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n                njs_string_get(&args[1], &string);\n            }\n        } else {\n            njs_string_get(&args[1], &string);\n        }\n    }\n    ret = njs_regexp_create(vm, &arguments[0], string.start, string.length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\nmatch:\n    return njs_regexp_prototype_exec(vm, arguments, nargs, unused);\n}", "target": 0}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "static handler_t mod_wstunnel_check_extension(request_st * const r, void *p_d) {\n    plugin_data *p = p_d;\n    handler_t rc;\n    if (NULL != r->handler_module)\n        return HANDLER_GO_ON;\n  if (r->http_version > HTTP_VERSION_1_1) {\n    if (!r->h2_connect_ext)\n        return HANDLER_GO_ON;\n  }\n  else {\n    if (r->http_method != HTTP_METHOD_GET)\n        return HANDLER_GO_ON;\n    if (r->http_version != HTTP_VERSION_1_1)\n        return HANDLER_GO_ON;\n    const buffer *vb;\n    vb = http_header_request_get(r, HTTP_HEADER_UPGRADE, CONST_STR_LEN(\"Upgrade\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"websocket\")))\n        return HANDLER_GO_ON;\n    vb = http_header_request_get(r, HTTP_HEADER_CONNECTION, CONST_STR_LEN(\"Connection\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"upgrade\")))\n        return HANDLER_GO_ON;\n  }\n    mod_wstunnel_patch_config(r, p);\n    if (NULL == p->conf.gw.exts) return HANDLER_GO_ON;\n    rc = gw_check_extension(r, (gw_plugin_data *)p, 1, sizeof(handler_ctx));\n    return (HANDLER_GO_ON == rc && r->handler_module == p->self)\n      ? wstunnel_handler_setup(r, p)\n      : rc;\n}", "target": 0}
{"code": "get_head_value_node(Node* node, int exact, regex_t* reg)\n{\n  Node* n = NULL_NODE;\n  switch (NTYPE(node)) {\n  case NT_BREF:\n  case NT_ALT:\n  case NT_CANY:\n#ifdef USE_SUBEXP_CALL\n  case NT_CALL:\n#endif\n    break;\n  case NT_CTYPE:\n  case NT_CCLASS:\n    if (exact == 0) {\n      n = node;\n    }\n    break;\n  case NT_LIST:\n    n = get_head_value_node(NCAR(node), exact, reg);\n    break;\n  case NT_STR:\n    {\n      StrNode* sn = NSTR(node);\n      if (sn->end <= sn->s)\n\tbreak;\n      if (exact != 0 &&\n\t  !NSTRING_IS_RAW(node) && IS_IGNORECASE(reg->options)) {\n      }\n      else {\n\tn = node;\n      }\n    }\n    break;\n  case NT_QTFR:\n    {\n      QtfrNode* qn = NQTFR(node);\n      if (qn->lower > 0) {\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n\tif (IS_NOT_NULL(qn->head_exact))\n\t  n = qn->head_exact;\n\telse\n#endif\n\t  n = get_head_value_node(qn->target, exact, reg);\n      }\n    }\n    break;\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n      switch (en->type) {\n      case ENCLOSE_OPTION:\n\t{\n\t  OnigOptionType options = reg->options;\n\t  reg->options = NENCLOSE(node)->option;\n\t  n = get_head_value_node(NENCLOSE(node)->target, exact, reg);\n\t  reg->options = options;\n\t}\n\tbreak;\n      case ENCLOSE_MEMORY:\n      case ENCLOSE_STOP_BACKTRACK:\n      case ENCLOSE_CONDITION:\n\tn = get_head_value_node(en->target, exact, reg);\n\tbreak;\n      }\n    }\n    break;\n  case NT_ANCHOR:\n    if (NANCHOR(node)->type == ANCHOR_PREC_READ)\n      n = get_head_value_node(NANCHOR(node)->target, exact, reg);\n    break;\n  default:\n    break;\n  }\n  return n;\n}", "target": 0}
{"code": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}", "target": 1}
{"code": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1}
{"code": "\tZEND_ME(exception, __toString, NULL, 0)\n\t{NULL, NULL, NULL}", "target": 0}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserialize(\n  folly::StringPiece serialized) {\n  FBUnserializer<V> unserializer(serialized);\n  return unserializer.unserializeThing();\n}", "target": 1}
{"code": "static int fsmBackup(int dirfd, rpmfi fi, rpmFileAction action)\n{\n    int rc = 0;\n    const char *suffix = NULL;\n    if (!(rpmfiFFlags(fi) & RPMFILE_GHOST)) {\n\tswitch (action) {\n\tcase FA_SAVE:\n\t    suffix = SUFFIX_RPMSAVE;\n\t    break;\n\tcase FA_BACKUP:\n\t    suffix = SUFFIX_RPMORIG;\n\t    break;\n\tdefault:\n\t    break;\n\t}\n    }\n    if (suffix) {\n\tchar * opath = fsmFsPath(fi, NULL);\n\tchar * path = fsmFsPath(fi, suffix);\n\trc = fsmRename(dirfd, opath, dirfd, path);\n\tif (!rc) {\n\t    rpmlog(RPMLOG_WARNING, _(\"%s saved as %s\\n\"), opath, path);\n\t}\n\tfree(path);\n\tfree(opath);\n    }\n    return rc;\n}", "target": 0}
{"code": "elg_get_info( int algo, int *npkey, int *nskey, int *nenc, int *nsig,\n\t\t\t\t\t\t\t int *use )\n{\n    *npkey = 3;\n    *nskey = 4;\n    *nenc = 2;\n    *nsig = 2;\n    switch( algo ) {\n      case PUBKEY_ALGO_ELGAMAL_E:\n\t*use = PUBKEY_USAGE_ENC;\n\treturn \"ELG-E\";\n      default: *use = 0; return NULL;\n    }\n}", "target": 0}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "yang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { \n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "static void do_change_user(FILE *fin, FILE *fout) {\n  char uname[BUFFER_SIZE];\n  read_buf(fin, uname);\n  if (strlen(uname) > 0) {\n    struct passwd *pw = getpwnam(uname);\n    if (pw) {\n      if (pw->pw_gid) {\n        setgid(pw->pw_gid);\n      }\n      if (pw->pw_uid) {\n        setuid(pw->pw_uid);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "allocateSpaceInTable (FileInfo * nested, TranslationTableOffset * offset,\n\t\t      int count)\n{\n  int spaceNeeded = ((count + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n  TranslationTableOffset size = tableUsed + spaceNeeded;\n  if (size > tableSize)\n    {\n      void *newTable;\n      size += (size / OFFSETSIZE);\n      newTable = realloc (table, size);\n      if (!newTable)\n\t{\n\t  compileError (nested, \"Not enough memory for translation table.\");\n\t  outOfMemory ();\n\t}\n      memset (((unsigned char *) newTable) + tableSize, 0, size - tableSize);\n      {\n\tChainEntry *entry;\n\tfor (entry = tableChain; entry != NULL; entry = entry->next)\n\t  if (entry->table == table)\n\t    entry->table = (TranslationTableHeader *) newTable;\n      }\n      table = (TranslationTableHeader *) newTable;\n      tableSize = size;\n    }\n  if (offset != NULL)\n    {\n      *offset = (tableUsed - sizeof (*table)) / OFFSETSIZE;\n      tableUsed += spaceNeeded;\n    }\n  return 1;\n}", "target": 0}
{"code": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\tBUG_ON(sig == -1);\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\tdo_notify_pidfd(tsk);\n\tif (sig != SIGCHLD) {\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\treturn autoreap;\n}", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\twrite_metapage(mp);\n\tIREAD_UNLOCK(ipbmap);\n\treturn (0);\n}", "target": 1}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": " static void tokenadd(struct jv_parser* p, char c) {\n   assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n     p->tokenlen = p->tokenlen*2 + 256;\n     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n   }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {\n  check_prohibited_package(name(), loader_data, CHECK);\n  TempNewSymbol pkg_name = package_from_name(name(), CHECK);\n  if (pkg_name != NULL && loader_data != NULL) {\n    _package_entry = loader_data->packages()->lookup_only(pkg_name);\n    if (_package_entry == NULL) {\n      ResourceMark rm;\n      if (!ModuleEntryTable::javabase_defined()) {\n        assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME \" module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());\n      } else {\n        assert(loader_data->unnamed_module() != NULL, \"unnamed module is NULL\");\n        _package_entry = loader_data->packages()->lookup(pkg_name,\n                                                         loader_data->unnamed_module());\n      }\n      assert(_package_entry != NULL, \"Package entry for class %s not found, loader %s\",\n             name()->as_C_string(), loader_data->loader_name_and_id());\n    }\n    if (log_is_enabled(Debug, module)) {\n      ResourceMark rm;\n      ModuleEntry* m = _package_entry->module();\n      log_trace(module)(\"Setting package: class: %s, package: %s, loader: %s, module: %s\",\n                        external_name(),\n                        pkg_name->as_C_string(),\n                        loader_data->loader_name_and_id(),\n                        (m->is_named() ? m->name()->as_C_string() : UNNAMED_MODULE));\n    }\n  } else {\n    ResourceMark rm;\n    log_trace(module)(\"Setting package: class: %s, package: unnamed, loader: %s, module: %s\",\n                      external_name(),\n                      (loader_data != NULL) ? loader_data->loader_name_and_id() : \"NULL\",\n                      UNNAMED_MODULE);\n  }\n}", "target": 0}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}", "target": 0}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "\tZIPARCHIVE_ME(getStream,\t\t\targinfo_ziparchive_getstream, ZEND_ACC_PUBLIC)\n\t{NULL, NULL, NULL}", "target": 0}
{"code": "xsltCompilerVarInfoFree(xsltCompilerCtxtPtr cctxt)\n{\n    xsltVarInfoPtr ivar = cctxt->ivars, ivartmp;    \n    while (ivar) {\n\tivartmp = ivar;\n\tivar = ivar->next;\n\txmlFree(ivartmp);\n    }\n}", "target": 0}
{"code": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n    \" test_filename = %s\\n\",\n    inParam.base_filename, inParam.test_filename);\n  printf(\"************************* \\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.base_filename);\n  if((fbase = fopen(inParam.base_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }\n    }\n  same = 1;\n  printf(\"\\n***** TEST SUCCEED: Files are the same. *****\\n\");\ncleanup:\n  if(fbase) fclose(fbase);\n  if(ftest) fclose(ftest);\n  free(inParam.base_filename);\n  free(inParam.test_filename);\n  return same ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr && sz >= offset) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}", "target": 1}
{"code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n  if (child && returnName) {\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *proto = jsvNewObject();\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n  return child;\n}", "target": 1}
{"code": "static void cfg_free_opt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tfor (i = 0; opts[i].name; ++i) {\n\t\tfree((void *)opts[i].name);\n\t\tif (opts[i].comment)\n\t\t\tfree(opts[i].comment);\n\t\tif (opts[i].def.parsed)\n\t\t\tfree(opts[i].def.parsed);\n\t\tif (opts[i].def.string)\n\t\t\tfree((void *)opts[i].def.string);\n\t\tif (opts[i].subopts)\n\t\t\tcfg_free_opt_array(opts[i].subopts);\n\t}\n\tfree(opts);\n}", "target": 0}
{"code": "static char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\treturn 'E';\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\tNFS_PROTO(data->inode)->commit_setup(data, &msg);\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}", "target": 0}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsValid(const PrintMsg_Print_Params& params) {\n  return !params.content_size.IsEmpty() && !params.page_size.IsEmpty() &&\n         !params.printable_area.IsEmpty() && params.document_cookie &&\n         params.desired_dpi && params.max_shrink && params.min_shrink &&\n         params.dpi && (params.margin_top >= 0) && (params.margin_left >= 0) &&\n         params.dpi > kMinDpi && params.document_cookie != 0;\n}", "target": 0}
{"code": "void RenderView::didReceiveResponse(\n    WebFrame* frame, unsigned identifier, const WebURLResponse& response) {\n  SiteIsolationMetrics::LogMimeTypeForCrossOriginRequest(frame,\n                                                         identifier,\n                                                         response);\n  if (!frame->provisionalDataSource() || frame->parent())\n    return;\n  if (frame->isViewSourceModeEnabled())\n    return;\n  NavigationState* navigation_state =\n      NavigationState::FromDataSource(frame->provisionalDataSource());\n  CHECK(navigation_state);\n  navigation_state->set_was_fetched_via_spdy(response.wasFetchedViaSPDY());\n  navigation_state->set_was_npn_negotiated(response.wasNpnNegotiated());\n  navigation_state->set_was_alternate_protocol_available(\n      response.wasAlternateProtocolAvailable());\n  navigation_state->set_was_fetched_via_proxy(response.wasFetchedViaProxy());\n  if (response.httpStatusCode() != 404)\n    return;\n  if (!GetAlternateErrorPageURL(response.url(), HTTP_404).is_valid())\n    return;\n  navigation_state->set_postpone_loading_data(true);\n  navigation_state->clear_postponed_data();\n}", "target": 0}
{"code": "static inline void CheckEventLogging()\n{\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}", "target": 1}
{"code": "bool PrintWebViewHelper::CopyAndPrint(WebKit::WebFrame* web_frame) {\n  WebPreferences prefs = render_view()->GetWebkitPreferences();\n  prefs.javascript_enabled = false;\n  prefs.java_enabled = false;\n  print_web_view_ = WebView::create(this);\n  prefs.Apply(print_web_view_);\n  print_web_view_->initializeMainFrame(this);\n  print_pages_params_->pages.clear();  \n  std::string html = web_frame->selectionAsMarkup().utf8();\n  std::string url_str = \"data:text/html;charset=utf-8,\";\n  url_str.append(html);\n  GURL url(url_str);\n  print_web_view_->mainFrame()->loadRequest(WebURLRequest(url));\n  return true;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}", "target": 1}
{"code": "void ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\tif (si != NULL) {\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\tqmPopup->addMenu(qmFilters);\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}", "target": 0}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "static void *m_start(struct seq_file *seq, loff_t *ppos, struct uid_gid_map *map)\n{\n\tstruct uid_gid_extent *extent = NULL;\n\tloff_t pos = *ppos;\n\tif (pos < map->nr_extents)\n\t\textent = &map->extent[pos];\n\treturn extent;\n}", "target": 0}
{"code": "    PreviewImage::PreviewImage(const PreviewImage& rhs)\n    {\n        properties_ = rhs.properties_;\n        pData_ = new byte[rhs.size_];\n        memcpy(pData_, rhs.pData_, rhs.size_);\n        size_ = rhs.size_;\n    }", "target": 0}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": " bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n {\n    if (m_allowStar)\n         return true;\n     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;\n     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))\n         return true;\n    for (size_t i = 0; i < m_list.size(); ++i) {\n        if (m_list[i].matches(effectiveURL, redirectStatus))\n            return true;\n    }\n    return false;\n }", "target": 1}
{"code": "static void cac_free_private_data(cac_private_data_t *priv)\n{\n\tfree(priv->cac_id);\n\tfree(priv->cache_buf);\n\tfree(priv->aca_path);\n\tlist_destroy(&priv->pki_list);\n\tlist_destroy(&priv->general_list);\n\tfree(priv);\n\treturn;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n \tstruct socket *ssocket = server->ssocket;\n \tint val = 1;\n \tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n \tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 1}
{"code": "static int wcd9335_slim_status(struct slim_device *sdev,\n\t\t\t       enum slim_device_status status)\n{\n\tstruct device *dev = &sdev->dev;\n\tstruct device_node *ifc_dev_np;\n\tstruct wcd9335_codec *wcd;\n\tint ret;\n\twcd = dev_get_drvdata(dev);\n\tifc_dev_np = of_parse_phandle(dev->of_node, \"slim-ifc-dev\", 0);\n\tif (!ifc_dev_np) {\n\t\tdev_err(dev, \"No Interface device found\\n\");\n\t\treturn -EINVAL;\n\t}\n\twcd->slim = sdev;\n\twcd->slim_ifc_dev = of_slim_get_device(sdev->ctrl, ifc_dev_np);\n\tof_node_put(ifc_dev_np);\n\tif (!wcd->slim_ifc_dev) {\n\t\tdev_err(dev, \"Unable to get SLIM Interface device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tslim_get_logical_addr(wcd->slim_ifc_dev);\n\twcd->regmap = regmap_init_slimbus(sdev, &wcd9335_regmap_config);\n\tif (IS_ERR(wcd->regmap)) {\n\t\tdev_err(dev, \"Failed to allocate slim register map\\n\");\n\t\treturn PTR_ERR(wcd->regmap);\n\t}\n\twcd->if_regmap = regmap_init_slimbus(wcd->slim_ifc_dev,\n\t\t\t\t\t\t  &wcd9335_ifc_regmap_config);\n\tif (IS_ERR(wcd->if_regmap)) {\n\t\tdev_err(dev, \"Failed to allocate ifc register map\\n\");\n\t\treturn PTR_ERR(wcd->if_regmap);\n\t}\n\tret = wcd9335_bring_up(wcd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bringup WCD9335\\n\");\n\t\treturn ret;\n\t}\n\tret = wcd9335_irq_init(wcd);\n\tif (ret)\n\t\treturn ret;\n\twcd9335_probe(wcd);\n\treturn ret;\n}", "target": 0}
{"code": "void generic_end_io_acct(struct request_queue *q, int rw,\n\t\t\t struct hd_struct *part, unsigned long start_time)\n{\n\tunsigned long duration = jiffies - start_time;\n\tint cpu = part_stat_lock();\n\tpart_stat_add(cpu, part, ticks[rw], duration);\n\tpart_round_stats(q, cpu, part);\n\tpart_dec_in_flight(q, part, rw);\n\tpart_stat_unlock();\n}", "target": 0}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "parse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "u32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\tif (!movie || !movie->moov) return 0;\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "BnGeneratePrimeForRSA(\n\t\t      bigNum          prime,\n\t\t      UINT32          bits,\n\t\t      UINT32          exponent,\n\t\t      RAND_STATE      *rand\n\t\t      )\n{\n    BOOL            found = FALSE;\n    pAssert(prime->allocated >= BITS_TO_CRYPT_WORDS(bits));\n    pAssert((bits % 32) == 0);\n    prime->size = BITS_TO_CRYPT_WORDS(bits);\n    while(!found)\n\t{\n\t    DRBG_Generate(rand, (BYTE *)prime->d, (UINT16)BITS_TO_BYTES(bits));\n\t    RsaAdjustPrimeCandidate(prime);\n\t    found = RsaCheckPrime(prime, exponent, rand) == TPM_RC_SUCCESS;\n\t}\n}", "target": 0}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "void Opal::Call::set_no_answer_forward (unsigned delay, const std::string & uri)\n{\n  forward_uri = uri;\n  NoAnswerTimer.SetInterval (0, PMIN (delay, 60));\n}", "target": 0}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static inline void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}", "target": 0}
{"code": "static void InitPSDInfo(Image *image,Image *layer,PSDInfo *info)\n{\n  (void) memset(info,0,sizeof(*info));\n  info->version=1;\n  info->columns=layer->columns;\n  info->rows=layer->rows;\n  info->mode=10; \n  if (IsGrayImage(image,&image->exception) != MagickFalse)\n    info->channels=2U;\n  else\n    if (image->storage_class == PseudoClass)\n      {\n        info->mode=2;\n        info->channels=2U;\n      }\n    else\n      {\n        if (image->colorspace != CMYKColorspace)\n          info->channels=4U;\n        else\n          info->channels=5U;\n      }\n  if (image->matte == MagickFalse)\n    info->channels--;\n  info->min_channels=info->channels;\n  if (image->matte != MagickFalse)\n    info->min_channels--;\n}", "target": 0}
{"code": "load_debug_section_with_follow (enum dwarf_section_display_enum sec_enum,\n\t\t\t\tvoid * handle)\n{\n  if (load_debug_section (sec_enum, handle))\n    {\n      if (debug_displays[sec_enum].section.filename == NULL)\n\t{\n\t  separate_info * i;\n\t  for (i = first_separate_info; i != NULL; i = i->next)\n\t    if (i->handle == handle)\n\t      {\n\t\tdebug_displays[sec_enum].section.filename = i->filename;\n\t\tbreak;\n\t      }\n\t}\n      return true;\n    }\n  if (do_follow_links)\n    {\n      separate_info * i;\n      for (i = first_separate_info; i != NULL; i = i->next)\n\t{\n\t  if (load_debug_section (sec_enum, i->handle))\n\t    {\n\t      debug_displays[sec_enum].section.filename = i->filename;\n\t      return true;\n\t    }\n\t}\n    }\n  return false;\n}", "target": 0}
{"code": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}", "target": 0}
{"code": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "bool lua_datum::is_number() const\n{\n    LUA_CHECK_TYPE(lua_isnumber);\n}", "target": 0}
{"code": "onig_reg_init(regex_t* reg, OnigOptionType option,\n\t      OnigCaseFoldType case_fold_flag,\n\t      OnigEncoding enc, const OnigSyntaxType* syntax)\n{\n  if (! onig_inited)\n    onig_init();\n  if (IS_NULL(reg))\n    return ONIGERR_INVALID_ARGUMENT;\n  if (ONIGENC_IS_UNDEF(enc))\n    return ONIGERR_DEFAULT_ENCODING_IS_NOT_SETTED;\n  if ((option & (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP))\n      == (ONIG_OPTION_DONT_CAPTURE_GROUP|ONIG_OPTION_CAPTURE_GROUP)) {\n    return ONIGERR_INVALID_COMBINATION_OF_OPTIONS;\n  }\n  (reg)->state = ONIG_STATE_MODIFY;\n  if ((option & ONIG_OPTION_NEGATE_SINGLELINE) != 0) {\n    option |= syntax->options;\n    option &= ~ONIG_OPTION_SINGLELINE;\n  }\n  else\n    option |= syntax->options;\n  (reg)->enc              = enc;\n  (reg)->options          = option;\n  (reg)->syntax           = syntax;\n  (reg)->optimize         = 0;\n  (reg)->exact            = (UChar* )NULL;\n  (reg)->int_map          = (int* )NULL;\n  (reg)->int_map_backward = (int* )NULL;\n  (reg)->chain            = (regex_t* )NULL;\n  (reg)->p                = (UChar* )NULL;\n  (reg)->alloc            = 0;\n  (reg)->used             = 0;\n  (reg)->name_table       = (void* )NULL;\n  (reg)->case_fold_flag   = case_fold_flag;\n  return 0;\n}", "target": 0}
{"code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n  LOG_DEBUG(5, \"Extracting: \" << path);\n  return extract(*SystemUtilities::oopen(path));\n}", "target": 1}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "_gcry_ecc_eddsa_compute_h_d (unsigned char **r_digest,\n                             gcry_mpi_t d, mpi_ec_t ec)\n{\n  gpg_err_code_t rc;\n  unsigned char *rawmpi = NULL;\n  unsigned int rawmpilen;\n  unsigned char *digest;\n  gcry_buffer_t hvec[2];\n  int hashalgo, b;\n  *r_digest = NULL;\n  hashalgo = GCRY_MD_SHA512;\n  if (hashalgo != GCRY_MD_SHA512)\n    return GPG_ERR_DIGEST_ALGO;\n  b = (ec->nbits+7)/8;\n  if (b != 256/8)\n    return GPG_ERR_INTERNAL; \n  digest = xtrycalloc_secure (2, b);\n  if (!digest)\n    return gpg_err_code_from_syserror ();\n  memset (hvec, 0, sizeof hvec);\n  rawmpi = _gcry_mpi_get_buffer (d, 0, &rawmpilen, NULL);\n  if (!rawmpi)\n    {\n      xfree (digest);\n      return gpg_err_code_from_syserror ();\n    }\n  hvec[0].data = digest;\n  hvec[0].off = 0;\n  hvec[0].len = b > rawmpilen? b - rawmpilen : 0;\n  hvec[1].data = rawmpi;\n  hvec[1].off = 0;\n  hvec[1].len = rawmpilen;\n  rc = _gcry_md_hash_buffers (hashalgo, 0, digest, hvec, 2);\n  xfree (rawmpi);\n  if (rc)\n    {\n      xfree (digest);\n      return rc;\n    }\n  reverse_buffer (digest, 32);  \n  digest[0]   = (digest[0] & 0x7f) | 0x40;\n  digest[31] &= 0xf8;\n  *r_digest = digest;\n  return 0;\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}", "target": 1}
{"code": "void ChangeListLoader::LoadChangeListFromServer(int64 start_changestamp) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!change_feed_fetcher_);\n  DCHECK(cached_about_resource_);\n  bool is_delta_update = start_changestamp != 0;\n  if (is_delta_update) {\n    change_feed_fetcher_.reset(\n        new DeltaFeedFetcher(scheduler_, start_changestamp));\n  } else {\n    change_feed_fetcher_.reset(new FullFeedFetcher(scheduler_));\n  }\n  change_feed_fetcher_->Run(\n      base::Bind(&ChangeListLoader::LoadChangeListFromServerAfterLoadChangeList,\n                 weak_ptr_factory_.GetWeakPtr(),\n                 base::Passed(make_scoped_ptr(\n                     new google_apis::AboutResource(*cached_about_resource_))),\n                 is_delta_update));\n}", "target": 0}
{"code": "void PrintHeaderFooterText(\n    string16 text,\n    WebKit::WebCanvas* canvas,\n    HeaderFooterPaint paint,\n    float webkit_scale_factor,\n    const PageSizeMargins& page_layout,\n    printing::HorizontalHeaderFooterPosition horizontal_position,\n    printing::VerticalHeaderFooterPosition vertical_position,\n    double offset_to_baseline) {\n#if defined(USE_SKIA)\n  size_t text_byte_length = text.length() * sizeof(char16);\n  double text_width_in_points = SkScalarToDouble(paint.measureText(\n      text.c_str(), text_byte_length));\n  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor, page_layout,\n                                          horizontal_position,\n                                          vertical_position, offset_to_baseline,\n                                          text_width_in_points);\n  paint.setTextSize(SkDoubleToScalar(\n      paint.getTextSize() / webkit_scale_factor));\n  canvas->drawText(text.c_str(), text_byte_length, point.x(), point.y(),\n                   paint);\n#elif defined(OS_MACOSX)\n  ScopedCFTypeRef<CFStringRef> cf_text(base::SysUTF16ToCFStringRef(text));\n  ScopedCFTypeRef<CFAttributedStringRef> cf_attr_text(\n      CFAttributedStringCreate(NULL, cf_text, paint));\n  ScopedCFTypeRef<CTLineRef> line(CTLineCreateWithAttributedString(\n      cf_attr_text));\n  double text_width_in_points =\n      CTLineGetTypographicBounds(line, NULL, NULL, NULL) * webkit_scale_factor;\n  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor,\n                                          page_layout, horizontal_position,\n                                          vertical_position, offset_to_baseline,\n                                          text_width_in_points);\n  CGContextSetTextPosition(canvas, SkScalarToDouble(point.x()),\n                           SkScalarToDouble(point.y()));\n  CTLineDraw(line, canvas);\n#endif\n}", "target": 0}
{"code": "static unsigned short muscle_parse_singleAcl(const sc_acl_entry_t* acl)\n{\n\tunsigned short acl_entry = 0;\n\twhile(acl) {\n\t\tint key = acl->key_ref;\n\t\tint method = acl->method;\n\t\tswitch(method) {\n\t\tcase SC_AC_NEVER:\n\t\t\treturn 0xFFFF;\n\t\tcase SC_AC_NONE:\n\t\tcase SC_AC_UNKNOWN:\n\t\t\tbreak;\n\t\tcase SC_AC_CHV:\n\t\t\tacl_entry |= (1 << key); \n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tacl = acl->next;\n\t}\n\treturn acl_entry;\n}", "target": 0}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 1}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": " void PageClickTracker::handleEvent(const WebDOMEvent& event) {\n   last_node_clicked_.reset();\n  if (!event.isMouseEvent())\n    return;\n   const WebDOMMouseEvent mouse_event = event.toConst<WebDOMMouseEvent>();\n   DCHECK(mouse_event.buttonDown());\n   if (mouse_event.button() != 0)\n    return;  \n  last_node_clicked_ = mouse_event.target();\n  was_focused_ = (GetFocusedNode() == last_node_clicked_);\n}", "target": 0}
{"code": "void EC_GROUP_clear_free(EC_GROUP *group)\n\t{\n\tif (!group) return;\n\tif (group->meth->group_clear_finish != 0)\n\t\tgroup->meth->group_clear_finish(group);\n\telse if (group->meth->group_finish != 0)\n\t\tgroup->meth->group_finish(group);\n\tEC_EX_DATA_clear_free_all_data(&group->extra_data);\n\tif (group->generator != NULL)\n        EC_EX_DATA_clear_free_all_data(&group->extra_data);\n        if (group->generator != NULL)\n                EC_POINT_clear_free(group->generator);\n        BN_clear_free(&group->order);\n\tOPENSSL_cleanse(group, sizeof *group);\n\tOPENSSL_free(group);\n\t}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "bool RenderMenuList::multiple()\n {\n     return toHTMLSelectElement(node())->multiple();\n }", "target": 1}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "PassRefPtrWillBeRawPtr<Element> ContainerNode::querySelector(const AtomicString& selectors, ExceptionState& exceptionState)\n{\n    if (selectors.isEmpty()) {\n        exceptionState.throwDOMException(SyntaxError, \"The provided selector is empty.\");\n        return nullptr;\n    }\n    SelectorQuery* selectorQuery = document().selectorQueryCache().add(selectors, document(), exceptionState);\n    if (!selectorQuery)\n        return nullptr;\n    NthIndexCache nthIndexCache(document());\n    return selectorQuery->queryFirst(*this);\n}", "target": 0}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "JOIN_TAB *first_linear_tab(JOIN *join,\n                           enum enum_with_bush_roots include_bush_roots,\n                           enum enum_with_const_tables const_tbls)\n{\n  JOIN_TAB *first= join->join_tab;\n  if (!first)\n    return NULL;\n  if (const_tbls == WITHOUT_CONST_TABLES)\n    first+= join->const_tables;\n  if (first >= join->join_tab + join->top_join_tab_count)\n    return NULL; \n  if (first->bush_children && include_bush_roots == WITHOUT_BUSH_ROOTS)\n  {\n    return first->bush_children->start;\n  }\n  return first;\n}", "target": 0}
{"code": "int http_remove_header2(struct http_msg *msg, struct buffer *buf,\n\t\t\tstruct hdr_idx *idx, struct hdr_ctx *ctx)\n{\n\tint cur_idx = ctx->idx;\n\tchar *sol = ctx->line;\n\tstruct hdr_idx_elem *hdr;\n\tint delta, skip_comma;\n\tif (!cur_idx)\n\t\treturn 0;\n\thdr = &idx->v[cur_idx];\n\tif (sol[ctx->del] == ':' && ctx->val + ctx->vlen + ctx->tws == hdr->len) {\n\t\tdelta = buffer_replace2(buf, sol, sol + hdr->len + hdr->cr + 1, NULL, 0);\n\t\thttp_msg_move_end(msg, delta);\n\t\tidx->used--;\n\t\thdr->len = 0;   \n\t\tidx->v[ctx->prev].next = idx->v[ctx->idx].next;\n\t\tif (idx->tail == ctx->idx)\n\t\t\tidx->tail = ctx->prev;\n\t\tctx->idx = ctx->prev;    \n\t\tctx->line -= idx->v[ctx->idx].len + idx->v[cur_idx].cr + 1;\n\t\tctx->val = idx->v[ctx->idx].len; \n\t\tctx->tws = ctx->vlen = 0;\n\t\treturn ctx->idx;\n\t}\n\tskip_comma = (ctx->val + ctx->vlen + ctx->tws == hdr->len) ? 0 : 1;\n\tdelta = buffer_replace2(buf, sol + ctx->del + skip_comma,\n\t\t\t\tsol + ctx->val + ctx->vlen + ctx->tws + skip_comma,\n\t\t\t\tNULL, 0);\n\thdr->len += delta;\n\thttp_msg_move_end(msg, delta);\n\tctx->val = ctx->del;\n\tctx->tws = ctx->vlen = 0;\n\treturn ctx->idx;\n}", "target": 0}
{"code": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n        }\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "u32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}", "target": 0}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 1}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "  QInt32() {}", "target": 1}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "void smp_idle_terminate(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n if (p_cb->flags & SMP_PAIR_FLAGS_WE_STARTED_DD) {\n    SMP_TRACE_DEBUG(\"Pairing terminated at IDLE state.\");\n    p_cb->status = SMP_FAIL;\n    smp_proc_pairing_cmpl(p_cb);\n }\n}", "target": 0}
{"code": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }", "target": 1}
{"code": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}", "target": 1}
{"code": "void LibRaw::fuji_compressed_load_raw()\n{\n  struct fuji_compressed_params common_info;\n  int cur_block;\n  unsigned line_size, *block_sizes;\n  INT64 raw_offset, *raw_block_offsets;\n  init_fuji_compr(&common_info);\n  line_size = sizeof(ushort) * (common_info.line_width + 2);\n  block_sizes = (unsigned *)malloc(\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(block_sizes, \"fuji_compressed_load_raw()\");\n  raw_block_offsets = (INT64 *)malloc(\n      sizeof(INT64) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(raw_block_offsets, \"fuji_compressed_load_raw()\");\n  raw_offset =\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks;\n  if (raw_offset & 0xC)\n    raw_offset += 0x10 - (raw_offset & 0xC);\n  raw_offset += libraw_internal_data.unpacker_data.data_offset;\n  libraw_internal_data.internal_data.input->seek(\n      libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n  libraw_internal_data.internal_data.input->read(\n      block_sizes, 1,\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  raw_block_offsets[0] = raw_offset;\n  for (cur_block = 0;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n  {\n    unsigned bsize = sgetn(4, (uchar *)(block_sizes + cur_block));\n    block_sizes[cur_block] = bsize;\n  }\n  for (cur_block = 1;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n    raw_block_offsets[cur_block] =\n        raw_block_offsets[cur_block - 1] + block_sizes[cur_block - 1];\n  fuji_decode_loop(&common_info,\n                   libraw_internal_data.unpacker_data.fuji_total_blocks,\n                   raw_block_offsets, block_sizes);\n  free(block_sizes);\n  free(raw_block_offsets);\n  free(common_info.q_table);\n}", "target": 0}
{"code": "int X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k)\n{\n    EVP_PKEY *xk = NULL;\n    int ok = 0;\n    xk = X509_REQ_get_pubkey(x);\n    switch (EVP_PKEY_cmp(xk, k)) {\n    case 1:\n        ok = 1;\n        break;\n    case 0:\n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,\n                X509_R_KEY_VALUES_MISMATCH);\n        break;\n    case -1:\n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);\n        break;\n    case -2:\n#ifndef OPENSSL_NO_EC\n        if (k->type == EVP_PKEY_EC) {\n            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);\n            break;\n        }\n#endif\n#ifndef OPENSSL_NO_DH\n        if (k->type == EVP_PKEY_DH) {\n            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,\n                    X509_R_CANT_CHECK_DH_KEY);\n            break;\n        }\n#endif\n        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);\n    }\n    EVP_PKEY_free(xk);\n    return (ok);\n}", "target": 0}
{"code": "sc_oberthur_decode_usage(unsigned flags)\n{\n\tunsigned ret = 0;\n\tif (flags & OBERTHUR_ATTR_ENCRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_ENCRYPT;\n\tif (flags & OBERTHUR_ATTR_DECRYPT)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\tif (flags & OBERTHUR_ATTR_SIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGN;\n\tif (flags & OBERTHUR_ATTR_RSIGN)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_SIGNRECOVER;\n\tif (flags & OBERTHUR_ATTR_WRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_WRAP;\n\tif (flags & OBERTHUR_ATTR_UNWRAP)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_UNWRAP;\n\tif (flags & OBERTHUR_ATTR_VERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFY;\n\tif (flags & OBERTHUR_ATTR_RVERIFY)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_VERIFYRECOVER;\n\tif (flags & OBERTHUR_ATTR_DERIVE)\n\t\tret |= SC_PKCS15_PRKEY_USAGE_DERIVE;\n\treturn ret;\n}", "target": 0}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tsize_t a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tsnmp_object = Z_SNMP_P(object);\n\tif (zend_parse_parameters(argc, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "            Status readCString( StringData* out ) {\n                const void* x = memchr( _buffer + _position, 0, _maxLength - _position );\n                if ( !x )\n                    return makeError(\"no end of c-string\", _idElem);\n                uint64_t len = static_cast<uint64_t>( static_cast<const char*>(x) - ( _buffer + _position ) );\n                StringData data( _buffer + _position, len );\n                _position += len + 1;\n                if ( out ) {\n                    *out = data;\n                }\n                return Status::OK();\n            }", "target": 0}
{"code": "static inline void snow_set_blocks(SnowContext *s, int level, int x, int y, int l, int cb, int cr, int mx, int my, int ref, int type){\n    const int w= s->b_width << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<rem_depth;\n    BlockNode block;\n    int i,j;\n    block.color[0]= l;\n    block.color[1]= cb;\n    block.color[2]= cr;\n    block.mx= mx;\n    block.my= my;\n    block.ref= ref;\n    block.type= type;\n    block.level= level;\n    for(j=0; j<block_w; j++){\n        for(i=0; i<block_w; i++){\n            s->block[index + i + j*w]= block;\n        }\n    }\n}", "target": 0}
{"code": " bool PasswordAutofillAgent::TryToShowTouchToFill(\n     const WebFormControlElement& control_element) {\n   const WebInputElement* element = ToWebInputElement(&control_element);\n  if (!element || (!base::Contains(web_input_to_password_info_, *element) &&\n                   !base::Contains(password_to_username_, *element))) {\n     return false;\n   }\n   if (was_touch_to_fill_ui_shown_)\n    return false;\n  was_touch_to_fill_ui_shown_ = true;\n  GetPasswordManagerDriver()->ShowTouchToFill();\n  return true;\n}", "target": 1}
{"code": "        std::string PngChunk::makeUtf8TxtChunk(const std::string& keyword, const std::string& text, bool compress)\n        {\n            std::string chunkData = keyword;\n            if (compress) {\n                static const char flags[] = {0x00, 0x01, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + zlibCompress(text);\n            } else {\n                static const char flags[] = {0x00, 0x00, 0x00, 0x00, 0x00};\n                chunkData += std::string(flags, 5) + text;\n            }\n            byte length[4];\n            ul2Data(length, static_cast<uint32_t>(chunkData.size()), bigEndian);\n            std::string chunkType = \"iTXt\";\n            std::string crcData = chunkType + chunkData;\n            uLong tmp = crc32(0L, Z_NULL, 0);\n            tmp = crc32(tmp, (const Bytef*)crcData.data(), static_cast<uInt>(crcData.size()));\n            byte crc[4];\n            ul2Data(crc, tmp, bigEndian);\n            return std::string((const char*)length, 4) + chunkType + chunkData + std::string((const char*)crc, 4);\n        }  ", "target": 0}
{"code": "bool ATSParser::PSISection::isCRCOkay() const {\n if (!isComplete()) {\n return false;\n }\n uint8_t* data = mBuffer->data();\n if ((data[1] & 0x80) == 0) {\n return true;\n }\n     unsigned sectionLength = U16_AT(data + 1) & 0xfff;\n     ALOGV(\"sectionLength %u, skip %u\", sectionLength, mSkipBytes);\n     sectionLength -= mSkipBytes;\n uint32_t crc = 0xffffffff;\n for(unsigned i = 0; i < sectionLength + 4 ; i++) {\n uint8_t b = data[i];\n int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;\n        crc = CRC_TABLE[index] ^ (crc << 8);\n }\n    ALOGV(\"crc: %08x\\n\", crc);\n return (crc == 0);\n}", "target": 1}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "bool bnx2x_port_after_undi(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *entry;\n\tbool val;\n\tdown(&bnx2x_prev_sem);\n\tentry = bnx2x_prev_path_get_entry(bp);\n\tval = !!(entry && (entry->undi & (1 << BP_PORT(bp))));\n\tup(&bnx2x_prev_sem);\n\treturn val;\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "d_lite_upto(VALUE self, VALUE max)\n{\n    VALUE date;\n    RETURN_ENUMERATOR(self, 1, &max);\n    date = self;\n    while (FIX2INT(d_lite_cmp(date, max)) <= 0) {\n\trb_yield(date);\n\tdate = d_lite_plus(date, INT2FIX(1));\n    }\n    return self;\n}", "target": 0}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}", "target": 1}
{"code": "int jpc_pi_init(jpc_pi_t *pi)\n{\n\tint compno;\n\tint rlvlno;\n\tint prcno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tint *prclyrno;\n\tpi->prgvolfirst = 0;\n\tpi->valid = 0;\n\tpi->pktno = -1;\n\tpi->pchgno = -1;\n\tpi->pchg = 0;\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t  ++compno, ++picomp) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  bool empty() const override { return value_ == nullptr ? true : value_->empty(); }", "target": 0}
{"code": "struct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\treturn pack;\n}", "target": 0}
{"code": "int lg2ff_init(struct hid_device *hid)\n{\n\tstruct lg2ff_device *lg2ff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);\n\tif (!report)\n\t\treturn -ENODEV;\n\tlg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);\n\tif (!lg2ff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, lg2ff, play_effect);\n\tif (error) {\n\t\tkfree(lg2ff);\n\t\treturn error;\n\t}\n\tlg2ff->report = report;\n\treport->field[0]->value[0] = 0xf3;\n\treport->field[0]->value[1] = 0x00;\n\treport->field[0]->value[2] = 0x00;\n\treport->field[0]->value[3] = 0x00;\n\treport->field[0]->value[4] = 0x00;\n\treport->field[0]->value[5] = 0x00;\n\treport->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force feedback for Logitech variant 2 rumble devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n    if (!m_scrollLayer)\n        return;\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}", "target": 1}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "mwifiex_ie_get_autoidx(struct mwifiex_private *priv, u16 subtype_mask,\n\t\t       struct mwifiex_ie *ie, u16 *index)\n{\n\tu16 mask, len, i;\n\tfor (i = 0; i < priv->adapter->max_mgmt_ie_index; i++) {\n\t\tmask = le16_to_cpu(priv->mgmt_ie[i].mgmt_subtype_mask);\n\t\tlen = le16_to_cpu(ie->ie_length);\n\t\tif (mask == MWIFIEX_AUTO_IDX_MASK)\n\t\t\tcontinue;\n\t\tif (mask == subtype_mask) {\n\t\t\tif (len > IEEE_MAX_IE_SIZE)\n\t\t\t\tcontinue;\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!priv->mgmt_ie[i].ie_length) {\n\t\t\tif (mwifiex_ie_index_used_by_other_intf(priv, i))\n\t\t\t\tcontinue;\n\t\t\t*index = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "alloc_handle( void *ctx_arg, int is_server )\n{\n\ttls_ctx\t*ctx;\n\ttls_session\t*ssl;\n\tif ( ctx_arg ) {\n\t\tctx = ctx_arg;\n\t} else {\n\t\tstruct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   \n\t\tif ( ldap_pvt_tls_init_def_ctx( is_server ) < 0 ) return NULL;\n\t\tctx = lo->ldo_tls_ctx;\n\t}\n\tssl = tls_imp->ti_session_new( ctx, is_server );\n\tif ( ssl == NULL ) {\n\t\tDebug( LDAP_DEBUG_ANY,\"TLS: can't create ssl handle.\\n\",0,0,0);\n\t\treturn NULL;\n\t}\n\treturn ssl;\n}", "target": 0}
{"code": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}", "target": 0}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_axis(const int x, const CImg<t>& values_y,\n                       const tc *const color, const float opacity=1,\n                       const unsigned int pattern=~0U, const unsigned int font_height=13,\n                       const bool allow_zero=true) {\n      if (is_empty()) return *this;\n      int siz = (int)values_y.size() - 1;\n      CImg<charT> txt(32);\n      CImg<T> label;\n      if (siz<=0) { \n        draw_line(x,0,x,_height - 1,color,opacity,pattern);\n        if (!siz) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)*values_y);\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            _yt = (height() - label.height())/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      } else { \n        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);\n        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);\n        cimg_foroff(values_y,y) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)values_y(y));\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            yi = (int)(y*(_height - 1)/siz),\n            _yt = yi - label.height()/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      }\n      return *this;", "target": 0}
{"code": "SPL_METHOD(SplMinHeap, compare)\n{\n\tzval *a, *b;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zz\", &a, &b) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(spl_ptr_heap_zval_min_cmp(a, b, NULL TSRMLS_CC));\n} ", "target": 0}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "static int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}", "target": 0}
{"code": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; \n\tstruct alloc_context ac = { };\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\tfinalise_ac(gfp_mask, order, &ac);\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\treturn page;\n}", "target": 0}
{"code": "ins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    \n    showmode();\n}", "target": 0}
{"code": "void FeatureInfo::EnableOESTextureHalfFloatLinear() {\n  if (!oes_texture_half_float_linear_available_)\n     return;\n   AddExtensionString(\"GL_OES_texture_half_float_linear\");\n   feature_flags_.enable_texture_half_float_linear = true;\n   feature_flags_.gpu_memory_buffer_formats.Add(gfx::BufferFormat::RGBA_F16);\n }", "target": 1}
{"code": "static int evdev_handle_get_keycode_v2(struct input_dev *dev, void __user *p)\n{\n\tstruct input_keymap_entry ke;\n\tint error;\n\tif (copy_from_user(&ke, p, sizeof(ke)))\n\t\treturn -EFAULT;\n\terror = input_get_keycode(dev, &ke);\n\tif (error)\n\t\treturn error;\n\tif (copy_to_user(p, &ke, sizeof(ke)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "int unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n        if (suffix[0] != '.')\n                return -EINVAL;\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return -EINVAL;\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}", "target": 0}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\tgf_filter_pck_send(pck);\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static inline struct rt6_info *ip6_dst_alloc(struct net *net,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct fib6_table *table)\n{\n\tstruct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,\n\t\t\t\t\t0, DST_OBSOLETE_FORCE_CHK, flags);\n\tif (rt) {\n\t\tstruct dst_entry *dst = &rt->dst;\n\t\tmemset(dst + 1, 0, sizeof(*rt) - sizeof(*dst));\n\t\trt6_init_peer(rt, table ? &table->tb6_peers : net->ipv6.peers);\n\t\trt->rt6i_genid = rt_genid(net);\n\t\tINIT_LIST_HEAD(&rt->rt6i_siblings);\n\t\trt->rt6i_nsiblings = 0;\n\t}\n\treturn rt;\n}", "target": 0}
{"code": "void ApplyBlockElementCommand::formatSelection(const VisiblePosition& startOfSelection, const VisiblePosition& endOfSelection)\n{\n    Position start = startOfSelection.deepEquivalent().downstream();\n    if (isAtUnsplittableElement(start)) {\n        RefPtr<Element> blockquote = createBlockElement();\n        insertNodeAt(blockquote, start);\n        RefPtr<Element> placeholder = createBreakElement(document());\n        appendNode(placeholder, blockquote);\n        setEndingSelection(VisibleSelection(positionBeforeNode(placeholder.get()), DOWNSTREAM, endingSelection().isDirectional()));\n        return;\n    }\n    RefPtr<Element> blockquoteForNextIndent;\n    VisiblePosition endOfCurrentParagraph = endOfParagraph(startOfSelection);\n    VisiblePosition endAfterSelection = endOfParagraph(endOfParagraph(endOfSelection).next());\n    m_endOfLastParagraph = endOfParagraph(endOfSelection).deepEquivalent();\n    bool atEnd = false;\n    Position end;\n    while (endOfCurrentParagraph != endAfterSelection && !atEnd) {\n        if (endOfCurrentParagraph.deepEquivalent() == m_endOfLastParagraph)\n            atEnd = true;\n        rangeForParagraphSplittingTextNodesIfNeeded(endOfCurrentParagraph, start, end);\n        endOfCurrentParagraph = end;\n        Position afterEnd = end.next();\n        Node* enclosingCell = enclosingNodeOfType(start, &isTableCell);\n        VisiblePosition endOfNextParagraph = endOfNextParagrahSplittingTextNodesIfNeeded(endOfCurrentParagraph, start, end);\n        formatRange(start, end, m_endOfLastParagraph, blockquoteForNextIndent);\n        if (enclosingCell && enclosingCell != enclosingNodeOfType(endOfNextParagraph.deepEquivalent(), &isTableCell))\n            blockquoteForNextIndent = 0;\n         if (endAfterSelection.isNotNull() && !endAfterSelection.deepEquivalent().inDocument())\n             break;\n        if (endOfNextParagraph.isNotNull() && !endOfNextParagraph.deepEquivalent().inDocument()) {\n            ASSERT_NOT_REACHED();\n             return;\n        }\n         endOfCurrentParagraph = endOfNextParagraph;\n     }\n }", "target": 1}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "static inline void sctp_ulpq_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 tsn, ctsn;\n\ttsn = event->tsn;\n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tcevent = sctp_skb2event(pos);\n\tctsn = cevent->tsn;\n\tif (TSN_lt(ctsn, tsn)) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tif (TSN_lt(tsn, ctsn))\n\t\t\tbreak;\n\t}\n\t__skb_insert(sctp_event2skb(event), pos->prev, pos, &ulpq->reasm);\n}", "target": 0}
{"code": "stmt_read_row_from_cursor(MYSQL_STMT *stmt, unsigned char **row)\n{\n  if (stmt->data_cursor)\n    return stmt_read_row_buffered(stmt, row);\n  if (stmt->server_status & SERVER_STATUS_LAST_ROW_SENT)\n    stmt->server_status &= ~SERVER_STATUS_LAST_ROW_SENT;\n  else\n  {\n    MYSQL *mysql= stmt->mysql;\n    NET *net= &mysql->net;\n    MYSQL_DATA *result= &stmt->result;\n    uchar buff[4  +\n               4 ];\n    free_root(&result->alloc, MYF(MY_KEEP_PREALLOC));\n    result->data= NULL;\n    result->rows= 0;\n    int4store(buff, stmt->stmt_id);\n    int4store(buff + 4, stmt->prefetch_rows); \n    if ((*mysql->methods->advanced_command)(mysql, COM_STMT_FETCH,\n                                            buff, sizeof(buff), (uchar*) 0, 0,\n                                            1, stmt))\n    {\n      if (stmt->mysql)\n        set_stmt_errmsg(stmt, net);\n      return 1;\n    }\n    if ((*mysql->methods->read_rows_from_cursor)(stmt))\n      return 1;\n    stmt->server_status= mysql->server_status;\n    stmt->data_cursor= result->data;\n    return stmt_read_row_buffered(stmt, row);\n  }\n  *row= 0;\n  return MYSQL_NO_DATA;\n}", "target": 0}
{"code": "static int mxf_read_tagged_value(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTaggedValue *tagged_value = arg;\n    switch (tag){\n    case 0x5001:\n        return mxf_read_utf16be_string(pb, size, &tagged_value->name);\n    case 0x5003:\n        return mxf_read_indirect_value(tagged_value, pb, size);\n    }\n    return 0;\n}", "target": 0}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "Item_func_null_predicate::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                                         uint *and_level,\n                                         table_map usable_tables,\n                                         SARGABLE_PARAM **sargables)\n{\n  if (is_local_field(args[0]) && !(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    Item *tmp= new (join->thd->mem_root) Item_null(join->thd);\n    if (unlikely(!tmp))                       \n      return;\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(),\n                         functype() == Item_func::ISNULL_FUNC,\n                         &tmp, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {\n  DCHECK(submission->method() == FormSubmission::PostMethod ||\n         submission->method() == FormSubmission::GetMethod);\n  DCHECK(submission->data());\n  DCHECK(submission->form());\n  if (submission->action().isEmpty())\n    return;\n  if (document().isSandboxed(SandboxForms)) {\n    document().addConsoleMessage(ConsoleMessage::create(\n        SecurityMessageSource, ErrorMessageLevel,\n        \"Blocked form submission to '\" + submission->action().elidedString() +\n            \"' because the form's frame is sandboxed and the 'allow-forms' \"\n            \"permission is not set.\"));\n     return;\n   }\n   if (protocolIsJavaScript(submission->action())) {\n    if (!document().contentSecurityPolicy()->allowFormAction(\n            submission->action()))\n      return;\n     document().frame()->script().executeScriptIfJavaScriptURL(\n         submission->action(), this);\n     return;\n  }\n  Frame* targetFrame = document().frame()->findFrameForNavigation(\n      submission->target(), *document().frame());\n  if (!targetFrame) {\n    if (!LocalDOMWindow::allowPopUp(*document().frame()) &&\n        !UserGestureIndicator::utilizeUserGesture())\n      return;\n    targetFrame = document().frame();\n  } else {\n    submission->clearTarget();\n  }\n  if (!targetFrame->host())\n    return;\n  UseCounter::count(document(), UseCounter::FormsSubmitted);\n  if (MixedContentChecker::isMixedFormAction(document().frame(),\n                                             submission->action()))\n    UseCounter::count(document().frame(),\n                      UseCounter::MixedContentFormsSubmitted);\n  if (targetFrame->isLocalFrame()) {\n    toLocalFrame(targetFrame)\n        ->navigationScheduler()\n        .scheduleFormSubmission(&document(), submission);\n  } else {\n    FrameLoadRequest frameLoadRequest =\n        submission->createFrameLoadRequest(&document());\n    toRemoteFrame(targetFrame)->navigate(frameLoadRequest);\n  }\n}", "target": 1}
{"code": "static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n        tags = strv_split(buf, \"\\n\\r\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"Got notification message for unit. Ignoring.\");\n}", "target": 1}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "static ssize_t ext4_direct_IO_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\tinode_lock_shared(inode);\n\tret = filemap_write_and_wait_range(mapping, iocb->ki_pos,\n\t\t\t\t\t   iocb->ki_pos + count - 1);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t   iter, ext4_dio_get_block, NULL, NULL, 0);\nout_unlock:\n\tinode_unlock_shared(inode);\n\treturn ret;\n}", "target": 0}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "void gd_stderr_error(int priority, const char *format, va_list args)\n{\n\tswitch (priority) {\n\tcase GD_ERROR:\n\t\tfputs(\"GD Error: \", stderr);\n\t\tbreak;\n\tcase GD_WARNING:\n\t\tfputs(\"GD Warning: \", stderr);\n\t\tbreak;\n\tcase GD_NOTICE:\n\t\tfputs(\"GD Notice: \", stderr);\n\t\tbreak;\n\tcase GD_INFO:\n\t\tfputs(\"GD Info: \", stderr);\n\t\tbreak;\n\tcase GD_DEBUG:\n\t\tfputs(\"GD Debug: \", stderr);\n\t\tbreak;\n\t}\n\tvfprintf(stderr, format, args);\n\tfflush(stderr);\n}", "target": 0}
{"code": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tes->s_free_inodes_count =\n\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tsb->s_dirt = 0;\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb, es);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,\n\t\t\t\t\tunsigned int access)\n{\n\tstruct snd_kcontrol *kctl;\n\tunsigned int idx;\n\tif (snd_BUG_ON(!control || !control->count))\n\t\treturn NULL;\n\tif (control->count > MAX_CONTROL_COUNT)\n\t\treturn NULL;\n\tkctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);\n\tif (kctl == NULL) {\n\t\tpr_err(\"ALSA: Cannot allocate control instance\\n\");\n\t\treturn NULL;\n\t}\n\t*kctl = *control;\n\tfor (idx = 0; idx < kctl->count; idx++)\n\t\tkctl->vd[idx].access = access;\n\treturn kctl;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tunsigned long eip = vcpu->arch.emulate_ctxt.eip;\n\tu32 dr6 = 0;\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1 | DR6_RTM;\n\t\t\tkvm_run->debug.arch.pc = kvm_rip_read(vcpu) +\n\t\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = EMULATE_USER_EXIT;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tdr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tvcpu->arch.dr6 &= ~15;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\t*r = EMULATE_DONE;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "bool HeaderToMetadataFilter::addMetadata(StructMap& map, const std::string& meta_namespace,\n                                         const std::string& key, std::string value, ValueType type,\n                                         ValueEncode encode) const {\n  ProtobufWkt::Value val;\n  ASSERT(!value.empty());\n  if (value.size() >= MAX_HEADER_VALUE_LEN) {\n    ENVOY_LOG(debug, \"metadata value is too long\");\n    return false;\n  }\n  if (encode == envoy::extensions::filters::http::header_to_metadata::v3::Config::BASE64) {\n    value = Base64::decodeWithoutPadding(value);\n    if (value.empty()) {\n      ENVOY_LOG(debug, \"Base64 decode failed\");\n      return false;\n    }\n  }\n  switch (type) {\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::STRING:\n    val.set_string_value(std::move(value));\n    break;\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::NUMBER: {\n    double dval;\n    if (absl::SimpleAtod(StringUtil::trim(value), &dval)) {\n      val.set_number_value(dval);\n    } else {\n      ENVOY_LOG(debug, \"value to number conversion failed\");\n      return false;\n    }\n    break;\n  }\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::PROTOBUF_VALUE: {\n    if (!val.ParseFromString(value)) {\n      ENVOY_LOG(debug, \"parse from decoded string failed\");\n      return false;\n    }\n    break;\n  }\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n  auto namespace_iter = map.find(meta_namespace);\n  if (namespace_iter == map.end()) {\n    map[meta_namespace] = ProtobufWkt::Struct();\n    namespace_iter = map.find(meta_namespace);\n  }\n  auto& keyval = namespace_iter->second;\n  (*keyval.mutable_fields())[key] = val;\n  return true;\n}", "target": 0}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "void FoFiTrueType::cvtCharStrings(char **encoding,\n\t\t\t\t  int *codeToGID,\n\t\t\t\t  FoFiOutputFunc outputFunc,\n\t\t\t\t  void *outputStream) {\n  char *name;\n  GooString *buf;\n  char buf2[16];\n  int i, k;\n  (*outputFunc)(outputStream, \"/CharStrings 256 dict dup begin\\n\", 32);\n  (*outputFunc)(outputStream, \"/.notdef 0 def\\n\", 15);\n  if (nCmaps == 0) {\n    goto err;\n  }\n  k = 0; \n  for (i = 255; i >= 0; --i) {\n    if (encoding) {\n      name = encoding[i];\n    } else {\n      sprintf(buf2, \"c%02x\", i);\n      name = buf2;\n    }\n    if (name && strcmp(name, \".notdef\")) {\n      k = codeToGID[i];\n      if (k > 0 && k < nGlyphs) {\n\t(*outputFunc)(outputStream, \"/\", 1);\n\t(*outputFunc)(outputStream, name, strlen(name));\n\tbuf = GooString::format(\" {0:d} def\\n\", k);\n\t(*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n\tdelete buf;\n      }\n    }\n  }\n err:\n  (*outputFunc)(outputStream, \"end readonly def\\n\", 17);\n}", "target": 0}
{"code": "static int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\t_enter(\"%zu\", prep->datalen);\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\tmemcpy(&prep->type_data, prep->data, 8);\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}", "target": 0}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "static int lookup1_values(int entries, int dim)\n{\n    int r = (int) floor(exp((float) log((float) entries) / dim));\n    if ((int) floor(pow((float) r+1, dim)) <= entries)   \n       ++r;                                              \n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); \n    return r;\n }", "target": 1}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    setUpstreamCount(1);                         \n    setUpstreamProtocol(Http::CodecType::HTTP2); \n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    acceptXdsConnection();\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }", "target": 1}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tDBG(\"Stopping stream\\n\");\n\tcpia2_usb_stream_stop(cam);\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG(\"Unregistering camera\\n\");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\tv4l2_device_put(&cam->v4l2_dev);\n\tif(cam->buffers) {\n\t\tDBG(\"Wakeup waiting processes\\n\");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\tLOG(\"CPiA2 camera disconnected.\\n\");\n}", "target": 1}
{"code": "static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,\n\t\t\t\t     size_t size, int dir, u64 dma_mask)\n{\n\tstruct dmar_domain *domain;\n\tphys_addr_t start_paddr;\n\tunsigned long iova_pfn;\n\tint prot = 0;\n\tint ret;\n\tstruct intel_iommu *iommu;\n\tunsigned long paddr_pfn = paddr >> PAGE_SHIFT;\n\tBUG_ON(dir == DMA_NONE);\n\tif (iommu_no_mapping(dev))\n\t\treturn paddr;\n\tdomain = get_valid_domain_for_dev(dev);\n\tif (!domain)\n\t\treturn DMA_MAPPING_ERROR;\n\tiommu = domain_get_iommu(domain);\n\tsize = aligned_nrpages(paddr, size);\n\tiova_pfn = intel_alloc_iova(dev, domain, dma_to_mm_pfn(size), dma_mask);\n\tif (!iova_pfn)\n\t\tgoto error;\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL || \\\n\t\t\t!cap_zlr(iommu->cap))\n\t\tprot |= DMA_PTE_READ;\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tprot |= DMA_PTE_WRITE;\n\tret = domain_pfn_mapping(domain, mm_to_dma_pfn(iova_pfn),\n\t\t\t\t mm_to_dma_pfn(paddr_pfn), size, prot);\n\tif (ret)\n\t\tgoto error;\n\tstart_paddr = (phys_addr_t)iova_pfn << PAGE_SHIFT;\n\tstart_paddr += paddr & ~PAGE_MASK;\n\treturn start_paddr;\nerror:\n\tif (iova_pfn)\n\t\tfree_iova_fast(&domain->iovad, iova_pfn, dma_to_mm_pfn(size));\n\tdev_err(dev, \"Device request: %zx@%llx dir %d --- failed\\n\",\n\t\tsize, (unsigned long long)paddr, dir);\n\treturn DMA_MAPPING_ERROR;\n}", "target": 0}
{"code": "    int32_t RotationMap::degrees(uint16_t orientation)\n    {\n        int32_t d = 0;\n        for (int i = 0; omList_[i].orientation != 0; ++i) {\n            if (omList_[i].orientation == orientation) {\n                d = omList_[i].degrees;\n                break;\n            }\n        }\n        return d;\n    }", "target": 0}
{"code": " int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}", "target": 1}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "static u64 execlists_update_context(struct i915_request *rq)\n{\n\tstruct intel_context *ce = rq->hw_context;\n\tu64 desc = ce->lrc_desc;\n\tu32 tail;\n\ttail = intel_ring_set_tail(rq->ring, rq->tail);\n\tif (unlikely(ce->lrc_reg_state[CTX_RING_TAIL] == tail))\n\t\tdesc |= CTX_DESC_FORCE_RESTORE;\n\tce->lrc_reg_state[CTX_RING_TAIL] = tail;\n\trq->tail = rq->wa_tail;\n\tmb();\n\tif (IS_TGL_REVID(rq->i915, TGL_REVID_A0, TGL_REVID_A0))\n\t\tdesc |= CTX_DESC_FORCE_RESTORE;\n\tce->lrc_desc &= ~CTX_DESC_FORCE_RESTORE;\n\treturn desc;\n}", "target": 0}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}", "target": 1}
{"code": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "size_t zmalloc_size(void *ptr) {\n    void *realptr = (char*)ptr-PREFIX_SIZE;\n    size_t size = *((size_t*)realptr);\n    if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));\n    return size+PREFIX_SIZE;\n}", "target": 1}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "ldap_pvt_tls_init_def_ctx( int is_server )\n{\n\tstruct ldapoptions *lo = LDAP_INT_GLOBAL_OPT();   \n\tint rc;\n\tLDAP_MUTEX_LOCK( &tls_def_ctx_mutex );\n\trc = ldap_int_tls_init_ctx( lo, is_server );\n\tLDAP_MUTEX_UNLOCK( &tls_def_ctx_mutex );\n\treturn rc;\n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "spnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\tdsyslog(\"Entering inquire_cred\\n\");\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\t\tassert((*mechanisms)->elements != NULL);\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\treturn (status);\n}", "target": 0}
{"code": "ProcPutImage(ClientPtr client)\n{\n    GC *pGC;\n    DrawablePtr pDraw;\n    long length;                \n    long lengthProto;           \n    char *tmpImage;\n    REQUEST(xPutImageReq);\n    REQUEST_AT_LEAST_SIZE(xPutImageReq);\n    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);\n    if (stuff->format == XYBitmap) {\n        if ((stuff->depth != 1) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n    }\n    else if (stuff->format == XYPixmap) {\n        if ((pDraw->depth != stuff->depth) ||\n            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))\n            return BadMatch;\n        length = BitmapBytePad(stuff->width + stuff->leftPad);\n        length *= stuff->depth;\n    }\n    else if (stuff->format == ZPixmap) {\n        if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))\n            return BadMatch;\n        length = PixmapBytePad(stuff->width, stuff->depth);\n    }\n    else {\n        client->errorValue = stuff->format;\n        return BadValue;\n    }\n     tmpImage = (char *) &stuff[1];\n     lengthProto = length;\n    if (lengthProto >= (INT32_MAX / stuff->height))\n         return BadLength;\n     if ((bytes_to_int32(lengthProto * stuff->height) +\n         bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)\n        return BadLength;\n    ReformatImage(tmpImage, lengthProto * stuff->height,\n                  stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,\n                  ClientOrder(client));\n    (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,\n                           stuff->width, stuff->height,\n                           stuff->leftPad, stuff->format, tmpImage);\n    return Success;\n}", "target": 1}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "SampleEncrypter::Create(const AP4_UI08* key, const AP4_UI08* iv, SampleEncrypter*& encrypter) {\n    encrypter = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    encrypter = new SampleEncrypter(stream_cipher, iv);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "static int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "void SimpleSoftOMXComponent::onSendCommand(\n        OMX_COMMANDTYPE cmd, OMX_U32 param) {\n switch (cmd) {\n case OMX_CommandStateSet:\n {\n            onChangeState((OMX_STATETYPE)param);\n break;\n }\n case OMX_CommandPortEnable:\n case OMX_CommandPortDisable:\n {\n            onPortEnable(param, cmd == OMX_CommandPortEnable);\n break;\n }\n case OMX_CommandFlush:\n {\n            onPortFlush(param, true );\n break;\n }\n default:\n            TRESPASS();\n break;\n }\n}", "target": 0}
{"code": "RPVector *r_bin_wasm_get_functions(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_funcs? bin->g_funcs: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_FUNCTION);\n}", "target": 0}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}", "target": 1}
{"code": "SPL_METHOD(SplHeap, key)\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\t\t\n\tRETURN_LONG(intern->heap->count - 1);\n}", "target": 0}
{"code": "digest_hex(unsigned char *p)\n{\n    char *h = \"0123456789abcdef\";\n    Str tmp = Strnew_size(MD5_DIGEST_LENGTH * 2 + 1);\n    int i;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++, p++) {\n\tStrcat_char(tmp, h[(*p >> 4) & 0x0f]);\n\tStrcat_char(tmp, h[*p & 0x0f]);\n    }\n    return tmp;\n}", "target": 0}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "static void gen8_logical_ring_enable_irq(struct intel_engine_cs *engine)\n{\n\tENGINE_WRITE(engine, RING_IMR,\n\t\t     ~(engine->irq_enable_mask | engine->irq_keep_mask));\n\tENGINE_POSTING_READ(engine, RING_IMR);\n}", "target": 0}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}", "target": 1}
{"code": "op_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti = 0;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n    if (u_savecommon(start_lnum - 1, start_lnum + oap->line_count,\n\t\t\t\t     start_lnum + oap->line_count, FALSE) == OK)\n\tfor (i = oap->line_count; --i >= 0 && !got_int; )\n\t{\n\t    if (i > 1\n\t\t    && (i % 50 == 0 || i == oap->line_count - 1)\n\t\t    && oap->line_count > p_report)\n\t\tsmsg(_(\"%ld lines to indent... \"), i);\n\t    if (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t     || how != get_lisp_indent)\n\t    {\n\t\tl = skipwhite(ml_get_curline());\n\t\tif (*l == NUL)\t\t    \n\t\t    amount = 0;\n\t\telse\n\t\t    amount = how();\t    \n\t\tif (amount >= 0 && set_indent(amount, 0))\n\t\t{\n\t\t    if (first_changed == 0)\n\t\t\tfirst_changed = curwin->w_cursor.lnum;\n\t\t    last_changed = curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;  \n\t}\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}", "target": 0}
{"code": "static inline cputime_t virt_ticks(struct task_struct *p)\n{\n\treturn p->utime;\n}", "target": 0}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_fetch_all_columns)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n\tunsigned long colno=0;\n\tint pg_numrows, pg_row;\n\tsize_t num_fields;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &result, &colno) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, \"PostgreSQL result\", le_result);\n\tpgsql_result = pg_result->result;\n\tnum_fields = PQnfields(pgsql_result);\n\tif (colno >= num_fields || colno < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid column number '%ld'\", colno);\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\tif ((pg_numrows = PQntuples(pgsql_result)) <= 0) {\n\t\treturn;\n\t}\n\tfor (pg_row = 0; pg_row < pg_numrows; pg_row++) {\n\t\tif (PQgetisnull(pgsql_result, pg_row, colno)) {\n\t\t\tadd_next_index_null(return_value);\n\t\t} else {\n\t\t\tadd_next_index_string(return_value, PQgetvalue(pgsql_result, pg_row, colno), 1); \n\t\t}\n\t}\n}", "target": 0}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "void show_opcodes(u8 *rip, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\tif (probe_kernel_read(opcodes, rip - PROLOGUE_SIZE, OPCODE_BUFSIZE)) {\n\t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n\t} else {\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t}\n}", "target": 1}
{"code": "void Hybrid_type_traits_decimal::div(Hybrid_type *val, ulonglong u) const\n{\n  int2my_decimal(E_DEC_FATAL_ERROR, u, TRUE, &val->dec_buf[2]);\n  my_decimal_div(E_DEC_FATAL_ERROR,\n                 &val->dec_buf[val->used_dec_buf_no ^ 1],\n                 &val->dec_buf[val->used_dec_buf_no],\n                 &val->dec_buf[2], 4);\n  val->used_dec_buf_no^= 1;\n}", "target": 0}
{"code": "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 start = 0;\n\tint i;\n\twrite_lock(&em_tree->lock);\n\tdo {\n\t\tem = lookup_extent_mapping(em_tree, start, (u64)-1);\n\t\tif (!em)\n\t\t\tbreak;\n\t\tmap = em->map_lookup;\n\t\tfor (i = 0; i < map->num_stripes; i++)\n\t\t\tif (srcdev == map->stripes[i].dev)\n\t\t\t\tmap->stripes[i].dev = tgtdev;\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t} while (start);\n\twrite_unlock(&em_tree->lock);\n}", "target": 0}
{"code": "static int hog_init(void)\n{\n\tint err;\n\terr = suspend_init(suspend_callback, resume_callback);\n\tif (err < 0)\n\t\terror(\"Loading suspend plugin failed: %s (%d)\", strerror(-err),\n\t\t\t\t\t\t\t\t\t-err);\n\telse\n\t\tsuspend_supported = TRUE;\n\treturn btd_profile_register(&hog_profile);\n}", "target": 0}
{"code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}", "target": 1}
{"code": "ProcQueryTree(ClientPtr client)\n{\n    xQueryTreeReply reply;\n    int rc, numChildren = 0;\n    WindowPtr pChild, pWin, pHead;\n    Window *childIDs = (Window *) NULL;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);\n    if (rc != Success)\n        return rc;\n    reply = (xQueryTreeReply) {\n        .type = X_Reply,\n        .sequenceNumber = client->sequence,\n        .root = pWin->drawable.pScreen->root->drawable.id,\n        .parent = (pWin->parent) ? pWin->parent->drawable.id : (Window) None\n    };\n    pHead = RealChildHead(pWin);\n    for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)\n        numChildren++;\n    if (numChildren) {\n        int curChild = 0;\n        childIDs = malloc(numChildren * sizeof(Window));\n        if (!childIDs)\n            return BadAlloc;\n        for (pChild = pWin->lastChild; pChild != pHead;\n             pChild = pChild->prevSib)\n            childIDs[curChild++] = pChild->drawable.id;\n    }\n    reply.nChildren = numChildren;\n    reply.length = bytes_to_int32(numChildren * sizeof(Window));\n    WriteReplyToClient(client, sizeof(xQueryTreeReply), &reply);\n    if (numChildren) {\n        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n        WriteSwappedDataToClient(client, numChildren * sizeof(Window),\n                                 childIDs);\n        free(childIDs);\n    }\n    return Success;\n}", "target": 0}
{"code": "static int openssl_static_locks_install(void)\n{\n    int result;\n    if (openssl_locks != NULL)\n    {\n        LogInfo(\"Locks already initialized\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        openssl_locks = malloc(CRYPTO_num_locks() * sizeof(LOCK_HANDLE));\n        if (openssl_locks == NULL)\n        {\n            LogError(\"Failed to allocate locks\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            int i;\n            for (i = 0; i < CRYPTO_num_locks(); i++)\n            {\n                openssl_locks[i] = Lock_Init();\n                if (openssl_locks[i] == NULL)\n                {\n                    LogError(\"Failed to allocate lock %d\", i);\n                    break;\n                }\n            }\n            if (i != CRYPTO_num_locks())\n            {\n                int j;\n                for (j = 0; j < i; j++)\n                {\n                    Lock_Deinit(openssl_locks[j]);\n                }\n                result = MU_FAILURE;\n            }\n            else\n            {\n                CRYPTO_set_locking_callback(openssl_static_locks_lock_unlock_cb);\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "    TiffComponent::AutoPtr TiffParserWorker::parse(\n        const byte*              pData,\n              uint32_t           size,\n              uint32_t           root,\n              TiffHeaderBase*    pHeader\n    )\n    {\n        if (pData == 0 || size == 0) return TiffComponent::AutoPtr(0);\n        if (!pHeader->read(pData, size) || pHeader->offset() >= size) {\n            throw Error(3, \"TIFF\");\n        }\n        TiffComponent::AutoPtr rootDir = TiffCreator::create(root, ifdIdNotSet);\n        if (0 != rootDir.get()) {\n            rootDir->setStart(pData + pHeader->offset());\n            TiffRwState state(pHeader->byteOrder(), 0);\n            TiffReader reader(pData, size, rootDir.get(), state);\n            rootDir->accept(reader);\n            reader.postProcess();\n        }\n        return rootDir;\n    } ", "target": 0}
{"code": "void cgit_clone_info(void)\n{\n\tif (!ctx.qry.path || strcmp(ctx.qry.path, \"refs\")) {\n\t\tcgit_print_error_page(400, \"Bad request\", \"Bad request\");\n\t\treturn;\n\t}\n\tctx.page.mimetype = \"text/plain\";\n\tctx.page.filename = \"info/refs\";\n\tcgit_print_http_headers();\n\tfor_each_ref(print_ref_info, NULL);\n}", "target": 0}
{"code": "JANET_CORE_FN(cfun_array_ensure,\n              \"(array/ensure arr capacity growth)\",\n              \"Ensures that the memory backing the array is large enough for `capacity` \"\n              \"items at the given rate of growth. `capacity` and `growth` must be integers. \"\n              \"If the backing capacity is already enough, then this function does nothing. \"\n              \"Otherwise, the backing memory will be reallocated so that there is enough space.\") {\n    janet_fixarity(argc, 3);\n    JanetArray *array = janet_getarray(argv, 0);\n    int32_t newcount = janet_getinteger(argv, 1);\n    int32_t growth = janet_getinteger(argv, 2);\n    if (newcount < 1) janet_panic(\"expected positive integer\");\n    janet_array_ensure(array, newcount, growth);\n    return argv[0];\n}", "target": 0}
{"code": "static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\tnfs_invalidate_atime(dir);\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}", "target": 0}
{"code": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n    {\n        filesystem::path fsUploadPath(utils::toNativePath(\n            HttpAppFrameworkImpl::instance().getUploadPath()));\n        fsPath = fsUploadPath / fsPath;\n    }\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n    {\n        LOG_TRACE << \"create path:\" << fsPath;\n        drogon::error_code err;\n        filesystem::create_directories(fsPath, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n    return saveTo(fsPath / fsFileName);\n}", "target": 1}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\tres = new unsigned char[sizeof(DNSHeader) * 2];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); \n}", "target": 0}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}", "target": 1}
{"code": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n         return true;\n     default:\n         break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\trq->prev_mm = NULL;\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_lock_switch(rq, prev);\n\tfinish_arch_post_lock_switch();\n\tfire_sched_in_preempt_notifiers(current);\n\tif (mm)\n\t\tmmdrop(mm);\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\t\tkprobe_flush_task(prev);\n\t\tput_task_struct(prev);\n\t}\n\ttick_nohz_task_switch();\n\treturn rq;\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "lt_dlinsertsearchdir (const char *before, const char *search_dir)\n{\n  int errors = 0;\n  if (before)\n    {\n      if ((before < user_search_path)\n\t  || (before >= user_search_path + LT_STRLEN (user_search_path)))\n\t{\n\t  LT__SETERROR (INVALID_POSITION);\n\t  return 1;\n\t}\n    }\n  if (search_dir && *search_dir)\n    {\n      if (lt_dlpath_insertdir (&user_search_path,\n\t\t\t       (char *) before, search_dir) != 0)\n\t{\n\t  ++errors;\n\t}\n    }\n  return errors;\n}", "target": 0}
{"code": "    Loader::Loader(PreviewId id, const Image &image)\n        : id_(id), image_(image),\n          width_(0), height_(0),\n          size_(0),\n          valid_(false)\n    {\n    }", "target": 0}
{"code": "int soft_offline_page(struct page *page, int flags)\n{\n\tint ret;\n\tunsigned long pfn = page_to_pfn(page);\n\tif (PageHWPoison(page)) {\n\t\tpr_info(\"soft offline: %#lx page already poisoned\\n\", pfn);\n\t\tif (flags & MF_COUNT_INCREASED)\n\t\t\tput_hwpoison_page(page);\n\t\treturn -EBUSY;\n\t}\n\tget_online_mems();\n\tret = get_any_page(page, pfn, flags);\n\tput_online_mems();\n\tif (ret > 0)\n\t\tret = soft_offline_in_use_page(page, flags);\n\telse if (ret == 0)\n\t\tsoft_offline_free_page(page);\n\treturn ret;\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "static int gdAlphaOverlayColor (int src, int dst, int max )\n{\n\tdst = dst << 1;\n\tif( dst > max ) {\n\t\treturn dst + (src << 1) - (dst * src / max) - max;\n\t} else {\n\t\treturn dst * src / max;\n\t}\n}", "target": 0}
{"code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}", "target": 1}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "static const char *_get_ntstatus_error_string(const char *nt_status_string)\n{\n\tint i;\n\tfor (i=0; ntstatus_errors[i].ntstatus_string != NULL; i++) {\n\t\tif (!strcasecmp(ntstatus_errors[i].ntstatus_string,\n\t\t\t\tnt_status_string)) {\n\t\t\treturn _(ntstatus_errors[i].error_string);\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "bool Matrix::invertTo(Matrix *other) const\n{\n    const double det_denominator = determinant();\n    if (unlikely(det_denominator == 0)) {\n        *other = { 1, 0, 0, 1, 0, 0 };\n        return false;\n    }\n    const double det = 1 / det_denominator;\n    other->m[0] = m[3] * det;\n    other->m[1] = -m[1] * det;\n    other->m[2] = -m[2] * det;\n    other->m[3] = m[0] * det;\n    other->m[4] = (m[2] * m[5] - m[3] * m[4]) * det;\n    other->m[5] = (m[1] * m[4] - m[0] * m[5]) * det;\n    return true;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}", "target": 1}
{"code": "static int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\ttxq_params->ac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\tif (txq_params->ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; \n\tint index;\n\tint i;\n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) \n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}", "target": 1}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  static FullTypeDef* no_type = new FullTypeDef();\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 1}
{"code": "gfx::Image GetTabAlertIndicatorImage(TabAlertState alert_state,\n                                     SkColor button_color) {\n  const gfx::VectorIcon* icon = nullptr;\n  switch (alert_state) {\n    case TabAlertState::AUDIO_PLAYING:\n      icon = &kTabAudioIcon;\n      break;\n    case TabAlertState::AUDIO_MUTING:\n      icon = &kTabAudioMutingIcon;\n      break;\n    case TabAlertState::MEDIA_RECORDING:\n      icon = &kTabMediaRecordingIcon;\n      break;\n    case TabAlertState::TAB_CAPTURING:\n      icon = &kTabMediaCapturingIcon;\n      break;\n    case TabAlertState::BLUETOOTH_CONNECTED:\n      icon = &kTabBluetoothConnectedIcon;\n      break;\n    case TabAlertState::USB_CONNECTED:\n      icon = &kTabUsbConnectedIcon;\n      break;\n    case TabAlertState::NONE:\n      return gfx::Image();\n  }\n  DCHECK(icon);\n  return gfx::Image(gfx::CreateVectorIcon(*icon, 16, button_color));\n}", "target": 0}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": " static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n \t\t\tunsigned int dataoff, unsigned int *timeouts)\n {\n\treturn true;\n }", "target": 1}
{"code": "AP_DECLARE(void) ap_set_content_length(request_rec *r, apr_off_t clength)\n{\n    r->clength = clength;\n    apr_table_setn(r->headers_out, \"Content-Length\",\n                   apr_off_t_toa(r->pool, clength));\n}", "target": 0}
{"code": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}", "target": 1}
{"code": "__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\tcgroup_exclude_rmdir(&memcg->css);\n\t__mem_cgroup_commit_charge_lrucare(page, memcg, ctype);\n\tif (do_swap_account && PageSwapCache(page)) {\n\t\tswp_entry_t ent = {.val = page_private(page)};\n\t\tstruct mem_cgroup *swap_memcg;\n\t\tunsigned short id;\n\t\tid = swap_cgroup_record(ent, 0);\n\t\trcu_read_lock();\n\t\tswap_memcg = mem_cgroup_lookup(id);\n\t\tif (swap_memcg) {\n\t\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\t\tres_counter_uncharge(&swap_memcg->memsw,\n\t\t\t\t\t\t     PAGE_SIZE);\n\t\t\tmem_cgroup_swap_statistics(swap_memcg, false);\n\t\t\tmem_cgroup_put(swap_memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}", "target": 0}
{"code": "void LibRaw::ahd_interpolate_green_h_and_v(\n    int top, int left, ushort (*out_rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + LIBRAW_AHD_TILE, height - 2);\n  const int collimit = MIN(left + LIBRAW_AHD_TILE, width - 2);\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val =\n          ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >>\n          2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 -\n             pix[-2 * width][c] - pix[2 * width][c]) >>\n            2;\n      out_rgb[1][row - top][col - left][1] =\n          ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}", "target": 0}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "handle_action(netdissect_options *ndo,\n              const uint8_t *src, const u_char *p, u_int length)\n{\n\tif (!ND_TTEST2(*p, 2))\n\t\treturn 0;\n\tif (length < 2)\n\t\treturn 0;\n\tif (ndo->ndo_eflag) {\n\t\tND_PRINT((ndo, \": \"));\n\t} else {\n\t\tND_PRINT((ndo, \" (%s): \", etheraddr_string(ndo, src)));\n\t}\n\tswitch (p[0]) {\n\tcase 0: ND_PRINT((ndo, \"Spectrum Management Act#%d\", p[1])); break;\n\tcase 1: ND_PRINT((ndo, \"QoS Act#%d\", p[1])); break;\n\tcase 2: ND_PRINT((ndo, \"DLS Act#%d\", p[1])); break;\n\tcase 3: ND_PRINT((ndo, \"BA \")); PRINT_BA_ACTION(p[1]); break;\n\tcase 7: ND_PRINT((ndo, \"HT \")); PRINT_HT_ACTION(p[1]); break;\n\tcase 13: ND_PRINT((ndo, \"MeshAction \")); PRINT_MESH_ACTION(p[1]); break;\n\tcase 14:\n\t\tND_PRINT((ndo, \"MultiohopAction \"));\n\t\tPRINT_MULTIHOP_ACTION(p[1]); break;\n\tcase 15:\n\t\tND_PRINT((ndo, \"SelfprotectAction \"));\n\t\tPRINT_SELFPROT_ACTION(p[1]); break;\n\tcase 127: ND_PRINT((ndo, \"Vendor Act#%d\", p[1])); break;\n\tdefault:\n\t\tND_PRINT((ndo, \"Reserved(%d) Act#%d\", p[0], p[1]));\n\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "KCleanup::selectionChanged( KFileInfo *selection )\n{\n    bool enabled = false;\n    _selection = selection;\n    if ( selection )\n    {\n\tenabled = worksFor( selection );\n\tif ( ! selection->isFinished() )\n\t{\n\t    switch ( _refreshPolicy )\n\t    {\n\t\tcase refreshThis:\n\t\tcase refreshParent:\n\t\tcase assumeDeleted:\n\t\t    enabled = false;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n    }\n    KAction::setEnabled( enabled );\n}", "target": 0}
{"code": "void spl_object_storage_addall(spl_SplObjectStorage *intern, zval *this, spl_SplObjectStorage *other TSRMLS_DC) { \n\tHashPosition pos;\n\tspl_SplObjectStorageElement *element;\n\tzend_hash_internal_pointer_reset_ex(&other->storage, &pos);\n\twhile (zend_hash_get_current_data_ex(&other->storage, (void **)&element, &pos) == SUCCESS) {\n\t\tspl_object_storage_attach(intern, this, element->obj, element->inf TSRMLS_CC);\n\t\tzend_hash_move_forward_ex(&other->storage, &pos);\n\t}\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} ", "target": 0}
{"code": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "void cred_to_ucred(struct pid *pid, const struct cred *cred,\n\t\t   struct ucred *ucred)\n{\n\tucred->pid = pid_vnr(pid);\n\tucred->uid = ucred->gid = -1;\n\tif (cred) {\n\t\tstruct user_namespace *current_ns = current_user_ns();\n\t\tucred->uid = from_kuid(current_ns, cred->euid);\n\t\tucred->gid = from_kgid(current_ns, cred->egid);\n\t}\n}", "target": 0}
{"code": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n{\n    int r, b;\n    b = cdt[p2];\n    r = cdt[p1]<<16;\n    return (b+r) << 1;\n}", "target": 0}
{"code": "static int find_length(struct pdf_struct *pdf,\n\t\t       struct pdf_obj *obj,\n\t\t       const char *start, off_t len)\n{\n    int length;\n    const char *q;\n    q = cli_memstr(start, len, \"/Length\", 7);\n    if (!q)\n\treturn 0;\n    q++;\n    len -= q - start;\n    start = pdf_nextobject(q, len);\n    if (!start)\n\treturn 0;\n    q = start;\n    length = atoi(q);\n    while (isdigit(*q)) q++;\n    if (*q == ' ') {\n\tint genid;\n\tq++;\n\tgenid = atoi(q);\n\twhile(isdigit(*q)) q++;\n\tif (q[0] == ' ' && q[1] == 'R') {\n\t    cli_dbgmsg(\"cli_pdf: length is in indirect object %u %u\\n\", length, genid);\n\t    obj = find_obj(pdf, obj, (length << 8) | (genid&0xff));\n\t    if (!obj) {\n\t\tcli_dbgmsg(\"cli_pdf: indirect object not found\\n\");\n\t\treturn 0;\n\t    }\n\t    q = pdf_nextobject(pdf->map+obj->start, pdf->size - obj->start);\n\t    length = atoi(q);\n\t}\n    }\n    if (start - pdf->map + length+5 > pdf->size) {\n\tlength = pdf->size - (start - pdf->map)-5;\n    }\n    return length;\n}", "target": 0}
{"code": "void for_each_server(PgPool *pool, void (*func)(PgSocket *sk))\n{\n\tstruct List *item;\n\tstatlist_for_each(item, &pool->idle_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->used_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->tested_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->active_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n\tstatlist_for_each(item, &pool->new_server_list)\n\t\tfunc(container_of(item, PgSocket, head));\n}", "target": 0}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "\t__must_hold(wqe->lock)\n{\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tif (!(worker->flags & IO_WORKER_F_UP))\n\t\treturn;\n\tif (atomic_dec_and_test(&acct->nr_running) && io_acct_run_queue(acct)) {\n\t\tatomic_inc(&acct->nr_running);\n\t\tatomic_inc(&wqe->wq->worker_refs);\n\t\tio_queue_worker_create(worker, acct, create_worker_cb);\n\t}\n}", "target": 0}
{"code": "PHP_FUNCTION(curl_version)\n{\n\tcurl_version_info_data *d;\n\tlong uversion = CURLVERSION_NOW;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &uversion) == FAILURE) {\n\t\treturn;\n\t}\n\td = curl_version_info(uversion);\n\tif (d == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\tCAAL(\"version_number\", d->version_num);\n\tCAAL(\"age\", d->age);\n\tCAAL(\"features\", d->features);\n\tCAAL(\"ssl_version_number\", d->ssl_version_num);\n\tCAAS(\"version\", d->version);\n\tCAAS(\"host\", d->host);\n\tCAAS(\"ssl_version\", d->ssl_version);\n\tCAAS(\"libz_version\", d->libz_version);\n\t{\n\t\tchar **p = (char **) d->protocols;\n\t\tzval  *protocol_list = NULL;\n\t\tMAKE_STD_ZVAL(protocol_list);\n\t\tarray_init(protocol_list);\n\t\twhile (*p != NULL) {\n\t\t\tadd_next_index_string(protocol_list, *p, 1);\n\t\t\tp++;\n\t\t}\n\t\tCAAZ(\"protocols\", protocol_list);\n\t}\n}", "target": 0}
{"code": "cmsUInt32Number  GenerateCRD(cmsContext ContextID,\n                             cmsHPROFILE hProfile,\n                             cmsUInt32Number Intent, cmsUInt32Number dwFlags,\n                             cmsIOHANDLER* mem)\n{\n    cmsUInt32Number dwBytesUsed;\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n        EmitHeader(mem, \"Color Rendering Dictionary (CRD)\", hProfile);\n    }\n    if (cmsGetDeviceClass(hProfile) == cmsSigNamedColorClass) {\n        if (!WriteNamedColorCRD(mem, hProfile, Intent, dwFlags)) {\n            return 0;\n        }\n    }\n    else {\n        if (!WriteOutputLUT(mem, hProfile, Intent, dwFlags)) {\n            return 0;\n        }\n    }\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n        _cmsIOPrintf(mem, \"%%%%EndResource\\n\");\n        _cmsIOPrintf(mem, \"\\n%% CRD End\\n\");\n    }\n    dwBytesUsed = mem ->UsedSpace;\n    return dwBytesUsed;\n    cmsUNUSED_PARAMETER(ContextID);\n}", "target": 0}
{"code": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = 2 * capacity() + 1; \n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);\n  }\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}", "target": 1}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "user_local_save_to_keyfile (User     *user,\n                            GKeyFile *keyfile)\n{\n        if (user->email)\n                g_key_file_set_string (keyfile, \"User\", \"Email\", user->email);\n        if (user->language)\n                g_key_file_set_string (keyfile, \"User\", \"Language\", user->language);\n        if (user->x_session)\n                g_key_file_set_string (keyfile, \"User\", \"XSession\", user->x_session);\n        if (user->location)\n                g_key_file_set_string (keyfile, \"User\", \"Location\", user->location);\n        if (user->password_hint)\n                g_key_file_set_string (keyfile, \"User\", \"PasswordHint\", user->password_hint);\n        if (user->icon_file)\n                g_key_file_set_string (keyfile, \"User\", \"Icon\", user->icon_file);\n}", "target": 0}
{"code": "vhost_user_set_req_fd(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"Invalid file descriptor for slave channel (%d)\\n\",\n\t\t\t\tfd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->slave_req_fd >= 0)\n\t\tclose(dev->slave_req_fd);\n\tdev->slave_req_fd = fd;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "static inline zend_long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tzend_long elements;\n\telements = parse_iv2((*p) + 2, p);\n\t(*p) += 2;\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(rval, ce);\n\t} else {\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name->val);\n\t\treturn 0;\n\t}\n\treturn elements;\n}", "target": 0}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "static void power_pmu_disable(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuhw;\n\tunsigned long flags;\n\tif (!ppmu)\n\t\treturn;\n\tlocal_irq_save(flags);\n\tcpuhw = &__get_cpu_var(cpu_hw_events);\n\tif (!cpuhw->disabled) {\n\t\tcpuhw->disabled = 1;\n\t\tcpuhw->n_added = 0;\n\t\tif (!cpuhw->pmcs_enabled) {\n\t\t\tppc_enable_pmcs();\n\t\t\tcpuhw->pmcs_enabled = 1;\n\t\t}\n\t\tif (cpuhw->mmcr[2] & MMCRA_SAMPLE_ENABLE) {\n\t\t\tmtspr(SPRN_MMCRA,\n\t\t\t      cpuhw->mmcr[2] & ~MMCRA_SAMPLE_ENABLE);\n\t\t\tmb();\n\t\t}\n\t\twrite_mmcr0(cpuhw, mfspr(SPRN_MMCR0) | MMCR0_FC);\n\t\tmb();\n\t}\n\tlocal_irq_restore(flags);\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 0}
{"code": "static char *failover_find_primary_device_id(VirtIONet *n)\n{\n    Error *err = NULL;\n    FailoverId fid;\n    fid.n = n;\n    if (!qemu_opts_foreach(qemu_find_opts(\"device\"),\n                           failover_set_primary, &fid, &err)) {\n        return NULL;\n    }\n    return fid.id;\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "PHPAPI char *php_replace_controlchars(char *str)\n{\n\treturn php_replace_controlchars_ex(str, strlen(str));\n}", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 1}
{"code": "int X509_REQ_add_extensions_nid(X509_REQ *req, STACK_OF(X509_EXTENSION) *exts,\n                                int nid)\n{\n    ASN1_TYPE *at = NULL;\n    X509_ATTRIBUTE *attr = NULL;\n    if (!(at = ASN1_TYPE_new()) || !(at->value.sequence = ASN1_STRING_new()))\n        goto err;\n    at->type = V_ASN1_SEQUENCE;\n    at->value.sequence->length =\n        ASN1_item_i2d((ASN1_VALUE *)exts,\n                      &at->value.sequence->data,\n                      ASN1_ITEM_rptr(X509_EXTENSIONS));\n    if (!(attr = X509_ATTRIBUTE_new()))\n        goto err;\n    if (!(attr->value.set = sk_ASN1_TYPE_new_null()))\n        goto err;\n    if (!sk_ASN1_TYPE_push(attr->value.set, at))\n        goto err;\n    at = NULL;\n    attr->single = 0;\n    attr->object = OBJ_nid2obj(nid);\n    if (!req->req_info->attributes) {\n        if (!(req->req_info->attributes = sk_X509_ATTRIBUTE_new_null()))\n            goto err;\n    }\n    if (!sk_X509_ATTRIBUTE_push(req->req_info->attributes, attr))\n        goto err;\n    return 1;\n err:\n    X509_ATTRIBUTE_free(attr);\n    ASN1_TYPE_free(at);\n    return 0;\n}", "target": 0}
{"code": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = s->node[node];\n\t\tif (n && n != &s->local_node)\n\t\t\tkmem_cache_free(kmalloc_caches, n);\n\t\ts->node[node] = NULL;\n\t}\n}", "target": 0}
{"code": "static int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}", "target": 0}
{"code": "int git_delta_read_header_fromstream(\n\tsize_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\t\tif (read == 0)\n\t\t\tbreak;\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\t\tlen += read;\n\t}\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t\t(hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}", "target": 0}
{"code": "static void sr_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\n{\n\tusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t       value, reg, NULL, 0);\n}", "target": 0}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n \tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "static int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = UDRS->spinup_date;\n\tv.select_date = UDRS->select_date;\n\tv.first_read_date = UDRS->first_read_date;\n\tv.probed_format = UDRS->probed_format;\n\tv.track = UDRS->track;\n\tv.maxblock = UDRS->maxblock;\n\tv.maxtrack = UDRS->maxtrack;\n\tv.generation = UDRS->generation;\n\tv.keep_data = UDRS->keep_data;\n\tv.fd_ref = UDRS->fd_ref;\n\tv.fd_device = UDRS->fd_device;\n\tv.last_checked = UDRS->last_checked;\n\tv.dmabuf = (uintptr_t)UDRS->dmabuf;\n\tv.bufblocks = UDRS->bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "static int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\treturn err;\n}", "target": 0}
{"code": "static void __mcheck_cpu_init_generic(void)\n{\n\tenum mcp_flags m_fl = 0;\n\tmce_banks_t all_banks;\n\tu64 cap;\n\tif (!mca_cfg.bootlog)\n\t\tm_fl = MCP_DONTLOG;\n\tbitmap_fill(all_banks, MAX_NR_BANKS);\n\tmachine_check_poll(MCP_UC | m_fl, &all_banks);\n\tcr4_set_bits(X86_CR4_MCE);\n\trdmsrl(MSR_IA32_MCG_CAP, cap);\n\tif (cap & MCG_CTL_P)\n\t\twrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);\n}", "target": 0}
{"code": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tnpoints = NPOINTS;\n\tcol = COL;\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\tefree(points);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_set_absolute_volume(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tint8_t volume;\n\tif (len != 1)\n\t\tgoto err;\n\tvolume = pdu->params[0] & 0x7F;\n\tmedia_transport_update_device_volume(session->dev, volume);\n\treturn AVC_CTYPE_ACCEPTED;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "xfs_ioctl_setattr_prepare_dax(\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode            *inode = VFS_I(ip);\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\tif (xfs_has_dax_always(mp) || xfs_has_dax_never(mp))\n\t\treturn;\n\tif (((fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t    !(ip->i_diflags2 & XFS_DIFLAG2_DAX)) ||\n\t    (!(fa->fsx_xflags & FS_XFLAG_DAX) &&\n\t     (ip->i_diflags2 & XFS_DIFLAG2_DAX)))\n\t\td_mark_dontcache(inode);\n}", "target": 0}
{"code": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tceph_set_cached_acl(inode, type, acl);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static const char *unset_define(cmd_parms *cmd, void *dummy,\n                                const char *name)\n{\n    int i;\n    const char **defines;\n    if (cmd->parent && ap_cstr_casecmp(cmd->parent->directive, \"<VirtualHost\")) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name, \" is not valid in \",\n                                      cmd->parent->directive, \" context\", NULL);\n    }\n    if (ap_strchr_c(name, ':') != NULL) {\n        return \"Variable name must not contain ':'\";\n    }\n    if (!saved_server_config_defines) {\n        init_config_defines(cmd->pool);\n    }\n    defines = (const char **)ap_server_config_defines->elts;\n    for (i = 0; i < ap_server_config_defines->nelts; i++) {\n        if (strcmp(defines[i], name) == 0) {\n            defines[i] = *(const char **)apr_array_pop(ap_server_config_defines);\n            break;\n        }\n    }\n    if (server_config_defined_vars) {\n        apr_table_unset(server_config_defined_vars, name);\n    }\n    return NULL;\n}", "target": 0}
{"code": "wchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  if (DestPath!=NULL)\n  {\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}", "target": 1}
{"code": "static void fuse_lib_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct statvfs buf;\n    char *path;\n    int err;\n    memset(&buf, 0, sizeof(buf));\n    pthread_rwlock_rdlock(&f->tree_lock);\n    if (!ino) {\n        err = -ENOMEM;\n        path = strdup(\"/\");\n    } else {\n        err = -ENOENT;\n        path = get_path(f, ino);\n    }\n    if (path) {\n        struct fuse_intr_data d;\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_statfs(f->fs, path, &buf);\n        fuse_finish_interrupt(f, req, &d);\n        free(path);\n    }\n    pthread_rwlock_unlock(&f->tree_lock);\n    if (!err)\n        fuse_reply_statfs(req, &buf);\n    else\n        reply_err(req, err);\n}", "target": 0}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n out_cleanup:\n \tovl_cleanup(wdir, newdentry);\n\tgoto out;\n }", "target": 1}
{"code": "rdpdr_handle_ok(int device, int handle)\n{\n\tswitch (g_rdpdr_device[device].device_type)\n\t{\n\t\tcase DEVICE_TYPE_PARALLEL:\n\t\tcase DEVICE_TYPE_SERIAL:\n\t\tcase DEVICE_TYPE_PRINTER:\n\t\tcase DEVICE_TYPE_SCARD:\n\t\t\tif (g_rdpdr_device[device].handle != handle)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t\tcase DEVICE_TYPE_DISK:\n\t\t\tif (g_fileinfo[handle].device_id != device)\n\t\t\t\treturn False;\n\t\t\tbreak;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int selinux_is_sblabel_mnt(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tBUILD_BUG_ON(SECURITY_FS_USE_MAX != 7);\n\tswitch (sbsec->behavior) {\n\tcase SECURITY_FS_USE_XATTR:\n\tcase SECURITY_FS_USE_TRANS:\n\tcase SECURITY_FS_USE_TASK:\n\tcase SECURITY_FS_USE_NATIVE:\n\t\treturn 1;\n\tcase SECURITY_FS_USE_GENFS:\n\t\treturn selinux_is_genfs_special_handling(sb);\n\tcase SECURITY_FS_USE_MNTPOINT:\n\tcase SECURITY_FS_USE_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 1}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "mm_destroy(struct mm_master *mm)\n{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %zu): %s\", mm->address, mm->size,\n\t\t    strerror(errno));\n\tif (mm->mmalloc == NULL)\n\t\tfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "waitfd(int fd, int *timeoutp, short events)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\tpfd.fd = fd;\n\tpfd.events = events;\n\tfor (; *timeoutp >= 0;) {\n\t\tmonotime_tv(&t_start);\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN && errno != EINTR)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\terrno = ETIMEDOUT;\n\treturn -1;\n}", "target": 0}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) \n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}", "target": 1}
{"code": " void EnsureInitializeForAndroidLayoutTests() {\n  CHECK(CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree));\n   JNIEnv* env = base::android::AttachCurrentThread();\n   content::NestedMessagePumpAndroid::RegisterJni(env);\n   content::RegisterNativesImpl(env);\n  bool success = base::MessageLoop::InitMessagePumpForUIFactory(\n      &CreateMessagePumpForUI);\n  CHECK(success) << \"Unable to initialize the message pump for Android.\";\n  base::FilePath files_dir(GetTestFilesDirectory(env));\n  base::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\n  EnsureCreateFIFO(stdout_fifo);\n  base::FilePath stderr_fifo(\n      files_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\n  EnsureCreateFIFO(stderr_fifo);\n  base::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\n  EnsureCreateFIFO(stdin_fifo);\n  success = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\n            base::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\n            base::android::RedirectStream(stderr, stderr_fifo, \"w\");\n  CHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 1}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "bitset_is_empty(BitSetRef bs)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) {\n    if (bs[i] != 0) return 0;\n  }\n  return 1;\n}", "target": 0}
{"code": "int service_init(int argc __attribute__((unused)),\n\t\t char **argv __attribute__((unused)),\n\t\t char **envp __attribute__((unused)))\n{\n    int opt;\n    const char *prefix;\n    initialize_nntp_error_table();\n    if (geteuid() == 0) fatal(\"must run as the Cyrus user\", EC_USAGE);\n    setproctitle_init(argc, argv, envp);\n    signals_set_shutdown(&shut_down);\n    signal(SIGPIPE, SIG_IGN);\n    global_sasl_init(1, 1, mysasl_cb);\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(newsprefix, sizeof(newsprefix), \"%s.\", prefix);\n    newsgroups = split_wildmats((char *) config_getstring(IMAPOPT_NEWSGROUPS));\n    if (duplicate_init(NULL, 0) != 0) {\n\tsyslog(LOG_ERR, \n\t       \"unable to init duplicate delivery database\\n\");\n\tfatal(\"unable to init duplicate delivery database\", EC_SOFTWARE);\n    }\n    mboxlist_init(0);\n    mboxlist_open(NULL);\n    quotadb_init(0);\n    quotadb_open(NULL);\n    denydb_init(0);\n    denydb_open(NULL);\n    idle_enabled();\n    while ((opt = getopt(argc, argv, \"srfp:\")) != EOF) {\n\tswitch(opt) {\n\tcase 's': \n\t    nntps = 1;\n\t    if (!tls_enabled()) {\n\t\tsyslog(LOG_ERR, \"nntps: required OpenSSL options not present\");\n\t\tfatal(\"nntps: required OpenSSL options not present\",\n\t\t      EC_CONFIG);\n\t    }\n\t    break;\n\tcase 'r': \n\t    nntp_capa = MODE_READ;\n\t    break;\n\tcase 'f': \n\t    nntp_capa = MODE_FEED;\n\t    break;\n\tcase 'p': \n\t    extprops_ssf = atoi(optarg);\n\t    break;\n\tdefault:\n\t    usage();\n\t}\n    }\n    annotatemore_init(NULL, NULL);\n    annotatemore_open();\n    newsmaster = (char *) config_getstring(IMAPOPT_NEWSMASTER);\n    newsmaster_authstate = auth_newstate(newsmaster);\n    singleinstance = config_getswitch(IMAPOPT_SINGLEINSTANCESTORE);\n    protin = protgroup_new(2);\n    return 0;\n}", "target": 0}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "int HeaderMapWrapper::luaPairs(lua_State* state) {\n  if (iterator_.get() != nullptr) {\n    luaL_error(state, \"cannot create a second iterator before completing the first\");\n  }\n  iterator_.reset(HeaderMapIterator::create(state, *this), true);\n  lua_pushcclosure(state, HeaderMapIterator::static_luaPairsIterator, 1);\n  return 1;\n}", "target": 0}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "ZEND_API int add_property_string_ex(zval *arg, const char *key, uint key_len, const char *str, int duplicate TSRMLS_DC) \n{\n\tzval *tmp;\n\tzval *z_key;\n\tsize_t _len = strlen(str);\n\tif (UNEXPECTED(_len > INT_MAX)) {\n\t\tzend_error_noreturn(E_ERROR, \"String overflow, max size is %d\", INT_MAX);\n\t}\n\tMAKE_STD_ZVAL(tmp);\n\tZVAL_STRINGL(tmp, str, _len, duplicate);\n\tMAKE_STD_ZVAL(z_key);\n\tZVAL_STRINGL(z_key, key, key_len-1, 1);\n\tZ_OBJ_HANDLER_P(arg, write_property)(arg, z_key, tmp, 0 TSRMLS_CC);\n\tzval_ptr_dtor(&tmp); \n\tzval_ptr_dtor(&z_key);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tbool isolated_pageblocks;\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\twhile (count) {\n\t\tstruct page *page;\n\t\tstruct list_head *list;\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\t\tdo {\n\t\t\tint mt;\t\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tmt = get_pcppage_migratetype(page);\n\t\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t\tif (unlikely(isolated_pageblocks))\n\t\t\t\tmt = get_pageblock_migratetype(page);\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\t\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\tspin_unlock(&zone->lock);\n}", "target": 0}
{"code": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask, gfp_t gfp_mask)\n{\n\tspin_lock_irq(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock_irq(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock_irq(&hugetlb_lock);\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}", "target": 0}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "static CURLcode cookie_output(struct Curl_easy *data,\n                              struct CookieInfo *c, const char *filename)\n{\n  struct Cookie *co;\n  FILE *out = NULL;\n  bool use_stdout = FALSE;\n  char *tempstore = NULL;\n  CURLcode error = CURLE_OK;\n  if(!c)\n    return CURLE_OK;\n  remove_expired(c);\n  if(!strcmp(\"-\", filename)) {\n    out = stdout;\n    use_stdout = TRUE;\n  }\n  else {\n    error = Curl_fopen(data, filename, &out, &tempstore);\n    if(error)\n      goto error;\n  }\n  fputs(\"# Netscape HTTP Cookie File\\n\"\n        \"# https:\n        \"# This file was generated by libcurl! Edit at your own risk.\\n\\n\",\n        out);\n  if(c->numcookies) {\n    unsigned int i;\n    size_t nvalid = 0;\n    struct Cookie **array;\n    array = calloc(1, sizeof(struct Cookie *) * c->numcookies);\n    if(!array) {\n      error = CURLE_OUT_OF_MEMORY;\n      goto error;\n    }\n    for(i = 0; i < COOKIE_HASH_SIZE; i++) {\n      for(co = c->cookies[i]; co; co = co->next) {\n        if(!co->domain)\n          continue;\n        array[nvalid++] = co;\n      }\n    }\n    qsort(array, nvalid, sizeof(struct Cookie *), cookie_sort_ct);\n    for(i = 0; i < nvalid; i++) {\n      char *format_ptr = get_netscape_format(array[i]);\n      if(!format_ptr) {\n        free(array);\n        error = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n      fprintf(out, \"%s\\n\", format_ptr);\n      free(format_ptr);\n    }\n    free(array);\n  }\n  if(!use_stdout) {\n    fclose(out);\n    out = NULL;\n    if(tempstore && Curl_rename(tempstore, filename)) {\n      unlink(tempstore);\n      error = CURLE_WRITE_ERROR;\n      goto error;\n    }\n  }\n  free(tempstore);\n  return CURLE_OK;\nerror:\n  if(out && !use_stdout)\n    fclose(out);\n  free(tempstore);\n  return error;\n}", "target": 0}
{"code": "Bool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "AP_DECLARE(const char *) ap_get_useragent_host(request_rec *r,\n                                               int type, int *str_is_ip)\n{\n    conn_rec *conn = r->connection;\n    int hostname_lookups;\n    int ignored_str_is_ip;\n    if (!r->useragent_addr || (r->useragent_addr == conn->client_addr)) {\n        return ap_get_remote_host(conn, r->per_dir_config, type, str_is_ip);\n    }\n    if (!str_is_ip) { \n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n    hostname_lookups = ((core_dir_config *)\n                        ap_get_core_module_config(r->per_dir_config))\n                            ->hostname_lookups;\n    if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n    if (type != REMOTE_NOLOOKUP\n        && r->useragent_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n        if (apr_getnameinfo(&r->useragent_host, r->useragent_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(r->useragent_host);\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                r->double_reverse = do_double_reverse(r->double_reverse,\n                                                      r->useragent_host,\n                                                      r->useragent_addr,\n                                                      r->pool);\n                if (r->double_reverse != 1) {\n                    r->useragent_host = NULL;\n                }\n            }\n        }\n        if (r->useragent_host == NULL) {\n            r->useragent_host = \"\";\n        }\n    }\n    if (type == REMOTE_DOUBLE_REV) {\n        r->double_reverse = do_double_reverse(r->double_reverse,\n                                              r->useragent_host,\n                                              r->useragent_addr, r->pool);\n        if (r->double_reverse == -1) {\n            return NULL;\n        }\n    }\n    if (r->useragent_host != NULL && r->useragent_host[0] != '\\0') {\n        return r->useragent_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return r->useragent_ip;\n        }\n    }\n}", "target": 0}
{"code": "option_handler (assuan_context_t ctx, const char *key, const char *value)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  if (!strcmp (key, \"event-signal\"))\n    {\n#ifdef HAVE_W32_SYSTEM\n      if (!*value)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = strtoul (value, NULL, 16);\n#else\n      int i = *value? atoi (value) : -1;\n      if (i < 0)\n        return gpg_error (GPG_ERR_ASS_PARAMETER);\n      ctrl->server_local->event_signal = i;\n#endif\n    }\n return 0;\n}", "target": 0}
{"code": "      unsigned int scalar4(const mp_func op,\n                           const unsigned int arg1, const unsigned int arg2, const unsigned int arg3,\n                           const unsigned int arg4) {\n        const unsigned int pos =\n          arg1>_cimg_mp_slot_c && _cimg_mp_is_comp(arg1)?arg1:\n          arg2>_cimg_mp_slot_c && _cimg_mp_is_comp(arg2)?arg2:\n          arg3>_cimg_mp_slot_c && _cimg_mp_is_comp(arg3)?arg3:\n          arg4>_cimg_mp_slot_c && _cimg_mp_is_comp(arg4)?arg4:scalar();\n        CImg<ulongT>::vector((ulongT)op,pos,arg1,arg2,arg3,arg4).move_to(code);\n        return pos;", "target": 0}
{"code": "SpiceMsgChannels *reds_msg_channels_new(RedsState *reds)\n{\n    SpiceMsgChannels* channels_info;\n    spice_assert(reds != NULL);\n    channels_info = (SpiceMsgChannels *)g_malloc(sizeof(SpiceMsgChannels)\n                            + reds->channels.size() * sizeof(SpiceChannelId));\n    reds_fill_channels(reds, channels_info);\n    return channels_info;\n}", "target": 0}
{"code": "lexer_compare_identifier_to_current (parser_context_t *context_p,        \n                                     const lexer_lit_location_t *right)  \n{\n  lexer_lit_location_t *left = &context_p->token.lit_location;\n  const uint8_t *left_p;\n  const uint8_t *right_p;\n  size_t count;\n  JERRY_ASSERT (left->length > 0 && right->length > 0);\n  if (left->length != right->length)\n  {\n    return 0;\n  }\n  if (!left->has_escape && !right->has_escape)\n  {\n    return memcmp (left->char_p, right->char_p, left->length) == 0;\n  }\n  left_p = left->char_p;\n  right_p = right->char_p;\n  count = left->length;\n  do\n  {\n    uint8_t utf8_buf[3];\n    size_t utf8_len, offset;\n    if (*left_p != LIT_CHAR_BACKSLASH && *right_p != LIT_CHAR_BACKSLASH)\n    {\n      if (*left_p++ != *right_p++)\n      {\n        return false;\n      }\n      count--;\n      continue;\n    }\n    if (*left_p == LIT_CHAR_BACKSLASH && *right_p == LIT_CHAR_BACKSLASH)\n    {\n      uint16_t left_chr = lexer_hex_to_character (context_p, left_p, 6);\n      if (left_chr != lexer_hex_to_character (context_p, right_p, 6))\n      {\n        return false;\n      }\n      left_p += 6;\n      right_p += 6;\n      count += lit_char_get_utf8_length (left_chr);\n      continue;\n    }\n    if (*right_p == LIT_CHAR_BACKSLASH)\n    {\n      const uint8_t *swap_p = left_p;\n      left_p = right_p;\n      right_p = swap_p;\n    }\n    utf8_len = lit_char_to_utf8_bytes (utf8_buf, lexer_hex_to_character (context_p, left_p, 6));\n    JERRY_ASSERT (utf8_len > 0);\n    count -= utf8_len;\n    offset = 0;\n    do\n    {\n      if (utf8_buf[offset] != *right_p++)\n      {\n        return false;\n      }\n      offset++;\n    }\n    while (offset < utf8_len);\n    left_p += 6;\n  }\n  while (count > 0);\n  return true;\n} ", "target": 0}
{"code": "static int ipip6_rcv(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\tiph = ip_hdr(skb);\n\tread_lock(&ipip6_lock);\n\tif ((tunnel = ipip6_tunnel_lookup(dev_net(skb->dev),\n\t\t\t\t\tiph->saddr, iph->daddr)) != NULL) {\n\t\tsecpath_reset(skb);\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tif ((tunnel->dev->priv_flags & IFF_ISATAP) &&\n\t\t    !isatap_chksrc(skb, iph, tunnel)) {\n\t\t\ttunnel->stat.rx_errors++;\n\t\t\tread_unlock(&ipip6_lock);\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\ttunnel->stat.rx_packets++;\n\t\ttunnel->stat.rx_bytes += skb->len;\n\t\tskb->dev = tunnel->dev;\n\t\tdst_release(skb->dst);\n\t\tskb->dst = NULL;\n\t\tnf_reset(skb);\n\t\tipip6_ecn_decapsulate(iph, skb);\n\t\tnetif_rx(skb);\n\t\tread_unlock(&ipip6_lock);\n\t\treturn 0;\n\t}\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\tkfree_skb(skb);\n\tread_unlock(&ipip6_lock);\nout:\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}", "target": 1}
{"code": "static int mpeg4_update_thread_context(AVCodecContext *dst,\n                                       const AVCodecContext *src)\n{\n    Mpeg4DecContext *s = dst->priv_data;\n    const Mpeg4DecContext *s1 = src->priv_data;\n    int ret = ff_mpeg_update_thread_context(dst, src);\n    if (ret < 0)\n        return ret;\n    memcpy(((uint8_t*)s) + sizeof(MpegEncContext), ((uint8_t*)s1) + sizeof(MpegEncContext), sizeof(Mpeg4DecContext) - sizeof(MpegEncContext));\n    return 0;\n}", "target": 0}
{"code": "static int x509_get_basic_constraints( unsigned char **p,\n                                       const unsigned char *end,\n                                       int *ca_istrue,\n                                       int *max_pathlen )\n{\n    int ret;\n    size_t len;\n    *ca_istrue = 0; \n    *max_pathlen = 0; \n    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )\n    {\n        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n            ret = mbedtls_asn1_get_int( p, end, ca_istrue );\n        if( ret != 0 )\n            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n        if( *ca_istrue != 0 )\n            *ca_istrue = 1;\n    }\n    if( *p == end )\n        return( 0 );\n    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n    if( *p != end )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n    (*max_pathlen)++;\n    return( 0 );\n}", "target": 0}
{"code": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n        r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}", "target": 0}
{"code": "static TPM_RESULT SWTPM_NVRAM_GetFilenameForName(char *filename,        \n                                                 size_t bufsize,\n                                                 uint32_t tpm_number,\n                                                 const char *name,      \n                                                 bool is_tempfile)      \n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n    switch (tpmversion) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"%s/TMP%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"%s/tpm%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n    return res;\n}", "target": 0}
{"code": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}", "target": 1}
{"code": " */\nstatic inline zval *add_next_index_object(zval *arg, zval *tmp)\n{\n\tHashTable *symtable;\n\tif (Z_TYPE_P(arg) == IS_OBJECT) {\n\t\tsymtable = Z_OBJPROP_P(arg);\n\t} else {\n\t\tsymtable = Z_ARRVAL_P(arg);\n\t}\n\treturn zend_hash_next_index_insert(symtable, tmp);", "target": 0}
{"code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queue_pairs = n->multiqueue ? n->max_queue_pairs : 1;\n    int cvq = n->max_ncs - n->max_queue_pairs;\n    if (!get_vhost_net(nc->peer)) {\n        return;\n    }\n    if ((virtio_net_started(n, status) && !nc->peer->link_down) ==\n        !!n->vhost_started) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r, i;\n        if (n->needs_vnet_hdr_swap) {\n            error_report(\"backend does not support %s vnet headers; \"\n                         \"falling back on userspace virtio\",\n                         virtio_is_big_endian(vdev) ? \"BE\" : \"LE\");\n            return;\n        }\n        for (i = 0;  i < queue_pairs; i++) {\n            NetClientState *qnc = qemu_get_subqueue(n->nic, i);\n            qemu_net_queue_purge(qnc->peer->incoming_queue, qnc);\n            qemu_net_queue_purge(qnc->incoming_queue, qnc->peer);\n        }\n        if (virtio_has_feature(vdev->guest_features, VIRTIO_NET_F_MTU)) {\n            r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);\n            if (r < 0) {\n                error_report(\"%uBytes MTU not supported by the backend\",\n                             n->net_conf.mtu);\n                return;\n            }\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queue_pairs, cvq);\n        n->vhost_started = 0;\n    }\n}", "target": 0}
{"code": "ExpressionFieldPath::ExpressionFieldPath(ExpressionContext* const expCtx,\n                                         const string& theFieldPath,\n                                         Variables::Id variable)\n    : Expression(expCtx), _fieldPath(theFieldPath), _variable(variable) {}", "target": 0}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "create_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n    stride += 0x1f;\n    stride >>= 5;\n    stride *= sizeof (uint32_t);\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n    buf_size = height * stride;\n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "void* chk_malloc(size_t bytes)\n{\n    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}", "target": 1}
{"code": "static void smp_update_key_mask(tSMP_CB* p_cb, uint8_t key_type, bool recv) {\n  SMP_TRACE_DEBUG(\n \"%s before update role=%d recv=%d local_i_key = %02x, local_r_key = %02x\",\n      __func__, p_cb->role, recv, p_cb->local_i_key, p_cb->local_r_key);\n if (((p_cb->le_secure_connections_mode_is_used) || (p_cb->smp_over_br)) &&\n ((key_type == SMP_SEC_KEY_TYPE_ENC) ||\n (key_type == SMP_SEC_KEY_TYPE_LK))) {\n    p_cb->local_i_key &= ~key_type;\n    p_cb->local_r_key &= ~key_type;\n } else if (p_cb->role == HCI_ROLE_SLAVE) {\n if (recv)\n      p_cb->local_i_key &= ~key_type;\n else\n      p_cb->local_r_key &= ~key_type;\n } else {\n if (recv)\n      p_cb->local_r_key &= ~key_type;\n else\n      p_cb->local_i_key &= ~key_type;\n }\n  SMP_TRACE_DEBUG(\"updated local_i_key = %02x, local_r_key = %02x\",\n                  p_cb->local_i_key, p_cb->local_r_key);\n}", "target": 0}
{"code": "int mbedtls_asn1_write_null( unsigned char **p, unsigned char *start )\n{\n    int ret;\n    size_t len = 0;\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, 0) );\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start, MBEDTLS_ASN1_NULL ) );\n    return( (int) len );\n}", "target": 0}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    if (value.slen < 0)\n        value.slen = 0;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_ping)\n{\n\tzval *pgsql_link;\n\tint id;\n\tPGconn *pgsql;\n\tPGresult *res;\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &pgsql_link) == SUCCESS) {\n\t\tid = -1;\n\t} else {\n\t\tpgsql_link = NULL;\n\t\tid = PGG(default_link);\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tres = PQexec(pgsql, \"SELECT 1;\");\n\tPQclear(res);\n\tif (PQstatus(pgsql) == CONNECTION_OK)\n\t\tRETURN_TRUE;\n\tPQreset(pgsql);\n\tif (PQstatus(pgsql) == CONNECTION_OK) {\n\t\tRETURN_TRUE;\n\t}\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "static int pagemap_pte_hole(unsigned long start, unsigned long end,\n\t\t\t\tvoid *private)\n{\n\tstruct pagemapread *pm = private;\n\tunsigned long addr;\n\tint err = 0;\n\tfor (addr = start; addr < end; addr += PAGE_SIZE) {\n\t\terr = add_to_pagemap(addr, PM_NOT_PRESENT, pm);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "\tvirtual const char *name() const { return \"sign\"; }", "target": 0}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "cmyk2g(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tfloat c = sv[0] * 0.3f;\n\tfloat m = sv[1] * 0.59f;\n\tfloat y = sv[2] * 0.11f;\n\tdv[0] = 1 - fz_min(c + m + y + sv[3], 1);\n}", "target": 0}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\tassert(buf);\n\tassert(cnt >= 0);\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}", "target": 1}
{"code": "static std::string ToHtmlTableHeader(Network* network) {\n  std::string str;\n  if (network->type() == TYPE_WIFI || network->type() == TYPE_CELLULAR) {\n    str += WrapWithTH(\"Name\") + WrapWithTH(\"Auto-Connect\") +\n        WrapWithTH(\"Strength\");\n    if (network->type() == TYPE_WIFI)\n      str += WrapWithTH(\"Encryption\") + WrapWithTH(\"Passphrase\") +\n          WrapWithTH(\"Identity\") + WrapWithTH(\"Certificate\");\n  }\n  str += WrapWithTH(\"State\") + WrapWithTH(\"Error\") + WrapWithTH(\"IP Address\");\n  return str;\n}", "target": 0}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n         c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n         if (nElements == 256) {\n             for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 1}
{"code": "pam_sm_close_session (pam_handle_t *pamh UNUSED, int flags UNUSED,\n\t\t      int argc UNUSED, const char **argv UNUSED)\n{\n  D((\"Called and Exit\"));\n  return PAM_SUCCESS;\n}", "target": 0}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n     n = ( (*p)[0] << 8 ) | (*p)[1];\n     *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n         return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "status_t Parcel::write(const FlattenableHelperInterface& val)\n{\n status_t err;\n const size_t len = val.getFlattenedSize();\n const size_t fd_count = val.getFdCount();\n if ((len > INT32_MAX) || (fd_count > INT32_MAX)) {\n return BAD_VALUE;\n }\n    err = this->writeInt32(len);\n if (err) return err;\n    err = this->writeInt32(fd_count);\n if (err) return err;\n void* const buf = this->writeInplace(pad_size(len));\n if (buf == NULL)\n return BAD_VALUE;\n int* fds = NULL;\n if (fd_count) {\n        fds = new int[fd_count];\n }\n    err = val.flatten(buf, len, fds, fd_count);\n for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n }\n if (fd_count) {\n delete [] fds;\n }\n return err;\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}", "target": 1}
{"code": "static int adpt_hba_reset(adpt_hba* pHba)\n{\n\tint rcode;\n\tpHba->state |= DPTI_STATE_RESET;\n\tif ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {\n\t\tprintk(KERN_ERR \"%s: Could not activate\\n\", pHba->name);\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_build_sys_table()) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in HOLD state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_online_hba(pHba)) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\t\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in OPERATIONAL state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tpHba->state &= ~DPTI_STATE_RESET;\n\tscsi_host_complete_all_commands(pHba->host, DID_RESET);\n\treturn 0;\t\n}", "target": 1}
{"code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "static int parseValuesReturnFilter (\n\tOperation *op,\n\tSlapReply *rs,\n\tLDAPControl *ctrl )\n{\n\tBerElement\t*ber;\n\tstruct berval\tfstr = BER_BVNULL;\n\tif ( op->o_valuesreturnfilter != SLAP_CONTROL_NONE ) {\n\t\trs->sr_text = \"valuesReturnFilter control specified multiple times\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISNULL( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is absent\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISEMPTY( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is empty\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tber = ber_init( &(ctrl->ldctl_value) );\n\tif (ber == NULL) {\n\t\trs->sr_text = \"internal error\";\n\t\treturn LDAP_OTHER;\n\t}\n\trs->sr_err = get_vrFilter( op, ber,\n\t\t(ValuesReturnFilter **)&(op->o_vrFilter), &rs->sr_text);\n\t(void) ber_free( ber, 1 );\n\tif( rs->sr_err != LDAP_SUCCESS ) {\n\t\tif( rs->sr_err == SLAPD_DISCONNECT ) {\n\t\t\trs->sr_err = LDAP_PROTOCOL_ERROR;\n\t\t\tsend_ldap_disconnect( op, rs );\n\t\t\trs->sr_err = SLAPD_DISCONNECT;\n\t\t} else {\n\t\t\tsend_ldap_result( op, rs );\n\t\t}\n\t\tif( op->o_vrFilter != NULL) vrFilter_free( op, op->o_vrFilter ); \n\t}\n#ifdef LDAP_DEBUG\n\telse {\n\t\tvrFilter2bv( op, op->o_vrFilter, &fstr );\n\t}\n\tDebug( LDAP_DEBUG_ARGS, \"\tvrFilter: %s\\n\",\n\t\tfstr.bv_len ? fstr.bv_val : \"empty\", 0, 0 );\n\top->o_tmpfree( fstr.bv_val, op->o_tmpmemctx );\n#endif\n\top->o_valuesreturnfilter = ctrl->ldctl_iscritical\n\t\t? SLAP_CONTROL_CRITICAL\n\t\t: SLAP_CONTROL_NONCRITICAL;\n\trs->sr_err = LDAP_SUCCESS;\n\treturn LDAP_SUCCESS;\n}", "target": 1}
{"code": "struct error_obj run_pam_auth(const char *username, char *password) {\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "is_empty(const uint8_t *data, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\treturn i + 1;\n}", "target": 0}
{"code": "xface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}", "target": 0}
{"code": "static void edge_heartbeat_schedule(struct edgeport_serial *edge_serial)\n{\n\tif (!edge_serial->use_heartbeat)\n\t\treturn;\n\tschedule_delayed_work(&edge_serial->heartbeat_work,\n\t\t\tFW_HEARTBEAT_SECS * HZ);\n}", "target": 0}
{"code": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1}
{"code": "GF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int mwifiex_cmd_uap_sta_deauth(struct mwifiex_private *priv,\n\t\t\t\t      struct host_cmd_ds_command *cmd, u8 *mac)\n{\n\tstruct host_cmd_ds_sta_deauth *sta_deauth = &cmd->params.sta_deauth;\n\tcmd->command = cpu_to_le16(HostCmd_CMD_UAP_STA_DEAUTH);\n\tmemcpy(sta_deauth->mac, mac, ETH_ALEN);\n\tsta_deauth->reason = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_sta_deauth) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}", "target": 0}
{"code": "static int move_to_new_page(struct page *newpage, struct page *page)\n{\n\tstruct address_space *mapping;\n\tint rc;\n\tif (TestSetPageLocked(newpage))\n\t\tBUG();\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tmapping = page_mapping(page);\n\tif (!mapping)\n\t\trc = migrate_page(mapping, newpage, page);\n\telse if (mapping->a_ops->migratepage)\n\t\trc = mapping->a_ops->migratepage(mapping,\n\t\t\t\t\t\tnewpage, page);\n\telse\n\t\trc = fallback_migrate_page(mapping, newpage, page);\n\tif (!rc) {\n\t\tmem_cgroup_page_migration(page, newpage);\n\t\tremove_migration_ptes(page, newpage);\n\t} else\n\t\tnewpage->mapping = NULL;\n\tunlock_page(newpage);\n\treturn rc;\n}", "target": 0}
{"code": "  FT_Stream_EnterFrame( FT_Stream  stream,\n                        FT_ULong   count )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_ULong  read_bytes;\n    FT_ASSERT( stream && stream->cursor == 0 );\n    if ( stream->read )\n    {\n      FT_Memory  memory = stream->memory;\n      if ( count > stream->size )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" frame size (%lu) larger than stream size (%lu)\\n\",\n                   count, stream->size ));\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n#ifdef FT_DEBUG_MEMORY\n      stream->base = (unsigned char*)ft_mem_qalloc( memory, count, &error );\n      if ( error )\n        goto Exit;\n#else\n      if ( FT_QALLOC( stream->base, count ) )\n        goto Exit;\n#endif\n      read_bytes = stream->read( stream, stream->pos,\n                                 stream->base, count );\n      if ( read_bytes < count )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" invalid read; expected %lu bytes, got %lu\\n\",\n                   count, read_bytes ));\n        FT_FREE( stream->base );\n        error = FT_Err_Invalid_Stream_Operation;\n      }\n      stream->cursor = stream->base;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += read_bytes;\n    }\n    else\n     {\n       if ( stream->pos >= stream->size        ||\n           stream->pos + count > stream->size )\n       {\n         FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                    \" invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\\n\",\n                   stream->pos, count, stream->size ));\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n      stream->cursor = stream->base + stream->pos;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += count;\n    }\n  Exit:\n    return error;\n  }", "target": 1}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "static gint conv_sjistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tguchar *out = outbuf;\n\twhile (*in != '\\0') {\n\t\tif (IS_ASCII(*in)) {\n\t\t\t*out++ = *in++;\n\t\t} else if (issjiskanji1(*in)) {\n\t\t\tif (issjiskanji2(*(in + 1))) {\n\t\t\t\tguchar out1 = *in;\n\t\t\t\tguchar out2 = *(in + 1);\n\t\t\t\tguchar row;\n\t\t\t\trow = out1 < 0xa0 ? 0x70 : 0xb0;\n\t\t\t\tif (out2 < 0x9f) {\n\t\t\t\t\tout1 = (out1 - row) * 2 - 1;\n\t\t\t\t\tout2 -= out2 > 0x7f ? 0x20 : 0x1f;\n\t\t\t\t} else {\n\t\t\t\t\tout1 = (out1 - row) * 2;\n\t\t\t\t\tout2 -= 0x7e;\n\t\t\t\t}\n\t\t\t\t*out++ = out1 | 0x80;\n\t\t\t\t*out++ = out2 | 0x80;\n\t\t\t\tin += 2;\n\t\t\t} else {\n\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\tin++;\n\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (issjishwkana(*in)) {\n\t\t\t*out++ = 0x8e;\n\t\t\t*out++ = *in++;\n\t\t} else {\n\t\t\t*out++ = SUBST_CHAR;\n\t\t\tin++;\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif \n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}", "target": 0}
{"code": "snmp_oid_decode_oid(uint8_t *buf, uint32_t *buff_len, uint32_t *oid, uint32_t *oid_len)\n{\n  uint32_t *start;\n  uint8_t *buf_end, type;\n  uint8_t len;\n  div_t first;\n  start = oid;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL) {\n    return NULL;\n  }\n  if(type != SNMP_DATA_TYPE_OBJECT) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL) {\n    return NULL;\n  }\n  buf_end = buf + len;\n  (*buff_len)--;\n  first = div(*buf++, 40);\n  *oid++ = (uint32_t)first.quot;\n  *oid++ = (uint32_t)first.rem;\n  while(buf != buf_end) {\n    --(*oid_len);\n    if(*oid_len == 0) {\n      return NULL;\n    }\n    int i;\n    *oid = (uint32_t)(*buf & 0x7F);\n    for(i = 0; i < 4; i++) {\n      (*buff_len)--;\n      if((*buf++ & 0x80) == 0) {\n        break;\n      }\n      *oid <<= 7;\n      *oid |= (*buf & 0x7F);\n    }\n    ++oid;\n  }\n  *oid++ = ((uint32_t)-1);\n  *oid_len = (uint32_t)(oid - start);\n  return buf;\n}", "target": 1}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "decode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif ((24+64) > plen)\n\t\treturn -1;\n        plen-=(24+64); \n\tif (152 < plen)\n\t\treturn -1;\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 12 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 0}
{"code": "int OutputValueSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;\n    cmsUInt32Number i;\n    if (sc -> FixWhite) {\n        if (In[0] == 0xFFFF) {  \n            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&\n                (In[2] >= 0x7800 && In[2] <= 0x8800)) {\n                cmsUInt16Number* Black;\n                cmsUInt16Number* White;\n                cmsUInt32Number nOutputs;\n                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))\n                        return 0;\n                for (i=0; i < nOutputs; i++)\n                        Out[i] = White[i];\n            }\n        }\n    }\n    if (In[0] != sc ->FirstComponent) {\n            if (sc ->FirstComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n                    sc ->SecondComponent = -1;\n                    _cmsIOPrintf(sc ->m, sc ->PostMaj);\n            }\n            _cmsPSActualColumn = 0;\n            _cmsIOPrintf(sc ->m, sc ->PreMaj);\n            sc ->FirstComponent = In[0];\n    }\n      if (In[1] != sc ->SecondComponent) {\n            if (sc ->SecondComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n            }\n            _cmsIOPrintf(sc ->m, sc ->PreMin);\n            sc ->SecondComponent = In[1];\n    }\n      for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {\n          cmsUInt16Number wWordOut = Out[i];\n          cmsUInt8Number wByteOut;           \n          wByteOut = Word2Byte(wWordOut);\n          WriteByte(sc -> m, wByteOut);\n      }\n      return 1;\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "static int nfs4_xdr_dec_server_caps(struct rpc_rqst *req,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_server_caps_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, req);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_server_caps(xdr, res);\nout:\n\treturn status;\n}", "target": 0}
{"code": "header_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "imapx_server_info_changed_cb (CamelIMAPXSummary *summary,\n\t\t\t      CamelMessageInfo *info,\n\t\t\t      gpointer user_data)\n{\n\tGHashTable *changed_meanwhile = user_data;\n\tg_return_if_fail (info != NULL);\n\tg_return_if_fail (changed_meanwhile != NULL);\n\tif (camel_message_info_uid (info)) {\n\t\tg_hash_table_insert (changed_meanwhile,\n\t\t\t(gpointer) camel_pstring_strdup (camel_message_info_uid (info)),\n\t\t\tGINT_TO_POINTER (1));\n\t}\n}", "target": 0}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "    void TiffReader::visitSizeEntry(TiffSizeEntry* object)\n    {\n        assert(object != 0);\n        readTiffEntry(object);\n        TiffFinder finder(object->dtTag(), object->dtGroup());\n        pRoot_->accept(finder);\n        TiffDataEntryBase* te = dynamic_cast<TiffDataEntryBase*>(finder.result());\n        if (te && te->pValue()) {\n            te->setStrips(object->pValue(), pData_, size_, baseOffset());\n        }\n    }", "target": 0}
{"code": "    static CImg<T> get_load_ascii(const char *const filename) {\n      return CImg<T>().load_ascii(filename);", "target": 0}
{"code": "mld6_print(netdissect_options *ndo, const u_char *bp)\n{\n\tconst struct mld6_hdr *mp = (const struct mld6_hdr *)bp;\n\tconst u_char *ep;\n\tep = ndo->ndo_snapend;\n\tif ((const u_char *)mp + sizeof(*mp) > ep)\n\t\treturn;\n\tND_PRINT((ndo,\"max resp delay: %d \", EXTRACT_16BITS(&mp->mld6_maxdelay)));\n\tND_PRINT((ndo,\"addr: %s\", ip6addr_string(ndo, &mp->mld6_addr)));\n}", "target": 0}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "static int matchFunc(const char*)\n{\n    return XMLTokenizerScope::currentDocLoader && currentThread() == libxmlLoaderThread;\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "get_stdinput(char *(*fn_readline)(const char *), void(*fn_addhist)(const char *))\n{\nint i;\ngstring * g = NULL;\nif (!fn_readline) { printf(\"> \"); fflush(stdout); }\nfor (i = 0;; i++)\n  {\n  uschar buffer[1024];\n  uschar *p, *ss;\n  #ifdef USE_READLINE\n  char *readline_line = NULL;\n  if (fn_readline != NULL)\n    {\n    if ((readline_line = fn_readline((i > 0)? \"\":\"> \")) == NULL) break;\n    if (*readline_line != 0 && fn_addhist != NULL) fn_addhist(readline_line);\n    p = US readline_line;\n    }\n  else\n  #endif\n    {\n    if (Ufgets(buffer, sizeof(buffer), stdin) == NULL) break;\n    p = buffer;\n    }\n  ss = p + (int)Ustrlen(p);\n  while (ss > p && isspace(ss[-1])) ss--;\n  if (i > 0)\n    {\n    while (p < ss && isspace(*p)) p++;   \n    }\n  g = string_catn(g, p, ss - p);\n  #ifdef USE_READLINE\n  if (fn_readline) free(readline_line);\n  #endif\n  if (ss == p || g->s[g->ptr-1] != '\\\\')\n    break;\n  --g->ptr;\n  (void) string_from_gstring(g);\n  }\nif (!g) printf(\"\\n\");\nreturn string_from_gstring(g);\n}", "target": 0}
{"code": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n\tif (!pmd_present(*pmd)) {\t\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}", "target": 0}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "bool sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n\t\t\tstruct sctp_paramhdr **errp)\n{\n\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) chunk->chunk_hdr;\n\tunion sctp_params param;\n\tbool addr_param_seen = false;\n\tsctp_walk_params(param, addip, addip_hdr.params) {\n\t\tsize_t length = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv4addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv6addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tif (addr_param_needed && !addr_param_seen)\n\t\t\t\treturn false;\n\t\t\tlength = ntohs(param.addip->param_hdr.length);\n\t\t\tif (length < sizeof(sctp_addip_param_t) +\n\t\t\t\t     sizeof(sctp_paramhdr_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (addr_param_needed && !addr_param_seen)\n\t\treturn false;\n\tif (!addr_param_needed && addr_param_seen)\n\t\treturn false;\n\tif (param.v != chunk->chunk_end)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "void rds_inc_init(struct rds_incoming *inc, struct rds_connection *conn,\n\t\t  __be32 saddr)\n{\n\tatomic_set(&inc->i_refcount, 1);\n\tINIT_LIST_HEAD(&inc->i_item);\n\tinc->i_conn = conn;\n\tinc->i_saddr = saddr;\n\tinc->i_rdma_cookie = 0;\n\tinc->i_rx_tstamp.tv_sec = 0;\n\tinc->i_rx_tstamp.tv_usec = 0;\n}", "target": 0}
{"code": "static void spl_ptr_heap_destroy(spl_ptr_heap *heap TSRMLS_DC) { \n\tint i;\n\tfor (i=0; i < heap->count; ++i) {\n\t\theap->dtor(heap->elements[i] TSRMLS_CC);\n\t}\n\tefree(heap->elements);\n\tefree(heap);\n}", "target": 0}
{"code": "passAddName (CharsString * name, int var)\n{\n  int k;\n  struct PassName *curname;\n  CharsString augmentedName;\n  for (augmentedName.length = 0;\n       augmentedName.length < name->length; augmentedName.length++)\n    augmentedName.\n      chars[augmentedName.length] = name->chars[augmentedName.length];\n  augmentedName.chars[augmentedName.length++] = passOpcode;\n  if (!\n      (curname =\n       malloc (sizeof (*curname) + CHARSIZE * (augmentedName.length - 1))))\n    {\n      outOfMemory ();\n    }\n  memset (curname, 0, sizeof (*curname));\n  for (k = 0; k < augmentedName.length; k++)\n    {\n      curname->name[k] = augmentedName.chars[k];\n    }\n  curname->length = augmentedName.length;\n  curname->varnum = var;\n  curname->next = passNames;\n  passNames = curname;\n  return 1;\n}", "target": 0}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "void SVGDocumentExtensions::serviceAnimations(double monotonicAnimationStartTime)\n{\n    WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;\n    timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());\n    WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();\n    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)\n        (*itr)->timeContainer()->serviceAnimations(monotonicAnimationStartTime);\n}", "target": 0}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "static void __meminit calculate_node_totalpages(struct pglist_data *pgdat,\n\t\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\t\tunsigned long *zones_size,\n\t\t\t\t\t\tunsigned long *zholes_size)\n{\n\tunsigned long realtotalpages = 0, totalpages = 0;\n\tenum zone_type i;\n\tfor (i = 0; i < MAX_NR_ZONES; i++) {\n\t\tstruct zone *zone = pgdat->node_zones + i;\n\t\tunsigned long zone_start_pfn, zone_end_pfn;\n\t\tunsigned long size, real_size;\n\t\tsize = zone_spanned_pages_in_node(pgdat->node_id, i,\n\t\t\t\t\t\t  node_start_pfn,\n\t\t\t\t\t\t  node_end_pfn,\n\t\t\t\t\t\t  &zone_start_pfn,\n\t\t\t\t\t\t  &zone_end_pfn,\n\t\t\t\t\t\t  zones_size);\n\t\treal_size = size - zone_absent_pages_in_node(pgdat->node_id, i,\n\t\t\t\t\t\t  node_start_pfn, node_end_pfn,\n\t\t\t\t\t\t  zholes_size);\n\t\tif (size)\n\t\t\tzone->zone_start_pfn = zone_start_pfn;\n\t\telse\n\t\t\tzone->zone_start_pfn = 0;\n\t\tzone->spanned_pages = size;\n\t\tzone->present_pages = real_size;\n\t\ttotalpages += size;\n\t\trealtotalpages += real_size;\n\t}\n\tpgdat->node_spanned_pages = totalpages;\n\tpgdat->node_present_pages = realtotalpages;\n\tprintk(KERN_DEBUG \"On node %d totalpages: %lu\\n\", pgdat->node_id,\n\t\t\t\t\t\t\trealtotalpages);\n}", "target": 0}
{"code": "R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https:\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tchar *host = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: *", "target": 1}
{"code": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}", "target": 1}
{"code": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", NT_PRXFPREG, sizeof(t->xfpu),\n\t\t\t  &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}", "target": 0}
{"code": "static int mxf_read_preface_metadata(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    AVFormatContext *s = mxf->fc;\n    int ret;\n    char *str = NULL;\n    if (tag >= 0x8000 && (IS_KLV_KEY(uid, mxf_avid_project_name))) {\n        SET_STR_METADATA(pb, \"project_name\", str);\n    }\n    return 0;\n}", "target": 0}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n{\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n    double rounded;\n    if (code == gs_error_undefinedresult) {\n        pdist->x = pdist->y = 0;\n    } else if (code < 0)\n        return code;\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "static unsigned int count_acl_entries(connection_struct *conn, SMB_ACL_T posix_acl)\n{\n\tunsigned int ace_count = 0;\n\tint entry_id = SMB_ACL_FIRST_ENTRY;\n\tSMB_ACL_ENTRY_T entry;\n\twhile ( posix_acl && (sys_acl_get_entry(posix_acl, entry_id, &entry) == 1)) {\n\t\tif (entry_id == SMB_ACL_FIRST_ENTRY) {\n\t\t\tentry_id = SMB_ACL_NEXT_ENTRY;\n\t\t}\n\t\tace_count++;\n\t}\n\treturn ace_count;\n}", "target": 0}
{"code": "size_t intsetBlobLen(intset *is) {\n    return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);\n}", "target": 1}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "sldns_affix_token(sldns_buffer* strbuf, char* token, size_t* token_len,\n\tint* quoted, int* parens, size_t* pre_data_pos,\n\tconst char* delimiters, sldns_rdf_type rdftype, size_t* token_strlen)\n{\n\tsize_t addlen = *token_len - *token_strlen;\n\tsize_t addstrlen = 0;\n\tif(addlen < 1) return 0;\n\ttoken[*token_strlen] = ' ';\n\ttoken[++(*token_strlen)] = 0;\n\taddlen = *token_len - *token_strlen;\n\tif(!sldns_parse_rdf_token(strbuf, token+*token_strlen, addlen, quoted,\n\t\tparens, pre_data_pos, delimiters, rdftype, &addstrlen))\n\t\treturn 0;\n\t(*token_strlen) += addstrlen;\n\treturn 1;\n}", "target": 0}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "void RendererSchedulerImpl::OnShutdownTaskQueue(\n    const scoped_refptr<MainThreadTaskQueue>& task_queue) {\n  if (main_thread_only().was_shutdown)\n    return;\n  if (task_queue_throttler_)\n    task_queue_throttler_->ShutdownTaskQueue(task_queue.get());\n  if (task_runners_.erase(task_queue)) {\n    switch (task_queue->queue_class()) {\n       case MainThreadTaskQueue::QueueClass::kTimer:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().timer_task_cost_estimator);\n       case MainThreadTaskQueue::QueueClass::kLoading:\n         task_queue->RemoveTaskObserver(\n             &main_thread_only().loading_task_cost_estimator);\n       default:\n         break;\n     }\n  }\n}", "target": 1}
{"code": "ZEND_API zend_bool zend_make_callable(zval *callable, char **callable_name TSRMLS_DC) \n{\n\tzend_fcall_info_cache fcc;\n\tif (zend_is_callable_ex(callable, NULL, IS_CALLABLE_STRICT, callable_name, NULL, &fcc, NULL TSRMLS_CC)) {\n\t\tif (Z_TYPE_P(callable) == IS_STRING && fcc.calling_scope) {\n\t\t\tzval_dtor(callable);\n\t\t\tarray_init(callable);\n\t\t\tadd_next_index_string(callable, fcc.calling_scope->name, 1);\n\t\t\tadd_next_index_string(callable, fcc.function_handler->common.function_name, 1);\n\t\t}\n\t\tif (fcc.function_handler &&\n\t\t\t((fcc.function_handler->type == ZEND_INTERNAL_FUNCTION &&\n\t\t      (fcc.function_handler->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER)) ||\n\t\t     fcc.function_handler->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY ||\n\t\t     fcc.function_handler->type == ZEND_OVERLOADED_FUNCTION)) {\n\t\t\tif (fcc.function_handler->type != ZEND_OVERLOADED_FUNCTION) {\n\t\t\t\tefree((char*)fcc.function_handler->common.function_name);\n\t\t\t}\n\t\t\tefree(fcc.function_handler);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int sc_path_set(sc_path_t *path, int type, const u8 *id, size_t id_len,\n\tint idx, int count)\n{\n\tif (path == NULL || id == NULL || id_len == 0 || id_len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(path, 0, sizeof(*path));\n\tmemcpy(path->value, id, id_len);\n\tpath->len   = id_len;\n\tpath->type  = type;\n\tpath->index = idx;\n\tpath->count = count;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": " struct task_struct * __cpuinit fork_idle(int cpu)\n {\n \tstruct task_struct *task;\n \tstruct pt_regs regs;\n \ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n \t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n \t\tinit_idle(task, cpu);\n \treturn task;\n }", "target": 1}
{"code": "static void __ref adjust_range_page_size_mask(struct map_range *mr,\n\t\t\t\t\t\t\t int nr_range)\n{\n\tint i;\n\tfor (i = 0; i < nr_range; i++) {\n\t\tif ((page_size_mask & (1<<PG_LEVEL_2M)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_2M))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PMD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PMD_SIZE);\n#ifdef CONFIG_X86_32\n\t\t\tif ((end >> PAGE_SHIFT) > max_low_pfn)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_2M;\n\t\t}\n\t\tif ((page_size_mask & (1<<PG_LEVEL_1G)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_1G))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PUD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PUD_SIZE);\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_1G;\n\t\t}\n\t}\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_interval_create_from_date_string)\n{\n\tchar           *time_str = NULL;\n\tint             time_str_len = 0;\n\ttimelib_time   *time;\n\ttimelib_error_container *err = NULL;\n\tphp_interval_obj *diobj;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &time_str, &time_str_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_instantiate(date_ce_interval, return_value TSRMLS_CC);\n\ttime = timelib_strtotime(time_str, time_str_len, &err, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\tdiobj = (php_interval_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tdiobj->diff = timelib_rel_time_clone(&time->relative);\n\tdiobj->initialized = 1;\n\ttimelib_time_dtor(time);\n\ttimelib_error_container_dtor(err);", "target": 0}
{"code": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid)) {\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "target": 1}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "static struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}", "target": 0}
{"code": "gimp_channel_get_node (GimpFilter *filter)\n{\n  GimpDrawable *drawable = GIMP_DRAWABLE (filter);\n  GimpChannel  *channel  = GIMP_CHANNEL (filter);\n  GeglNode     *node;\n  GeglNode     *source;\n  GeglNode     *mode_node;\n  const Babl   *color_format;\n  node = GIMP_FILTER_CLASS (parent_class)->get_node (filter);\n  source = gimp_drawable_get_source_node (drawable);\n  gegl_node_add_child (node, source);\n  g_warn_if_fail (channel->color_node == NULL);\n  if (gimp_drawable_get_linear (drawable))\n    color_format = babl_format (\"RGBA float\");\n  else\n    color_format = babl_format (\"R'G'B'A float\");\n  channel->color_node = gegl_node_new_child (node,\n                                             \"operation\", \"gegl:color\",\n                                             \"format\",    color_format,\n                                             NULL);\n  gimp_gegl_node_set_color (channel->color_node,\n                            &channel->color);\n  g_warn_if_fail (channel->mask_node == NULL);\n  channel->mask_node = gegl_node_new_child (node,\n                                            \"operation\", \"gegl:opacity\",\n                                            NULL);\n  gegl_node_connect_to (channel->color_node, \"output\",\n                        channel->mask_node,  \"input\");\n  g_warn_if_fail (channel->invert_node == NULL);\n  channel->invert_node = gegl_node_new_child (node,\n                                              \"operation\", \"gegl:invert-linear\",\n                                              NULL);\n  if (channel->show_masked)\n    {\n      gegl_node_connect_to (source,               \"output\",\n                            channel->invert_node, \"input\");\n      gegl_node_connect_to (channel->invert_node, \"output\",\n                            channel->mask_node,   \"aux\");\n    }\n  else\n    {\n      gegl_node_connect_to (source,             \"output\",\n                            channel->mask_node, \"aux\");\n    }\n  mode_node = gimp_drawable_get_mode_node (drawable);\n  gegl_node_connect_to (channel->mask_node, \"output\",\n                        mode_node,          \"aux\");\n  return node;\n}", "target": 0}
{"code": "void TabSpecificContentSettings::OnContentBlocked(\n    ContentSettingsType type,\n     const std::string& resource_identifier) {\n   DCHECK(type != CONTENT_SETTINGS_TYPE_GEOLOCATION)\n       << \"Geolocation settings handled by OnGeolocationPermissionSet\";\n   content_accessed_[type] = true;\n  std::string identifier;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableResourceContentSettings)) {\n    identifier = resource_identifier;\n  }\n  if (!identifier.empty())\n    AddBlockedResource(type, identifier);\n#if defined (OS_ANDROID)\n  if (type == CONTENT_SETTINGS_TYPE_POPUPS) {\n    content_blocked_[type] = false;\n    content_blockage_indicated_to_user_[type] = false;\n  }\n#endif\n  if (!content_blocked_[type]) {\n    content_blocked_[type] = true;\n    content::NotificationService::current()->Notify(\n        chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n        content::Source<WebContents>(web_contents()),\n        content::NotificationService::NoDetails());\n  }\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0, GFP_ATOMIC);\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\treturn retval;\n}", "target": 0}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 1}
{"code": "const std::string& GetExtensionIdForMutedTab(content::WebContents* contents) {\n  DCHECK_EQ(GetTabAudioMutedReason(contents) != TabMutedReason::EXTENSION,\n            LastMuteMetadata::FromWebContents(contents)->extension_id.empty());\n  return LastMuteMetadata::FromWebContents(contents)->extension_id;\n}", "target": 0}
{"code": "canonicalize_path (const char *path, char **pcanonical)\n{\n  char *canonical = 0;\n  assert (path && *path);\n  assert (pcanonical);\n  canonical = MALLOC (char, 1+ LT_STRLEN (path));\n  if (!canonical)\n    return 1;\n  {\n    size_t dest = 0;\n    size_t src;\n    for (src = 0; path[src] != LT_EOS_CHAR; ++src)\n      {\n\tif (path[src] == LT_PATHSEP_CHAR)\n\t  {\n\t    if ((dest == 0)\n\t\t|| (path[1+ src] == LT_PATHSEP_CHAR)\n\t\t|| (path[1+ src] == LT_EOS_CHAR))\n\t      continue;\n\t  }\n\tif ((path[src] != '/')\n#if defined(LT_DIRSEP_CHAR)\n\t    && (path[src] != LT_DIRSEP_CHAR)\n#endif\n\t    )\n\t  {\n\t    canonical[dest++] = path[src];\n\t  }\n\telse if ((path[1+ src] != LT_PATHSEP_CHAR)\n\t\t && (path[1+ src] != LT_EOS_CHAR)\n#if defined(LT_DIRSEP_CHAR)\n\t\t && (path[1+ src] != LT_DIRSEP_CHAR)\n#endif\n\t\t && (path[1+ src] != '/'))\n\t  {\n\t    canonical[dest++] = '/';\n\t  }\n      }\n    canonical[dest] = LT_EOS_CHAR;\n  }\n  *pcanonical = canonical;\n  return 0;\n}", "target": 0}
{"code": "XkbExtensionInit(void)\n{\n    ExtensionEntry *extEntry;\n    if ((extEntry = AddExtension(XkbName, XkbNumberEvents, XkbNumberErrors,\n\t\t\t\t ProcXkbDispatch, SProcXkbDispatch,\n\t\t\t\t NULL, StandardMinorOpcode))) {\n\tXkbReqCode = (unsigned char)extEntry->base;\n\tXkbEventBase = (unsigned char)extEntry->eventBase;\n\tXkbErrorBase = (unsigned char)extEntry->errorBase;\n\tXkbKeyboardErrorCode = XkbErrorBase+XkbKeyboard;\n\tRT_XKBCLIENT = CreateNewResourceType(XkbClientGone);\n    }\n    return;\n}", "target": 0}
{"code": " static blink::WebScreenOrientations stringToOrientations(const AtomicString& orientationString)\n {\n     DEFINE_STATIC_LOCAL(const AtomicString, portrait, (\"portrait\", AtomicString::ConstructFromLiteral));\n     DEFINE_STATIC_LOCAL(const AtomicString, landscape, (\"landscape\", AtomicString::ConstructFromLiteral));\n     if (orientationString == portrait)\n         return blink::WebScreenOrientationPortraitPrimary | blink::WebScreenOrientationPortraitSecondary;\n     if (orientationString == landscape)\n        return blink::WebScreenOrientationLandscapePrimary | blink::WebScreenOrientationLandscapeSecondary;\n    unsigned length = 0;\n    ScreenOrientationInfo* orientationMap = orientationsMap(length);\n    for (unsigned i = 0; i < length; ++i) {\n        if (orientationMap[i].name == orientationString)\n            return orientationMap[i].orientation;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_destroy_clientid(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t struct nfs_client *clp)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = clp->cl_mvops->minor_version,\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_clientid(xdr, clp->cl_clientid, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n \t\treturn;\n \tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}", "target": 1}
{"code": "RecordFlushReplyBuffer(RecordContextPtr pContext,\n                       void *data1, int len1, void *data2, int len2)\n{\n    if (!pContext->pRecordingClient || pContext->pRecordingClient->clientGone ||\n        pContext->inFlush)\n        return;\n    ++pContext->inFlush;\n    if (pContext->numBufBytes)\n        WriteToClient(pContext->pRecordingClient, pContext->numBufBytes,\n                      pContext->replyBuffer);\n    pContext->numBufBytes = 0;\n    if (len1)\n        WriteToClient(pContext->pRecordingClient, len1, data1);\n    if (len2)\n        WriteToClient(pContext->pRecordingClient, len2, data2);\n    --pContext->inFlush;\n}                               ", "target": 0}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "ieee80211_rx_h_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\treturn ieee80211_rx_mesh_check(rx);\n\tif (unlikely((ieee80211_is_data(hdr->frame_control) ||\n\t\t      ieee80211_is_pspoll(hdr->frame_control)) &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_WDS &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {\n\t\tif (rx->sta && rx->sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    ieee80211_is_data_present(hdr->frame_control)) {\n\t\t\tunsigned int hdrlen;\n\t\t\t__be16 ethertype;\n\t\t\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\t\t\tif (rx->skb->len < hdrlen + 8)\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tskb_copy_bits(rx->skb, hdrlen + 6, &ethertype, 2);\n\t\t\tif (ethertype == rx->sdata->control_port_protocol)\n\t\t\t\treturn RX_CONTINUE;\n\t\t}\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t    cfg80211_rx_spurious_frame(rx->sdata->dev,\n\t\t\t\t\t       hdr->addr2,\n\t\t\t\t\t       GFP_ATOMIC))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\treturn RX_DROP_MONITOR;\n\t}\n\treturn RX_CONTINUE;\n}", "target": 0}
{"code": "unix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror_f(\"path \\\"%s\\\" too long for Unix domain socket\", path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"socket: %.100s\", strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot bind to path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot listen on path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}", "target": 0}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnResizeOrRepaintACK(\n    const ViewHostMsg_ResizeOrRepaint_ACK_Params& params) {\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::OnResizeOrRepaintACK\");\n  TimeTicks paint_start = TimeTicks::Now();\n  current_size_ = params.view_size;\n  bool is_resize_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_resize_ack(params.flags);\n  if (is_resize_ack) {\n    DCHECK(!g_check_for_pending_resize_ack || resize_ack_pending_);\n    resize_ack_pending_ = false;\n  }\n  bool is_repaint_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_repaint_ack(params.flags);\n  if (is_repaint_ack) {\n    DCHECK(repaint_ack_pending_);\n    TRACE_EVENT_ASYNC_END0(\n        \"renderer_host\", \"RenderWidgetHostImpl::repaint_ack_pending_\", this);\n    repaint_ack_pending_ = false;\n    TimeDelta delta = TimeTicks::Now() - repaint_start_time_;\n    UMA_HISTOGRAM_TIMES(\"MPArch.RWH_RepaintDelta\", delta);\n  }\n  DCHECK(!params.view_size.IsEmpty());\n  DidCompleteResizeOrRepaint(params, paint_start);\n  last_auto_resize_request_number_ = params.sequence_number;\n  if (auto_resize_enabled_) {\n    bool post_callback = new_auto_size_.IsEmpty();\n    new_auto_size_ = params.view_size;\n    if (post_callback) {\n      base::ThreadTaskRunnerHandle::Get()->PostTask(\n          FROM_HERE, base::BindOnce(&RenderWidgetHostImpl::DelayedAutoResized,\n                                    weak_factory_.GetWeakPtr()));\n    }\n  }\n  TimeDelta delta = TimeTicks::Now() - paint_start;\n  UMA_HISTOGRAM_TIMES(\"MPArch.RWH_OnMsgResizeOrRepaintACK\", delta);\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": " void TestBlinkPlatformSupport::cryptographicallyRandomValues(\n     unsigned char* buffer,\n     size_t length) {\n }", "target": 1}
{"code": "void RemoteFrame::ScheduleNavigation(Document& origin_document,\n                                      const KURL& url,\n                                      WebFrameLoadType frame_load_type,\n                                      UserGestureStatus user_gesture_status) {\n   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));\n   frame_request.GetResourceRequest().SetHasUserGesture(\n       user_gesture_status == UserGestureStatus::kActive);\n  frame_request.GetResourceRequest().SetFrameType(\n      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel\n                    : network::mojom::RequestContextFrameType::kNested);\n  Navigate(frame_request, frame_load_type);\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_set_server_protocol(server_rec* s, const char* proto)\n{\n    core_server_config *conf = ap_get_core_module_config(s->module_config);\n    conf->protocol = proto;\n}", "target": 0}
{"code": "static int is_printable(char p)\n{\n\tif ((p >= 'a' && p <= 'z') || (p >= 'A' && p <= 'Z') ||\n\t    (p >= '0' && p <= '9') || p == ' ' || p == '(' || p == ')' ||\n\t    p == '+' || p == ',' || p == '-' || p == '.' || p == '/' ||\n\t    p == ':' || p == '=' || p == '?')\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "print_optimize_info(FILE* f, regex_t* reg)\n{\n  static const char* on[] = { \"NONE\", \"EXACT\", \"EXACT_BM\", \"EXACT_BM_NOT_REV\",\n                              \"EXACT_IC\", \"MAP\" };\n  fprintf(f, \"optimize: %s\\n\", on[reg->optimize]);\n  fprintf(f, \"  anchor: \"); print_anchor(f, reg->anchor);\n  if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)\n    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);\n  fprintf(f, \"\\n\");\n  if (reg->optimize) {\n    fprintf(f, \"  sub anchor: \"); print_anchor(f, reg->sub_anchor);\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"\\n\");\n  if (reg->exact) {\n    UChar *p;\n    fprintf(f, \"exact: [\");\n    for (p = reg->exact; p < reg->exact_end; p++) {\n      fputc(*p, f);\n    }\n    fprintf(f, \"]: length: %ld\\n\", (reg->exact_end - reg->exact));\n  }\n  else if (reg->optimize & ONIG_OPTIMIZE_MAP) {\n    int c, i, n = 0;\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n      if (reg->map[i]) n++;\n    fprintf(f, \"map: n=%d\\n\", n);\n    if (n > 0) {\n      c = 0;\n      fputc('[', f);\n      for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n\tif (reg->map[i] != 0) {\n          if (c > 0)  fputs(\", \", f);\n          c++;\n          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&\n              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))\n            fputc(i, f);\n          else\n            fprintf(f, \"%d\", i);\n        }\n      }\n      fprintf(f, \"]\\n\");\n    }\n  }\n}", "target": 0}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n    if (equalIgnoringCase(m_scheme, \"http\"))\n        return equalIgnoringCase(url.protocol(), \"http\") || equalIgnoringCase(url.protocol(), \"https\");\n    if (equalIgnoringCase(m_scheme, \"ws\"))\n        return equalIgnoringCase(url.protocol(), \"ws\") || equalIgnoringCase(url.protocol(), \"wss\");\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 0}
{"code": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\tinotify_enabled = 1;\n}", "target": 1}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "static u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}", "target": 0}
{"code": "static void __mcheck_cpu_init_timer(void)\n{\n\tstruct timer_list *t = this_cpu_ptr(&mce_timer);\n\ttimer_setup(t, mce_timer_fn, TIMER_PINNED);\n\tmce_start_timer(t);\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "ospf_header_dump (struct ospf_header *ospfh)\n{\n  char buf[9];\n  u_int16_t auth_type = ntohs (ospfh->auth_type);\n  zlog_debug (\"Header\");\n  zlog_debug (\"  Version %d\", ospfh->version);\n  zlog_debug (\"  Type %d (%s)\", ospfh->type,\n\t     LOOKUP (ospf_packet_type_str, ospfh->type));\n  zlog_debug (\"  Packet Len %d\", ntohs (ospfh->length));\n  zlog_debug (\"  Router ID %s\", inet_ntoa (ospfh->router_id));\n  zlog_debug (\"  Area ID %s\", inet_ntoa (ospfh->area_id));\n  zlog_debug (\"  Checksum 0x%x\", ntohs (ospfh->checksum));\n  zlog_debug (\"  AuType %s\", LOOKUP (ospf_auth_type_str, auth_type));\n  switch (auth_type)\n    {\n    case OSPF_AUTH_NULL:\n      break;\n    case OSPF_AUTH_SIMPLE:\n      memset (buf, 0, 9);\n      strncpy (buf, (char *) ospfh->u.auth_data, 8);\n      zlog_debug (\"  Simple Password %s\", buf);\n      break;\n    case OSPF_AUTH_CRYPTOGRAPHIC:\n      zlog_debug (\"  Cryptographic Authentication\");\n      zlog_debug (\"  Key ID %d\", ospfh->u.crypt.key_id);\n      zlog_debug (\"  Auth Data Len %d\", ospfh->u.crypt.auth_data_len);\n      zlog_debug (\"  Sequence number %ld\",\n\t\t (u_long)ntohl (ospfh->u.crypt.crypt_seqnum));\n      break;\n    default:\n      zlog_debug (\"* This is not supported authentication type\");\n      break;\n    }\n}", "target": 0}
{"code": "snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *type = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}", "target": 1}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "static int domain_add_dev_info(struct dmar_domain *domain, struct device *dev)\n{\n\tstruct dmar_domain *ndomain;\n\tstruct intel_iommu *iommu;\n\tu8 bus, devfn;\n\tiommu = device_to_iommu(dev, &bus, &devfn);\n\tif (!iommu)\n\t\treturn -ENODEV;\n\tndomain = dmar_insert_one_dev_info(iommu, bus, devfn, dev, domain);\n\tif (ndomain != domain)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = (unsigned char *) in;\n  r = (ctx->count[1] >> 3) & 0x3f;\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n  memcpy(ctx->buf, src, len);\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "gopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n    debugs(10, 3, gopherState->entry->url());\n    ++ statCounter.server.all.requests;\n    ++ statCounter.server.other.requests;\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == nullptr)) {\n        gopherMimeCreate(gopherState);\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n        gopherToHTML(gopherState, (char *) nullptr, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}", "target": 1}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 1}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n \t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "bool RenderView::CaptureThumbnail(WebView* view,\n                                  int w,\n                                  int h,\n                                  SkBitmap* thumbnail,\n                                  ThumbnailScore* score) {\n  base::TimeTicks beginning_time = base::TimeTicks::Now();\n  skia::PlatformCanvas canvas;\n  if (!PaintViewIntoCanvas(view, canvas))\n    return false;\n  skia::BitmapPlatformDevice& device =\n      static_cast<skia::BitmapPlatformDevice&>(canvas.getTopPlatformDevice());\n  const SkBitmap& src_bmp = device.accessBitmap(false);\n  SkRect dest_rect = { 0, 0, SkIntToScalar(w), SkIntToScalar(h) };\n  float dest_aspect = dest_rect.width() / dest_rect.height();\n  SkIRect src_rect;\n  if (src_bmp.width() < dest_rect.width() ||\n      src_bmp.height() < dest_rect.height()) {\n    src_rect.set(0, 0, static_cast<S16CPU>(dest_rect.width()),\n                 static_cast<S16CPU>(dest_rect.height()));\n    score->good_clipping = false;\n  } else {\n    float src_aspect = static_cast<float>(src_bmp.width()) / src_bmp.height();\n    if (src_aspect > dest_aspect) {\n      S16CPU new_width = static_cast<S16CPU>(src_bmp.height() * dest_aspect);\n      S16CPU x_offset = (src_bmp.width() - new_width) / 2;\n      src_rect.set(x_offset, 0, new_width + x_offset, src_bmp.height());\n      score->good_clipping = false;\n    } else {\n      src_rect.set(0, 0, src_bmp.width(),\n                   static_cast<S16CPU>(src_bmp.width() / dest_aspect));\n      score->good_clipping = true;\n    }\n  }\n  score->at_top = (view->mainFrame()->scrollOffset().height == 0);\n  SkBitmap subset;\n  device.accessBitmap(false).extractSubset(&subset, src_rect);\n  *thumbnail = skia::ImageOperations::Resize(\n      subset, skia::ImageOperations::RESIZE_LANCZOS3, w, h);\n  score->boring_score = CalculateBoringScore(thumbnail);\n  HISTOGRAM_TIMES(\"Renderer4.Thumbnail\",\n                  base::TimeTicks::Now() - beginning_time);\n  return true;\n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static IHEVCD_ERROR_T ihevcd_parse_profile_tier_level_layer(bitstrm_t *ps_bitstrm,\n profile_tier_lvl_t *ps_ptl)\n{\n    WORD32 value;\n    WORD32 i;\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    BITS_PARSE(\"XXX_profile_space[]\", value, ps_bitstrm, 2);\n    ps_ptl->i1_profile_space = value;\n    BITS_PARSE(\"XXX_tier_flag[]\", value, ps_bitstrm, 1);\n    ps_ptl->i1_tier_flag = value;\n    BITS_PARSE(\"XXX_profile_idc[]\", value, ps_bitstrm, 5);\n    ps_ptl->i1_profile_idc = value;\n for(i = 0; i < MAX_PROFILE_COMPATBLTY; i++)\n {\n        BITS_PARSE(\"XXX_profile_compatibility_flag[][j]\", value, ps_bitstrm, 1);\n        ps_ptl->ai1_profile_compatibility_flag[i] = value;\n }\n    BITS_PARSE(\"general_progressive_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_progressive_source_flag = value;\n    BITS_PARSE(\"general_interlaced_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_interlaced_source_flag = value;\n    BITS_PARSE(\"general_non_packed_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_non_packed_constraint_flag = value;\n    BITS_PARSE(\"general_frame_only_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_frame_only_constraint_flag = value;\n    BITS_PARSE(\"XXX_reserved_zero_44bits[0..15]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[16..31]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[32..43]\", value, ps_bitstrm, 12);\n return ret;\n}", "target": 0}
{"code": "\tMode mode() const { return m_mode; }", "target": 0}
{"code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}", "target": 1}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "static int prepare_func_exit(struct bpf_verifier_env *env, int *insn_idx)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_func_state *caller, *callee;\n\tstruct bpf_reg_state *r0;\n\tint err;\n\tcallee = state->frame[state->curframe];\n\tr0 = &callee->regs[BPF_REG_0];\n\tif (r0->type == PTR_TO_STACK) {\n\t\tverbose(env, \"cannot return stack pointer to the caller\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstate->curframe--;\n\tcaller = state->frame[state->curframe];\n\tif (callee->in_callback_fn) {\n\t\tstruct tnum range = tnum_range(0, 1);\n\t\tif (r0->type != SCALAR_VALUE) {\n\t\t\tverbose(env, \"R0 not a scalar value\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (!tnum_in(range, r0->var_off)) {\n\t\t\tverbose_invalid_scalar(env, r0, &range, \"callback return\", \"R0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tcaller->regs[BPF_REG_0] = *r0;\n\t}\n\terr = copy_reference_state(caller, callee);\n\tif (err)\n\t\treturn err;\n\t*insn_idx = callee->callsite + 1;\n\tif (env->log.level & BPF_LOG_LEVEL) {\n\t\tverbose(env, \"returning from callee:\\n\");\n\t\tprint_verifier_state(env, callee, true);\n\t\tverbose(env, \"to caller at %d:\\n\", *insn_idx);\n\t\tprint_verifier_state(env, caller, true);\n\t}\n\tfree_func_state(callee);\n\tstate->frame[state->curframe + 1] = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "int recursive_destroy(char *dirname)\n{\n\tint ret;\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\twhile ((direntp = readdir(dir))) {\n\t\tchar *pathname;\n\t\tstruct stat mystat;\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret < 0) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"Failed to stat \\\"%s\\\"\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tret = recursive_destroy(pathname);\n\t\tif (ret < 0)\n\t\t\tr = -1;\n\tnext:\n\t\tfree(pathname);\n\t}\n\tret = rmdir(dirname);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\tret = closedir(dir);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "void dccp_shutdown(struct sock *sk, int how)\n{\n\tdccp_pr_debug(\"entry\\n\");\n}", "target": 0}
{"code": "char *_q_makeword(char *str, char stop)\n{\n    char *word;\n    int  len, i;\n    for (len = 0; ((str[len] != stop) && (str[len])); len++);\n    word = (char *)malloc(sizeof(char) * (len + 1));\n    for (i = 0; i < len; i++) word[i] = str[i];\n    word[i] = '\\0';\n    if (str[len])len++;\n    for (i = len; str[i]; i++) str[i - len] = str[i];\n    str[i - len] = '\\0';\n    return word;\n}", "target": 0}
{"code": "copy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}", "target": 0}
{"code": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}", "target": 1}
{"code": "void AudioOutputController::DoCreate(AudioParameters params) {\n  DCHECK_EQ(message_loop_, MessageLoop::current());\n  if (state_ == kClosed)\n    return;\n  DCHECK(state_ == kEmpty);\n  if (!AudioManager::GetAudioManager())\n    return;\n  stream_ = AudioManager::GetAudioManager()->MakeAudioOutputStreamProxy(params);\n  if (!stream_) {\n    handler_->OnError(this, 0);\n    return;\n  }\n  if (!stream_->Open()) {\n    stream_->Close();\n    stream_ = NULL;\n    handler_->OnError(this, 0);\n    return;\n  }\n  stream_->SetVolume(volume_);\n  state_ = kCreated;\n  handler_->OnCreated(this);\n  if (!LowLatencyMode()) {\n    AutoLock auto_lock(lock_);\n    SubmitOnMoreData_Locked();\n  }\n}", "target": 0}
{"code": "vhost_user_set_vring_kick(struct virtio_net **pdev, struct VhostUserMsg *pmsg)\n{\n\tstruct vhost_vring_file file;\n\tstruct vhost_virtqueue *vq;\n\tstruct virtio_net *dev = *pdev;\n\tfile.index = pmsg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\tif (pmsg->payload.u64 & VHOST_USER_VRING_NOFD_MASK)\n\t\tfile.fd = VIRTIO_INVALID_EVENTFD;\n\telse\n\t\tfile.fd = pmsg->fds[0];\n\tRTE_LOG(INFO, VHOST_CONFIG,\n\t\t\"vring kick idx:%d file:%d\\n\", file.index, file.fd);\n\tdev = translate_ring_addresses(dev, file.index);\n\tif (!dev)\n\t\treturn;\n\t*pdev = dev;\n\tvq = dev->virtqueue[file.index];\n\tif (!(dev->features & (1ULL << VHOST_USER_F_PROTOCOL_FEATURES)))\n\t\tvq->enabled = 1;\n\tif (vq->kickfd >= 0)\n\t\tclose(vq->kickfd);\n\tvq->kickfd = file.fd;\n}", "target": 0}
{"code": "cursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    \n{\n    linenr_T\tlnum;\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    while (n--)\n\t    {\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\tif (n > 0 || !((State & INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n    coladvance(curwin->w_curswant);\n    if (upd_topline)\n\tupdate_topline();\t\n    return OK;\n}", "target": 0}
{"code": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff + 5 < IOSIZE)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse if (d - IObuff + (*mb_ptr2len)(s) + 1 >= IOSIZE)\n\t    break;\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 1}
{"code": "static int __init atalk_init(void)\n{\n\tint rc;\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}", "target": 1}
{"code": "static int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\tif (state != NETLINK_URELEASE)\n\t\treturn NOTIFY_DONE;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wdev_list, list)\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\trcu_read_unlock();\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleGetActiveAttrib(\n    uint32 immediate_data_size, const gles2::GetActiveAttrib& c) {\n  GLuint program = c.program;\n  GLuint index = c.index;\n  uint32 name_bucket_id = c.name_bucket_id;\n  typedef gles2::GetActiveAttrib::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result) {\n    return error::kOutOfBounds;\n  }\n  if (result->success != 0) {\n    return error::kInvalidArguments;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      program, \"glGetActiveAttrib\");\n  if (!info) {\n    return error::kNoError;\n  }\n  const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n      info->GetAttribInfo(index);\n  if (!attrib_info) {\n    SetGLError(GL_INVALID_VALUE, \"glGetActiveAttrib: index out of range\");\n    return error::kNoError;\n  }\n  result->success = 1;  \n  result->size = attrib_info->size;\n  result->type = attrib_info->type;\n  Bucket* bucket = CreateBucket(name_bucket_id);\n  bucket->SetFromString(attrib_info->name);\n  return error::kNoError;\n}", "target": 0}
{"code": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "int sctp_ulpq_tail_data(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff_head temp;\n\tsctp_data_chunk_t *hdr;\n\tstruct sctp_ulpevent *event;\n\thdr = (sctp_data_chunk_t *) chunk->chunk_hdr;\n\tevent = sctp_ulpevent_make_rcvmsg(chunk->asoc, chunk, gfp);\n\tif (!event)\n\t\treturn -ENOMEM;\n\tevent = sctp_ulpq_reasm(ulpq, event);\n\tif ((event) && (event->msg_flags & MSG_EOR)){\n\t\tskb_queue_head_init(&temp);\n\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\tevent = sctp_ulpq_order(ulpq, event);\n\t}\n\tif (event)\n\t\tsctp_ulpq_tail_event(ulpq, event);\n\treturn 0;\n}", "target": 0}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        if (timestamp >= file_info.m_ModificationTime) {\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n    }\n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}", "target": 1}
{"code": "static int ogm_chapter(AVFormatContext *as, uint8_t *key, uint8_t *val)\n{\n    int i, cnum, h, m, s, ms, keylen = strlen(key);\n    AVChapter *chapter = NULL;\n    if (keylen < 9 || sscanf(key, \"CHAPTER%03d\", &cnum) != 1)\n        return 0;\n    if (keylen <= 10) {\n        if (sscanf(val, \"%02d:%02d:%02d.%03d\", &h, &m, &s, &ms) < 4)\n            return 0;\n        avpriv_new_chapter(as, cnum, (AVRational) { 1, 1000 },\n                           ms + 1000 * (s + 60 * (m + 60 * h)),\n                           AV_NOPTS_VALUE, NULL);\n        av_free(val);\n    } else if (!strcmp(key + keylen - 4, \"NAME\")) {\n        for (i = 0; i < as->nb_chapters; i++)\n            if (as->chapters[i]->id == cnum) {\n                chapter = as->chapters[i];\n                break;\n            }\n        if (!chapter)\n            return 0;\n        av_dict_set(&chapter->metadata, \"title\", val, AV_DICT_DONT_STRDUP_VAL);\n    } else\n        return 0;\n    av_free(key);\n    return 1;\n}", "target": 0}
{"code": "int gnutls_x509_crl_verify(gnutls_x509_crl_t crl,\n\t\t\t   const gnutls_x509_crt_t * CA_list,\n\t\t\t   int CA_list_length, unsigned int flags,\n\t\t\t   unsigned int *verify)\n{\n    int ret;\n    ret = _gnutls_verify_crl2(crl, CA_list, CA_list_length, flags, verify);\n    if (ret < 0) {\n\tgnutls_assert();\n\treturn ret;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int dump_suid_policy()\n{\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n    return suid_dump_policy;\n}", "target": 0}
{"code": "static void vc_uniscr_putc(struct vc_data *vc, char32_t uc)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr)\n\t\tuniscr->lines[vc->vc_y][vc->vc_x] = uc;\n}", "target": 0}
{"code": "bool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\tif (efer & EFER_FFXSR) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n\t\t\treturn false;\n\t}\n\tif (efer & EFER_SVME) {\n\t\tstruct kvm_cpuid_entry2 *feat;\n\t\tfeat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\tif (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,\n                            unsigned size)\n{\n    NvmeCtrl *n = (NvmeCtrl *)opaque;\n    trace_pci_nvme_mmio_write(addr, data, size);\n    if (addr < sizeof(n->bar)) {\n        nvme_write_bar(n, addr, data, size);\n    } else {\n        nvme_process_db(n, addr, data);\n    }\n}", "target": 0}
{"code": "escape_attach (int argc, char **argv, compose_env_t *env)\n{\n  const char *encoding = default_encoding;\n  const char *content_type = default_content_type;\n  switch (argc)\n    {\n    case 4:\n      encoding = argv[3];\n    case 3:\n      content_type = argv[2];\n    case 2:\n      return attlist_attach_file (&env->attlist,\n\t\t\t\t  -1, argv[1], argv[1], argv[1],\n\t\t\t\t  content_type, encoding);\n    default:\n      return escape_check_args (argc, argv, 2, 4);\n    }\n  return 1;\n}", "target": 0}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "loop_pop(codegen_scope *s, int val)\n{\n  if (val) {\n    genop_1(s, OP_LOADNIL, cursp());\n  }\n  dispatch_linked(s, s->loop->pc2);\n  s->loop = s->loop->prev;\n  if (val) push();\n}", "target": 0}
{"code": "    DataValue::DataValue(const byte* buf,\n              long len, ByteOrder byteOrder,TypeId typeId)\n        : Value(typeId)\n    {\n        read(buf, len, byteOrder);\n    }", "target": 0}
{"code": "static gboolean udscs_server_accept_cb(GSocketService    *service,\n                                       GSocketConnection *socket_conn,\n                                       GObject           *source_object,\n                                       gpointer           user_data)\n{\n    struct udscs_server *server = user_data;\n    UdscsConnection *new_conn;\n    new_conn = g_object_new(UDSCS_TYPE_CONNECTION, NULL);\n    new_conn->debug = server->debug;\n    new_conn->read_callback = server->read_callback;\n    g_object_ref(socket_conn);\n    vdagent_connection_setup(VDAGENT_CONNECTION(new_conn),\n                             G_IO_STREAM(socket_conn),\n                             FALSE,\n                             sizeof(struct udscs_message_header),\n                             server->error_cb);\n    server->connections = g_list_prepend(server->connections, new_conn);\n    if (server->debug)\n        syslog(LOG_DEBUG, \"new client accepted: %p\", new_conn);\n    if (server->connect_callback)\n        server->connect_callback(new_conn);\n    return TRUE;\n}", "target": 1}
{"code": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}", "target": 1}
{"code": "    template<typename t>\n    T& max_min(t& min_val) {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"max_min(): Empty instance.\",\n                                    cimglist_instance);\n      T *ptr_max = _data->_data;\n      T min_value = *ptr_max, max_value = min_value;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];\n        cimg_for(img,ptrs,T) {\n          const T val = *ptrs;\n          if (val>max_value) { max_value = val; ptr_max = ptrs; }\n          if (val<min_value) min_value = val;\n        }", "target": 0}
{"code": "KCleanup::itemDir( const KFileInfo *item ) const\n{\n    QString dir = item->url();\n    if ( ! item->isDir() && ! item->isDotEntry() )\n    {\n\tdir.replace ( QRegExp ( \"/[^/]*$\" ), \"\" );\n    }\n    return dir;\n}", "target": 0}
{"code": "static int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}", "target": 0}
{"code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\t*len = sizeof(*addr);\n\treturn 0;\n}", "target": 1}
{"code": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\tif (flags & O_CREAT)\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t} else if (flags & O_PATH) {\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\top->open_flag = flags;\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\top->acc_mode = acc_mode;\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}", "target": 0}
{"code": "_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n    for (; argc-- > 0; ++argv) {\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strncmp(*argv,\"conffile=\",9)) {\n\t  if ((*argv)[9] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = 9+*argv;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if (!strncmp(*argv,\"envfile=\",8)) {\n\t  if ((*argv)[8] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = 8+*argv;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"user_envfile=\",13)) {\n\t  if ((*argv)[13] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = 13+*argv;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"readenv=\",8))\n\t  *readenv = atoi(8+*argv);\n\telse if (!strncmp(*argv,\"user_readenv=\",13))\n\t  *user_readenv = atoi(13+*argv);\n\telse\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n    return ctrl;\n}", "target": 0}
{"code": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}", "target": 1}
{"code": "GF_Err CoLL_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, p->maxCLL);\n\tgf_bs_write_u16(bs, p->maxFALL);\n\treturn GF_OK;\n}", "target": 0}
{"code": "    **/\n    bool operator==(const char *const expression) const {\n      return *this==(+*this)._fill(expression,true,true,0,0,\"operator==\",this);", "target": 0}
{"code": "static bool vhost_work_seq_done(struct vhost_dev *dev, struct vhost_work *work,\n\t\t\t\tunsigned seq)\n{\n\tint left;\n\tspin_lock_irq(&dev->work_lock);\n\tleft = seq - work->done_seq;\n\tspin_unlock_irq(&dev->work_lock);\n\treturn left <= 0;\n}", "target": 0}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}", "target": 1}
{"code": "void EventBindings::AttachFilteredEvent(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(2, args.Length());\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsObject());\n  std::string event_name = *v8::String::Utf8Value(args[0]);\n  if (!context()->HasAccessOrThrowError(event_name))\n    return;\n  std::unique_ptr<base::DictionaryValue> filter;\n  {\n    std::unique_ptr<content::V8ValueConverter> converter(\n        content::V8ValueConverter::create());\n    std::unique_ptr<base::Value> filter_value(converter->FromV8Value(\n        v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));\n    if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {\n      args.GetReturnValue().Set(static_cast<int32_t>(-1));\n      return;\n    }\n     filter = base::DictionaryValue::From(std::move(filter_value));\n   }\n  base::DictionaryValue* filter_weak = filter.get();\n   int id = g_event_filter.Get().AddEventMatcher(\n       event_name, ParseEventMatcher(std::move(filter)));\n   attached_matcher_ids_.insert(id);\n   std::string extension_id = context()->GetExtensionID();\n   if (AddFilter(event_name, extension_id, *filter_weak)) {\n     bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());\n    content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(\n        extension_id, event_name, *filter_weak, lazy));\n  }\n  args.GetReturnValue().Set(static_cast<int32_t>(id));\n}", "target": 1}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "virgl_cmd_resource_flush(VuGpu *g,\n                         struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_resource_flush rf;\n    int i;\n    VUGPU_FILL_CMD(rf);\n    glFlush();\n    if (!rf.resource_id) {\n        g_debug(\"bad resource id for flush..?\");\n        return;\n    }\n    for (i = 0; i < VIRTIO_GPU_MAX_SCANOUTS; i++) {\n        if (g->scanout[i].resource_id != rf.resource_id) {\n            continue;\n        }\n        VhostUserGpuMsg msg = {\n            .request = VHOST_USER_GPU_DMABUF_UPDATE,\n            .size = sizeof(VhostUserGpuUpdate),\n            .payload.update.scanout_id = i,\n            .payload.update.x = rf.r.x,\n            .payload.update.y = rf.r.y,\n            .payload.update.width = rf.r.width,\n            .payload.update.height = rf.r.height\n        };\n        vg_send_msg(g, &msg, -1);\n        vg_wait_ok(g);\n    }\n}", "target": 0}
{"code": "static void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\n\t              vc->vc_blink, vc->vc_underline,\n\t              vc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\n\tvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\n}", "target": 0}
{"code": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tElf32_Sym *sym32;\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif \n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n\treturn 0;\n}", "target": 0}
{"code": "int seccomp_lock_personality(unsigned long personality) {\n        uint32_t arch;\n        int r;\n        if (personality >= PERSONALITY_INVALID)\n                return -EINVAL;\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(personality),\n                                1,\n                                SCMP_A0(SCMP_CMP_NE, personality));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to enable personality lock for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "void SecurityManager::resend_handshake_message_token(\n        const GUID_t& remote_participant_key) const\n{\n    auto sentry = is_security_manager_initialized();\n    if (!sentry)\n    {\n        return;\n    }\n    shared_lock<shared_mutex> _(mutex_);\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n    if (dp_it != discovered_participants_.end())\n    {\n        SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();\n        if (remote_participant_info)\n        {\n            if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())\n            {\n                CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(\n                    remote_participant_info->change_sequence_number_);\n                remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();\n                if (p_change != nullptr)\n                {\n                    EPROSIMA_LOG_INFO(SECURITY, \"Authentication handshake resent to participant \" <<\n                            remote_participant_key);\n                    if (participant_stateless_message_writer_history_->add_change(p_change))\n                    {\n                        remote_participant_info->change_sequence_number_ = p_change->sequenceNumber;\n                    }\n                }\n            }\n            dp_it->second->set_auth(remote_participant_info);\n        }\n    }\n}", "target": 1}
{"code": "void nl80211_send_remain_on_channel_cancel(\n\tstruct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev,\n\tu64 cookie, struct ieee80211_channel *chan, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}", "target": 0}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n  DrawInfo\n    *draw_info;\n  Image\n    *image;\n  MagickBooleanType\n    status;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 0}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n \t\treturn -EMSGSIZE;\n \talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n \tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n \talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "int http_skip_chunk_crlf(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *ptr;\n\tint bytes;\n\tbytes = 1;\n\tptr = buf->lr;\n\tif (*ptr == '\\r') {\n\t\tbytes++;\n\t\tptr++;\n\t\tif (ptr >= buf->data + buf->size)\n\t\t\tptr = buf->data;\n\t}\n\tif (bytes > buf->l - buf->send_max)\n\t\treturn 0;\n\tif (*ptr != '\\n') {\n\t\tmsg->err_pos = ptr - buf->data;\n\t\treturn -1;\n\t}\n\tptr++;\n\tif (ptr >= buf->data + buf->size)\n\t\tptr = buf->data;\n\tbuf->lr = ptr;\n\tmsg->sov = ptr - buf->data;\n\tmsg->som = msg->sov - bytes;\n\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\treturn 1;\n}", "target": 0}
{"code": "hash_findi_add(struct hash_table *hash, const char *str)\n{\n    struct hash_insert hi;\n    void **r;\n    char *strx;\n    size_t l = strlen(str) + 1;\n    r = hash_findib(hash, str, l, &hi);\n    if (r)\n        return r;\n    strx = nasm_malloc(l);  \n    memcpy(strx, str, l);\n    return hash_add(&hi, strx, NULL);\n}", "target": 0}
{"code": "static int do_nonlinear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tint write_access, pte_t orig_pte)\n{\n\tunsigned int flags = FAULT_FLAG_NONLINEAR |\n\t\t\t\t(write_access ? FAULT_FLAG_WRITE : 0);\n\tpgoff_t pgoff;\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\treturn 0;\n\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR) ||\n\t\t\t!(vma->vm_flags & VM_CAN_NONLINEAR))) {\n\t\tprint_bad_pte(vma, orig_pte, address);\n\t\treturn VM_FAULT_OOM;\n\t}\n\tpgoff = pte_to_pgoff(orig_pte);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather *tlb;\n\tstruct vm_area_struct *vma = mm->mmap;\n\tunsigned long nr_accounted = 0;\n\tunsigned long end;\n\tarch_exit_mmap(mm);\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb = tlb_gather_mmu(mm, 1);\n\tend = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL);\n\tvm_unacct_memory(nr_accounted);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, 0);\n\ttlb_finish_mmu(tlb, 0, end);\n\twhile (vma)\n\t\tvma = remove_vma(vma);\n\tBUG_ON(mm->nr_ptes > (FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);\n}", "target": 0}
{"code": "static ssize_t set_bank(struct device *s, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tu64 new;\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\tattr_to_bank(attr)->ctl = new;\n\tmce_restart();\n\treturn size;\n}", "target": 0}
{"code": "chop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n}", "target": 0}
{"code": "z_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}", "target": 1}
{"code": "rfbMpiToBytes(const gcry_mpi_t value, uint8_t *result, size_t size)\n{\n  gcry_error_t error;\n  size_t len;\n  int i;\n  error = gcry_mpi_print(GCRYMPI_FMT_USG, result, size, &len, value);\n  if (gcry_err_code(error) != GPG_ERR_NO_ERROR)\n  {\n    rfbClientLog(\"gcry_mpi_print error: %s\\n\", gcry_strerror(error));\n    return FALSE;\n  }\n  for (i=size-1;i>(int)size-1-(int)len;--i)\n    result[i] = result[i-size+len];\n  for (;i>=0;--i)\n    result[i] = 0;\n  return TRUE;\n}", "target": 0}
{"code": "snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)\n{\n  static snmp_header_t header;\n  static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n  static uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n  buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);\n  if(buff == NULL) {\n    return NULL;\n  }\n  if(header.version != SNMP_VERSION_1) {\n    if(strncmp(header.community.community, SNMP_COMMUNITY, header.community.length)) {\n      LOG_ERR(\"Request with invalid community\\n\");\n      return NULL;\n    }\n  }\n  switch(header.pdu_type) {\n  case SNMP_DATA_TYPE_PDU_GET_REQUEST:\n    if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n    if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_BULK:\n    if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  default:\n    LOG_ERR(\"Invalid request type\");\n    return NULL;\n  }\n  header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;\n  out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);\n  return ++out;\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "int fuse_fs_truncate(struct fuse_fs *fs, const char *path, off_t size)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.truncate)\n        return fs->op.truncate(path, size);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "static uint32_t get_lease(struct dhcp_packet *packet, uint16_t packet_len)\n{\n\tuint8_t *option;\n\tuint32_t lease_seconds;\n\toption = dhcp_get_option(packet, packet_len, DHCP_LEASE_TIME);\n\tif (!option)\n\t\treturn 3600;\n\tlease_seconds = get_be32(option);\n\tif (lease_seconds < 10)\n\t\tlease_seconds = 10;\n\treturn lease_seconds;\n}", "target": 0}
{"code": "static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,\n\t\t\t   int broadcast_flags, struct sock *one_sk,\n\t\t\t   struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tstruct sk_buff *skb2 = NULL;\n\tint err = -ESRCH;\n\tif (!skb)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, node, &net_pfkey->table) {\n\t\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\t\tint err2;\n\t\tif (pfk->promisc)\n\t\t\tpfkey_broadcast_one(skb, &skb2, allocation, sk);\n\t\tif (sk == one_sk)\n\t\t\tcontinue;\n\t\tif (broadcast_flags != BROADCAST_ALL) {\n\t\t\tif (broadcast_flags & BROADCAST_PROMISC_ONLY)\n\t\t\t\tcontinue;\n\t\t\tif ((broadcast_flags & BROADCAST_REGISTERED) &&\n\t\t\t    !pfk->registered)\n\t\t\t\tcontinue;\n\t\t\tif (broadcast_flags & BROADCAST_ONE)\n\t\t\t\tcontinue;\n\t\t}\n\t\terr2 = pfkey_broadcast_one(skb, &skb2, allocation, sk);\n\t\tif ((broadcast_flags & BROADCAST_REGISTERED) && err)\n\t\t\terr = err2;\n\t}\n\trcu_read_unlock();\n\tif (one_sk != NULL)\n\t\terr = pfkey_broadcast_one(skb, &skb2, allocation, one_sk);\n\tkfree_skb(skb2);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 0}
{"code": "    template<typename tf>\n    CImg<floatT> get_isosurface3d(CImgList<tf>& primitives, const float isovalue,\n                                  const int size_x=-100, const int size_y=-100, const int size_z=-100) const {\n      if (_spectrum>1)\n        throw CImgInstanceException(_cimg_instance\n                                    \"get_isosurface3d(): Instance is not a scalar image.\",\n                                    cimg_instance);\n      primitives.assign();\n      if (is_empty()) return *this;\n      CImg<floatT> vertices;\n      if ((size_x==-100 && size_y==-100 && size_z==-100) || (size_x==width() && size_y==height() && size_z==depth())) {\n        const _functor3d_int func(*this);\n        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.0f,height() - 1.0f,depth() - 1.0f,\n                                width(),height(),depth());\n      } else {\n        const _functor3d_float func(*this);\n        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.0f,height() - 1.0f,depth() - 1.0f,\n                                size_x,size_y,size_z);\n      }\n      return vertices;", "target": 0}
{"code": "static int ecryptfs_threadfn(void *ignored)\n{\n\tset_freezable();\n\twhile (1)  {\n\t\tstruct ecryptfs_open_req *req;\n\t\twait_event_freezable(\n\t\t\tecryptfs_kthread_ctl.wait,\n\t\t\t(!list_empty(&ecryptfs_kthread_ctl.req_list)\n\t\t\t || kthread_should_stop()));\n\t\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (!list_empty(&ecryptfs_kthread_ctl.req_list)) {\n\t\t\treq = list_first_entry(&ecryptfs_kthread_ctl.req_list,\n\t\t\t\t\t       struct ecryptfs_open_req,\n\t\t\t\t\t       kthread_ctl_list);\n\t\t\tlist_del(&req->kthread_ctl_list);\n\t\t\t*req->lower_file = dentry_open(&req->path,\n\t\t\t\t(O_RDWR | O_LARGEFILE), current_cred());\n\t\t\tcomplete(&req->done);\n\t\t}\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t}\nout:\n\treturn 0;\n}", "target": 0}
{"code": "static int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  SnippetIter *p = (SnippetIter *)ctx;\n  SnippetPhrase *pPhrase = &p->aPhrase[iPhrase];\n  char *pCsr;\n  int rc;\n  pPhrase->nToken = pExpr->pPhrase->nToken;\n  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pCsr);\n  assert( rc==SQLITE_OK || pCsr==0 );\n  if( pCsr ){\n    int iFirst = 0;\n    pPhrase->pList = pCsr;\n    fts3GetDeltaPosition(&pCsr, &iFirst);\n    assert( iFirst>=0 );\n    pPhrase->pHead = pCsr;\n    pPhrase->pTail = pCsr;\n    pPhrase->iHead = iFirst;\n    pPhrase->iTail = iFirst;\n  }else{\n    assert( rc!=SQLITE_OK || (\n       pPhrase->pList==0 && pPhrase->pHead==0 && pPhrase->pTail==0 \n    ));\n  }\n  return rc;\n}", "target": 0}
{"code": "static void nfs4_handle_setlk_error(struct nfs_server *server, struct nfs4_lock_state *lsp, int new_lock_owner, int error)\n{\n\tswitch (error) {\n\tcase -NFS4ERR_ADMIN_REVOKED:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\t\tif (new_lock_owner != 0 ||\n\t\t   test_bit(NFS_LOCK_INITIALIZED, &lsp->ls_flags) != 0)\n\t\t\tnfs4_schedule_stateid_recovery(server, lsp->ls_state);\n\t\tbreak;\n\tcase -NFS4ERR_STALE_STATEID:\n\t\tlsp->ls_seqid.flags &= ~NFS_SEQID_CONFIRMED;\n\tcase -NFS4ERR_EXPIRED:\n\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t};\n}", "target": 0}
{"code": "int vfs_parse_fs_string(struct fs_context *fc, const char *key,\n\t\t\tconst char *value, size_t v_size)\n{\n\tint ret;\n\tstruct fs_parameter param = {\n\t\t.key\t= key,\n\t\t.type\t= fs_value_is_flag,\n\t\t.size\t= v_size,\n\t};\n\tif (value) {\n\t\tparam.string = kmemdup_nul(value, v_size, GFP_KERNEL);\n\t\tif (!param.string)\n\t\t\treturn -ENOMEM;\n\t\tparam.type = fs_value_is_string;\n\t}\n\tret = vfs_parse_fs_param(fc, &param);\n\tkfree(param.string);\n\treturn ret;\n}", "target": 0}
{"code": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n  if (p >= end)\n    to->reach_end = 1;\n}", "target": 1}
{"code": "return_zero_rows(JOIN *join, select_result *result, List<TABLE_LIST> &tables,\n\t\t List<Item> &fields, bool send_row, ulonglong select_options,\n\t\t const char *info, Item *having, List<Item> &all_fields)\n{\n  DBUG_ENTER(\"return_zero_rows\");\n  if (select_options & SELECT_DESCRIBE)\n  {\n    select_describe(join, FALSE, FALSE, FALSE, info);\n    DBUG_RETURN(0);\n  }\n  join->join_free();\n  if (send_row)\n  {\n    List_iterator<TABLE_LIST> ti(tables);\n    TABLE_LIST *table;\n    while ((table= ti++))\n    {\n      if (!table->is_jtbm())\n        mark_as_null_row(table->table);\t\t\n    }\n    List_iterator_fast<Item> it(all_fields);\n    Item *item;\n    while ((item= it++))\n      item->no_rows_in_result();\n    if (having && having->val_int() == 0)\n      send_row=0;\n  }\n  if (!join->send_row_on_empty_set())\n  {\n    join->thd->set_examined_row_count(0);\n    join->thd->limit_found_rows= 0;\n  }\n  if (!(result->send_result_set_metadata(fields,\n                              Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)))\n  {\n    bool send_error= FALSE;\n    if (send_row)\n      send_error= result->send_data(fields) > 0;\n    if (likely(!send_error))\n      result->send_eof();\t\t\t\t\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": " static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n\tif(dest != src) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }", "target": 1}
{"code": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return NULL;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 0}
{"code": "static struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\terr = nla_parse_nested(tb, NFTA_COUNTER_MAX, attr, nft_counter_policy);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\treturn newstats;\n}", "target": 0}
{"code": "bool InstanceKlass::supers_have_passed_fingerprint_checks() {\n  if (java_super() != NULL && !java_super()->has_passed_fingerprint_check()) {\n    ResourceMark rm;\n    log_trace(class, fingerprint)(\"%s : super %s not fingerprinted\", external_name(), java_super()->external_name());\n    return false;\n  }\n  Array<Klass*>* local_interfaces = this->local_interfaces();\n  if (local_interfaces != NULL) {\n    int length = local_interfaces->length();\n    for (int i = 0; i < length; i++) {\n      InstanceKlass* intf = InstanceKlass::cast(local_interfaces->at(i));\n      if (!intf->has_passed_fingerprint_check()) {\n        ResourceMark rm;\n        log_trace(class, fingerprint)(\"%s : interface %s not fingerprinted\", external_name(), intf->external_name());\n        return false;\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "static double util_pointsize( wmfAPI* API, wmfFont* font, char* str, double font_height, ExceptionInfo *exception)\n{\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  TypeMetric\n    metrics;\n  DrawInfo\n    *draw_info;\n  double\n    pointsize = 0;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=font_height;\n  draw_info->text=str;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    {\n      if (strlen(str) == 1)\n        {\n          pointsize = (font_height *\n                       ( font_height / (metrics.ascent + fabs(metrics.descent))));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / ( metrics.ascent + fabs(metrics.descent)));\n        }\n      else\n        {\n          pointsize = (font_height * (font_height / (metrics.height)));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / metrics.height);\n        }\n#if 0\n      draw_info.pointsize = pointsize;\n      if (GetTypeMetrics(image, &draw_info, &metrics, exception) != MagickFalse)\n        pointsize *= (font_height / (metrics.ascent + fabs(metrics.descent)));\n      pointsize *= 1.114286; \n#endif\n    }\n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"String    = %s\\n\", str);\n  printf(\"Font      = %s\\n\", WMF_FONT_PSNAME(font));\n  printf(\"lfHeight  = %g\\n\", font_height);\n  printf(\"bounds    = %g,%g %g,%g\\n\", metrics.bounds.x1, metrics.bounds.y1,\n         metrics.bounds.x2,metrics.bounds.y2);\n  printf(\"ascent    = %g\\n\", metrics.ascent);\n  printf(\"descent   = %g\\n\", metrics.descent);\n  printf(\"height    = %g\\n\", metrics.height);\n  printf(\"Pointsize = %g\\n\", pointsize);\n#endif\n  return floor(pointsize);\n}", "target": 0}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "bool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}", "target": 0}
{"code": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui);\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n        return get_manuf_name(oui);\n    }\n    return \"\";\n}", "target": 1}
{"code": "static unsigned etag_match(const char *hdr[], const char *etag)\n{\n    unsigned i, match = 0;\n    tok_t tok;\n    char *token;\n    for (i = 0; !match && hdr[i]; i++) {\n        tok_init(&tok, hdr[i], \",\", TOK_TRIMLEFT|TOK_TRIMRIGHT);\n        while (!match && (token = tok_next(&tok))) {\n            if (!etagcmp(token, etag)) match = 1;\n        }\n        tok_fini(&tok);\n    }\n    return match;\n}", "target": 0}
{"code": "std::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n  return dbc;\n}", "target": 1}
{"code": "lexer_scan_identifier (parser_context_t *context_p, \n                       bool propety_name) \n{\n  skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  if (context_p->source_p < context_p->source_end_p\n      && (lit_char_is_identifier_start (context_p->source_p) || context_p->source_p[0] == LIT_CHAR_BACKSLASH))\n  {\n    lexer_parse_identifier (context_p, false);\n    if (propety_name && context_p->token.lit_location.length == 3)\n    {\n      skip_spaces (context_p);\n      if (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_identifier_to_current (context_p, &lexer_get_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n        }\n        else if (lexer_compare_identifier_to_current (context_p, &lexer_set_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n        }\n      }\n    }\n    return;\n  }\n  if (propety_name)\n  {\n    lexer_next_token (context_p);\n    if (context_p->token.type == LEXER_LITERAL\n        || context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      return;\n    }\n  }\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n} ", "target": 0}
{"code": "static ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\trdma_lock_handler(ctx->cm_id);\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tmutex_lock(&cur_file->mut);\n\t\tresp.events_reported = ctx->events_reported;\n\t\tmutex_unlock(&cur_file->mut);\n\t\tgoto response;\n\t}\n\tucma_lock_files(cur_file, new_file);\n\txa_lock(&ctx_table);\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\txa_unlock(&ctx_table);\n\tucma_unlock_files(cur_file, new_file);\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}", "target": 1}
{"code": "void* leak_memalign(size_t alignment, size_t bytes)\n{\n    if (alignment <= MALLOC_ALIGNMENT)\n        return leak_malloc(bytes);\n    if (alignment & (alignment-1))\n        alignment = 1L << (31 - __builtin_clz(alignment));\n    size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n    void* base = leak_malloc(size);\n    if (base != NULL) {\n        intptr_t ptr = (intptr_t)base;\n        if ((ptr % alignment) == 0)\n            return base;\n        ptr += ((-ptr) % alignment);\n        ((void**)ptr)[-1] = MEMALIGN_GUARD;\n        ((void**)ptr)[-2] = base;\n        return (void*)ptr;\n    }\n    return base;\n}", "target": 1}
{"code": "ieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\tif (!(local->hw.flags & IEEE80211_HW_SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\tif (local->hw.flags & IEEE80211_HW_SUPPORTS_DYNAMIC_PS)\n\t\treturn TX_CONTINUE;\n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\tifmgd = &tx->sdata->u.mgd;\n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "win_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\tif (after == 1)\n\t{\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n#if defined(FEAT_GUI)\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}", "target": 0}
{"code": "Tss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    clearbuf(buf);\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n    handler = !handler ? unknown_layer_handler : handler;\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n    return buf;\n}", "target": 1}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n     register unsigned char\n       *q;\n     q=(unsigned char *) p;\n     if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n     p=PushLongPixel(MSBEndian,p,&long_sans);\n     p=PushShortPixel(MSBEndian,p,&id);\n     p=PushShortPixel(MSBEndian,p,&short_sans);\n     p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n       {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n         break;\n       }\n     p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n   }\n }", "target": 1}
{"code": "ospf_ls_req_send (struct ospf_neighbor *nbr)\n{\n  struct ospf_interface *oi;\n  struct ospf_packet *op;\n  u_int16_t length = OSPF_HEADER_SIZE;\n  oi = nbr->oi;\n  op = ospf_packet_new (oi->ifp->mtu);\n  ospf_make_header (OSPF_MSG_LS_REQ, oi, op->s);\n  length += ospf_make_ls_req (nbr, op->s);\n  if (length == OSPF_HEADER_SIZE)\n    {\n      ospf_packet_free (op);\n      return;\n    }\n  ospf_fill_header (oi, op->s, length);\n  op->length = length;\n  if (oi->type == OSPF_IFTYPE_POINTOPOINT) \n    op->dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    op->dst = nbr->address.u.prefix4;\n  ospf_packet_add (oi, op);\n  OSPF_ISM_WRITE_ON (oi->ospf);\n  OSPF_NSM_TIMER_ON (nbr->t_ls_req, ospf_ls_req_timer, nbr->v_ls_req);\n}", "target": 0}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n  if (pref.type == SessionStartupPref::LAST &&\n      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n  return pref;\n}", "target": 1}
{"code": "ex_ni(exarg_T *eap)\n{\n    if (!eap->skip)\n\teap->errmsg =\n\t\t_(\"E319: Sorry, the command is not available in this version\");\n}", "target": 0}
{"code": "static int verify_chunk_dev_extent_mapping(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\n\tstruct extent_map *em;\n\tstruct rb_node *node;\n\tint ret = 0;\n\tread_lock(&em_tree->lock);\n\tfor (node = rb_first_cached(&em_tree->map); node; node = rb_next(node)) {\n\t\tem = rb_entry(node, struct extent_map, rb_node);\n\t\tif (em->map_lookup->num_stripes !=\n\t\t    em->map_lookup->verified_stripes) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"chunk %llu has missing dev extent, have %d expect %d\",\n\t\t\t\t  em->start, em->map_lookup->verified_stripes,\n\t\t\t\t  em->map_lookup->num_stripes);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tread_unlock(&em_tree->lock);\n\treturn ret;\n}", "target": 0}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldl_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "SProcRecordRegisterClients(ClientPtr client)\n{\n    REQUEST(xRecordRegisterClientsReq);\n    int status;\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xRecordRegisterClientsReq);\n    if ((status = SwapCreateRegister(client, (void *) stuff)) != Success)\n        return status;\n    return ProcRecordRegisterClients(client);\n}                               ", "target": 0}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": " std::string GetUploadData(const std::string& brand) {\n   DCHECK(!brand.empty());\n  std::string data(kPostXml);\n  const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\");\n  size_t placeholder_pos = data.find(placeholder);\n  DCHECK(placeholder_pos != std::string::npos);\n  data.replace(placeholder_pos, placeholder.size(), brand);\n  return data;\n }", "target": 1}
{"code": "static int drff_init(struct hid_device *hid)\n{\n\tstruct drff_device *drff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdrff = kzalloc(sizeof(struct drff_device), GFP_KERNEL);\n\tif (!drff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, drff, drff_play);\n\tif (error) {\n\t\tkfree(drff);\n\t\treturn error;\n\t}\n\tdrff->report = report;\n\tdrff->report->field[0]->value[0] = 0xf3;\n\tdrff->report->field[0]->value[1] = 0x00;\n\tdrff->report->field[0]->value[2] = 0x00;\n\tdrff->report->field[0]->value[3] = 0x00;\n\tdrff->report->field[0]->value[4] = 0x00;\n\tdrff->report->field[0]->value[5] = 0x00;\n\tdrff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for DragonRise Inc. \"\n\t\t \"game controllers by Richard Walmsley <richwalm@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "readpw(PK11SlotInfo *slot UNUSED,\n       PRBool retry UNUSED,\n       void *arg UNUSED)\n{\n\tstruct termios sio, tio;\n\tchar line[LINE_MAX], *p;\n\tchar *ret;\n\tingress();\n\tmemset(line, '\\0', sizeof (line));\n\tif (tcgetattr(fileno(stdin), &sio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\ttio = sio;\n\ttio.c_lflag &= ~ECHO;\n\tif (tcsetattr(fileno(stdin), 0, &tio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\tfprintf(stdout, \"Enter passphrase for private key: \");\n\tfflush(stdout);\n\tret = fgets(line, sizeof(line), stdin);\n\tset_errno_guard();\n\ttcsetattr(fileno(stdin), 0, &sio);\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (ret == NULL)\n\t\treturn NULL;\n\tp = line + strcspn(line, \"\\r\\n\");\n\tif (p == NULL)\n\t\tp = line + strcspn(line, \"\\n\");\n\tif (p != NULL)\n\t\t*p = '\\0';\n\tret = strdup(line);\n\tmemset(line, '\\0', sizeof (line));\n\tif (!ret) {\n\t\twarnx(\"Could not read passphrase.\");\n\t\treturn NULL;\n\t}\n\tegress();\n\treturn ret;\n}", "target": 0}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "_dbus_close_all (void)\n{\n  int maxfds, i;\n#ifdef __linux__\n  DIR *d;\n  d = opendir (\"/proc/self/fd\");\n  if (d)\n    {\n      for (;;)\n        {\n          struct dirent buf, *de;\n          int k, fd;\n          long l;\n          char *e = NULL;\n          k = readdir_r (d, &buf, &de);\n          if (k != 0 || !de)\n            break;\n          if (de->d_name[0] == '.')\n            continue;\n          errno = 0;\n          l = strtol (de->d_name, &e, 10);\n          if (errno != 0 || e == NULL || *e != '\\0')\n            continue;\n          fd = (int) l;\n          if (fd < 3)\n            continue;\n          if (fd == dirfd (d))\n            continue;\n          close (fd);\n        }\n      closedir (d);\n      return;\n    }\n#endif\n  maxfds = sysconf (_SC_OPEN_MAX);\n  if (maxfds < 0)\n    maxfds = 1024;\n  for (i = 3; i < maxfds; i++)\n    close (i);\n}", "target": 0}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "bool safeCreateFile(const String& path, CFDataRef data)\n{\n    WCHAR tempDirPath[MAX_PATH];\n    if (!GetTempPathW(WTF_ARRAY_LENGTH(tempDirPath), tempDirPath))\n        return false;\n    WCHAR tempPath[MAX_PATH];\n    if (!GetTempFileNameW(tempDirPath, L\"WEBKIT\", 0, tempPath))\n        return false;\n    HANDLE tempFileHandle = CreateFileW(tempPath, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);\n    if (tempFileHandle == INVALID_HANDLE_VALUE)\n        return false;\n    DWORD written;\n    if (!WriteFile(tempFileHandle, CFDataGetBytePtr(data), static_cast<DWORD>(CFDataGetLength(data)), &written, 0))\n        return false;\n    CloseHandle(tempFileHandle);\n    String destination = path;\n    if (!MoveFileExW(tempPath, destination.charactersWithNullTermination(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED))\n        return false;\n    return true;\n}", "target": 0}
{"code": "static int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "static int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n can_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n \t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n \t}\n error2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "   Get status info from a mailbox */\nPHP_FUNCTION(imap_status)\n{\n\tzval *streamind;\n\tzend_string *mbx;\n\tzend_long flags;\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rSl\", &streamind, &mbx, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif (mail_status(imap_le_struct->imap_stream, ZSTR_VAL(mbx), flags)) {\n\t\tadd_property_long(return_value, \"flags\", IMAPG(status_flags));\n\t\tif (IMAPG(status_flags) & SA_MESSAGES) {\n\t\t\tadd_property_long(return_value, \"messages\", IMAPG(status_messages));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_RECENT) {\n\t\t\tadd_property_long(return_value, \"recent\", IMAPG(status_recent));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UNSEEN) {\n\t\t\tadd_property_long(return_value, \"unseen\", IMAPG(status_unseen));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDNEXT) {\n\t\t\tadd_property_long(return_value, \"uidnext\", IMAPG(status_uidnext));\n\t\t}\n\t\tif (IMAPG(status_flags) & SA_UIDVALIDITY) {\n\t\t\tadd_property_long(return_value, \"uidvalidity\", IMAPG(status_uidvalidity));\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "static void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}", "target": 0}
{"code": "   Copy specified message to a mailbox */\nPHP_FUNCTION(imap_mail_copy)\n{\n\tzval *streamind;\n\tzend_long options = 0;\n\tzend_string *seq, *folder;\n\tint argc = ZEND_NUM_ARGS();\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &seq, &folder, &options) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? options : NIL)) == T) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "KCleanup::KCleanup( QString\t\tid,\n\t\t    QString\t\tcommand,\n\t\t    QString\t\ttitle,\n\t\t    KActionCollection *\tparent\t)\n    : KAction( title,\n\t       parent)\n    , _id\t( id\t  )\n    , _command\t( command )\n    , _title\t( title\t  )\n{\n    _selection\t\t= 0;\n    _enabled\t\t= true;\n    _worksForDir\t= true;\n    _worksForFile\t= false;\n    _worksForDotEntry\t= false;\n    _worksLocalOnly\t= true;\n    _recurse\t\t= false;\n    _askForConfirmation\t= false;\n    _refreshPolicy\t= noRefresh;\n    KAction::setEnabled( false );\n    parent->addAction(id,this);\n    connect(this, SIGNAL(triggered()),\n            this, SLOT(executeWithSelection()));\n}", "target": 0}
{"code": "  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }", "target": 0}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "void WebContentsImpl::SetIsCrashed(base::TerminationStatus status,\n                                   int error_code) {\n  if (status == crashed_status_)\n    return;\n  crashed_status_ = status;\n  crashed_error_code_ = error_code;\n  NotifyNavigationStateChanged(INVALIDATE_TYPE_TAB);\n}", "target": 0}
{"code": "h2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}", "target": 1}
{"code": "uint get_next_field_for_derived_key(uchar *arg)\n{\n  KEYUSE *keyuse= *(KEYUSE **) arg;\n  if (!keyuse)\n    return (uint) (-1);\n  TABLE *table= keyuse->table;\n  uint key= keyuse->key;\n  uint fldno= keyuse->keypart; \n  uint keypart= keyuse->keypart_map == (key_part_map) 1 ?\n                                         0 : (keyuse-1)->keypart+1;\n  for ( ; \n        keyuse->table == table && keyuse->key == key && keyuse->keypart == fldno;\n        keyuse++)\n    keyuse->keypart= keypart;\n  if (keyuse->key != key)\n    keyuse= 0;\n  *((KEYUSE **) arg)= keyuse;\n  return fldno;\n}", "target": 0}
{"code": "static inline void packet_increment_rx_head(struct packet_sock *po,\n\t\t\t\t\t    struct packet_ring_buffer *rb)\n{\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\treturn packet_increment_head(rb);\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }", "target": 1}
{"code": "void __netdev_watchdog_up(struct net_device *dev)\n{\n\tif (dev->tx_timeout) {\n\t\tif (dev->watchdog_timeo <= 0)\n\t\t\tdev->watchdog_timeo = 5*HZ;\n\t\tif (!mod_timer(&dev->watchdog_timer,\n\t\t\t       round_jiffies(jiffies + dev->watchdog_timeo)))\n\t\t\tdev_hold(dev);\n\t}\n}", "target": 0}
{"code": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_random_parent_after_fork(void)\n{\n    apr_uint16_t data;\n    apr_random_insecure_bytes(rng, &data, sizeof(data));\n}", "target": 0}
{"code": "static int nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tint event, gfp_t gfp_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = ctx->portid;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_set(skb, ctx, set, event, 0);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, gfp_flags);\nerr:\n\tif (err < 0)\n\t\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, err);\n\treturn err;\n}", "target": 0}
{"code": "static NTSTATUS ldapsrv_DelRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_DelRequest *req = &call->request->r.DelRequest;\n\tstruct ldap_Result *del_result;\n\tstruct ldapsrv_reply *del_reply;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldb_context *samdb = call->conn->ldb;\n\tstruct ldb_dn *dn;\n\tconst char *errstr = NULL;\n\tint result = LDAP_SUCCESS;\n\tint ldb_ret;\n\tstruct ldb_result *res = NULL;\n\tDEBUG(10, (\"DelRequest\"));\n\tDEBUGADD(10, (\" dn: %s\\n\", req->dn));\n\tlocal_ctx = talloc_named(call, 0, \"DelRequest local memory context\");\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\tdn = ldb_dn_new(local_ctx, samdb, req->dn);\n\tNT_STATUS_HAVE_NO_MEMORY(dn);\n\tDEBUG(10, (\"DelRequest: dn: [%s]\\n\", req->dn));\n\tdel_reply = ldapsrv_init_reply(call, LDAP_TAG_DelResponse);\n\tNT_STATUS_HAVE_NO_MEMORY(del_reply);\n\tif (result == LDAP_SUCCESS) {\n\t\tres = talloc_zero(local_ctx, struct ldb_result);\n\t\tNT_STATUS_HAVE_NO_MEMORY(res);\n\t\tldb_ret = ldapsrv_del_with_controls(call, dn, call->request->controls, res);\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\tdel_result = &del_reply->msg->r.DelResponse;\n\tdel_result->dn = NULL;\n\tif ((res != NULL) && (res->refs != NULL)) {\n\t\tdel_result->resultcode = map_ldb_error(local_ctx,\n\t\t\t\t\t\t       LDB_ERR_REFERRAL, NULL,\n\t\t\t\t\t\t       &errstr);\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = talloc_strdup(call, *res->refs);\n\t} else {\n\t\tdel_result->resultcode = result;\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = NULL;\n\t}\n\ttalloc_free(local_ctx);\n\treturn ldapsrv_queue_reply(call, del_reply);\n}", "target": 0}
{"code": "static void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\tu64 boot_ns;\n\tboot_ns = ktime_to_ns(ktime_add(tk->tkr.base_mono, tk->offs_boot));\n\twrite_seqcount_begin(&vdata->seq);\n\tvdata->clock.vclock_mode\t= tk->tkr.clock->archdata.vclock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr.mask;\n\tvdata->clock.mult\t\t= tk->tkr.mult;\n\tvdata->clock.shift\t\t= tk->tkr.shift;\n\tvdata->boot_ns\t\t\t= boot_ns;\n\tvdata->nsec_base\t\t= tk->tkr.xtime_nsec;\n\twrite_seqcount_end(&vdata->seq);\n}", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "static void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}", "target": 0}
{"code": "storageStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    g_autofree char *configdir = NULL;\n    g_autofree char *rundir = NULL;\n    bool autostart = true;\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n    driver = g_new0(virStorageDriverState, 1);\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    storageDriverLock();\n    if (!(driver->pools = virStoragePoolObjListNew()))\n        goto error;\n    if (privileged) {\n        driver->configDir = g_strdup(SYSCONFDIR \"/libvirt/storage\");\n        driver->autostartDir = g_strdup(SYSCONFDIR \"/libvirt/storage/autostart\");\n        driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/storage\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n        driver->configDir = g_strdup_printf(\"%s/storage\", configdir);\n        driver->autostartDir = g_strdup_printf(\"%s/storage/autostart\", configdir);\n        driver->stateDir = g_strdup_printf(\"%s/storage/run\", rundir);\n    }\n    driver->privileged = privileged;\n    if (g_mkdir_with_parents(driver->stateDir, 0777) < 0) {\n        virReportError(errno,\n                       _(\"cannot create directory %s\"),\n                       driver->stateDir);\n        goto error;\n    }\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllState(driver->pools,\n                                      driver->stateDir) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllConfigs(driver->pools,\n                                        driver->configDir,\n                                        driver->autostartDir) < 0)\n        goto error;\n    storagePoolUpdateAllState();\n    if (virDriverShouldAutostart(driver->stateDir, &autostart) < 0)\n        goto error;\n    if (autostart)\n        storageDriverAutostart();\n    driver->storageEventState = virObjectEventStateNew();\n    if (!(driver->caps = virStorageBackendGetCapabilities()))\n        goto error;\n    storageDriverUnlock();\n    return VIR_DRV_STATE_INIT_COMPLETE;\n error:\n    storageDriverUnlock();\n    storageStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n}", "target": 0}
{"code": "bool HTMLFormControlElement::isAutofocusable() const\n {\n    if (!fastHasAttribute(autofocusAttr))\n        return false;\n    if (hasTagName(inputTag))\n        return !toHTMLInputElement(this)->isInputTypeHidden();\n    if (hasTagName(selectTag))\n        return true;\n    if (hasTagName(keygenTag))\n        return true;\n    if (hasTagName(buttonTag))\n        return true;\n    if (hasTagName(textareaTag))\n        return true;\n     return false;\n }", "target": 1}
{"code": "\tFOR_EACH_MODULE_Type(CIRCNetwork* pNetwork) : CMuser(pNetwork ? pNetwork->GetUser()->GetModules() : CMtemp), CMnet(pNetwork ? pNetwork->GetModules() : CMtemp) {\n\t\twhere = AtGlobal;\n\t}", "target": 0}
{"code": "static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag;\n    if (track->mode == MODE_MP4 || track->mode == MODE_PSP)\n        tag = mp4_get_codec_tag(s, track);\n    else if (track->mode == MODE_ISM) {\n        tag = mp4_get_codec_tag(s, track);\n        if (!tag && track->par->codec_id == AV_CODEC_ID_WMAPRO)\n            tag = MKTAG('w', 'm', 'a', ' ');\n    } else if (track->mode == MODE_IPOD)\n        tag = ipod_get_codec_tag(s, track);\n    else if (track->mode & MODE_3GP)\n        tag = ff_codec_get_tag(codec_3gp_tags, track->par->codec_id);\n    else if (track->mode == MODE_F4V)\n        tag = ff_codec_get_tag(codec_f4v_tags, track->par->codec_id);\n    else\n        tag = mov_get_codec_tag(s, track);\n    return tag;\n}", "target": 0}
{"code": " INST_HANDLER (lds) {\t\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "target": 1}
{"code": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tsplit_huge_page_pmd(walk->mm, pmd);\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 0}
{"code": "static int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[1];\n\tint err;\n\terr = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (err)\n\t\treturn err;\n\tif (!dev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\twhile (1) {\n\t\terr = rdev_dump_mpath(dev, netdev, path_idx, dst, next_hop,\n\t\t\t\t      &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\t\tpath_idx++;\n\t}\n out:\n\tcb->args[1] = path_idx;\n\terr = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn err;\n}", "target": 0}
{"code": "    virtual AP4_Result WritePartial(const void* buffer,\n                                    AP4_Size    bytes_to_write, \n                                    AP4_Size&   bytes_written) {\n        AP4_UI08* out = new AP4_UI08[bytes_to_write+16];\n        AP4_Size  out_size = bytes_to_write+16;\n        AP4_Result result = m_StreamCipher->ProcessBuffer((const AP4_UI08*)buffer,\n                                                          bytes_to_write,\n                                                          out,\n                                                          &out_size);\n        if (AP4_SUCCEEDED(result)) {\n            result = m_Output->Write(out, out_size);\n            bytes_written = bytes_to_write;\n            m_Size       += bytes_to_write;\n        } else {\n            bytes_written = 0;\n        }\n        delete[] out;\n        return result;\n    }", "target": 0}
{"code": "coolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}", "target": 0}
{"code": "mono_method_get_class (MonoMethod *method)\n{\n\treturn method->klass;\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}", "target": 1}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\n\tint n = ss->n;\n\tfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\n\tcc->opaque = cached;\n\tcc->convert = fz_cached_color_convert;\n\tcc->ds = ds ? ds : fz_device_gray(ctx);\n\tcc->ss = ss;\n\tcc->is = is;\n\tfz_try(ctx)\n\t{\n\t\tfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\n\t\tcached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n\t}\n\tfz_catch(ctx)\n\t{\n                fz_drop_color_converter(ctx, &cached->base);\n                fz_drop_hash_table(ctx, cached->hash);\n                fz_free(ctx, cached);\n                fz_rethrow(ctx);\n        }\n }", "target": 1}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n {\n \tint status = -1;\n \tBYTE descriptor;\n \twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n \tif (!stream)\n \t\treturn -1;\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\tStream_Read_UINT8(stream, descriptor); \n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n \t\t\tgoto fail;\n \t\t*ppDstData = NULL;\n \t\tif (zgfx->OutputCount > 0)\n \t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n \t\tUINT16 segmentCount;\n \t\tUINT32 uncompressedSize;\n \t\tBYTE* pConcatenated;\n \t\tif (Stream_GetRemainingLength(stream) < 6)\n \t\t\tgoto fail;\n\t\tStream_Read_UINT16(stream, segmentCount); \n\t\tStream_Read_UINT32(stream, uncompressedSize); \n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\t\t\tStream_Read_UINT32(stream, segmentSize); \n \t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n \t\t\t\tgoto fail;\n \t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n \t\t\tpConcatenated += zgfx->OutputCount;\n \t\t}\n \t}\n \telse\n\t{\n\t\tgoto fail;\n\t}\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static inline struct net *xt_net(const struct xt_action_param *par)\n{\n\treturn par->state->net;\n}", "target": 0}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1}
{"code": "static int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}", "target": 0}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": " */\nxmlNodePtr\nxmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur->type == XML_NAMESPACE_DECL)\n            return(NULL);\n        if (cur->type == XML_ATTRIBUTE_NODE)\n            return(cur->parent);\n    }\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn (NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));", "target": 0}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "vhost_user_set_vring_addr(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tstruct vhost_virtqueue *vq;\n\tstruct vhost_vring_addr *addr = &msg->payload.addr;\n\tbool access_ok;\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (dev->mem == NULL)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tvq = dev->virtqueue[msg->payload.addr.index];\n\taccess_ok = vq->access_ok;\n\tmemcpy(&vq->ring_addrs, addr, sizeof(*addr));\n\tvring_invalidate(dev, vq);\n\tif ((vq->enabled && (dev->features &\n\t\t\t\t(1ULL << VHOST_USER_F_PROTOCOL_FEATURES))) ||\n\t\t\taccess_ok) {\n\t\tdev = translate_ring_addresses(dev, msg->payload.addr.index);\n\t\tif (!dev)\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t*pdev = dev;\n\t}\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}", "target": 1}
{"code": "theme_adium_update_enable_webkit_developer_tools (EmpathyThemeAdium *theme)\n{\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (theme);\n\tWebKitWebView  *web_view = WEBKIT_WEB_VIEW (theme);\n\tgboolean        enable_webkit_developer_tools;\n\tenable_webkit_developer_tools = g_settings_get_boolean (\n\t\t\tpriv->gsettings_chat,\n\t\t\tEMPATHY_PREFS_CHAT_WEBKIT_DEVELOPER_TOOLS);\n\tg_object_set (G_OBJECT (webkit_web_view_get_settings (web_view)),\n\t\t      \"enable-developer-extras\",\n\t\t      enable_webkit_developer_tools,\n\t\t      NULL);\n}", "target": 0}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tnla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),\n\t\t    TIPC_MAX_LINK_NAME);\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 0}
{"code": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  default:\n    break;\n  }\n  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}", "target": 1}
{"code": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}", "target": 1}
{"code": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "static bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t} else {\n\t\tspin_lock(&tx->sta->lock);\n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\t\tif (!tid_tx) {\n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\tif (reset_agg_timer && tid_tx->timeout)\n\t\ttid_tx->last_tx = jiffies;\n\treturn queued;\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_get_play_status(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tuint32_t position;\n\tuint32_t duration;\n\tif (len != 0) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tposition = player_get_position(player);\n\tduration = player_get_duration(player);\n\tposition = htonl(position);\n\tduration = htonl(duration);\n\tmemcpy(&pdu->params[0], &duration, 4);\n\tmemcpy(&pdu->params[4], &position, 4);\n\tpdu->params[8] = player_get_status(player);\n\tpdu->params_len = htons(9);\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "static int isdn_ppp_skip_ac(struct ippp_struct *is, struct sk_buff *skb)\n{\n\tif (skb->len < 1)\n\t\treturn -1;\n\tif (skb->data[0] == 0xff) {\n\t\tif (skb->len < 2)\n\t\t\treturn -1;\n\t\tif (skb->data[1] != 0x03)\n\t\t\treturn -1;\n\t\tskb_pull(skb, 2);\n\t} else {\n\t\tif (is->pppcfg & SC_REJ_COMP_AC)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "js_Regexp *js_toregexp(js_State *J, int idx)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CREGEXP)\n\t\treturn &v->u.object->u.r;\n\tjs_typeerror(J, \"not a regexp\");\n}", "target": 0}
{"code": "int git_treebuilder_insert(\n\tconst git_tree_entry **entry_out,\n\tgit_treebuilder *bld,\n\tconst char *filename,\n\tconst git_oid *id,\n\tgit_filemode_t filemode)\n{\n\tgit_tree_entry *entry;\n\tsize_t pos;\n\tassert(bld && id && filename);\n\tif (!valid_filemode(filemode))\n\t\treturn tree_error(\"Failed to insert entry. Invalid filemode for file\", filename);\n\tif (!valid_entry_name(filename))\n\t\treturn tree_error(\"Failed to insert entry. Invalid name for a tree entry\", filename);\n\tif (!tree_key_search(&pos, &bld->entries, filename, strlen(filename))) {\n\t\tentry = git_vector_get(&bld->entries, pos);\n\t\tif (entry->removed) {\n\t\t\tentry->removed = 0;\n\t\t\tbld->entrycount++;\n\t\t}\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t} else {\n\t\tentry = alloc_entry(filename);\n\t\tGITERR_CHECK_ALLOC(entry);\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t\tif (git_vector_insert_sorted(&bld->entries, entry, NULL) < 0) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\tbld->entrycount++;\n\t}\n\tif (entry_out)\n\t\t*entry_out = entry;\n\treturn 0;\n}", "target": 0}
{"code": "rleUncompress (int inLength, int maxLength, const signed char in[], char out[])\n{\n    char *outStart = out;\n    while (inLength > 0)\n    {\n\tif (*in < 0)\n\t{\n\t    int count = -((int)*in++);\n\t    inLength -= count + 1;\n\t    if (0 > (maxLength -= count))\n\t\treturn 0;\n        if (inLength < 0)\n          return 0;\n        memcpy(out, in, count);\n        out += count;\n        in  += count;\n\t}\n\telse\n\t{\n\t    int count = *in++;\n\t    inLength -= 2;\n\t    if (0 > (maxLength -= count + 1))\n\t\treturn 0;\n        memset(out, *(char*)in, count+1);\n        out += count+1;\n\t    in++;\n\t}\n    }\n    return out - outStart;\n}", "target": 1}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}", "target": 1}
{"code": "PinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "unescape_single_char (char *str, char chr)\n{\n  const char c1 = XNUM_TO_DIGIT (chr >> 4);\n  const char c2 = XNUM_TO_DIGIT (chr & 0xf);\n  char *h = str;                \n  char *t = str;                \n  for (; *h; h++, t++)\n    {\n      if (h[0] == '%' && h[1] == c1 && h[2] == c2)\n        {\n          *t = chr;\n          h += 2;\n        }\n      else\n        *t = *h;\n    }\n  *t = '\\0';\n}", "target": 0}
{"code": "static void lag_pred_line(LagarithContext *l, uint8_t *buf,\n                          int width, int stride, int line)\n{\n    int L, TL;\n    if (!line) {\n        int i, align_width = (width - 1) & ~31;\n        L = l->dsp.add_hfyu_left_prediction(buf + 1, buf + 1,\n                                            align_width, buf[0]);\n        for (i = align_width + 1; i < width; i++)\n            buf[i] += buf[i - 1];\n    } else {\n        L = buf[width - stride - 1];\n        if (line == 1) {\n            TL = l->avctx->pix_fmt == AV_PIX_FMT_YUV420P ? buf[-stride] : L;\n        } else {\n            TL = buf[width - (2 * stride) - 1];\n        }\n        add_lag_median_prediction(buf, buf - stride, buf,\n                                  width, &L, &TL);\n    }\n}", "target": 0}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev) < 0) {\n\t\t\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\twp_idx++;\n\t}\n out:\n\tmutex_unlock(&cfg80211_mutex);\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}", "target": 1}
{"code": "static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t len;\n\tu32 opt;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = BT_SECURITY_LOW;\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trfcomm_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "add_header (char *name, char *value, int mode)\n{\n  struct add_header *hp;\n  if (!add_header_list)\n    {\n      int rc = mu_list_create (&add_header_list);\n      if (rc)\n\t{\n\t  mu_error (_(\"Cannot create header list: %s\"), mu_strerror (rc));\n\t  exit (1);\n\t}\n    }\n  hp = mu_alloc (sizeof (*hp));\n  hp->mode = mode;\n  hp->name = name;\n  hp->value = value;\n  mu_list_append (add_header_list, hp);\n}", "target": 0}
{"code": "OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype) {\n  return [t, dtype](OpDef* op_def) {\n    FullTypeDef* tdef =\n        op_def->mutable_output_arg(0)->mutable_experimental_full_type();\n    tdef->set_type_id(t);\n    FullTypeDef* arg = tdef->add_args();\n    arg->set_type_id(TFT_TENSOR);\n    FullTypeDef* targ = arg->add_args();\n    targ->set_type_id(dtype);\n    return Status::OK();\n  };\n}", "target": 0}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 1}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "onig_get_used_stack_size_in_callout(OnigCalloutArgs* a, int* used_num, int* used_bytes)\n{\n  int n;\n  n = (int )(a->stk - a->stk_base);\n  if (used_num != 0)\n    *used_num = n;\n  if (used_bytes != 0)\n    *used_bytes = n * sizeof(StackType);\n  return ONIG_NORMAL;\n}", "target": 0}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "FunctionDef FunctionDefHelper::Create(\n    const string& function_name, gtl::ArraySlice<string> in_def,\n    gtl::ArraySlice<string> out_def, gtl::ArraySlice<string> attr_def,\n    gtl::ArraySlice<Node> node_def,\n    gtl::ArraySlice<std::pair<string, string>> ret_def) {\n  return Create(function_name, in_def, out_def, attr_def, node_def, ret_def,\n                {});\n}", "target": 0}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "bool IsIDNComponentInSingleScript(const char16* str, int str_len) {\n  UScriptCode first_script = USCRIPT_INVALID_CODE;\n  bool is_first = true;\n  int i = 0;\n  while (i < str_len) {\n    unsigned code_point;\n    U16_NEXT(str, i, str_len, code_point);\n    UErrorCode err = U_ZERO_ERROR;\n    UScriptCode cur_script = uscript_getScript(code_point, &err);\n    if (err != U_ZERO_ERROR)\n      return false;  \n    cur_script = NormalizeScript(cur_script);\n    if (is_first && cur_script != USCRIPT_COMMON) {\n      first_script = cur_script;\n      is_first = false;\n    } else {\n      if (cur_script != USCRIPT_COMMON && cur_script != first_script)\n        return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "isdn_statstr(void)\n{\n\tstatic char istatbuf[2048];\n\tchar *p;\n\tint i;\n\tsprintf(istatbuf, \"idmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", (dev->drvmap[i] < 0) ? \"-\" : dev->drvid[dev->drvmap[i]]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nchmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->chanmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\ndrmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->drvmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nusage:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->usage[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nflags:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\n\t\tif (dev->drv[i]) {\n\t\t\tsprintf(p, \"%ld \", dev->drv[i]->online);\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t} else {\n\t\t\tsprintf(p, \"? \");\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t}\n\t}\n\tsprintf(p, \"\\nphone:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", dev->num[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\n\");\n\treturn istatbuf;\n}", "target": 0}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 1}
{"code": "void Location::SetLocation(const String& url,\n                           LocalDOMWindow* current_window,\n                           LocalDOMWindow* entered_window,\n                           ExceptionState* exception_state,\n                           SetLocationPolicy set_location_policy) {\n  if (!IsAttached())\n    return;\n  if (!current_window->GetFrame())\n    return;\n  Document* entered_document = entered_window->document();\n  if (!entered_document)\n    return;\n  KURL completed_url = entered_document->CompleteURL(url);\n  if (completed_url.IsNull())\n    return;\n  if (!current_window->GetFrame()->CanNavigate(*dom_window_->GetFrame(),\n                                               completed_url)) {\n    if (exception_state) {\n      exception_state->ThrowSecurityError(\n          \"The current window does not have permission to navigate the target \"\n          \"frame to '\" +\n          url + \"'.\");\n    }\n    return;\n  }\n  if (exception_state && !completed_url.IsValid()) {\n    exception_state->ThrowDOMException(DOMExceptionCode::kSyntaxError,\n                                       \"'\" + url + \"' is not a valid URL.\");\n    return;\n  }\n   if (dom_window_->IsInsecureScriptAccess(*current_window, completed_url))\n     return;\n   V8DOMActivityLogger* activity_logger =\n       V8DOMActivityLogger::CurrentActivityLoggerIfIsolatedWorld();\n   if (activity_logger) {\n    Vector<String> argv;\n    argv.push_back(\"LocalDOMWindow\");\n    argv.push_back(\"url\");\n    argv.push_back(entered_document->Url());\n    argv.push_back(completed_url);\n    activity_logger->LogEvent(\"blinkSetAttribute\", argv.size(), argv.data());\n  }\n  WebFrameLoadType frame_load_type = WebFrameLoadType::kStandard;\n  if (set_location_policy == SetLocationPolicy::kReplaceThisFrame)\n    frame_load_type = WebFrameLoadType::kReplaceCurrentItem;\n  dom_window_->GetFrame()->ScheduleNavigation(*current_window->document(),\n                                              completed_url, frame_load_type,\n                                              UserGestureStatus::kNone);\n}", "target": 1}
{"code": "snmp_ber_decode_integer(unsigned char *buf, uint32_t *buff_len, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_INTEGER) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\ticmp_param->data.icmph.checksum = 0;\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}", "target": 1}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "sshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 0}
{"code": "bool IsSmartVirtualKeyboardEnabled() {\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n           keyboard::switches::kEnableVirtualKeyboard)) {\n     return false;\n   }\n  return !base::CommandLine::ForCurrentProcess()->HasSwitch(\n      keyboard::switches::kDisableSmartVirtualKeyboard);\n }", "target": 1}
{"code": "gfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}", "target": 0}
{"code": "int GamutSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)\n{\n    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;\n    cmsCIELab LabIn1, LabOut1;\n    cmsCIELab LabIn2, LabOut2;\n    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];\n    cmsFloat64Number dE1, dE2, ErrorRatio;\n    ErrorRatio = 1.0;\n    cmsDoTransform(t -> hInput, In, &LabIn1, 1);\n    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);\n    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);\n    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));\n    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);\n    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);\n    dE1 = cmsDeltaE(&LabIn1, &LabOut1);\n    dE2 = cmsDeltaE(&LabIn2, &LabOut2);\n    if (dE1 < t->Thereshold && dE2 < t->Thereshold)\n        Out[0] = 0;\n    else {\n        if (dE1 < t->Thereshold && dE2 > t->Thereshold)\n            Out[0] = 0;\n        else\n            if (dE1 > t->Thereshold && dE2 < t->Thereshold)\n                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);\n            else  {\n                if (dE2 == 0.0)\n                    ErrorRatio = dE1;\n                else\n                    ErrorRatio = dE1 / dE2;\n                if (ErrorRatio > t->Thereshold)\n                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);\n                else\n                    Out[0] = 0;\n            }\n    }\n    return TRUE;\n}", "target": 0}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "_XcursorAddPathElt (char *path, const char *elt, int len)\n{\n    size_t    pathlen = strlen (path);\n    if (path[0] == '\\0' || path[pathlen - 1] != '/')\n    {\n\tstrcat (path, \"/\");\n\tpathlen++;\n    }\n    if (len == -1)\n\tlen = strlen (elt);\n    while (len && elt[0] == '/')\n    {\n\telt++;\n\tlen--;\n    }\n    strncpy (path + pathlen, elt, len);\n    path[pathlen + len] = '\\0';\n}", "target": 0}
{"code": "  cf2_initGlobalRegionBuffer( CFF_Decoder*  decoder,\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n    FT_ASSERT( decoder && decoder->globals );\n     FT_ZERO( buf );\n    idx += decoder->globals_bias;\n     if ( idx >= decoder->num_globals )\n       return TRUE;     \n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n  }", "target": 1}
{"code": "coolkey_get_public_key(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj, CK_KEY_TYPE key_type)\n{\n\tsc_pkcs15_pubkey_t *key;\n\tkey = coolkey_make_public_key(p15card->card, obj, key_type);\n\tif (key) {\n\t\treturn key;\n\t}\n\treturn coolkey_get_public_key_from_certificate(p15card, obj);\n}", "target": 0}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static int midi_setup_trackname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_trackname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::UniquePtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::UniquePtr(new CiffDirectory); break;\n            default: m = CiffComponent::UniquePtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(std::move(m));\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "vg_resource_attach_backing(VuGpu *g,\n                           struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n    VUGPU_FILL_CMD(ab);\n    virtio_gpu_bswap_32(&ab, sizeof(ab));\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        g_critical(\"%s: illegal resource specified %d\",\n                   __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    res->iov_cnt = ab.nr_entries;\n}", "target": 0}
{"code": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\tinstruction_pointer_set(regs, bp_vaddr);\n\tsmp_rmb(); \n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\tif (!get_utask())\n\t\tgoto out;\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\thandler_chain(uprobe, regs);\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\nout:\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 1}
{"code": "static void imap_login_preinit(void)\n{\n\tlogin_set_roots = imap_login_setting_roots;\n}", "target": 0}
{"code": "static int nested_svm_intercept(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\tint vmexit = NESTED_EXIT_HOST;\n\tswitch (exit_code) {\n\tcase SVM_EXIT_MSR:\n\t\tvmexit = nested_svm_exit_handled_msr(svm);\n\t\tbreak;\n\tcase SVM_EXIT_IOIO:\n\t\tvmexit = nested_svm_intercept_ioio(svm);\n\t\tbreak;\n\tcase SVM_EXIT_READ_CR0 ... SVM_EXIT_WRITE_CR8: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_CR0);\n\t\tif (svm->nested.intercept_cr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0 ... SVM_EXIT_WRITE_DR7: {\n\t\tu32 bit = 1U << (exit_code - SVM_EXIT_READ_DR0);\n\t\tif (svm->nested.intercept_dr & bit)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_EXCP_BASE ... SVM_EXIT_EXCP_BASE + 0x1f: {\n\t\tu32 excp_bits = 1 << (exit_code - SVM_EXIT_EXCP_BASE);\n\t\tif (svm->nested.intercept_exceptions & excp_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\telse if ((exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR) &&\n\t\t\t svm->apf_reason != 0)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_ERR: {\n\t\tvmexit = NESTED_EXIT_DONE;\n\t\tbreak;\n\t}\n\tdefault: {\n\t\tu64 exit_bits = 1ULL << (exit_code - SVM_EXIT_INTR);\n\t\tif (svm->nested.intercept & exit_bits)\n\t\t\tvmexit = NESTED_EXIT_DONE;\n\t}\n\t}\n\treturn vmexit;\n}", "target": 0}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "static void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}", "target": 0}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "static struct dst_entry *ip6_route_input_lookup(struct net *net,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tstruct flowi6 *fl6, int flags)\n{\n\tif (rt6_need_strict(&fl6->daddr) && dev->type != ARPHRD_PIMREG)\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\treturn fib6_rule_lookup(net, fl6, flags, ip6_pol_route_input);\n}", "target": 0}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n \tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 1}
{"code": "int CF_LoadEncodedChunk(const CuckooFilter *cf, long long pos, const char *data, size_t datalen) {\n    if (datalen == 0) {\n        return REDISMODULE_ERR;\n    }\n    long long offset = pos - datalen - 1;\n    long long currentSize;\n    int filterIx = 0;\n    SubCF *filter = NULL;\n    for (; filterIx < cf->numFilters; ++filterIx) {\n        filter = cf->filters + filterIx;\n        currentSize = filter->bucketSize * filter->numBuckets;\n        if (offset < currentSize) {\n            break;\n        }\n        offset -= currentSize;\n    }\n    memcpy(filter->data + offset, data, datalen);\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\treturn 0;\n}", "target": 0}
{"code": "isdn_net_unreachable(struct net_device *dev, struct sk_buff *skb, char *reason)\n{\n\tif (skb) {\n\t\tu_short proto = ntohs(skb->protocol);\n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s, signalling dst_link_failure %s\\n\",\n\t\t       dev->name,\n\t\t       (reason != NULL) ? reason : \"unknown\",\n\t\t       (proto != ETH_P_IP) ? \"Protocol != ETH_P_IP\" : \"\");\n\t\tdst_link_failure(skb);\n\t}\n\telse {  \n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s\\n\",\n\t\t       dev->name,\n\t\t       (reason != NULL) ? reason : \"reason unknown\");\n\t}\n}", "target": 0}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "void test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}", "target": 1}
{"code": "    EncoderFct TiffMapping::findEncoder(\n        const std::string& make,\n              uint32_t     extendedTag,\n              IfdId        group\n    )\n    {\n        EncoderFct encoderFct = 0;\n        const TiffMappingInfo* td = find(tiffMappingInfo_,\n                                         TiffMappingInfo::Key(make, extendedTag, group));\n        if (td) {\n            encoderFct = td->encoderFct_;\n        }\n        return encoderFct;\n    }", "target": 0}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "spice_server_char_device_add_interface(SpiceServer *reds, SpiceBaseInstance *sin)\n{\n    SpiceCharDeviceInstance* char_device =\n            SPICE_UPCAST(SpiceCharDeviceInstance, sin);\n    red::shared_ptr<RedCharDevice> dev_state;\n    spice_debug(\"CHAR_DEVICE %s\", char_device->subtype);\n    if (strcmp(char_device->subtype, SUBTYPE_VDAGENT) == 0) {\n        if (reds->vdagent) {\n            spice_warning(\"vdagent already attached\");\n            return -1;\n        }\n        dev_state = attach_to_red_agent(reds, char_device);\n    }\n#ifdef USE_SMARTCARD\n    else if (strcmp(char_device->subtype, SUBTYPE_SMARTCARD) == 0) {\n        dev_state = smartcard_device_connect(reds, char_device);\n        if (!dev_state) {\n            return -1;\n        }\n    }\n#endif\n    else if (strcmp(char_device->subtype, SUBTYPE_USBREDIR) == 0) {\n        dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_USBREDIR);\n    }\n    else if (strcmp(char_device->subtype, SUBTYPE_PORT) == 0) {\n        if (strcmp(char_device->portname, \"org.spice-space.webdav.0\") == 0) {\n            dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_WEBDAV);\n        } else if (strcmp(char_device->portname, \"org.spice-space.stream.0\") == 0) {\n            dev_state = stream_device_connect(reds, char_device);\n        } else {\n            dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_PORT);\n        }\n    }\n    if (dev_state) {\n        spice_assert(dev_state.get() == char_device->st);\n        if (reds->vm_running) {\n            dev_state->start();\n        }\n        reds_add_char_device(reds, dev_state);\n    } else {\n        spice_warning(\"failed to create device state for %s\", char_device->subtype);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "bool ReadListValue(const Message* m, PickleIterator* iter,\n                   ListValue* value, int recursion) {\n  int size;\n  if (!ReadParam(m, iter, &size))\n    return false;\n  for (int i = 0; i < size; ++i) {\n    Value* subval;\n    if (!ReadValue(m, iter, &subval, recursion + 1))\n      return false;\n    value->Set(i, subval);\n  }\n  return true;\n}", "target": 0}
{"code": "static void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}", "target": 0}
{"code": "file_reset(struct magic_set *ms, int checkloaded)\n{\n\tif (checkloaded && ms->mlist[0] == NULL) {\n\t\tfile_error(ms, 0, \"no magic files loaded\");\n\t\treturn -1;\n\t}\n\tif (ms->o.buf) {\n\t\tfree(ms->o.buf);\n\t\tms->o.buf = NULL;\n\t}\n\tif (ms->o.pbuf) {\n\t\tfree(ms->o.pbuf);\n\t\tms->o.pbuf = NULL;\n\t}\n\tms->event_flags &= ~EVENT_HAD_ERR;\n\tms->error = -1;\n\treturn 0;\n}", "target": 0}
{"code": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "void InotifyReader::OnInotifyEvent(const inotify_event* event) {\n  if (event->mask & IN_IGNORED)\n    return;\n  FilePath::StringType child(event->len ? event->name : FILE_PATH_LITERAL(\"\"));\n  base::AutoLock auto_lock(lock_);\n  for (WatcherSet::iterator watcher = watchers_[event->wd].begin();\n       watcher != watchers_[event->wd].end();\n       ++watcher) {\n    (*watcher)->OnFilePathChanged(event->wd,\n                                  child,\n                                  event->mask & (IN_CREATE | IN_MOVED_TO),\n                                  event->mask & IN_ISDIR);\n  }\n}", "target": 0}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\treturn 0;\n}", "target": 0}
{"code": "static int dsa_missing_parameters(const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    dsa = pkey->pkey.dsa;\n    if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "void CScreencopyPortal::queueNextShareFrame(CScreencopyPortal::SSession* pSession) {\n    const auto PSTREAM = m_pPipewire->streamFromSession(pSession);\n    if (PSTREAM && !PSTREAM->streamState)\n        return;\n    const auto FRAMETOOKMS           = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - pSession->sharingData.begunFrame).count() / 1000.0;\n    const auto MSTILNEXTREFRESH      = 1000.0 / (pSession->sharingData.framerate) - FRAMETOOKMS;\n    pSession->sharingData.begunFrame = std::chrono::system_clock::now();\n    Debug::log(TRACE, \"[screencopy] set fps {}, frame took {:.2f}ms, ms till next refresh {:.2f}, estimated actual fps: {:.2f}\", pSession->sharingData.framerate, FRAMETOOKMS,\n               MSTILNEXTREFRESH, std::clamp(1000.0 / FRAMETOOKMS, 1.0, (double)pSession->sharingData.framerate));\n    g_pPortalManager->addTimer({std::clamp(MSTILNEXTREFRESH - 1.0 , 6.0, 1000.0), [pSession]() { g_pPortalManager->m_sPortals.screencopy->startFrameCopy(pSession); }});\n}", "target": 1}
{"code": "static int ssl_flight_append( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_flight_item *msg;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> ssl_flight_append\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"message appended to flight\",\n                           ssl->out_msg, ssl->out_msglen );\n    if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                            sizeof( mbedtls_ssl_flight_item ) ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                                    ssl->out_msglen ) );\n        mbedtls_free( msg );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    memcpy( msg->p, ssl->out_msg, ssl->out_msglen );\n    msg->len = ssl->out_msglen;\n    msg->type = ssl->out_msgtype;\n    msg->next = NULL;\n    if( ssl->handshake->flight == NULL )\n        ssl->handshake->flight = msg;\n    else\n    {\n        mbedtls_ssl_flight_item *cur = ssl->handshake->flight;\n        while( cur->next != NULL )\n            cur = cur->next;\n        cur->next = msg;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= ssl_flight_append\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}", "target": 1}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;\n}", "target": 1}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+PrimitiveExtentPad*quantum+1.0;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) extent,quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i < (ssize_t) extent; i++)\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n          return(MagickTrue);\n        }\n    }\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *)  AcquireCriticalMemory(\n    (size_t) (PrimitiveExtentPad*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t)\n    (PrimitiveExtentPad*quantum));\n  *mvg_info->extent=1;\n  return(MagickFalse);\n}", "target": 0}
{"code": "ldap_start_tls_s ( LDAP *ld,\n\tLDAPControl **serverctrls,\n\tLDAPControl **clientctrls )\n{\n#ifndef HAVE_TLS\n\treturn LDAP_NOT_SUPPORTED;\n#else\n\tint rc;\n\tchar *rspoid = NULL;\n\tstruct berval *rspdata = NULL;\n\tif ( ldap_tls_inplace( ld ) ) {\n\t\treturn LDAP_LOCAL_ERROR;\n\t}\n\trc = ldap_extended_operation_s( ld, LDAP_EXOP_START_TLS,\n\t\tNULL, serverctrls, clientctrls, &rspoid, &rspdata );\n\tif ( rspoid != NULL ) {\n\t\tLDAP_FREE(rspoid);\n\t}\n\tif ( rspdata != NULL ) {\n\t\tber_bvfree( rspdata );\n\t}\n\tif ( rc == LDAP_SUCCESS ) {\n\t\trc = ldap_int_tls_start( ld, ld->ld_defconn, NULL );\n\t}\n\treturn rc;\n#endif\n}", "target": 0}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "plugin_init (Ekiga::KickStart& kickstart)\n{\n#ifdef DEBUG\n  gchar* path = g_build_path (G_DIR_SEPARATOR_S,\n\t\t\t      g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL);\n  plugin_parse_directory (kickstart, path);\n  g_free (path);\n#else\n  plugin_parse_directory (kickstart,\n\t\t\t  EKIGA_PLUGIN_DIR);\n#endif\n}", "target": 1}
{"code": "static int hardware_enable_all(void)\n{\n\tint r = 0;\n\traw_spin_lock(&kvm_lock);\n\tkvm_usage_count++;\n\tif (kvm_usage_count == 1) {\n\t\tatomic_set(&hardware_enable_failed, 0);\n\t\ton_each_cpu(hardware_enable_nolock, NULL, 1);\n\t\tif (atomic_read(&hardware_enable_failed)) {\n\t\t\thardware_disable_all_nolock();\n\t\t\tr = -EBUSY;\n\t\t}\n\t}\n\traw_spin_unlock(&kvm_lock);\n\treturn r;\n}", "target": 0}
{"code": "gen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { \n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}", "target": 0}
{"code": "ospf_auth_type (struct ospf_interface *oi)\n{\n  int auth_type;\n  if (OSPF_IF_PARAM (oi, auth_type) == OSPF_AUTH_NOTSET)\n    auth_type = oi->area->auth_type;\n  else\n    auth_type = OSPF_IF_PARAM (oi, auth_type);\n  if (auth_type == OSPF_AUTH_CRYPTOGRAPHIC &&\n      list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    return OSPF_AUTH_NULL;\n  return auth_type;\n}", "target": 0}
{"code": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\tif (is_vm_hugetlb_page(vma) && (addr &\n\t\t\t\t\t~(huge_page_mask(hstate_vma(vma)))))\n\t\treturn -EINVAL;\n\tnew = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\t*new = *vma;\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\tif (!err)\n\t\treturn 0;\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tkmem_cache_free(vm_area_cachep, new);\n\treturn err;\n}", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "merge_public_with_secret (KBNODE pubblock, KBNODE secblock)\n{\n  KBNODE pub;\n  assert (pubblock->pkt->pkttype == PKT_PUBLIC_KEY);\n  assert (secblock->pkt->pkttype == PKT_SECRET_KEY);\n  for (pub = pubblock; pub; pub = pub->next)\n    {\n      if (pub->pkt->pkttype == PKT_PUBLIC_KEY)\n\t{\n\t  PKT_public_key *pk = pub->pkt->pkt.public_key;\n\t  PKT_secret_key *sk = secblock->pkt->pkt.secret_key;\n\t  assert (pub == pubblock); \n\t  copy_public_parts_to_secret_key (pk, sk);\n\t  free_public_key (pk);\n\t  pub->pkt->pkttype = PKT_SECRET_KEY;\n\t  pub->pkt->pkt.secret_key = copy_secret_key (NULL, sk);\n\t}\n      else if (pub->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  KBNODE sec;\n\t  PKT_public_key *pk = pub->pkt->pkt.public_key;\n\t  for (sec = secblock->next; sec; sec = sec->next)\n\t    {\n\t      if (sec->pkt->pkttype == PKT_SECRET_SUBKEY)\n\t\t{\n\t\t  PKT_secret_key *sk = sec->pkt->pkt.secret_key;\n\t\t  if (!cmp_public_secret_key (pk, sk))\n\t\t    {\n\t\t      copy_public_parts_to_secret_key (pk, sk);\n\t\t      free_public_key (pk);\n\t\t      pub->pkt->pkttype = PKT_SECRET_SUBKEY;\n\t\t      pub->pkt->pkt.secret_key = copy_secret_key (NULL, sk);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  if (!sec)\n\t    BUG (); \n\t}\n    }\n}", "target": 0}
{"code": "static int r_jws_verify_sig_hmac(jws_t * jws, jwk_t * jwk) {\n  unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n  int ret;\n  if (sig != NULL && 0 == o_strcmp((const char *)jws->signature_b64url, (const char *)sig)) {\n    ret = RHN_OK;\n  } else {\n    ret = RHN_ERROR_INVALID;\n  }\n  o_free(sig);\n  return ret;\n}", "target": 1}
{"code": "static bool is_ready_state(int status)\n{\n\tint state = status & (STATUS_READY | STATUS_DIR | STATUS_DMA);\n\treturn state == STATUS_READY;\n}", "target": 0}
{"code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    AnsiContext *s = avctx->priv_data;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    s->frame = av_frame_alloc();\n    if (!s->frame)\n        return AVERROR(ENOMEM);\n    s->font        = avpriv_vga16_font;\n    s->font_height = 16;\n    s->fg          = DEFAULT_FG_COLOR;\n    s->bg          = DEFAULT_BG_COLOR;\n    if (!avctx->width || !avctx->height)\n        ff_set_dimensions(avctx, 80 << 3, 25 << 4);\n    return 0;\n}", "target": 0}
{"code": "static int curl_fnmatch(void *ctx, const char *pattern, const char *string)\n{\n\tphp_curl *ch = (php_curl *) ctx;\n\tphp_curl_fnmatch *t = ch->handlers->fnmatch;\n\tint rval = CURL_FNMATCHFUNC_FAIL;\n\tswitch (t->method) {\n\t\tcase PHP_CURL_USER: {\n\t\t\tzval argv[3];\n\t\t\tzval retval;\n\t\t\tint  error;\n\t\t\tzend_fcall_info fci;\n\t\t\tZVAL_RES(&argv[0], ch->res);\n\t\t\tZ_ADDREF(argv[0]);\n\t\t\tZVAL_STRING(&argv[1], pattern);\n\t\t\tZVAL_STRING(&argv[2], string);\n\t\t\tfci.size = sizeof(fci);\n\t\t\tfci.function_table = EG(function_table);\n\t\t\tZVAL_COPY_VALUE(&fci.function_name, &t->func_name);\n\t\t\tfci.object = NULL;\n\t\t\tfci.retval = &retval;\n\t\t\tfci.param_count = 3;\n\t\t\tfci.params = argv;\n\t\t\tfci.no_separation = 0;\n\t\t\tfci.symbol_table = NULL;\n\t\t\tch->in_callback = 1;\n\t\t\terror = zend_call_function(&fci, &t->fci_cache);\n\t\t\tch->in_callback = 0;\n\t\t\tif (error == FAILURE) {\n\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot call the CURLOPT_FNMATCH_FUNCTION\");\n\t\t\t} else if (!Z_ISUNDEF(retval)) {\n\t\t\t\tif (Z_TYPE(retval) != IS_LONG) {\n\t\t\t\t\tconvert_to_long_ex(&retval);\n\t\t\t\t}\n\t\t\t\trval = Z_LVAL(retval);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&argv[0]);\n\t\t\tzval_ptr_dtor(&argv[1]);\n\t\t\tzval_ptr_dtor(&argv[2]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rval;\n}", "target": 0}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)\n{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n  lodepng_color_profile_init(&prof);\n  error = get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n  if(prof.key && w * h <= 16) prof.alpha = 1; \n  grey_ok = !prof.colored && !prof.alpha; \n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; \n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; \n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); \n    for(i = 0; i < prof.numcolors; i++)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else \n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; \n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "vte_sequence_handler_scroll_up (VteTerminal *terminal, GValueArray *params)\n{\n\tlong val = 1;\n\tGValue *value;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tval = g_value_get_long(value);\n\t\t\tval = MAX(val, 1);\n\t\t}\n\t}\n\t_vte_terminal_scroll_text (terminal, -val);\n}", "target": 0}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  if (MinSize > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n  destroy_range(this->begin(), this->end());\n  if (!this->isSmall())\n    free(this->begin());\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    X509 *x = NULL;\n    int ok = 0, cnum = 0;\n    unsigned int last_reasons = 0;\n    cnum = ctx->error_depth;\n    x = sk_X509_value(ctx->chain, cnum);\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        last_reasons = ctx->current_reasons;\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        if (!ok) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto err;\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto err;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto err;\n        } else\n            ok = 1;\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto err;\n        }\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        if (last_reasons == ctx->current_reasons) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n    }\n err:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n    ctx->current_crl = NULL;\n    return ok;\n}", "target": 0}
{"code": "u32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}", "target": 0}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "static int bnx2x_set_q_rx_mode(struct bnx2x *bp, u8 cl_id,\n\t\t\t       unsigned long rx_mode_flags,\n\t\t\t       unsigned long rx_accept_flags,\n\t\t\t       unsigned long tx_accept_flags,\n\t\t\t       unsigned long ramrod_flags)\n{\n\tstruct bnx2x_rx_mode_ramrod_params ramrod_param;\n\tint rc;\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\tramrod_param.cid = 0;\n\tramrod_param.cl_id = cl_id;\n\tramrod_param.rx_mode_obj = &bp->rx_mode_obj;\n\tramrod_param.func_id = BP_FUNC(bp);\n\tramrod_param.pstate = &bp->sp_state;\n\tramrod_param.state = BNX2X_FILTER_RX_MODE_PENDING;\n\tramrod_param.rdata = bnx2x_sp(bp, rx_mode_rdata);\n\tramrod_param.rdata_mapping = bnx2x_sp_mapping(bp, rx_mode_rdata);\n\tset_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\n\tramrod_param.ramrod_flags = ramrod_flags;\n\tramrod_param.rx_mode_flags = rx_mode_flags;\n\tramrod_param.rx_accept_flags = rx_accept_flags;\n\tramrod_param.tx_accept_flags = tx_accept_flags;\n\trc = bnx2x_config_rx_mode(bp, &ramrod_param);\n\tif (rc < 0) {\n\t\tBNX2X_ERR(\"Set rx_mode %d failed\\n\", bp->rx_mode);\n\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tunregister_netdev(sp->dev);\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "Http::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\tdelta = ktime_sub(now, timer->expires);\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\treturn orun;\n}", "target": 1}
{"code": "void IDNSpoofChecker::SetAllowedUnicodeSet(UErrorCode* status) {\n  if (U_FAILURE(*status))\n    return;\n  const icu::UnicodeSet* recommended_set =\n      uspoof_getRecommendedUnicodeSet(status);\n  icu::UnicodeSet allowed_set;\n  allowed_set.addAll(*recommended_set);\n  const icu::UnicodeSet* inclusion_set = uspoof_getInclusionUnicodeSet(status);\n  allowed_set.addAll(*inclusion_set);\n  allowed_set.remove(0x338u);\n  allowed_set.remove(0x58au);  \n  allowed_set.remove(0x2010u);\n  allowed_set.remove(0x2019u);  \n  allowed_set.remove(0x2027u);\n  allowed_set.remove(0x30a0u);  \n   allowed_set.remove(0x2bbu);  \n   allowed_set.remove(0x2bcu);  \n#if defined(OS_MACOSX)\n  allowed_set.remove(0x0620u);\n  allowed_set.remove(0x0F8Cu);\n  allowed_set.remove(0x0F8Du);\n  allowed_set.remove(0x0F8Eu);\n  allowed_set.remove(0x0F8Fu);\n#endif\n  allowed_set.remove(0x01CDu, 0x01DCu);  \n  allowed_set.remove(0x1C80u, 0x1C8Fu);  \n  allowed_set.remove(0x1E00u, 0x1E9Bu);  \n  allowed_set.remove(0x1F00u, 0x1FFFu);  \n  allowed_set.remove(0xA640u, 0xA69Fu);  \n  allowed_set.remove(0xA720u, 0xA7FFu);  \n  uspoof_setAllowedUnicodeSet(checker_, &allowed_set, status);\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime)\n{\n\tint ret;\n\tstruct rt_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.rt_period = period,\n\t\t.rt_runtime = runtime,\n\t};\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data);\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "PgUser *force_user(PgDatabase *db, const char *name, const char *passwd)\n{\n\tPgUser *user = db->forced_user;\n\tif (!user) {\n\t\tuser = slab_alloc(user_cache);\n\t\tif (!user)\n\t\t\treturn NULL;\n\t\tlist_init(&user->head);\n\t\tlist_init(&user->pool_list);\n\t}\n\tsafe_strcpy(user->name, name, sizeof(user->name));\n\tsafe_strcpy(user->passwd, passwd, sizeof(user->passwd));\n\tdb->forced_user = user;\n\treturn user;\n}", "target": 0}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "AcpiNsPrintNodePathname (\n    ACPI_NAMESPACE_NODE     *Node,\n    const char              *Message)\n{\n    ACPI_BUFFER             Buffer;\n    ACPI_STATUS             Status;\n    if (!Node)\n    {\n        AcpiOsPrintf (\"[NULL NAME]\");\n        return;\n    }\n    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;\n    Status = AcpiNsHandleToPathname (Node, &Buffer, TRUE);\n    if (ACPI_SUCCESS (Status))\n    {\n        if (Message)\n        {\n            AcpiOsPrintf (\"%s \", Message);\n        }\n        AcpiOsPrintf (\"[%s] (Node %p)\", (char *) Buffer.Pointer, Node);\n        ACPI_FREE (Buffer.Pointer);\n    }\n}", "target": 0}
{"code": "static void imx_usdhc_init(Object *obj)\n{\n    SDHCIState *s = SYSBUS_SDHCI(obj);\n    s->io_ops = &usdhc_mmio_ops;\n    s->quirks = SDHCI_QUIRK_NO_BUSY_IRQ;\n}", "target": 0}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,\n\t\t     struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct buffer *req = s->req;\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tif (!s || !req)\n\t\treturn 0;\n\tif (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->r > req->data + req->size - global.tune.maxrewrite)) &&\n\t    (req->l <= req->size - global.tune.maxrewrite))\n\t\thttp_buffer_heavy_realign(req, msg);\n\tif (likely(req->lr < req->r))\n\t\thttp_msg_analyzer(req, msg, &txn->hdr_idx);\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\n\t\tif ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {\n\t\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\t\treturn 1;\n\t\t}\n\t\ttest->flags |= ACL_TEST_F_MAY_CHANGE;\n\t\treturn 0;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->l > req->size - global.tune.maxrewrite ||\n\t     req->r > req->data + req->size - global.tune.maxrewrite))) {\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\ttxn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SN_REDIRECTABLE;\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\treturn 1;\n\t}\n\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\treturn 1;\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\tmutex_lock(&dir->i_mutex);\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "decode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; \n\tif (24 > plen)\n\t\treturn -1;\n        plen-=24; \n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 4 + plenbytes;\ntrunc:\n\treturn -2;\nbadtlv:\n\treturn -3;\n}", "target": 0}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,\n                                            const char *debug_name)\n{\n   struct vrend_decode_ctx *dctx;\n   if (handle >= VREND_MAX_CTX)\n      return;\n   dctx = malloc(sizeof(struct vrend_decode_ctx));\n   if (!dctx)\n      return;\n   dctx->grctx = vrend_create_context(handle, nlen, debug_name);\n   if (!dctx->grctx) {\n      free(dctx);\n      return;\n   }\n   dctx->ds = &dctx->ids;\n   dec_ctx[handle] = dctx;\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_subject_alt_names(const gnutls_datum_t * ext,\n\t\t\t\t\t  gnutls_subject_alt_names_t sans,\n\t\t\t\t\t  unsigned int flags)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result, ret;\n\tunsigned int i;\n\tgnutls_datum_t san, othername_oid;\n\tunsigned type;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(), \"PKIX1.GeneralNames\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\ti = 0;\n\tdo {\n\t\tsan.data = NULL;\n\t\tsan.size = 0;\n\t\tothername_oid.data = NULL;\n\t\tret = _gnutls_parse_general_name2(c2, \"\", i, &san, &type, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (type == GNUTLS_SAN_OTHERNAME) {\n\t\t\tret =\n\t\t\t    _gnutls_parse_general_name2(c2, \"\", i,\n\t\t\t\t\t\t\t&othername_oid,\n\t\t\t\t\t\t\tNULL, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (san.size == 0 || san.data == NULL) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_X509_UNKNOWN_SAN);\n\t\t\tbreak;\n\t\t}\n\t\tret = subject_alt_names_set(&sans->names, &sans->size,\n\t\t\t\t\t    type, &san,\n\t\t\t\t\t    (char *)othername_oid.data);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ti++;\n\t} while (ret >= 0);\n\tsans->size = i;\n\tif (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\tgnutls_free(san.data);\n\t\tgnutls_free(othername_oid.data);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "static CURLUcode decode_host(char *hostname, char **outp)\n{\n  char *per = NULL;\n  if(hostname[0] != '[')\n    per = strchr(hostname, '%');\n  if(!per) {\n    *outp = strdup(hostname);\n    if(!*outp)\n      return CURLUE_OUT_OF_MEMORY;\n  }\n  else {\n    size_t dlen;\n    CURLcode result = Curl_urldecode(hostname, 0, outp, &dlen, REJECT_CTRL);\n    if(result)\n      return CURLUE_BAD_HOSTNAME;\n  }\n  return CURLUE_OK;\n}", "target": 0}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  try {\n    __u8 struct_v = 1;\n    ::decode(struct_v, iter);\n    ::decode(entity_name, iter);\n    ::decode(global_id, iter);\n  } catch (const buffer::error &err) {\n    ldout(cct, 0) << \"AuthNoneAuthorizeHandle::verify_authorizer() failed to decode\" << dendl;\n    return false;\n  }\n  caps_info.allow_all = true;\n  return true;\n}", "target": 1}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_result_error)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n\tchar *err = NULL;\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"r\",\n\t\t\t\t\t\t\t\t &result) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, result, -1, \"PostgreSQL result\", le_result);\n\tpgsql_result = pg_result->result;\n\tif (!pgsql_result) {\n\t\tRETURN_FALSE;\n\t}\n\terr = (char *)PQresultErrorMessage(pgsql_result);\n\tRETURN_STRING(err);\n}", "target": 0}
{"code": "void Rectangle(double x,double y,double w,double h) {\n    outpos += sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f re\",x,y,w,h);\n}", "target": 1}
{"code": "int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}", "target": 0}
{"code": "  void forget_ptr(void *ptr)\n  {\n    if (ptr)\n      for (int i = 0; i < LIBRAW_MSIZE; i++)\n        if (mems[i] == ptr)\n        {\n          mems[i] = NULL;\n          break;\n        }\n  }", "target": 0}
{"code": "void sctp_assoc_set_primary(struct sctp_association *asoc,\n\t\t\t    struct sctp_transport *transport)\n{\n\tint changeover = 0;\n\tif (asoc->peer.primary_path != NULL &&\n\t    asoc->peer.primary_path != transport)\n\t\tchangeover = 1 ;\n\tasoc->peer.primary_path = transport;\n\tmemcpy(&asoc->peer.primary_addr, &transport->ipaddr,\n\t       sizeof(union sctp_addr));\n\tif ((transport->state == SCTP_ACTIVE) ||\n\t    (transport->state == SCTP_UNKNOWN))\n\t\tasoc->peer.active_path = transport;\n\tif (!asoc->outqueue.outstanding_bytes && !asoc->outqueue.out_qlen)\n\t\treturn;\n\tif (transport->cacc.changeover_active)\n\t\ttransport->cacc.cycling_changeover = changeover;\n\ttransport->cacc.changeover_active = changeover;\n\ttransport->cacc.next_tsn_at_change = asoc->next_tsn;\n}", "target": 0}
{"code": "void* leak_malloc(size_t bytes)\n{\n    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n            base = (AllocationEntry*)base + 1;\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n    return base;\n}", "target": 1}
{"code": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn result;\n}", "target": 0}
{"code": "      static double mp_diag(_cimg_math_parser& mp) {\n        double *ptrd = &_mp_arg(1) + 1;\n        const double *ptrs = &_mp_arg(2) + 1;\n        const unsigned int k = (unsigned int)mp.opcode[3];\n        CImg<doubleT>(ptrd,k,k,1,1,true) = CImg<doubleT>(ptrs,1,k,1,1,true).get_diagonal();\n        return cimg::type<double>::nan();", "target": 0}
{"code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\t\tself->rpc_tid = sw.tid;\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t\t*rpc = &self->rpc;\n\t}\nerr_exit:\n\treturn err;\n}", "target": 1}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static int __packet_get_status(struct packet_sock *po, void *frame)\n{\n\tunion {\n\t\tstruct tpacket_hdr *h1;\n\t\tstruct tpacket2_hdr *h2;\n\t\tvoid *raw;\n\t} h;\n\tsmp_rmb();\n\th.raw = frame;\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\tflush_dcache_page(pgv_to_page(&h.h1->tp_status));\n\t\treturn h.h1->tp_status;\n\tcase TPACKET_V2:\n\t\tflush_dcache_page(pgv_to_page(&h.h2->tp_status));\n\t\treturn h.h2->tp_status;\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n  if (decNumberIsInfinite(pdec)) {\n    return NULL;\n  }\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n    decNumberToString(pdec, plit->literal_data);\n  }\n  return plit->literal_data;\n}", "target": 1}
{"code": "unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {\n    zl = zrealloc(zl,len);\n    ZIPLIST_BYTES(zl) = intrev32ifbe(len);\n    zl[len-1] = ZIP_END;\n    return zl;\n}", "target": 1}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "optimize_straight_join(JOIN *join, table_map join_tables)\n{\n  JOIN_TAB *s;\n  uint idx= join->const_tables;\n  bool disable_jbuf= join->thd->variables.join_cache_level == 0;\n  double    record_count= 1.0;\n  double    read_time=    0.0;\n  uint use_cond_selectivity= \n         join->thd->variables.optimizer_use_condition_selectivity;\n  POSITION  loose_scan_pos;\n  for (JOIN_TAB **pos= join->best_ref + idx ; (s= *pos) ; pos++)\n  {\n    best_access_path(join, s, join_tables, join->positions, idx,\n                     disable_jbuf, record_count,\n                     join->positions + idx, &loose_scan_pos);\n    record_count= COST_MULT(record_count, join->positions[idx].records_read);\n    read_time= COST_ADD(read_time,\n                        COST_ADD(join->positions[idx].read_time,\n                                 record_count / (double) TIME_FOR_COMPARE));\n    advance_sj_state(join, join_tables, idx, &record_count, &read_time,\n                     &loose_scan_pos);\n    join_tables&= ~(s->table->map);\n    double pushdown_cond_selectivity= 1.0;\n    if (use_cond_selectivity > 1)\n      pushdown_cond_selectivity= table_cond_selectivity(join, idx, s,\n                                                        join_tables);\n    join->positions[idx].cond_selectivity= pushdown_cond_selectivity;\n    ++idx;\n  }\n  if (join->sort_by_table &&\n      join->sort_by_table != join->positions[join->const_tables].table->table)\n    read_time+= record_count;  \n  memcpy((uchar*) join->best_positions, (uchar*) join->positions,\n         sizeof(POSITION)*idx);\n  join->join_record_count= record_count;\n  join->best_read= read_time - 0.001;\n}", "target": 0}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "cdf_timespec_to_timestamp(cdf_timestamp_t *t, const struct timeval *ts)\n{\n#ifndef __lint__\n\t(void)&t;\n\t(void)&ts;\n#endif\n#ifdef notyet\n\tstruct tm tm;\n\tif (gmtime_r(&ts->ts_sec, &tm) == NULL) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\t*t = (ts->ts_usec / CDF_TIME_PREC) * CDF_TIME_PREC;\n\t*t = tm.tm_sec;\n\t*t += tm.tm_min * 60;\n\t*t += tm.tm_hour * 60 * 60;\n\t*t += tm.tm_mday * 60 * 60 * 24;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}", "target": 1}
{"code": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}", "target": 1}
{"code": "ppp_create_interface(struct net *net, int unit, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\tpn = ppp_pernet(net);\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif \n\tdev_net_set(dev, net);\n\tret = -EEXIST;\n\tmutex_lock(&pn->all_ppp_mutex);\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\t*retp = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; \n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\tret = register_netdev(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tprintk(KERN_ERR \"PPP: couldn't register device %s (%d)\\n\",\n\t\t       dev->name, ret);\n\t\tgoto out2;\n\t}\n\tppp->ppp_net = net;\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\t*retp = 0;\n\treturn ppp;\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}", "target": 0}
{"code": "_zip_u2d_time(time_t time, unsigned short *dtime, unsigned short *ddate)\n{\n    struct tm *tm;\n    tm = localtime(&time);\n    *ddate = ((tm->tm_year+1900-1980)<<9) + ((tm->tm_mon+1)<<5)\n\t+ tm->tm_mday;\n    *dtime = ((tm->tm_hour)<<11) + ((tm->tm_min)<<5)\n\t+ ((tm->tm_sec)>>1);\n    return;\n}", "target": 0}
{"code": "static int plug_ctx_cmp(void *priv, struct list_head *a, struct list_head *b)\n{\n\tstruct request *rqa = container_of(a, struct request, queuelist);\n\tstruct request *rqb = container_of(b, struct request, queuelist);\n\treturn !(rqa->mq_ctx < rqb->mq_ctx ||\n\t\t (rqa->mq_ctx == rqb->mq_ctx &&\n\t\t  blk_rq_pos(rqa) < blk_rq_pos(rqb)));\n}", "target": 0}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 0}
{"code": "\tChunk *inChunk() { return m_inChunk.get(); }", "target": 0}
{"code": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "TEST_F(LuaHeaderMapWrapperTest, ModifyAfterIteration) {\n  const std::string SCRIPT{R\"EOF(\n    function callMe(object)\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n      object:add(\"hello\", \"world\")\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n    end\n  )EOF\"};\n  InSequence s;\n  setup(SCRIPT);\n  Http::TestRequestHeaderMapImpl headers{{\"foo\", \"bar\"}};\n  HeaderMapWrapper::create(coroutine_->luaState(), headers, []() { return true; });\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'hello' 'world'\"));\n  start(\"callMe\");\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag,\n\t\t const UChar** pp, const UChar* end)\n{\n  int v;\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    (*pp)++;\n    return TRUE;\n  }\n  (*pp)++;\n  v = (EncISO_8859_15_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  if ((v | BIT_CTYPE_LOWER) != 0) {\n    if (*p == 0xaa || *p == 0xb5 || *p == 0xba)\n      return FALSE;\n    else\n      return TRUE;\n  }\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *length = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "elg_get_nbits (gcry_sexp_t parms)\n{\n  gcry_sexp_t l1;\n  gcry_mpi_t p;\n  unsigned int nbits;\n  l1 = sexp_find_token (parms, \"p\", 1);\n  if (!l1)\n    return 0; \n  p= sexp_nth_mpi (l1, 1, GCRYMPI_FMT_USG);\n  sexp_release (l1);\n  nbits = p? mpi_get_nbits (p) : 0;\n  _gcry_mpi_release (p);\n  return nbits;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType IsOptionMember(const char *option,\n  const char *options)\n{\n  char\n    **option_list,\n    *string;\n  int\n    number_options;\n  MagickBooleanType\n    member;\n  register ssize_t\n    i;\n  if (options == (const char *) NULL)\n    return(MagickFalse);\n  string=ConstantString(options);\n  (void) SubstituteString(&string,\",\",\" \");\n  option_list=StringToArgv(string,&number_options);\n  string=DestroyString(string);\n  if (option_list == (char **) NULL)\n    return(MagickFalse);\n  member=MagickFalse;\n  for (i=1; i < (ssize_t) number_options; i++)\n  {\n    if ((*option_list[i] == '!') &&\n        (LocaleCompare(option,option_list[i]+1) == 0))\n      break;\n    if (GlobExpression(option,option_list[i],MagickTrue) != MagickFalse)\n      {\n        member=MagickTrue;\n        break;\n      }\n    option_list[i]=DestroyString(option_list[i]);\n  }\n  for ( ; i < (ssize_t) number_options; i++)\n    option_list[i]=DestroyString(option_list[i]);\n  option_list=(char **) RelinquishMagickMemory(option_list);\n  return(member);\n}", "target": 1}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "void AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true );\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}", "target": 1}
{"code": "void LibRaw::nikon_coolscan_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  for (int row = 0; row < raw_height; row++)\n  {\n      if(tiff_bps <=8)\n        fread(buf, 1, bufsize, ifp);\n      else\n          read_shorts(ubuf,width*3);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (is_NikonTransfer == 2)\n    { \n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = ((float)curve[buf[col * 3]]) / 255.0f;\n        ip[col][1] = ((float)curve[buf[col * 3 + 1]]) / 255.0f;\n        ip[col][2] = ((float)curve[buf[col * 3 + 2]]) / 255.0f;\n        ip[col][3] = 0;\n      }\n    }\n    else if (tiff_bps <= 8)\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n    else\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n  }\n  free(buf);\n}", "target": 0}
{"code": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\treturn 0;\n}", "target": 0}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n        code = ENC_CP1254_TO_LOWER_CASE(code);\n    }\n    else if (code == 0x83 || code == 0xAA || code == 0xBA || code == 0xB5)\n      ;\n    else if ((EncCP1254_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code == 0x9A || code == 0x9C || code == 0x9E)\n\tcode -= 0x10;\n      else if (code == 0xFF)\n\tcode -= 0x60;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tret = fn(&kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}", "target": 0}
{"code": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n  params << net->serverEncode(bufname) << quotedReply;\n  net->putCmd(\"NOTICE\", params);\n}", "target": 1}
{"code": "void MimeHandlerViewContainer::OnReady() {\n  if (!render_frame() || !is_embedded_)\n    return;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  blink::WebAssociatedURLLoaderOptions options;\n  DCHECK(!loader_);\n  loader_.reset(frame->CreateAssociatedURLLoader(options));\n   blink::WebURLRequest request(original_url_);\n   request.SetRequestContext(blink::WebURLRequest::kRequestContextObject);\n   loader_->LoadAsynchronously(request, this);\n }", "target": 1}
{"code": "Method* ciEnv::lookup_method(ciInstanceKlass* accessor,\n                             ciKlass*         holder,\n                             Symbol*          name,\n                             Symbol*          sig,\n                             Bytecodes::Code  bc,\n                             constantTag      tag) {\n  InstanceKlass* accessor_klass = accessor->get_instanceKlass();\n  Klass* holder_klass = holder->get_Klass();\n  assert(check_klass_accessibility(accessor, holder_klass), \"holder not accessible\");\n  LinkInfo link_info(holder_klass, name, sig, accessor_klass,\n                     LinkInfo::AccessCheck::required,\n                     LinkInfo::LoaderConstraintCheck::required,\n                     tag);\n  switch (bc) {\n    case Bytecodes::_invokestatic:\n      return LinkResolver::resolve_static_call_or_null(link_info);\n    case Bytecodes::_invokespecial:\n      return LinkResolver::resolve_special_call_or_null(link_info);\n    case Bytecodes::_invokeinterface:\n      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n    case Bytecodes::_invokevirtual:\n      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n    default:\n      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n      return NULL; \n  }\n}", "target": 0}
{"code": "    uint32_t TiffEntryBase::doWriteData(IoWrapper&,\n                                        ByteOrder ,\n                                        int32_t   ,\n                                        uint32_t  ,\n                                        uint32_t& ) const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "static struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,\n\t\t\t\t\t\t   struct sctp_transport *trans2)\n{\n\tif (trans1->error_count > trans2->error_count) {\n\t\treturn trans2;\n\t} else if (trans1->error_count == trans2->error_count &&\n\t\t   ktime_after(trans2->last_time_heard,\n\t\t\t       trans1->last_time_heard)) {\n\t\treturn trans2;\n\t} else {\n\t\treturn trans1;\n\t}\n}", "target": 0}
{"code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}", "target": 1}
{"code": "int __isolate_free_page(struct page *page, unsigned int order)\n{\n\tunsigned long watermark;\n\tstruct zone *zone;\n\tint mt;\n\tBUG_ON(!PageBuddy(page));\n\tzone = page_zone(page);\n\tmt = get_pageblock_migratetype(page);\n\tif (!is_migrate_isolate(mt)) {\n\t\twatermark = min_wmark_pages(zone) + (1UL << order);\n\t\tif (!zone_watermark_ok(zone, 0, watermark, 0, ALLOC_CMA))\n\t\t\treturn 0;\n\t\t__mod_zone_freepage_state(zone, -(1UL << order), mt);\n\t}\n\tlist_del(&page->lru);\n\tzone->free_area[order].nr_free--;\n\trmv_page_order(page);\n\tif (order >= pageblock_order - 1) {\n\t\tstruct page *endpage = page + (1 << order) - 1;\n\t\tfor (; page < endpage; page += pageblock_nr_pages) {\n\t\t\tint mt = get_pageblock_migratetype(page);\n\t\t\tif (!is_migrate_isolate(mt) && !is_migrate_cma(mt)\n\t\t\t    && !is_migrate_highatomic(mt))\n\t\t\t\tset_pageblock_migratetype(page,\n\t\t\t\t\t\t\t  MIGRATE_MOVABLE);\n\t\t}\n\t}\n\treturn 1UL << order;\n}", "target": 0}
{"code": "aubio_filterbank_do (aubio_filterbank_t * f, const cvec_t * in, fvec_t * out)\n{\n  fvec_t tmp;\n  tmp.length = in->length;\n  tmp.data = in->norm;\n  if (f->power != 1.) fvec_pow(&tmp, f->power);\n  fmat_vecmul(f->filters, &tmp, out);\n  return;\n}", "target": 0}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": "int qemu_can_send_packet(NetClientState *sender)\n{\n    int vm_running = runstate_is_running();\n    if (!vm_running) {\n        return 0;\n    }\n    if (!sender->peer) {\n        return 1;\n    }\n    if (sender->peer->receive_disabled) {\n        return 0;\n    } else if (sender->peer->info->can_receive &&\n               !sender->peer->info->can_receive(sender->peer)) {\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, size;\n\tint npinned;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\tint ret;\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn ERR_PTR(-EINVAL);\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (WARN_ON_ONCE(npages > INT_MAX))\n\t\treturn ERR_PTR(-EINVAL);\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnpinned = pin_user_pages_fast(uaddr, npages, write ? FOLL_WRITE : 0, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\t*n = npages;\n\tsev->pages_locked = locked;\n\treturn pages;\nerr:\n\tif (npinned > 0)\n\t\tunpin_user_pages(pages, npinned);\n\tkvfree(pages);\n\treturn ERR_PTR(ret);\n}", "target": 0}
{"code": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    int table_length;\n     int table_offset;\n     ulong format;\n    uint numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; \n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }", "target": 1}
{"code": "static int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\tif (!res->sr_session)\n\t\treturn 0;\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\tstatus = -EREMOTEIO;\n\tif (memcmp(id.data, res->sr_session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot - res->sr_session->fc_slot_table.slots) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tdummy = be32_to_cpup(p++);\n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\tstatus = -EIO;\n\tgoto out_err;\n#else  \n\treturn 0;\n#endif \n}", "target": 0}
{"code": "GfxShading *GfxShading::parse(GfxResources *res, Object *obj, OutputDev *out, GfxState *state)\n{\n    GfxShading *shading;\n    Dict *dict;\n    int typeA;\n    Object obj1;\n    if (obj->isDict()) {\n        dict = obj->getDict();\n    } else if (obj->isStream()) {\n        dict = obj->streamGetDict();\n    } else {\n        return nullptr;\n    }\n    obj1 = dict->lookup(\"ShadingType\");\n    if (!obj1.isInt()) {\n        error(errSyntaxWarning, -1, \"Invalid ShadingType in shading dictionary\");\n        return nullptr;\n    }\n    typeA = obj1.getInt();\n    switch (typeA) {\n    case 1:\n        shading = GfxFunctionShading::parse(res, dict, out, state);\n        break;\n    case 2:\n        shading = GfxAxialShading::parse(res, dict, out, state);\n        break;\n    case 3:\n        shading = GfxRadialShading::parse(res, dict, out, state);\n        break;\n    case 4:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 4, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 4 shading object\");\n            goto err1;\n        }\n        break;\n    case 5:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 5, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 5 shading object\");\n            goto err1;\n        }\n        break;\n    case 6:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 6, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 6 shading object\");\n            goto err1;\n        }\n        break;\n    case 7:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 7, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 7 shading object\");\n            goto err1;\n        }\n        break;\n    default:\n        error(errSyntaxWarning, -1, \"Unimplemented shading type {0:d}\", typeA);\n        goto err1;\n    }\n    return shading;\nerr1:\n    return nullptr;\n}", "target": 0}
{"code": "QString KNSResource::longDescription()\n{\n    QString ret = m_entry.summary();\n    if (m_entry.shortSummary().isEmpty()) {\n        const int newLine = ret.indexOf(QLatin1Char('\\n'));\n        if (newLine<0)\n            ret.clear();\n        else\n            ret = ret.mid(newLine+1).trimmed();\n    }\n    ret.remove(QLatin1Char('\\r'));\n    ret.replace(QStringLiteral(\"[li]\"), QStringLiteral(\"\\n* \"));\n    ret.remove(QRegularExpression(QStringLiteral(\"\\\\[\\\\/?[a-z]*\\\\]\")));\n    static const QRegularExpression urlRegExp(QStringLiteral(\"(^|\\\\s)([-a-zA-Z0-9@:%_\\\\+.~#?&\n    ret.replace(urlRegExp, QStringLiteral(\"<a href=\\\"\\\\2\\\">\\\\2</a>\"));\n    return ret;\n}", "target": 1}
{"code": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    if (codeBlock) {\n      pushCallStack(codeBlock, ip);\n    } else {\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}", "target": 1}
{"code": "build_cert_bag (unsigned char *buffer, size_t buflen, char *salt,\n                size_t *r_length)\n{\n  size_t len[9], needed;\n  unsigned char *p, *certbag;\n  size_t certbaglen;\n  needed = compute_tag_length (buflen);\n  needed += buflen;\n  needed += DIM (data_rc2iter2048);\n  needed += 2 + DIM (oid_data);\n  len[5] = needed;\n  needed += compute_tag_length ( needed);\n  needed += 3;\n  len[3] = needed;\n  needed += compute_tag_length (needed);\n  len[2] = needed;\n  needed += compute_tag_length (needed);\n  needed += 2 + DIM (oid_encryptedData);\n  len[0] = needed;\n  needed += compute_tag_length (needed);\n  p = certbag = gcry_malloc (needed);\n  if (!certbag)\n    {\n      log_error (\"error allocating buffer\\n\");\n      return NULL;\n    }\n  p = store_tag_length (p, TAG_SEQUENCE, len[0]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_encryptedData));\n  memcpy (p, oid_encryptedData, DIM (oid_encryptedData));\n  p += DIM (oid_encryptedData);\n  p = store_tag_length (p, 0xa0, len[2]);\n  p = store_tag_length (p, TAG_SEQUENCE, len[3]);\n  *p++ = TAG_INTEGER;\n  *p++ = 1;\n  *p++ = 0;\n  p = store_tag_length (p, TAG_SEQUENCE, len[5]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_data));\n  memcpy (p, oid_data, DIM (oid_data));\n  p += DIM (oid_data);\n  memcpy (p, data_rc2iter2048, DIM (data_rc2iter2048));\n  memcpy (p + DATA_RC2ITER2048_SALT_OFF, salt, 8);\n  p += DIM (data_rc2iter2048);\n  p = store_tag_length (p, 0x80, buflen);\n  memcpy (p, buffer, buflen);\n  p += buflen;\n  certbaglen = p - certbag;\n  if (needed != certbaglen)\n    log_debug (\"length mismatch: %lu, %lu\\n\",\n               (unsigned long)needed, (unsigned long)certbaglen);\n  *r_length = certbaglen;\n  return certbag;\n}", "target": 0}
{"code": "MagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "gxps_images_guess_content_type (GXPSArchive *zip,\n\t\t\t\tconst gchar *image_uri)\n{\n\tGInputStream *stream;\n\tguchar        buffer[1024];\n\tgssize        bytes_read;\n\tgchar        *mime_type;\n\tstream = gxps_archive_open (zip, image_uri);\n\tif (!stream)\n\t\treturn NULL;\n\tbytes_read = g_input_stream_read (stream, buffer, 1024, NULL, NULL);\n\tmime_type = g_content_type_guess (NULL, buffer, bytes_read, NULL);\n\tg_object_unref (stream);\n\treturn mime_type;\n}", "target": 0}
{"code": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    s_poll_init(fds, 1);\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 1}
{"code": "unsigned long __ref init_memory_mapping(unsigned long start,\n\t\t\t\t\t       unsigned long end)\n{\n\tstruct map_range mr[NR_RANGE_MR];\n\tunsigned long ret = 0;\n\tint nr_range, i;\n\tpr_debug(\"init_memory_mapping: [mem %#010lx-%#010lx]\\n\",\n\t       start, end - 1);\n\tmemset(mr, 0, sizeof(mr));\n\tnr_range = split_mem_range(mr, 0, start, end);\n\tfor (i = 0; i < nr_range; i++)\n\t\tret = kernel_physical_mapping_init(mr[i].start, mr[i].end,\n\t\t\t\t\t\t   mr[i].page_size_mask);\n\tadd_pfn_range_mapped(start >> PAGE_SHIFT, ret >> PAGE_SHIFT);\n\treturn ret >> PAGE_SHIFT;\n}", "target": 0}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "static float *get_window(vorb *f, int len)\n{\n    len <<= 1;\n    if (len == f->blocksize_0) return f->window[0];\n    if (len == f->blocksize_1) return f->window[1];\n   assert(0);\n    return NULL;\n }", "target": 1}
{"code": "static ssize_t _nfsd_copy_file_range(struct nfsd4_copy *copy)\n{\n\tssize_t bytes_copied = 0;\n\tsize_t bytes_total = copy->cp_count;\n\tu64 src_pos = copy->cp_src_pos;\n\tu64 dst_pos = copy->cp_dst_pos;\n\tdo {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbytes_copied = nfsd_copy_file_range(copy->file_src, src_pos,\n\t\t\t\tcopy->file_dst, dst_pos, bytes_total);\n\t\tif (bytes_copied <= 0)\n\t\t\tbreak;\n\t\tbytes_total -= bytes_copied;\n\t\tcopy->cp_res.wr_bytes_written += bytes_copied;\n\t\tsrc_pos += bytes_copied;\n\t\tdst_pos += bytes_copied;\n\t} while (bytes_total > 0 && !copy->cp_synchronous);\n\treturn bytes_copied;\n}", "target": 0}
{"code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\tnetns_nsid_socket_init();\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\nerr_out:\n\tfree(answer);\n\treturn -1;\n}", "target": 1}
{"code": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\tget_bh(iloc->bh);\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}", "target": 0}
{"code": "static int file_cb(\n\tconst git_diff_delta *delta,\n\tfloat progress,\n\tvoid *payload)\n{\n\tstruct diff_data *diff_data = payload;\n\tGIT_UNUSED(progress);\n\tif (delta->old_file.path)\n\t\tdiff_data->old_path = git__strdup(delta->old_file.path);\n\tif (delta->new_file.path)\n\t\tdiff_data->new_path = git__strdup(delta->new_file.path);\n\tgit_oid_cpy(&diff_data->old_id, &delta->old_file.id);\n\tgit_oid_cpy(&diff_data->new_id, &delta->new_file.id);\n\treturn 0;\n}", "target": 0}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "read_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "comics_remove_dir (gchar *path_name)\n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path =\n\t\t\t\tg_build_filename (path_name,\n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": " stringprep_utf8_nfkc_normalize (const char *str, ssize_t len)\n {\n   return g_utf8_normalize (str, len, G_NORMALIZE_NFKC);\n }", "target": 1}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1}
{"code": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}", "target": 1}
{"code": "int STDCALL mysql_server_init(int argc __attribute__((unused)),\n\t\t\t      char **argv __attribute__((unused)),\n\t\t\t      char **groups __attribute__((unused)))\n{\n  int result= 0;\n  if (!mysql_client_init)\n  {\n    mysql_client_init=1;\n    org_my_init_done=my_init_done;\n    if (my_init())\t\t\t\t\n      return 1;\n    init_client_errs();\n    if (mysql_client_plugin_init())\n      return 1;\n    if (!mysql_port)\n    {\n      char *env;\n      struct servent *serv_ptr __attribute__((unused));\n      mysql_port = MYSQL_PORT;\n#if MYSQL_PORT_DEFAULT == 0\n      if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n        mysql_port= (uint) ntohs((ushort) serv_ptr->s_port);\n#endif\n      if ((env= getenv(\"MYSQL_TCP_PORT\")))\n        mysql_port=(uint) atoi(env);\n    }\n    if (!mysql_unix_port)\n    {\n      char *env;\n#ifdef __WIN__\n      mysql_unix_port = (char*) MYSQL_NAMEDPIPE;\n#else\n      mysql_unix_port = (char*) MYSQL_UNIX_ADDR;\n#endif\n      if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n\tmysql_unix_port = env;\n    }\n    mysql_debug(NullS);\n#if defined(SIGPIPE) && !defined(__WIN__)\n    (void) signal(SIGPIPE, SIG_IGN);\n#endif\n#ifdef EMBEDDED_LIBRARY\n    if (argc > -1)\n       result= init_embedded_server(argc, argv, groups);\n#endif\n  }\n  else\n    result= (int)my_thread_init();         \n  return result;\n}", "target": 0}
{"code": "static void bson_append( bson *b, const void *data, int len ) {\n    memcpy( b->cur , data , len );\n    b->cur += len;\n}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "static zend_bool php_auto_globals_create_request(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *form_variables;\n\tunsigned char _gpc_flags[3] = {0, 0, 0};\n\tchar *p;\n\tALLOC_ZVAL(form_variables);\n\tarray_init(form_variables);\n\tINIT_PZVAL(form_variables);\n\tif (PG(request_order) != NULL) {\n\t\tp = PG(request_order);\n\t} else {\n\t\tp = PG(variables_order);\n\t}\n\tfor (; p && *p; p++) {\n\t\tswitch (*p) {\n\t\t\tcase 'g':\n\t\t\tcase 'G':\n\t\t\t\tif (!_gpc_flags[0]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_GET]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[0] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\t\t\t\tif (!_gpc_flags[1]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_POST]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[1] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tif (!_gpc_flags[2]) {\n\t\t\t\t\tphp_autoglobal_merge(Z_ARRVAL_P(form_variables), Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_COOKIE]) TSRMLS_CC);\n\t\t\t\t\t_gpc_flags[2] = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &form_variables, sizeof(zval *), NULL);\n\treturn 0;\n}", "target": 0}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "static void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}", "target": 0}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int prb_curr_blk_in_use(struct kbdq_core *pkc,\n\t\t\t\t      struct block_desc *pbd)\n{\n\treturn TP_STATUS_USER & BLOCK_STATUS(pbd);\n}", "target": 0}
{"code": "charactersDefined (FileInfo * nested)\n{\n  int noErrors = 1;\n  int k;\n  if ((newRule->opcode >= CTO_Space && newRule->opcode <= CTO_LitDigit)\n      || newRule->opcode == CTO_SwapDd\n      ||\n      newRule->opcode == CTO_Replace || newRule->opcode == CTO_MultInd\n      || newRule->opcode == CTO_Repeated ||\n      ((newRule->opcode >= CTO_Context && newRule->opcode <=\n\tCTO_Pass4) && newRule->opcode != CTO_Correct))\n    return 1;\n  for (k = 0; k < newRule->charslen; k++)\n    if (!compile_findCharOrDots (newRule->charsdots[k], 0))\n      {\n\tcompileError (nested, \"Character %s is not defined\", showString\n\t\t      (&newRule->charsdots[k], 1));\n\tnoErrors = 0;\n      }\n  if (!(newRule->opcode == CTO_Correct || newRule->opcode ==\n\tCTO_NoBreak || newRule->opcode == CTO_SwapCc || newRule->opcode ==\n\tCTO_SwapCd))\n    {\n      for (k = newRule->charslen; k < newRule->charslen + newRule->dotslen;\n\t   k++)\n\tif (!compile_findCharOrDots (newRule->charsdots[k], 1))\n\t  {\n\t    compileError (nested, \"Dot pattern %s is not defined.\",\n\t\t\t  unknownDots (newRule->charsdots[k]));\n\t    noErrors = 0;\n\t  }\n    }\n  return noErrors;\n}", "target": 0}
{"code": "static void opj_j2k_setup_decoding (opj_j2k_t *p_j2k)\n{\n        assert(p_j2k != 00);\n        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_tiles);\n}", "target": 0}
{"code": "yang_read_reference(struct lys_module *module, void *node, char *value, char *where, enum yytokentype type)\n{\n    int ret;\n    char *ref = \"reference\";\n    switch (type) {\n    case MODULE_KEYWORD:\n        ret = yang_check_string(module, &module->ref, ref, \"module\", value, NULL);\n        break;\n    case REVISION_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_revision *)node)->ref, ref, where, value, NULL);\n        break;\n    case IMPORT_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_import *)node)->ref, ref, where, value, NULL);\n        break;\n    case INCLUDE_KEYWORD:\n        ret = yang_check_string(module, &((struct lys_include *)node)->ref, ref, where, value, NULL);\n        break;\n    case NODE_PRINT:\n        ret = yang_check_string(module, &((struct lys_node *)node)->ref, ref, where, value, node);\n        break;\n    default:\n        ret = yang_check_string(module, &((struct lys_node *)node)->ref, ref, where, value, NULL);\n        break;\n    }\n    return ret;\n}", "target": 0}
{"code": "int nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret = 0;\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_exchange_id_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "DLLIMPORT int cfg_opt_nprint_var(cfg_opt_t *opt, unsigned int index, FILE *fp)\n{\n\tconst char *str;\n\tif (!opt || !fp) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\tswitch (opt->type) {\n\tcase CFGT_INT:\n\t\tfprintf(fp, \"%ld\", cfg_opt_getnint(opt, index));\n\t\tbreak;\n\tcase CFGT_FLOAT:\n\t\tfprintf(fp, \"%f\", cfg_opt_getnfloat(opt, index));\n\t\tbreak;\n\tcase CFGT_STR:\n\t\tstr = cfg_opt_getnstr(opt, index);\n\t\tfprintf(fp, \"\\\"\");\n\t\twhile (str && *str) {\n\t\t\tif (*str == '\"')\n\t\t\t\tfprintf(fp, \"\\\\\\\"\");\n\t\t\telse if (*str == '\\\\')\n\t\t\t\tfprintf(fp, \"\\\\\\\\\");\n\t\t\telse\n\t\t\t\tfprintf(fp, \"%c\", *str);\n\t\t\tstr++;\n\t\t}\n\t\tfprintf(fp, \"\\\"\");\n\t\tbreak;\n\tcase CFGT_BOOL:\n\t\tfprintf(fp, \"%s\", cfg_opt_getnbool(opt, index) ? \"true\" : \"false\");\n\t\tbreak;\n\tcase CFGT_NONE:\n\tcase CFGT_SEC:\n\tcase CFGT_FUNC:\n\tcase CFGT_PTR:\n\tcase CFGT_COMMENT:\n\t\tbreak;\n\t}\n\treturn CFG_SUCCESS;\n}", "target": 0}
{"code": "STATIC void\nS_dump_regex_sets_structures(pTHX_ RExC_state_t *pRExC_state,\n                             AV * stack, const IV fence, AV * fence_stack)\n{   \n    const SSize_t stack_top = av_tindex_skip_len_mg(stack);\n    const SSize_t fence_stack_top = av_tindex_skip_len_mg(fence_stack);\n    SSize_t i;\n    PERL_ARGS_ASSERT_DUMP_REGEX_SETS_STRUCTURES;\n    PerlIO_printf(Perl_debug_log, \"\\nParse position is:%s\\n\", RExC_parse);\n    if (stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Stack: (fence=%d)\\n\", (int) fence);\n        for (i = stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(stack, i, FALSE);\n            if (! element_ptr) {\n            }\n            if (IS_OPERATOR(*element_ptr)) {\n                PerlIO_printf(Perl_debug_log, \"[%d]: %c\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n            }\n            else {\n                PerlIO_printf(Perl_debug_log, \"[%d] \", (int) i);\n                sv_dump(*element_ptr);\n            }\n        }\n    }\n    if (fence_stack_top < 0) {\n        PerlIO_printf(Perl_debug_log, \"Nothing on fence_stack\\n\");\n    }\n    else {\n        PerlIO_printf(Perl_debug_log, \"Fence_stack: \\n\");\n        for (i = fence_stack_top; i >= 0; i--) {\n            SV ** element_ptr = av_fetch(fence_stack, i, FALSE);\n            if (! element_ptr) {\n            }\n            PerlIO_printf(Perl_debug_log, \"[%d]: %d\\n\",\n                                            (int) i, (int) SvIV(*element_ptr));\n        }\n    }", "target": 0}
{"code": "cluster_hash_key_make (void *p)\n{\n  const struct cluster_list *cluster = p;\n  return jhash(cluster->list, cluster->length, 0);\n}", "target": 0}
{"code": "compileWarning(FileInfo *nested, char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (nested)\n\t\t_lou_logMessage(LOG_WARN, \"%s:%d: warning: %s\", nested->fileName,\n\t\t\t\tnested->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOG_WARN, \"warning: %s\", buffer);\n\twarningCount++;\n#endif\n}", "target": 0}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint space;\n\tif (tp->rcvq_space.time == 0)\n\t\tgoto new_measure;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tspace = 2 * (tp->copied_seq - tp->rcvq_space.seq);\n\tspace = max(tp->rcvq_space.space, space);\n\tif (tp->rcvq_space.space != space) {\n\t\tint rcvmem;\n\t\ttp->rcvq_space.space = space;\n\t\tif (sysctl_tcp_moderate_rcvbuf &&\n\t\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\t\tint new_clamp = space;\n\t\t\tspace /= tp->advmss;\n\t\t\tif (!space)\n\t\t\t\tspace = 1;\n\t\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\t\trcvmem += 128;\n\t\t\tspace *= rcvmem;\n\t\t\tspace = min(space, sysctl_tcp_rmem[2]);\n\t\t\tif (space > sk->sk_rcvbuf) {\n\t\t\t\tsk->sk_rcvbuf = space;\n\t\t\t\ttp->window_clamp = new_clamp;\n\t\t\t}\n\t\t}\n\t}\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "XML_GetBuffer(XML_Parser parser, int len)\n{\n  switch (ps_parsing) {\n  case XML_SUSPENDED:\n    errorCode = XML_ERROR_SUSPENDED;\n    return NULL;\n  case XML_FINISHED:\n    errorCode = XML_ERROR_FINISHED;\n    return NULL;\n  default: ;\n  }\n  if (len > bufferLim - bufferEnd) {\n    int neededSize = len + (int)(bufferEnd - bufferPtr);\n#ifdef XML_CONTEXT_BYTES\n    int keep = (int)(bufferPtr - buffer);\n    if (keep > XML_CONTEXT_BYTES)\n      keep = XML_CONTEXT_BYTES;\n    neededSize += keep;\n#endif  \n    if (neededSize  <= bufferLim - buffer) {\n#ifdef XML_CONTEXT_BYTES\n      if (keep < bufferPtr - buffer) {\n        int offset = (int)(bufferPtr - buffer) - keep;\n        memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);\n        bufferEnd -= offset;\n        bufferPtr -= offset;\n      }\n#else\n      memmove(buffer, bufferPtr, bufferEnd - bufferPtr);\n      bufferEnd = buffer + (bufferEnd - bufferPtr);\n      bufferPtr = buffer;\n#endif  \n    }\n    else {\n      char *newBuf;\n      int bufferSize = (int)(bufferLim - bufferPtr);\n      if (bufferSize == 0)\n        bufferSize = INIT_BUFFER_SIZE;\n      do {\n        bufferSize *= 2;\n      } while (bufferSize < neededSize);\n      newBuf = (char *)MALLOC(bufferSize);\n      if (newBuf == 0) {\n        errorCode = XML_ERROR_NO_MEMORY;\n        return NULL;\n      }\n      bufferLim = newBuf + bufferSize;\n#ifdef XML_CONTEXT_BYTES\n      if (bufferPtr) {\n        int keep = (int)(bufferPtr - buffer);\n        if (keep > XML_CONTEXT_BYTES)\n          keep = XML_CONTEXT_BYTES;\n        memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);\n        FREE(buffer);\n        buffer = newBuf;\n        bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;\n        bufferPtr = buffer + keep;\n      }\n      else {\n        bufferEnd = newBuf + (bufferEnd - bufferPtr);\n        bufferPtr = buffer = newBuf;\n      }\n#else\n      if (bufferPtr) {\n        memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);\n        FREE(buffer);\n      }\n      bufferEnd = newBuf + (bufferEnd - bufferPtr);\n      bufferPtr = buffer = newBuf;\n#endif  \n    }\n    eventPtr = eventEndPtr = NULL;\n    positionPtr = NULL;\n  }\n  return bufferEnd;\n}", "target": 1}
{"code": "static inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "Eina_Bool ewk_view_reload(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_reload(smartData->main_frame);\n}", "target": 0}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "            bool isValid() const\n            {\n                return version_ != -1;\n            }", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "cmsHPROFILE CreatePCS2ITU_ICC(void)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* BToA0;\n    cmsStage* ColorMap;\n    BToA0 = cmsPipelineAlloc(0, 3, 3);\n    if (BToA0 == NULL) return NULL;\n    ColorMap = cmsStageAllocCLut16bit(0, GRID_POINTS, 3, 3, NULL);\n    if (ColorMap == NULL) return NULL;\n    cmsPipelineInsertStage(BToA0, cmsAT_BEGIN, ColorMap);\n    cmsStageSampleCLut16bit(ColorMap, PCS2ITU, NULL, 0);\n    hProfile = cmsCreateProfilePlaceholder(0);\n    if (hProfile == NULL) {\n        cmsPipelineFree(BToA0);\n        return NULL;\n    }\n    cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA0);\n    cmsSetColorSpace(hProfile, cmsSigLabData);\n    cmsSetPCS(hProfile, cmsSigLabData);\n    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n    cmsPipelineFree(BToA0);\n    return hProfile;\n}", "target": 0}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\tr_list_append (ret, addr);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "bool WddxPacket::add_var(const String& varName, bool hasVarTag) {\n  VarEnv* v = g_context->getOrCreateVarEnv();\n  if (!v) return false;\n  Variant varVariant = *reinterpret_cast<Variant*>(v->lookup(varName.get()));\n  return recursiveAddVar(varName, varVariant, hasVarTag);\n}", "target": 0}
{"code": "imapx_uidset_done (struct _uidset_state *ss,\n                   CamelIMAPXCommand *ic)\n{\n\tgint ret = FALSE;\n\tif (ss->last != 0) {\n\t\tif (ss->entries > 0)\n\t\t\tcamel_imapx_command_add (ic, \",\");\n\t\tif (ss->last == ss->start)\n\t\t\tcamel_imapx_command_add (ic, \"%d\", ss->last);\n\t\telse\n\t\t\tcamel_imapx_command_add (ic, \"%d:%d\", ss->start, ss->last);\n\t}\n\tret = ss->last != 0;\n\tss->start = 0;\n\tss->last = 0;\n\tss->uids = 0;\n\tss->entries = 0;\n\treturn ret;\n}", "target": 0}
{"code": "size_t util_path_encode(char *s, size_t len)\n{\n\tchar t[(len * 3)+1];\n\tsize_t i, j;\n\tfor (i = 0, j = 0; s[i] != '\\0'; i++) {\n\t\tif (s[i] == '/') {\n\t\t\tmemcpy(&t[j], \"\\\\x2f\", 4);\n\t\t\tj += 4;\n\t\t} else if (s[i] == '\\\\') {\n\t\t\tmemcpy(&t[j], \"\\\\x5c\", 4);\n\t\t\tj += 4;\n\t\t} else {\n\t\t\tt[j] = s[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tif (len == 0)\n\t\treturn j;\n\ti = (j < len - 1) ? j : len - 1;\n\tmemcpy(s, t, i);\n\ts[i] = '\\0';\n\treturn j;\n}", "target": 1}
{"code": "Status FunctionCallFrame::ConsumeRetvals(std::vector<Tensor>* rets,\n                                         bool allow_dead_tensors) {\n  rets->clear();\n  rets->reserve(rets_.size());\n  for (size_t i = 0; i < rets_.size(); ++i) {\n    if (rets_[i].has_val) {\n      rets->emplace_back(std::move(rets_[i].val));\n    } else if (allow_dead_tensors) {\n      rets->emplace_back();\n    } else {\n      return errors::Internal(\"Retval[\", i, \"] does not have value\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}", "target": 1}
{"code": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\treturn -1;\n\t    } else {\n\t\treturn 0;\n\t    }\n\t}\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                \n\t    }\n\t    s = os;\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              \n\t\tused += strlen(os);\n\t\tp = s;                  \n\t    } else {\n\t\tused += strlen(os);\n\t\tbreak;                  \n\t    }\n\t} else {\n\t}\n    }\n    return used;\n}", "target": 0}
{"code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}", "target": 1}
{"code": "void LibRaw::layer_thumb(){}", "target": 0}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static boolean str_fill_input_buffer(j_decompress_ptr cinfo)\n{\n    int c;\n    struct str_src_mgr *src = (struct str_src_mgr *)cinfo->src;\n    if (src->index == 0) {\n        c = 0xFF;\n        src->index++;\n    } else if (src->index == 1) {\n        c = 0xD8;\n        src->index++;\n    } else\n        c = src->str->getChar();\n    if (c != EOF) {\n        src->buffer = c;\n        src->pub.next_input_byte = &src->buffer;\n        src->pub.bytes_in_buffer = 1;\n        return TRUE;\n    } else\n        return FALSE;\n}", "target": 0}
{"code": "void SetTransferMatrix(double x11,double x12,double x21,double x22,double x,double y)\n{\n    if ( ( fabs(x11-1.) > 0.001 ) || ( fabs(x22-1.) > 0.001 )\n         || ( fabs(x12) > 0.001 ) || ( fabs(x21) > 0.001 )\n         || ( fabs(x) > 0.001 ) || ( fabs(y) > 0.001 ) ) {\n        outpos +=\n        sprintf(outpos,\"%12.3f %12.3f %12.3f %12.3f %12.3f %12.3f cm\\n\",x11,x12,x21,x22,x,y);\n    }\n}", "target": 1}
{"code": "static char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "  void* GetData() { return embedder_data_; }", "target": 0}
{"code": "purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_purgekeys\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n \t\tskb_queue_walk(queue, skb) {\n \t\t\t*peeked = skb->peeked;\n \t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n \t\t\t\t\t*off -= skb->len;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}", "target": 1}
{"code": "setup_new_fields(THD *thd, List<Item> &fields,\n\t\t List<Item> &all_fields, ORDER *new_field)\n{\n  Item\t  **item;\n  uint counter;\n  enum_resolution_type not_used;\n  DBUG_ENTER(\"setup_new_fields\");\n  thd->mark_used_columns= MARK_COLUMNS_READ;       \n  for (; new_field ; new_field= new_field->next)\n  {\n    if ((item= find_item_in_list(*new_field->item, fields, &counter,\n\t\t\t\t IGNORE_ERRORS, &not_used)))\n      new_field->item=item;\t\t\t\n    else\n    {\n      thd->where=\"procedure list\";\n      if ((*new_field->item)->fix_fields(thd, new_field->item))\n\tDBUG_RETURN(1); \n      all_fields.push_front(*new_field->item, thd->mem_root);\n      new_field->item=all_fields.head_ref();\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "void kvm_arch_free_memslot(struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\tsk->sk_write_space(sk);\n}", "target": 0}
{"code": "static u32 bnx2x_reg_rd_ind(struct bnx2x *bp, u32 addr)\n{\n\tu32 val;\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);\n\tpci_read_config_dword(bp->pdev, PCICFG_GRC_DATA, &val);\n\tpci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,\n\t\t\t       PCICFG_VENDOR_ID_OFFSET);\n\treturn val;\n}", "target": 0}
{"code": "int CSoundFile::FrequencyToTranspose(DWORD freq)\n{\n\treturn int(1536*(log(freq/8363.0)/log(2.0)));\n#ifdef MSC_VER\n\tconst float _f1_8363 = 1.0f / 8363.0f;\n\tconst float _factor = 128 * 12;\n\tLONG result;\n\tif (!freq) return 0;\n\t_asm {\n\tfld _factor\n\tfild freq\n\tfld _f1_8363\n\tfmulp st(1), st(0)\n\tfyl2x\n\tfistp result\n\t}\n\treturn result;\n#endif\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "static GList *player_list_metadata(struct avrcp_player *player)\n{\n\tGList *l, *attrs = NULL;\n\tif (player == NULL)\n\t\treturn g_list_prepend(NULL,\n\t\t\t\tGUINT_TO_POINTER(AVRCP_MEDIA_ATTRIBUTE_TITLE));\n\tl = player->cb->list_metadata(player->user_data);\n\tfor (; l; l = l->next) {\n\t\tconst char *key = l->data;\n\t\tattrs = g_list_append(attrs,\n\t\t\t\t\tGUINT_TO_POINTER(str_to_metadata(key)));\n\t}\n\treturn attrs;\n}", "target": 0}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "static RBinWasmElementEntry *parse_element_entry(RBinWasmObj *bin, ut64 bound, ut32 index) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmElementEntry *elem = R_NEW0 (RBinWasmElementEntry);\n\tif (elem) {\n\t\telem->sec_i = index;\n\t\telem->file_offset = r_buf_tell (b);\n\t\tif (!consume_u32_r (b, bound, &elem->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_init_expr_r (b, bound, R_BIN_WASM_END_OF_CODE, NULL)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_u32_r (b, bound, &elem->num_elem)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (r_buf_tell (b) <= bound && j < elem->num_elem) {\n\t\t\tif (!consume_u32_r (b, bound, NULL)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\treturn elem;\nbeach:\n\tfree (elem);\n\treturn NULL;\n}", "target": 0}
{"code": "DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,\n\tconst unsigned char *srcBuf, int width, int pitch, int height,\n\tint pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)\n{\n\tunsigned char *dstPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\tif(width<=0 || height<=0 || dstBuf==NULL || pad<0 || !isPow2(pad)\n\t\t|| subsamp<0 || subsamp>=NUMSUBOPT)\n\t\t_throw(\"tjEncodeYUV3(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tdstPlanes[0]=dstBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tdstPlanes[1]=dstPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tdstPlanes[1]=dstPlanes[0]+strides[0]*ph0;\n\t\tdstPlanes[2]=dstPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,\n\t\tdstPlanes, strides, subsamp, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}", "target": 1}
{"code": "static bool rbuf_switch_to_malloc(conn *c) {\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "exif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\t} else\n\t\tdoff = offset + 8;\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}", "target": 1}
{"code": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n    mcf_fec_bd bd;\n    int frame_size;\n    int len;\n    uint8_t frame[FEC_MAX_FRAME_SIZE];\n    uint8_t *ptr;\n    DPRINTF(\"do_tx\\n\");\n    ptr = frame;\n    frame_size = 0;\n    addr = s->tx_descriptor;\n    while (1) {\n        mcf_fec_read_bd(&bd, addr);\n        DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                addr, bd.flags, bd.length, bd.data);\n        if ((bd.flags & FEC_BD_R) == 0) {\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        mcf_fec_write_bd(&bd, addr);\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n    s->tx_descriptor = addr;\n}", "target": 1}
{"code": "mptctl_fw_download(unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\treturn mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n    ogs_msleep(300);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static void nvme_aio_err(NvmeRequest *req, int ret)\n{\n    uint16_t status = NVME_SUCCESS;\n    Error *local_err = NULL;\n    switch (req->cmd.opcode) {\n    case NVME_CMD_READ:\n        status = NVME_UNRECOVERED_READ;\n        break;\n    case NVME_CMD_FLUSH:\n    case NVME_CMD_WRITE:\n    case NVME_CMD_WRITE_ZEROES:\n    case NVME_CMD_ZONE_APPEND:\n        status = NVME_WRITE_FAULT;\n        break;\n    default:\n        status = NVME_INTERNAL_DEV_ERROR;\n        break;\n    }\n    trace_pci_nvme_err_aio(nvme_cid(req), strerror(-ret), status);\n    error_setg_errno(&local_err, -ret, \"aio failed\");\n    error_report_err(local_err);\n    if (req->status && status != NVME_INTERNAL_DEV_ERROR) {\n        return;\n    }\n    req->status = status;\n}", "target": 0}
{"code": "START_TEST(test_tm_adopt_ispidowner)\n  {\n  fail_unless(TRUE == ispidowner(getpid()));\n  fail_unless(FALSE == ispidowner(1));\n  }", "target": 1}
{"code": "do_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n    ELAPSED_INIT(start_tv);\n# endif\n    if (hide_cursor)\n        cursor_sleep();\n    else\n        cursor_on();\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n# ifdef ELAPSED_FUNC\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\tdone += wait_now;\n# endif\n    }\n    if (got_int)\n\t(void)vpeekc();\n    if (hide_cursor)\n        cursor_unsleep();\n}", "target": 0}
{"code": "get_signed_descriptor_by_fp(const char *fp, int extrainfo,\n                            time_t publish_cutoff)\n{\n  if (router_digest_is_me(fp)) {\n    if (extrainfo)\n      return &(router_get_my_extrainfo()->cache_info);\n    else\n      return &(router_get_my_routerinfo()->cache_info);\n  } else {\n    const routerinfo_t *ri = router_get_by_id_digest(fp);\n    if (ri &&\n        ri->cache_info.published_on > publish_cutoff) {\n      if (extrainfo)\n        return extrainfo_get_by_descriptor_digest(\n                                     ri->cache_info.extra_info_digest);\n      else\n        return &ri->cache_info;\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n  char *name;\n  uint32_t i;\n  if (!len) return NULL;\n  if (len>400) len=400;\n  name = cli_malloc(len);\n  if (!name) {\n    cli_dbgmsg(\"SIS: OOM\\n\");\n    return NULL;\n  }\n  fseek(f, ptr, SEEK_SET);\n  if (fread(name, len, 1, f)!=1) {\n    cli_dbgmsg(\"SIS: Unable to read string\\n\");\n    free(name);\n    return NULL;\n  }\n  for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n  name[i/2]='\\0';\n  return name;\n}", "target": 1}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "ff_layout_choose_best_ds_for_read(struct pnfs_layout_segment *lseg,\n\t\t\t\t  u32 start_idx, u32 *best_idx)\n{\n\tstruct nfs4_pnfs_ds *ds;\n\tds = ff_layout_choose_valid_ds_for_read(lseg, start_idx, best_idx);\n\tif (ds)\n\t\treturn ds;\n\treturn ff_layout_choose_any_ds_for_read(lseg, start_idx, best_idx);\n}", "target": 0}
{"code": "node_str_cat_codepoint(Node* node, OnigEncoding enc, OnigCodePoint c)\n{\n  UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];\n  int num = ONIGENC_CODE_TO_MBC(enc, c, buf);\n  if (num < 0) return num;\n  return onig_node_str_cat(node, buf, buf + num);\n}", "target": 0}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "SPL_METHOD(SplFileObject, fread)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong length = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n\t\treturn;\n\t}\n\tif (length <= 0) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n \t\tRETURN_FALSE;\n \t}\n \tZ_STRVAL_P(return_value) = emalloc(length + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 1}
{"code": "void _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "Http::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "TEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    \n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  \n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    \n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}", "target": 0}
{"code": "static int php_snmp_read_max_oids(php_snmp_object *snmp_object, zval *retval)\n{\n\tif (snmp_object->max_oids > 0) {\n\t\tZVAL_LONG(retval, snmp_object->max_oids);\n\t} else {\n\t\tZVAL_NULL(retval);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "bool GLSurface::InitializeOneOffInternal() {\n  switch (GetGLImplementation()) {\n    case kGLImplementationEGLGLES2:\n      if (!GLSurfaceEGL::InitializeOneOff()) {\n        LOG(ERROR) << \"GLSurfaceEGL::InitializeOneOff failed.\";\n        return false;\n      }\n      return true;\n    case kGLImplementationOSMesaGL:\n    case kGLImplementationMockGL:\n      return true;\n    default:\n      return false;\n  }\n}", "target": 0}
{"code": "SWFShape_drawScaledLine(SWFShape shape, int dx, int dy)\n{\n\tShapeRecord record;\n\tif ( shape->isEnded )\n\t\treturn;\n\tif ( dx == 0 && dy == 0 )\n\t\treturn;\n\trecord = newShapeRecord(shape, SHAPERECORD_LINETO);\n\tSWF_assert(SWFOutput_numSBits(dx) < 18);\n\tSWF_assert(SWFOutput_numSBits(dy) < 18);\n\trecord.record.lineTo->dx = dx;\n\trecord.record.lineTo->dy = dy;\n\tshape->xpos += dx;\n\tshape->ypos += dy;\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "target": 1}
{"code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 1}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 0}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)\n{\n    hdr_ptr x;\n    char *status_line = NULL;\n    request_rec *rr;\n    if (r->proto_num < HTTP_VERSION(1,1)) {\n        return;\n    }\n    if (!ap_is_HTTP_INFO(r->status)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00575)\n                      \"Status is %d - not sending interim response\", r->status);\n        return;\n    }\n    if ((r->status == HTTP_CONTINUE) && !r->expecting_100) {\n        return;\n    }\n    for (rr = r; rr != NULL; rr = rr->main) {\n        rr->expecting_100 = 0;\n    }\n    status_line = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, \" \", r->status_line, CRLF, NULL);\n    ap_xlate_proto_to_ascii(status_line, strlen(status_line));\n    x.f = r->connection->output_filters;\n    x.bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    ap_fputs(x.f, x.bb, status_line);\n    if (send_headers) {\n        apr_table_do(send_header, &x, r->headers_out, NULL);\n        apr_table_clear(r->headers_out);\n    }\n    ap_fputs(x.f, x.bb, CRLF_ASCII);\n    ap_fflush(x.f, x.bb);\n    apr_brigade_destroy(x.bb);\n}", "target": 0}
{"code": "static int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tcrash_enable_local_vmclear(cpu);\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\tif ((old & test_bits) != test_bits) {\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); \n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\treturn 0;\n}", "target": 0}
{"code": "static bool ok_jpg_read_dqt(ok_jpg_decoder *decoder) {\n    ok_jpg *jpg = decoder->jpg;\n    uint8_t buffer[2];\n    if (!ok_read(decoder, buffer, sizeof(buffer))) {\n        return false;\n    }\n    int length = readBE16(buffer) - 2;\n    while (length >= 65) {\n        uint8_t pt = ok_read_uint8(decoder);\n        int Pq = pt >> 4;\n        int Tq = pt & 0x0f;\n        if (Pq == 1) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, \"Unsupported JPEG (16-bit q_table)\");\n            return false;\n        }\n        if (Pq != 0 || Tq > 3) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid JPEG (Pq/Tq)\");\n            return false;\n        }\n        if (!ok_read(decoder, decoder->q_table[Tq], 64)) {\n            return false;\n        }\n        length -= 65;\n    }\n    if (length != 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid DQT segment length\");\n        return false;\n    } else {\n        return true;\n    }\n}", "target": 0}
{"code": "static int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; \n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tbool writing_zero = false;\n\tbool zero_used = false;\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif (value_reg && register_is_null(value_reg))\n\t\twriting_zero = true;\n\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n\tif (err)\n\t\treturn err;\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (!env->allow_ptr_leaks\n\t\t\t\t&& *stype != NOT_INIT\n\t\t\t\t&& *stype != SCALAR_VALUE) {\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\tm->msg_iov = iov;\n\terr = 0;\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "    uint32_t TiffImageEntry::doSizeImage() const\n    {\n        if (!pValue()) return 0;\n        uint32_t len = pValue()->sizeDataArea();\n        if (len == 0) {\n            for (Strips::const_iterator i = strips_.begin(); i != strips_.end(); ++i) {\n                len += i->second;\n            }\n        }\n        return len;\n    } ", "target": 0}
{"code": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    start = ftell(fp);\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "rdpsnd_flush_record(void)\n{\n\tSTREAM s;\n\tunsigned int chunk_size;\n\tchar *data;\n\tif (record_buffer_size == 0)\n\t\treturn;\n\tassert(record_buffer_size <= sizeof(record_buffer));\n\tdata = record_buffer;\n\twhile (record_buffer_size)\n\t{\n\t\tif (record_buffer_size < 1596)\n\t\t\tchunk_size = record_buffer_size;\n\t\telse\n\t\t\tchunk_size = 1596;\n\t\ts = rdpsnd_init_packet(RDPSND_REC_DATA, chunk_size);\n\t\tout_uint8p(s, data, chunk_size);\n\t\ts_mark_end(s);\n\t\trdpsnd_send(s);\n\t\tdata = data + chunk_size;\n\t\trecord_buffer_size -= chunk_size;\n\t\tDEBUG_SOUND((\"RDPSND: -> RDPSND_REC_DATA(length: %u)\\n\", (unsigned) chunk_size));\n\t}\n\trecord_buffer_size = 0;\n}", "target": 0}
{"code": "static void fio_signal_handler_setup(void) {\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n  memset(&act, 0, sizeof(act));\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}", "target": 1}
{"code": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "bool ChildThread::OnMessageReceived(const IPC::Message& msg) {\n  if (mojo_application_->OnMessageReceived(msg))\n    return true;\n  if (resource_dispatcher_->OnMessageReceived(msg))\n    return true;\n  if (socket_stream_dispatcher_->OnMessageReceived(msg))\n    return true;\n  if (websocket_dispatcher_->OnMessageReceived(msg))\n    return true;\n  if (file_system_dispatcher_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(ChildThread, msg)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_Shutdown, OnShutdown)\n#if defined(IPC_MESSAGE_LOG_ENABLED)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_SetIPCLoggingEnabled,\n                        OnSetIPCLoggingEnabled)\n#endif\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_SetProfilerStatus,\n                        OnSetProfilerStatus)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_GetChildProfilerData,\n                        OnGetChildProfilerData)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_DumpHandles, OnDumpHandles)\n#if defined(USE_TCMALLOC)\n    IPC_MESSAGE_HANDLER(ChildProcessMsg_GetTcmallocStats, OnGetTcmallocStats)\n#endif\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  if (handled)\n    return true;\n  if (msg.routing_id() == MSG_ROUTING_CONTROL)\n    return OnControlMessageReceived(msg);\n  return router_.OnMessageReceived(msg);\n}", "target": 0}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "wb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}", "target": 1}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\terror = xfs_attr_set(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}", "target": 0}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "int gnutls_x509_ext_export_subject_key_id(const gnutls_datum_t * id,\n\t\t\t\t       gnutls_datum_t * ext)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint ret, result;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t\"PKIX1.SubjectKeyIdentifier\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_write_value(c2, \"\", id->data, id->size);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\tif (list_empty(mounts))\n\t\treturn;\n\tnamespace_lock();\n\tlock_mount_hash();\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, 1);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}", "target": 0}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": " status_t CameraClient::dump(int fd, const Vector<String16>& args) {\n     const size_t SIZE = 256;\n     char buffer[SIZE];\n size_t len = snprintf(buffer, SIZE, \"Client[%d] (%p) PID: %d\\n\",\n            mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    len = (len > SIZE - 1) ? SIZE - 1 : len;\n    write(fd, buffer, len);\n return mHardware->dump(fd, args);\n}", "target": 1}
{"code": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    return;\n  }\n  const absl::string_view header_value = absl::string_view(data, length);\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}", "target": 1}
{"code": "static ssize_t itlb_multihit_show_state(char *buf)\n{\n\tif (itlb_multihit_kvm_mitigation)\n\t\treturn sprintf(buf, \"KVM: Mitigation: Split huge pages\\n\");\n\telse\n\t\treturn sprintf(buf, \"KVM: Vulnerable\\n\");\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();\n     if (view_)\n       view_->DidNavigate();\n    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();\n    if (old_surface_id == new_surface_id)\n      return;\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n  if (!new_content_rendering_timeout_)\n    return;\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}", "target": 1}
{"code": "static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "static struct rt6_info *rt6_multipath_select(struct rt6_info *match,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct rt6_info *sibling, *next_sibling;\n\tint route_choosen;\n\troute_choosen = rt6_info_hash_nhsfn(match->rt6i_nsiblings + 1, fl6);\n\tif (route_choosen)\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t&match->rt6i_siblings, rt6i_siblings) {\n\t\t\troute_choosen--;\n\t\t\tif (route_choosen == 0) {\n\t\t\t\tmatch = sibling;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\treturn match;\n}", "target": 0}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": " tbGetBuffer(unsigned size)\n {\n    char *rtrn;\n    if (size >= BUFFER_SIZE)\n        return NULL;\n    if ((BUFFER_SIZE - tbNext) <= size)\n        tbNext = 0;\n    rtrn = &textBuffer[tbNext];\n    tbNext += size;\n    return rtrn;\n }", "target": 1}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "AcpiNsGetNodeUnlocked (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_GENERIC_STATE      ScopeInfo;\n    ACPI_STATUS             Status;\n    char                    *InternalPath;\n    ACPI_FUNCTION_TRACE_PTR (NsGetNodeUnlocked, ACPI_CAST_PTR (char, Pathname));\n    if (!Pathname)\n    {\n        *ReturnNode = PrefixNode;\n        if (!PrefixNode)\n        {\n            *ReturnNode = AcpiGbl_RootNode;\n        }\n        return_ACPI_STATUS (AE_OK);\n    }\n    if (ACPI_IS_ROOT_PREFIX (Pathname[0]) && (!Pathname[1]))\n    {\n        *ReturnNode = AcpiGbl_RootNode;\n        return_ACPI_STATUS (AE_OK);\n    }\n    Status = AcpiNsInternalizeName (Pathname, &InternalPath);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n    ScopeInfo.Scope.Node = PrefixNode;\n    Status = AcpiNsLookup (&ScopeInfo, InternalPath, ACPI_TYPE_ANY,\n        ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),\n        NULL, ReturnNode);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"%s, %s\\n\",\n            Pathname, AcpiFormatException (Status)));\n    }\n    ACPI_FREE (InternalPath);\n    return_ACPI_STATUS (Status);\n}", "target": 0}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n{\n\tgsize decimal_point_len;\n\tgint8 num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_end = &num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_ptr;\n\tsize_t num_len;\n\tws_assert(precision != 0);\n\tif (buflen == 0) {\n\t\treturn;\n\t}\n\tdecimal_point_len = g_strlcpy(buf, decimal_point, buflen);\n\tif (decimal_point_len >= buflen) {\n\t\treturn;\n\t}\n\tbuf += decimal_point_len;\n\tbuflen -= decimal_point_len;\n\tswitch (precision) {\n\tcase 1:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000000, precision);\n\t\tbreak;\n\tcase 2:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000000, precision);\n\t\tbreak;\n\tcase 3:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000000, precision);\n\t\tbreak;\n\tcase 4:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000, precision);\n\t\tbreak;\n\tcase 5:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000, precision);\n\t\tbreak;\n\tcase 6:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000, precision);\n\t\tbreak;\n\tcase 7:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100, precision);\n\t\tbreak;\n\tcase 8:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10, precision);\n\t\tbreak;\n\tcase 9:\n\t\tnum_ptr = uint_to_str_back_len(num_end, nsecs,\n\t\t    precision);\n\t\tbreak;\n\tdefault:\n\t\tws_assert_not_reached();\n\t\tbreak;\n\t}\n\tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);\n\tif (num_len == 0) {\n\t\treturn;\n\t}\n\tmemcpy(buf, num_ptr, num_len);\n\t*(buf + num_len) = '\\0';\n}", "target": 1}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  IndexPacket\n    *indexes;\n  PixelPacket\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "static int decode_fill(AACContext *ac, GetBitContext *gb, int len) {\n    uint8_t buf[256];\n    int i, major, minor;\n    if (len < 13+7*8)\n        goto unknown;\n    get_bits(gb, 13); len -= 13;\n    for(i=0; i+1<sizeof(buf) && len>=8; i++, len-=8)\n        buf[i] = get_bits(gb, 8);\n    buf[i] = 0;\n    if (ac->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(ac->avctx, AV_LOG_DEBUG, \"FILL:%s\\n\", buf);\n    if (sscanf(buf, \"libfaac %d.%d\", &major, &minor) == 2){\n        ac->avctx->internal->skip_samples = 1024;\n    }\nunknown:\n    skip_bits_long(gb, len);\n    return 0;\n}", "target": 0}
{"code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}", "target": 1}
{"code": "struct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)\n{\n\tkvm_pfn_t pfn;\n\tpfn = gfn_to_pfn(kvm, gfn);\n\treturn kvm_pfn_to_page(pfn);\n}", "target": 0}
{"code": "static int zpff_init(struct hid_device *hid)\n{\n\tstruct zpff_device *zpff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint i, error;\n\tfor (i = 0; i < 4; i++) {\n\t\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);\n\t\tif (!report)\n\t\t\treturn -ENODEV;\n\t}\n\tzpff = kzalloc(sizeof(struct zpff_device), GFP_KERNEL);\n\tif (!zpff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, zpff, zpff_play);\n\tif (error) {\n\t\tkfree(zpff);\n\t\treturn error;\n\t}\n\tzpff->report = report;\n\tzpff->report->field[0]->value[0] = 0x00;\n\tzpff->report->field[1]->value[0] = 0x02;\n\tzpff->report->field[2]->value[0] = 0x00;\n\tzpff->report->field[3]->value[0] = 0x00;\n\thid_hw_request(hid, zpff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"force feedback for Zeroplus based devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "  void from_sync_policy_group(rgw::sal::RGWRadosStore *store,\n                              const rgw_sync_policy_group& group) {\n    bool enabled = (group.status == rgw_sync_policy_group::Status::ENABLED);\n    for (auto& pipe : group.pipes) {\n      auto& rule = rules.emplace_back();\n      rule.from_sync_policy_pipe(store, pipe, enabled);\n    }\n  }", "target": 0}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "rend_service_intro_established(origin_circuit_t *circuit,\n                               const uint8_t *request,\n                               size_t request_len)\n{\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  (void) request;\n  (void) request_len;\n  tor_assert(circuit->rend_data);\n  const char *rend_pk_digest =\n    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);\n  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {\n    log_warn(LD_PROTOCOL,\n             \"received INTRO_ESTABLISHED cell on non-intro circuit.\");\n    goto err;\n  }\n  service = rend_service_get_by_pk_digest(rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, \"Unknown service on introduction circuit %u.\",\n              (unsigned)circuit->base_.n_circ_id);\n     goto err;\n   }\n   intro = find_intro_point(circuit);\n  if (intro == NULL) {\n    log_warn(LD_REND,\n             \"Introduction circuit established without a rend_intro_point_t \"\n             \"object for service %s on circuit %u\",\n             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  intro->circuit_established = 1;\n   service->desc_is_dirty = time(NULL);\n   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n                rend_pk_digest, REND_SERVICE_ID_LEN);\n   log_info(LD_REND,\n            \"Received INTRO_ESTABLISHED cell on circuit %u for service %s\",\n            (unsigned)circuit->base_.n_circ_id, serviceid);\n  pathbias_mark_use_success(circuit);\n  return 0;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);\n  return -1;\n}", "target": 1}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n   schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static int fts3EvalPhraseStart(Fts3Cursor *pCsr, int bOptOk, Fts3Phrase *p){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc = SQLITE_OK;             \n  int i;\n  int bHaveIncr = 0;\n  int bIncrOk = (bOptOk \n   && pCsr->bDesc==pTab->bDescIdx \n   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0\n   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0\n#ifdef SQLITE_TEST\n   && pTab->bNoIncrDoclist==0\n#endif\n  );\n  for(i=0; bIncrOk==1 && i<p->nToken; i++){\n    Fts3PhraseToken *pToken = &p->aToken[i];\n    if( pToken->bFirst || (pToken->pSegcsr!=0 && !pToken->pSegcsr->bLookup) ){\n      bIncrOk = 0;\n    }\n    if( pToken->pSegcsr ) bHaveIncr = 1;\n  }\n  if( bIncrOk && bHaveIncr ){\n    int iCol = (p->iColumn >= pTab->nColumn ? -1 : p->iColumn);\n    for(i=0; rc==SQLITE_OK && i<p->nToken; i++){\n      Fts3PhraseToken *pToken = &p->aToken[i];\n      Fts3MultiSegReader *pSegcsr = pToken->pSegcsr;\n      if( pSegcsr ){\n        rc = sqlite3Fts3MsrIncrStart(pTab, pSegcsr, iCol, pToken->z, pToken->n);\n      }\n    }\n    p->bIncr = 1;\n  }else{\n    rc = fts3EvalPhraseLoad(pCsr, p);\n    p->bIncr = 0;\n  }\n  assert( rc!=SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr==0 || p->bIncr );\n  return rc;\n}", "target": 0}
{"code": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "ospf_fifo_pop (struct ospf_fifo *fifo)\n{\n  struct ospf_packet *op;\n  op = fifo->head;\n  if (op)\n    {\n      fifo->head = op->next;\n      if (fifo->head == NULL)\n\tfifo->tail = NULL;\n      fifo->count--;\n    }\n  return op;\n}", "target": 0}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "static int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tapr_time_t session_expires = oidc_session_get_session_expires(r, session);\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_handle_unauthenticated_user(r, cfg);\n\t}\n\toidc_log_session_expires(r, \"session max lifetime\", session_expires);\n\treturn OK;\n}", "target": 0}
{"code": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}", "target": 1}
{"code": "static void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           \n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); \n\tf = (uint32_t) (ff * 1000000000.0);  \n\tND_PRINT(\"%u.%09d\", i, f);\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}", "target": 1}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": " long ssl_get_algorithm2(SSL *s)\n        {\n        long alg2 = s->s3->tmp.new_cipher->algorithm2;\n       if (TLS1_get_version(s) >= TLS1_2_VERSION &&\n            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n        return alg2;\n\t}", "target": 1}
{"code": "static bool check_allocations(ASS_Shaper *shaper, size_t new_size)\n{\n    if (new_size > shaper->n_glyphs) {\n        if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||\n            !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||\n             !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||\n             !ASS_REALLOC_ARRAY(shaper->cmap, new_size))\n             return false;\n     }\n     return true;\n }", "target": 1}
{"code": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}", "target": 1}
{"code": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n  order_group_num*= 2;\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n  return array == NULL;\n}", "target": 1}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n uint32_t cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n     if (mStatus != NO_ERROR) {\n         return mStatus;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}", "target": 1}
{"code": "static void mkiss_put(struct mkiss *ax)\n{\n\tif (refcount_dec_and_test(&ax->refcnt))\n\t\tcomplete(&ax->dead);\n}", "target": 0}
{"code": "static int __init nf_tables_module_init(void)\n{\n\tint err;\n\tinfo = kmalloc(sizeof(struct nft_expr_info) * NFT_RULE_MAXEXPRS,\n\t\t       GFP_KERNEL);\n\tif (info == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err2;\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err3;\n\tpr_info(\"nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\\n\");\n\treturn register_pernet_subsys(&nf_tables_net_ops);\nerr3:\n\tnf_tables_core_module_exit();\nerr2:\n\tkfree(info);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "\tvirtual void describe()\n\t{\n\t\tgetDefaultPCMMapping(m_outChunk->f.sampleWidth,\n\t\t\tm_outChunk->f.pcm.slope,\n\t\t\tm_outChunk->f.pcm.intercept,\n\t\t\tm_outChunk->f.pcm.minClip,\n\t\t\tm_outChunk->f.pcm.maxClip);\n\t}", "target": 0}
{"code": "mm_request_send(int socket, enum monitor_reqtype type, Buffer *m)\n{\n\tu_int mlen = buffer_len(m);\n\tu_char buf[5];\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\tPUT_32BIT(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t\n\tif (atomicio(write, socket, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write\", __func__);\n\tif (atomicio(write, socket, buffer_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write\", __func__);\n}", "target": 0}
{"code": "  bool const_item() const { return used_tables() == 0; }", "target": 1}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "static xmlParserCtxtPtr createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const char* chunk)\n{\n    if (!didInit) {\n        xmlInitParser();\n        xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);\n        xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);\n        libxmlLoaderThread = currentThread();\n        didInit = true;\n    }\n    xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk, xmlStrlen((const xmlChar*)chunk));\n    if (!parser)\n        return 0;\n    memcpy(parser->sax, handlers, sizeof(xmlSAXHandler));\n    xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT);\n    parser->sax2 = 1;\n    parser->instate = XML_PARSER_CONTENT; \n    parser->depth = 0;\n    parser->str_xml = xmlDictLookup(parser->dict, BAD_CAST \"xml\", 3);\n    parser->str_xmlns = xmlDictLookup(parser->dict, BAD_CAST \"xmlns\", 5);\n    parser->str_xml_ns = xmlDictLookup(parser->dict, XML_XML_NAMESPACE, 36);\n    parser->_private = userData;\n    return parser;\n}", "target": 0}
{"code": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}", "target": 1}
{"code": "void ZeroSuggestProvider::Run(const GURL& suggest_url) {\n  if (OmniboxFieldTrial::InZeroSuggestMostVisitedFieldTrial()) {\n    most_visited_urls_.clear();\n    scoped_refptr<history::TopSites> ts = client()->GetTopSites();\n    if (ts) {\n      waiting_for_most_visited_urls_request_ = true;\n      ts->GetMostVisitedURLs(\n          base::Bind(&ZeroSuggestProvider::OnMostVisitedUrlsAvailable,\n                     weak_ptr_factory_.GetWeakPtr()), false);\n    }\n  } else {\n    net::NetworkTrafficAnnotationTag traffic_annotation =\n        net::DefineNetworkTrafficAnnotation(\"omnibox_zerosuggest\", R\"(\n        semantics {\n          sender: \"Omnibox\"\n          description:\n            \"When the user focuses the omnibox, Chrome can provide search or \"\n            \"navigation suggestions from the default search provider in the \"\n            \"omnibox dropdown, based on the current page URL.\\n\"\n            \"This is limited to users whose default search engine is Google, \"\n            \"as no other search engines currently support this kind of \"\n            \"suggestion.\"\n          trigger: \"The omnibox receives focus.\"\n          data: \"The URL of the current page.\"\n          destination: GOOGLE_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: true\n          cookies_store: \"user\"\n          setting:\n            \"Users can control this feature via the 'Use a prediction service \"\n            \"to help complete searches and URLs typed in the address bar' \"\n            \"settings under 'Privacy'. The feature is enabled by default.\"\n          chrome_policy {\n            SearchSuggestEnabled {\n                policy_options {mode: MANDATORY}\n                SearchSuggestEnabled: false\n            }\n          }\n        })\");\n    const int kFetcherID = 1;\n    fetcher_ =\n        net::URLFetcher::Create(kFetcherID, suggest_url, net::URLFetcher::GET,\n                                this, traffic_annotation);\n    data_use_measurement::DataUseUserData::AttachToFetcher(\n        fetcher_.get(), data_use_measurement::DataUseUserData::OMNIBOX);\n    fetcher_->SetRequestContext(client()->GetRequestContext());\n    fetcher_->SetLoadFlags(net::LOAD_DO_NOT_SAVE_COOKIES);\n    net::HttpRequestHeaders headers;\n    bool is_signed_in = false;\n    variations::AppendVariationHeaders(fetcher_->GetOriginalURL(),\n                                       client()->IsOffTheRecord(), false,\n                                       is_signed_in, &headers);\n    fetcher_->SetExtraRequestHeaders(headers.ToString());\n    fetcher_->Start();\n    LogOmniboxZeroSuggestRequest(ZERO_SUGGEST_REQUEST_SENT);\n  }\n}", "target": 0}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "get_indent_buf(buf_T *buf, linenr_T lnum)\n{\n# ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get_buf(buf, lnum, FALSE),\n\t\t\t       (int)curbuf->b_p_ts, buf->b_p_vts_array, FALSE);\n# else\n    return get_indent_str(ml_get_buf(buf, lnum, FALSE), (int)buf->b_p_ts, FALSE);\n# endif\n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if (code == 0xB5)\n      ;\n    else if ((EncCP1252_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n\tcode = ENC_CP1252_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1252_CtypeTable[code]&BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code >= 0xB0 && code <= 0xBF)\n\tcode -= 0x10;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "int HeaderMapWrapper::luaGet(lua_State* state) {\n  const char* key = luaL_checkstring(state, 2);\n  const auto value =\n      Http::HeaderUtility::getAllOfHeaderAsString(headers_, Http::LowerCaseString(key));\n  if (value.result().has_value()) {\n    lua_pushlstring(state, value.result().value().data(), value.result().value().length());\n    return 1;\n  } else {\n    return 0;\n  }\n}", "target": 0}
{"code": "g_markup_parse_context_new (const GMarkupParser *parser,\n                            GMarkupParseFlags    flags,\n                            gpointer             user_data,\n                            GDestroyNotify       user_data_dnotify)\n{\n  GMarkupParseContext *context;\n  g_return_val_if_fail (parser != NULL, NULL);\n  context = g_new (GMarkupParseContext, 1);\n  context->ref_count = 1;\n  context->parser = parser;\n  context->flags = flags;\n  context->user_data = user_data;\n  context->dnotify = user_data_dnotify;\n  context->line_number = 1;\n  context->char_number = 1;\n  context->partial_chunk = NULL;\n  context->spare_chunks = NULL;\n  context->spare_list_nodes = NULL;\n  context->state = STATE_START;\n  context->tag_stack = NULL;\n  context->tag_stack_gstr = NULL;\n  context->attr_names = NULL;\n  context->attr_values = NULL;\n  context->cur_attr = -1;\n  context->alloc_attrs = 0;\n  context->current_text = NULL;\n  context->current_text_len = -1;\n  context->current_text_end = NULL;\n  context->start = NULL;\n  context->iter = NULL;\n  context->document_empty = TRUE;\n  context->parsing = FALSE;\n  context->awaiting_pop = FALSE;\n  context->subparser_stack = NULL;\n  context->subparser_element = NULL;\n  context->held_user_data = NULL;\n  context->balance = 0;\n  return context;\n}", "target": 0}
{"code": "static void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i, j;\n    for (i = 0; i < count; i++)\n        for (j = 0; j < data[i].key_data_ver; j++)\n            if (data[i].key_data_length[j])\n                krb5_db_free(context, data[i].key_data_contents[j]);\n    krb5_db_free(context, data);\n}", "target": 0}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "int snd_card_register(struct snd_card *card)\n{\n\tint err;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}", "target": 0}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "uint8_t* sldns_str2wire_dname(const char* str, size_t* len)\n{\n\tuint8_t dname[LDNS_MAX_DOMAINLEN+1];\n\t*len = sizeof(dname);\n\tif(sldns_str2wire_dname_buf(str, dname, len) == 0) {\n\t\tuint8_t* r;\n\t\tif(*len > sizeof(dname)) return NULL;\n\t\tr = (uint8_t*)malloc(*len);\n\t\tif(r) return memcpy(r, dname, *len);\n\t}\n\t*len = 0;\n\treturn NULL;\n}", "target": 0}
{"code": "        bool operator()(const Exiv2::Exifdatum& md) const\n        {\n            return idx_ == md.idx() && 0 == strcmp(md.groupName().c_str(), groupName_);\n        }", "target": 0}
{"code": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n  *str = (const char *)buf;\n  *buff_len -= *length;\n  return buf + *length;\n}", "target": 1}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tstatic_key_slow_dec(&kvm_no_apic_vcpu);\n}", "target": 0}
{"code": "OFCondition DcmSCP::listen()\n{\n  dcmEnableAutomaticInputDataCorrection.set( OFFalse );\n  OFCondition cond = EC_Normal;\n  if( !dcmDataDict.isDictionaryLoaded() )\n    DCMNET_WARN(\"No data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( m_cfg->getPort() < 1024 && geteuid() != 0 )\n  {\n    DCMNET_ERROR(\"No privileges to open this network port (\" << m_cfg->getPort() << \")\");\n    return NET_EC_InsufficientPortPrivileges;\n  }\n#endif\n#endif\n  T_ASC_Network *network = NULL;\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, m_cfg->getPort()), m_cfg->getACSETimeout(), &network );\n  if( cond.bad() )\n    return cond;\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() && !stopAfterCurrentAssociation() )\n  {\n    cond = waitForAssociationRQ(network);\n  }\n  cond = ASC_dropNetwork( &network );\n  network = NULL;\n  return cond;\n}", "target": 1}
{"code": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\tdev->dev_up = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "static void perf_event_comm_event(struct perf_comm_event *comm_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tchar comm[TASK_COMM_LEN];\n\tunsigned int size;\n\tstruct pmu *pmu;\n\tint ctxn;\n\tmemset(comm, 0, sizeof(comm));\n\tstrlcpy(comm, comm_event->task->comm, sizeof(comm));\n\tsize = ALIGN(strlen(comm)+1, sizeof(u64));\n\tcomm_event->comm = comm;\n\tcomm_event->comm_size = size;\n\tcomm_event->event_id.header.size = sizeof(comm_event->event_id) + size;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_comm_ctx(&cpuctx->ctx, comm_event);\n\t\tctxn = pmu->task_ctx_nr;\n\t\tif (ctxn < 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_event_comm_ctx(ctx, comm_event);\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\n        Packet *p, Flow * const pflow)\n{\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);\n    PacketPatternCleanup(det_ctx);\n     if (pflow != NULL) {\n        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {\n             StreamReassembleRawUpdateProgress(pflow->protoctx, p,\n                     det_ctx->raw_stream_progress);\n            DetectEngineCleanHCBDBuffers(det_ctx);\n        }\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);\n    SCReturn;\n}", "target": 1}
{"code": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len, int seed)\n{\n    unsigned long value = (unsigned long) seed;\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}", "target": 1}
{"code": "void ring_buffer_record_enable(struct ring_buffer *buffer)\n{\n\tatomic_dec(&buffer->record_disabled);\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "static GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif \n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}", "target": 1}
{"code": "static int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    avio_rb24(pb); \n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n    return 0;\n}", "target": 0}
{"code": "static struct media_item *parse_media_folder(struct avrcp *session,\n\t\t\t\t\tuint8_t *operands, uint16_t len)\n{\n\tstruct avrcp_player *player = session->controller->player;\n\tstruct media_player *mp = player->user_data;\n\tstruct media_item *item;\n\tuint16_t namelen;\n\tchar name[255];\n\tuint64_t uid;\n\tuint8_t type;\n\tuint8_t playable;\n\tif (len < 12)\n\t\treturn NULL;\n\tuid = get_be64(&operands[0]);\n\ttype = operands[8];\n\tplayable = operands[9];\n\tnamelen = MIN(get_be16(&operands[12]), sizeof(name) - 1);\n\tif (namelen > 0) {\n\t\tmemcpy(name, &operands[14], namelen);\n\t\tname[namelen] = '\\0';\n\t}\n\titem = media_player_create_folder(mp, name, type, uid);\n\tif (!item)\n\t\treturn NULL;\n\tmedia_item_set_playable(item, playable & 0x01);\n\treturn item;\n}", "target": 0}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "RSAES_PKCS1v1_5Encode(\n\t\t      TPM2B       *padded,        \n\t\t      TPM2B       *message,       \n\t\t      RAND_STATE  *rand\n\t\t      )\n{\n    UINT32      ps = padded->size - message->size - 3;\n    if(message->size > padded->size - 11)\n\treturn TPM_RC_VALUE;\n    memcpy(&padded->buffer[padded->size - message->size], message->buffer,\n\t   message->size);\n    padded->buffer[0] = 0;\n    padded->buffer[1] = 2;\n    DRBG_Generate(rand, &padded->buffer[2], (UINT16)ps);\n    padded->buffer[2 + ps] = 0;\n    for(ps++; ps > 1; ps--)\n\t{\n\t    if(padded->buffer[ps] == 0)\n\t\tpadded->buffer[ps] = 0x55;  \n\t}\n    return TPM_RC_SUCCESS;\n}", "target": 0}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "bool HTMLSelectElement::anonymousIndexedSetter(unsigned index, PassRefPtr<HTMLOptionElement> value, ExceptionState& exceptionState)\n{\n    if (!value) {\n        exceptionState.throwTypeError(ExceptionMessages::failedToSet(String::number(index), \"HTMLSelectElement\", \"The value provided was not an HTMLOptionElement.\"));\n        return false;\n    }\n    setOption(index, value.get(), exceptionState);\n    return true;\n}", "target": 0}
{"code": "empty_param_read(iparam_list * plist, const ref * pkey, iparam_loc * ploc)\n{\n    return 1;\n}", "target": 0}
{"code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n\tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "T2P* t2p_init()\n{\n\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\n\tif(t2p==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \n\t\t\t(unsigned long) sizeof(T2P));\n\t\treturn( (T2P*) NULL );\n\t}\n\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\n\tt2p->pdf_majorversion=1;\n\tt2p->pdf_minorversion=1;\n\tt2p->pdf_defaultxres=300.0;\n\tt2p->pdf_defaultyres=300.0;\n\tt2p->pdf_defaultpagewidth=612.0;\n\tt2p->pdf_defaultpagelength=792.0;\n\tt2p->pdf_xrefcount=3; \n\tt2p->tiff_maxdatasize = DEFAULT_MAX_MALLOC;\n\treturn(t2p);\n}", "target": 0}
{"code": "static void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}", "target": 0}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "static int exif_rewrite_tag_format_to_unsigned(int format)\n{\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE: return TAG_FMT_BYTE;\n\t\tcase TAG_FMT_SRATIONAL: return TAG_FMT_URATIONAL;\n\t\tcase TAG_FMT_SSHORT: return TAG_FMT_USHORT;\n\t\tcase TAG_FMT_SLONG: return TAG_FMT_ULONG;\n\t}\n\treturn format;\n}", "target": 0}
{"code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n        numTiles[i] = (l + size - 1) / size;\n    }\n}", "target": 1}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}", "target": 1}
{"code": "static void nvme_dsm_cb(void *opaque, int ret)\n{\n    NvmeDSMAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    NvmeNamespace *ns = req->ns;\n    NvmeDsmRange *range;\n    uint64_t slba;\n    uint32_t nlb;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto done;\n    }\nnext:\n    if (iocb->idx == iocb->nr) {\n        goto done;\n    }\n    range = &iocb->range[iocb->idx++];\n    slba = le64_to_cpu(range->slba);\n    nlb = le32_to_cpu(range->nlb);\n    trace_pci_nvme_dsm_deallocate(slba, nlb);\n    if (nlb > n->dmrsl) {\n        trace_pci_nvme_dsm_single_range_limit_exceeded(nlb, n->dmrsl);\n        goto next;\n    }\n    if (nvme_check_bounds(ns, slba, nlb)) {\n        trace_pci_nvme_err_invalid_lba_range(slba, nlb,\n                                             ns->id_ns.nsze);\n        goto next;\n    }\n    iocb->aiocb = blk_aio_pdiscard(ns->blkconf.blk, nvme_l2b(ns, slba),\n                                   nvme_l2b(ns, nlb),\n                                   nvme_dsm_md_cb, iocb);\n    return;\ndone:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "void pickHyprPicker(sdbus::MethodCall& call) {\n    const std::string HYPRPICKER_CMD = \"hyprpicker --format=rgb --no-fancy\";\n    std::string       rgbColor       = execAndGet(HYPRPICKER_CMD.c_str());\n    if (rgbColor.size() > 12) {\n        Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    std::array<uint8_t, 3> colors{0, 0, 0};\n    try {\n        for (uint8_t i = 0; i < 2; i++) {\n            uint64_t next = rgbColor.find(' ');\n            if (next == std::string::npos) {\n                Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n                sendEmptyDbusMethodReply(call, 1);\n                return;\n            }\n            colors[i] = std::stoi(rgbColor.substr(0, next));\n            rgbColor  = rgbColor.substr(next + 1, rgbColor.size() - next);\n        }\n        colors[2] = std::stoi(rgbColor);\n    } catch (...) {\n        Debug::log(ERR, \"Reading RGB values from hyprpicker failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n    auto [r, g, b] = colors;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"color\"] = sdbus::Struct(std::tuple{r / 255.0, g / 255.0, b / 255.0});\n    auto reply = call.createReply();\n    reply << (uint32_t)0;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "TEST_F(ExtractorTest, TestDefaultHeaderLocation) {\n  auto headers = TestRequestHeaderMapImpl{{\"Authorization\", \"Bearer jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token\");\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer1\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer2\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer3\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer4\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"unknown_issuer\"));\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.has(Http::CustomHeaders::get().Authorization));\n}", "target": 0}
{"code": "static bool cma_protocol_roce(const struct rdma_cm_id *id)\n{\n\tstruct ib_device *device = id->device;\n\tconst u32 port_num = id->port_num ?: rdma_start_port(device);\n\treturn rdma_protocol_roce(device, port_num);\n}", "target": 0}
{"code": "static int check_ld_imm(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_map *map;\n\tint err;\n\tif (BPF_SIZE(insn->code) != BPF_DW) {\n\t\tverbose(env, \"invalid BPF_LD_IMM insn\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (insn->off != 0) {\n\t\tverbose(env, \"BPF_LD_IMM64 uses reserved fields\\n\");\n\t\treturn -EINVAL;\n\t}\n\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\tif (err)\n\t\treturn err;\n\tif (insn->src_reg == 0) {\n\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t__mark_reg_known(&regs[insn->dst_reg], imm);\n\t\treturn 0;\n\t}\n\tmap = env->used_maps[aux->map_index];\n\tmark_reg_known_zero(env, regs, insn->dst_reg);\n\tregs[insn->dst_reg].map_ptr = map;\n\tif (insn->src_reg == BPF_PSEUDO_MAP_VALUE) {\n\t\tregs[insn->dst_reg].type = PTR_TO_MAP_VALUE;\n\t\tregs[insn->dst_reg].off = aux->map_off;\n\t\tif (map_value_has_spin_lock(map))\n\t\t\tregs[insn->dst_reg].id = ++env->id_gen;\n\t} else if (insn->src_reg == BPF_PSEUDO_MAP_FD) {\n\t\tregs[insn->dst_reg].type = CONST_PTR_TO_MAP;\n\t} else {\n\t\tverbose(env, \"bpf verifier is misconfigured\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}", "target": 1}
{"code": "static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "static ssize_t store_int_with_restart(struct device *s,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tssize_t ret = device_store_int(s, attr, buf, size);\n\tmce_restart();\n\treturn ret;\n}", "target": 1}
{"code": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}", "target": 1}
{"code": "static void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}", "target": 0}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "decode_string(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive string size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_strings(self);\n    else\n        ret = decode_definite_string(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "void blk_mq_add_to_requeue_list(struct request *rq, bool at_head)\n{\n\tstruct request_queue *q = rq->q;\n\tunsigned long flags;\n\tBUG_ON(rq->cmd_flags & REQ_SOFTBARRIER);\n\tspin_lock_irqsave(&q->requeue_lock, flags);\n\tif (at_head) {\n\t\trq->cmd_flags |= REQ_SOFTBARRIER;\n\t\tlist_add(&rq->queuelist, &q->requeue_list);\n\t} else {\n\t\tlist_add_tail(&rq->queuelist, &q->requeue_list);\n\t}\n\tspin_unlock_irqrestore(&q->requeue_lock, flags);\n}", "target": 0}
{"code": "struct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint offset, i;\n\tstruct bio *bio;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\t\tif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}", "target": 0}
{"code": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n    return NULL;\n#endif\n    return NULL;\n}", "target": 1}
{"code": "char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\tif (i < nb && end >= size)\n\t\treturn 0; \n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\treturn end;\n}", "target": 0}
{"code": "save_fonteffect(struct html_feed_environ *h_env, struct readbuffer *obuf)\n{\n    if (obuf->fontstat_sp < FONT_STACK_SIZE)\n\tbcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp],\n\t      FONTSTAT_SIZE);\n    obuf->fontstat_sp++;\n    if (obuf->in_bold)\n\tpush_tag(obuf, \"</b>\", HTML_N_B);\n    if (obuf->in_italic)\n\tpush_tag(obuf, \"</i>\", HTML_N_I);\n    if (obuf->in_under)\n\tpush_tag(obuf, \"</u>\", HTML_N_U);\n    if (obuf->in_strike)\n\tpush_tag(obuf, \"</s>\", HTML_N_S);\n    if (obuf->in_ins)\n\tpush_tag(obuf, \"</ins>\", HTML_N_INS);\n    bzero(obuf->fontstat, FONTSTAT_SIZE);\n}", "target": 0}
{"code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t\n  int strsize;\t\t\t\n  int next_ch;\n  insize = 0;\n  strsize = s->ds_length;\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}", "target": 1}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "std::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      \n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    \n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    \n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    \n  if (depth == 1) {\n    for (int64 i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}", "target": 0}
{"code": "print_address_information(address_item *addr, FILE *f, uschar *si, uschar *sc,\n  uschar *se)\n{\nBOOL yield = TRUE;\nuschar *printed = US\"\";\naddress_item *ancestor = addr;\nwhile (ancestor->parent) ancestor = ancestor->parent;\nfprintf(f, \"%s\", CS si);\nif (addr->parent && testflag(addr, af_hide_child))\n  {\n  printed = US\"an undisclosed address\";\n  yield = FALSE;\n  }\nelse if (!testflag(addr, af_pfr) || !addr->parent)\n  printed = addr->address;\nelse\n  {\n  uschar *s = addr->address;\n  uschar *ss;\n  if (addr->address[0] == '>') { ss = US\"mail\"; s++; }\n  else if (addr->address[0] == '|') ss = US\"pipe\";\n  else ss = US\"save\";\n  fprintf(f, \"%s to %s%sgenerated by \", ss, s, sc);\n  printed = addr->parent->address;\n  }\nfprintf(f, \"%s\", CS string_printing(printed));\nif (ancestor != addr)\n  {\n  uschar *original = ancestor->onetime_parent;\n  if (!original) original= ancestor->address;\n  if (strcmpic(original, printed) != 0)\n    fprintf(f, \"%s(%sgenerated from %s)\", sc,\n      ancestor != addr->parent ? \"ultimately \" : \"\",\n      string_printing(original));\n  }\nif (addr->host_used)\n  fprintf(f, \"\\n    host %s [%s]\",\n\t  addr->host_used->name, addr->host_used->address);\nfprintf(f, \"%s\", CS se);\nreturn yield;\n}", "target": 0}
{"code": "GF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;", "target": 0}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n     t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n     t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n     }\n }", "target": 1}
{"code": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n  http1_consume_data(uuid, p);\n}", "target": 1}
{"code": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n    PROCNAME(\"gplotAddPlot\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n    return 0;\n}", "target": 1}
{"code": "static int ExecuteHelp( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    char            szTable[250]                        = \"\";\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLLEN          nRows               = 0;\n    szSepLine[ 0 ] = 0;\n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n    if ( iniElement( szSQL, ' ', '\\0', 1, szTable, sizeof(szTable) ) == INI_SUCCESS )\n    {\n        SQLWCHAR tname[ 1024 ];\n        ansi_to_unicode( szTable, tname );\n        if ( SQLColumns( hStmt, NULL, 0, NULL, 0, tname, SQL_NTS, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLColumns\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    else\n    {\n        if ( SQLTables( hStmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLTables\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    if ( bHTMLTable )\n        WriteHeaderHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteHeaderNormal( hStmt, szSepLine );\n    else if ( cDelimiter && bColumnNames )\n        WriteHeaderDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteBodyHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        nRows = WriteBodyNormal( hStmt );\n    else\n        WriteBodyDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteFooterHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteFooterNormal( hStmt, szSepLine, nRows );\n    SQLFreeStmt( hStmt, SQL_DROP );\n    return 1;\n}", "target": 0}
{"code": "static int spl_ptr_heap_cmp_cb_helper(zval *object, spl_heap_object *heap_object, zval *a, zval *b, long *result TSRMLS_DC) { \n\t\tzval *result_p = NULL;\n\t\tzend_call_method_with_2_params(&object, heap_object->std.ce, &heap_object->fptr_cmp, \"compare\", &result_p, a, b);\n\t\tif (EG(exception)) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tconvert_to_long(result_p);\n\t\t*result = Z_LVAL_P(result_p);\n\t\tzval_ptr_dtor(&result_p);\n\t\treturn SUCCESS;\n}", "target": 0}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)\n{\n\tif (prev->on_rq)\n\t\tupdate_curr(cfs_rq);\n\tcheck_spread(cfs_rq, prev);\n\tif (prev->on_rq) {\n\t\tupdate_stats_wait_start(cfs_rq, prev);\n\t\t__enqueue_entity(cfs_rq, prev);\n\t}\n\tcfs_rq->curr = NULL;\n}", "target": 0}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "methodHandle LinkResolver::lookup_instance_method_in_klasses(Klass* klass,\n                                                             Symbol* name,\n                                                             Symbol* signature,\n                                                             Klass::PrivateLookupMode private_mode, TRAPS) {\n  Method* result = klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);\n  while (result != NULL && result->is_static() && result->method_holder()->super() != NULL) {\n    Klass* super_klass = result->method_holder()->super();\n    result = super_klass->uncached_lookup_method(name, signature, Klass::find_overpass, private_mode);\n  }\n  if (klass->is_array_klass()) {\n    return methodHandle(THREAD, result);\n  }\n  if (result == NULL) {\n    Array<Method*>* default_methods = InstanceKlass::cast(klass)->default_methods();\n    if (default_methods != NULL) {\n      result = InstanceKlass::find_method(default_methods, name, signature);\n      assert(result == NULL || !result->is_static(), \"static defaults not allowed\");\n    }\n  }\n  return methodHandle(THREAD, result);\n}", "target": 0}
{"code": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}", "target": 1}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "xmlCopyAttribute(xmlAttributePtr attr) {\n    xmlAttributePtr cur;\n    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlAttribute));\n    cur->type = XML_ATTRIBUTE_DECL;\n    cur->atype = attr->atype;\n    cur->def = attr->def;\n    cur->tree = xmlCopyEnumeration(attr->tree);\n    if (attr->elem != NULL)\n\tcur->elem = xmlStrdup(attr->elem);\n    if (attr->name != NULL)\n\tcur->name = xmlStrdup(attr->name);\n    if (attr->prefix != NULL)\n\tcur->prefix = xmlStrdup(attr->prefix);\n    if (attr->defaultValue != NULL)\n\tcur->defaultValue = xmlStrdup(attr->defaultValue);\n    return(cur);\n}", "target": 0}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "static int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\terq->flags = 1;\n\treturn 0;\n}", "target": 0}
{"code": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\tbprm->mm = NULL;\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\tdo_close_on_exec(current->files);\n\treturn 0;\nout:\n\treturn retval;\n}", "target": 0}
{"code": "sock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}", "target": 0}
{"code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}", "target": 0}
{"code": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx)\n\t\teventfd_ctx_put(v->config_ctx);\n}", "target": 1}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "read_response_line(smtp_inblock *inblock, uschar *buffer, int size, int timeout)\n{\nuschar *p = buffer;\nuschar *ptr = inblock->ptr;\nuschar *ptrend = inblock->ptrend;\nclient_conn_ctx * cctx = inblock->cctx;\nfor (;;)\n  {\n  int rc;\n  while (ptr < ptrend)\n    {\n    int c = *ptr++;\n    if (c == '\\n')\n      {\n      while (p > buffer && isspace(p[-1])) p--;\n      *p = 0;\n      inblock->ptr = ptr;\n      return p - buffer;\n      }\n    *p++ = c;\n    if (--size < 4)\n      {\n      *p = 0;                     \n      errno = ERRNO_SMTPFORMAT;\n      return -1;\n      }\n    }\n  if((rc = ip_recv(cctx, inblock->buffer, inblock->buffersize, timeout)) <= 0)\n    {\n    DEBUG(D_deliver|D_transport|D_acl)\n      debug_printf_indent(errno ? \"  SMTP(%s)<<\\n\" : \"  SMTP(closed)<<\\n\",\n\tstrerror(errno));\n    break;\n    }\n  ptrend = inblock->ptrend = inblock->buffer + rc;\n  ptr = inblock->buffer;\n  DEBUG(D_transport|D_acl) debug_printf_indent(\"read response data: size=%d\\n\", rc);\n  }\n*buffer = 0;\nreturn -1;\n}", "target": 0}
{"code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}", "target": 1}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n        wArray[i] = num;\n    }\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n    parseStream(wArray, indices);\n}", "target": 1}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}", "target": 0}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n {\n \tstruct sclp_ctl_sccb ctl_sccb;\n \tstruct sccb_header *sccb;\n \tint rc;\n \tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n \tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n \tif (!sccb)\n \t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n \t\trc = -EFAULT;\n \t\tgoto out_free;\n \t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n \t\tgoto out_free;\n \t}\n \trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "xfs_iunlink_remove(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_buf\t\t*last_ibp;\n\tstruct xfs_dinode\t*last_dip = NULL;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\tnext_agino;\n\txfs_agino_t\t\thead_agino;\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\ttrace_xfs_iunlink_remove(ip);\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = agibp->b_addr;\n\thead_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (!xfs_verify_agino(mp, agno, head_agino)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\tagi, sizeof(*agi));\n\t\treturn -EFSCORRUPTED;\n\t}\n\terror = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO, &next_agino);\n\tif (error)\n\t\treturn error;\n\tif (next_agino != NULLAGINO) {\n\t\terror = xfs_iunlink_change_backref(agibp->b_pag, next_agino,\n\t\t\t\tNULLAGINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (head_agino != agino) {\n\t\tstruct xfs_imap\timap;\n\t\txfs_agino_t\tprev_agino;\n\t\terror = xfs_iunlink_map_prev(tp, agno, head_agino, agino,\n\t\t\t\t&prev_agino, &imap, &last_dip, &last_ibp,\n\t\t\t\tagibp->b_pag);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_iunlink_update_dinode(tp, agno, prev_agino, last_ibp,\n\t\t\t\tlast_dip, &imap, next_agino);\n\t\treturn xfs_iunlink_change_backref(agibp->b_pag, agino,\n\t\t\t\tnext_agino);\n\t}\n\treturn xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,\n\t\t\tnext_agino);\n}", "target": 0}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "get_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}", "target": 0}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n \t\tmegasas_free_cmds(instance);\n \t}\n \treturn 0;\n}", "target": 1}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "allocateCharacterClasses ()\n{\n  int k = 0;\n  characterClasses = NULL;\n  characterClassAttribute = 1;\n  while (characterClassNames[k])\n    {\n      widechar wname[MAXSTRING];\n      int length = strlen (characterClassNames[k]);\n      int kk;\n      for (kk = 0; kk < length; kk++)\n\twname[kk] = (widechar) characterClassNames[k][kk];\n      if (!addCharacterClass (NULL, wname, length))\n\t{\n\t  deallocateCharacterClasses ();\n\t  return 0;\n\t}\n      k++;\n    }\n  return 1;\n}", "target": 0}
{"code": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "acl_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, char *sol,\n                  struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tstruct hdr_idx *idx = &txn->hdr_idx;\n\tstruct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;\n\tif (!txn)\n\t\treturn 0;\n\tif (!(test->flags & ACL_TEST_F_FETCH_MORE))\n\t\tctx->idx = 0;\n\tif (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, ctx)) {\n\t\ttest->flags |= ACL_TEST_F_FETCH_MORE;\n\t\ttest->flags |= ACL_TEST_F_VOL_HDR;\n\t\ttest->i = strl2ic((char *)ctx->line + ctx->val, ctx->vlen);\n\t\treturn 1;\n\t}\n\ttest->flags &= ~ACL_TEST_F_FETCH_MORE;\n\ttest->flags |= ACL_TEST_F_VOL_HDR;\n\treturn 0;\n}", "target": 0}
{"code": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "static int present_and_same_family(const struct sadb_address *src,\n\t\t\t\t   const struct sadb_address *dst)\n{\n\tconst struct sockaddr *s_addr, *d_addr;\n\tif (!src || !dst)\n\t\treturn 0;\n\ts_addr = (const struct sockaddr *)(src + 1);\n\td_addr = (const struct sockaddr *)(dst + 1);\n\tif (s_addr->sa_family != d_addr->sa_family)\n\t\treturn 0;\n\tif (s_addr->sa_family != AF_INET\n#if IS_ENABLED(CONFIG_IPV6)\n\t    && s_addr->sa_family != AF_INET6\n#endif\n\t\t)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "static int proc_parse_options(char *options, struct pid_namespace *pid)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tif (!options)\n\t\treturn 1;\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpid->pid_gid = make_kgid(current_user_ns(), option);\n\t\t\tbreak;\n\t\tcase Opt_hidepid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 2) {\n\t\t\t\tpr_err(\"proc: hidepid value must be between 0 and 2.\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpid->hide_pid = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"proc: unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\\n\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "extract_option(uschar **name, uschar **value)\n{\nuschar *n;\nuschar *v = smtp_cmd_data + Ustrlen(smtp_cmd_data) - 1;\nwhile (isspace(*v)) v--;\nv[1] = 0;\nwhile (v > smtp_cmd_data && *v != '=' && !isspace(*v))\n  {\n  if (*v == '\"') do v--; while (*v != '\"' && v > smtp_cmd_data+1);\n  v--;\n  }\nn = v;\nif (*v == '=')\n  {\n  while(isalpha(n[-1])) n--;\n  if (!isspace(n[-1])) return FALSE;\n  n[-1] = 0;\n  }\nelse\n  {\n  n++;\n  if (v == smtp_cmd_data) return FALSE;\n  }\n*v++ = 0;\n*name = n;\n*value = v;\nreturn TRUE;\n}", "target": 0}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "void Document::open(Document* entered_document,\n                    ExceptionState& exception_state) {\n  if (ImportLoader()) {\n    exception_state.ThrowDOMException(\n        kInvalidStateError, \"Imported document doesn't support open().\");\n    return;\n  }\n  if (!IsHTMLDocument()) {\n    exception_state.ThrowDOMException(kInvalidStateError,\n                                      \"Only HTML documents support open().\");\n    return;\n  }\n  if (throw_on_dynamic_markup_insertion_count_) {\n    exception_state.ThrowDOMException(\n        kInvalidStateError,\n        \"Custom Element constructor should not use open().\");\n    return;\n  }\n  if (entered_document) {\n    if (!GetSecurityOrigin()->IsSameSchemeHostPortAndSuborigin(\n            entered_document->GetSecurityOrigin())) {\n      exception_state.ThrowSecurityError(\n          \"Can only call open() on same-origin documents.\");\n      return;\n    }\n    SetSecurityOrigin(entered_document->GetSecurityOrigin());\n    if (this != entered_document) {\n       KURL new_url = entered_document->Url();\n       new_url.SetFragmentIdentifier(String());\n       SetURL(new_url);\n     }\n     cookie_url_ = entered_document->CookieURL();\n  }\n  open();\n}", "target": 1}
{"code": "static bool parse_namemap(RBuffer *b, ut64 bound, RIDStorage *map, ut32 *count) {\n\tsize_t i;\n\tif (!consume_u32_r (b, bound, count)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < *count; i++) {\n\t\tut32 idx;\n\t\tif (!consume_u32_r (b, bound, &idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tchar *name = NULL;\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &name)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_id_storage_add (map, name, &idx)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn true;\n}", "target": 0}
{"code": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n    if (!mount_point.isEmpty())\n        return mount_point;\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n        return QString();\n    }\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n        return QString();\n    }\n    return mount_point;\n}", "target": 1}
{"code": "oftrace_add_recirc_node(struct ovs_list *recirc_queue,\n                        enum oftrace_recirc_type type, const struct flow *flow,\n                        const struct dp_packet *packet, uint32_t recirc_id,\n                        const uint16_t zone)\n{\n    if (!recirc_id_node_find_and_ref(recirc_id)) {\n        return false;\n    }\n    struct oftrace_recirc_node *node = xmalloc(sizeof *node);\n    ovs_list_push_back(recirc_queue, &node->node);\n    node->type = type;\n    node->recirc_id = recirc_id;\n    node->flow = *flow;\n    node->flow.recirc_id = recirc_id;\n    node->flow.ct_zone = zone;\n    node->packet = packet ? dp_packet_clone(packet) : NULL;\n    return true;\n}", "target": 0}
{"code": "static int fts3EvalPhraseNext(\n  Fts3Cursor *pCsr,               \n  Fts3Phrase *p,                  \n  u8 *pbEof                       \n){\n  int rc = SQLITE_OK;\n  Fts3Doclist *pDL = &p->doclist;\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  if( p->bIncr ){\n    rc = fts3EvalIncrPhraseNext(pCsr, p, pbEof);\n  }else if( pCsr->bDesc!=pTab->bDescIdx && pDL->nAll ){\n    sqlite3Fts3DoclistPrev(pTab->bDescIdx, pDL->aAll, pDL->nAll, \n        &pDL->pNextDocid, &pDL->iDocid, &pDL->nList, pbEof\n    );\n    pDL->pList = pDL->pNextDocid;\n  }else{\n    fts3EvalDlPhraseNext(pTab, pDL, pbEof);\n  }\n  return rc;\n}", "target": 0}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}", "target": 0}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "_gnutls_x509_encode_and_copy_PKI_params(ASN1_TYPE dst,\n\t\t\t\t\tconst char *dst_name,\n\t\t\t\t\tgnutls_pk_algorithm_t\n\t\t\t\t\tpk_algorithm,\n\t\t\t\t\tgnutls_pk_params_st * params)\n{\n\tconst char *pk;\n\tgnutls_datum_t der = { NULL, 0 };\n\tint result;\n\tchar name[128];\n\tpk = _gnutls_x509_pk_to_oid(pk_algorithm);\n\tif (pk == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNKNOWN_PK_ALGORITHM;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.algorithm\");\n\tresult = asn1_write_value(dst, name, pk, 1);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult =\n\t    _gnutls_x509_write_pubkey_params(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.parameters\");\n\tresult = asn1_write_value(dst, name, der.data, der.size);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _gnutls_x509_write_pubkey(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".subjectPublicKey\");\n\tresult = asn1_write_value(dst, name, der.data, der.size * 8);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "MagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n  const char\n    *element;\n  LinkedListInfo\n    *messages,\n    *paths;\n  StringInfo\n    *xml;\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}", "target": 0}
{"code": "exit_cifs_idmap(void)\n{\n\tkey_revoke(root_cred->thread_keyring);\n\tunregister_key_type(&cifs_idmap_key_type);\n\tput_cred(root_cred);\n\tcifs_dbg(FYI, \"Unregistered %s key type\\n\", cifs_idmap_key_type.name);\n}", "target": 0}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n }", "target": 1}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err gf_fs_set_http_max_rate(GF_FilterSession *fs, u32 rate)\n{\n\tif (!fs) return GF_OK;\n\tif (!fs->download_manager) {\n\t\tgf_fs_get_download_manager(fs);\n\t\tif (!fs->download_manager) return GF_OUT_OF_MEM;\n\t}\n\tgf_dm_set_data_rate(fs->download_manager, rate);\n\treturn GF_OK;\n}", "target": 0}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "HMAC_SHA256_Final(unsigned char digest[32], struct HMAC_SHA256_CTX * ctx)\n{\n  unsigned char ihash[32];\n  scrypt_SHA256_Final(ihash, &ctx->ictx);\n  scrypt_SHA256_Update(&ctx->octx, ihash, 32);\n  scrypt_SHA256_Final(digest, &ctx->octx);\n  memset(ihash, 0, 32);\n}", "target": 1}
{"code": "void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunion cpu_time_count now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tint clear_dead;\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\tif (timer->it.cpu.expires.sched == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\tif (unlikely(p == NULL)) {\n\tdead:\n\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t   &itp->it_value);\n\t\treturn;\n\t}\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tclear_dead = p->exit_state;\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tif (unlikely(p->signal == NULL)) {\n\t\t\tput_task_struct(p);\n\t\t\ttimer->it.cpu.task = NULL;\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\tread_unlock(&tasklist_lock);\n\t\t\tgoto dead;\n\t\t} else {\n\t\t\tcpu_clock_sample_group(timer->it_clock, p, &now);\n\t\t\tclear_dead = (unlikely(p->exit_state) &&\n\t\t\t\t      thread_group_empty(p));\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\tif (timer->it.cpu.incr.sched == 0 &&\n\t\t    cpu_time_before(timer->it_clock,\n\t\t\t\t    timer->it.cpu.expires, now)) {\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\t\treturn;\n\t\t}\n\t\tbump_cpu_timer(timer, now);\n\t}\n\tif (unlikely(clear_dead)) {\n\t\tclear_dead_task(timer, now);\n\t\tgoto dead;\n\t}\n\tif (cpu_time_before(timer->it_clock, now, timer->it.cpu.expires)) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   cpu_time_sub(timer->it_clock,\n\t\t\t\t\t\ttimer->it.cpu.expires, now),\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}", "target": 0}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_list_player_values(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tunsigned int i;\n\tif (len != 1)\n\t\tgoto err;\n\tif (player_get_setting(player, pdu->params[0]) < 0)\n\t\tgoto err;\n\tlen = attr_get_max_val(pdu->params[0]);\n\tfor (i = 1; i <= len; i++)\n\t\tpdu->params[i] = i;\n\tpdu->params[0] = len;\n\tpdu->params_len = htons(len + 1);\n\treturn AVC_CTYPE_STABLE;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "    static void _distance_scan(const unsigned int len,\n                               const longT *const g,\n                               longT (*const sep)(const longT, const longT, const longT *const),\n                               longT (*const f)(const longT, const longT, const longT *const),\n                               longT *const s,\n                               longT *const t,\n                               longT *const dt) {\n      longT q = s[0] = t[0] = 0;\n      for (int u = 1; u<(int)len; ++u) { \n        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }\n        if (q<0) { q = 0; s[0] = u; }\n        else { const longT w = 1 + sep(s[q], u, g); if (w<(longT)len) { ++q; s[q] = u; t[q] = w; }}\n      }\n      for (int u = (int)len - 1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; } ", "target": 0}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n \tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 0}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}", "target": 0}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "static __init int efivar_ssdt_load(void)\n{\n\tLIST_HEAD(entries);\n\tstruct efivar_entry *entry, *aux;\n\tunsigned long size;\n\tvoid *data;\n\tint ret;\n\tret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);\n\tlist_for_each_entry_safe(entry, aux, &entries, list) {\n\t\tpr_info(\"loading SSDT from variable %s-%pUl\\n\", efivar_ssdt,\n\t\t\t&entry->var.VendorGuid);\n\t\tlist_del(&entry->list);\n\t\tret = efivar_entry_size(entry, &size);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var size\\n\");\n\t\t\tgoto free_entry;\n\t\t}\n\t\tdata = kmalloc(size, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_entry;\n\t\t}\n\t\tret = efivar_entry_get(entry, NULL, &size, data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var data\\n\");\n\t\t\tgoto free_data;\n\t\t}\n\t\tret = acpi_load_table(data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to load table: %d\\n\", ret);\n\t\t\tgoto free_data;\n\t\t}\n\t\tgoto free_entry;\nfree_data:\n\t\tkfree(data);\nfree_entry:\n\t\tkfree(entry);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n uint32_t numSyncSamples = U32_AT(&header[4]);\n if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n }\n uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n return ERROR_OUT_OF_RANGE;\n }\n    mTotalSize += allocSize;\n if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n \"    Requested sync sample table size = %llu\\n\"\n \"    Eventual sample table size >= %llu\\n\"\n \"    Allowed sample table size = %llu\\n\",\n (unsigned long long)allocSize,\n (unsigned long long)mTotalSize,\n (unsigned long long)kMaxTotalSize);\n return ERROR_OUT_OF_RANGE;\n }\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n (unsigned long long)numSyncSamples);\n return ERROR_OUT_OF_RANGE;\n }\n     if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n             (size_t)allocSize) != (ssize_t)allocSize) {\n        delete mSyncSamples;\n         mSyncSamples = NULL;\n         return ERROR_IO;\n     }\n for (size_t i = 0; i < numSyncSamples; ++i) {\n if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n continue;\n }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n return OK;\n}", "target": 1}
{"code": "change_refs_to_tmp_fields(THD *thd, Ref_ptr_array ref_pointer_array,\n\t\t\t  List<Item> &res_selected_fields,\n\t\t\t  List<Item> &res_all_fields, uint elements,\n\t\t\t  List<Item> &all_fields)\n{\n  List_iterator_fast<Item> it(all_fields);\n  Item *item, *new_item;\n  res_selected_fields.empty();\n  res_all_fields.empty();\n  uint i, border= all_fields.elements - elements;\n  for (i= 0; (item= it++); i++)\n  {\n    if (item->type() == Item::SUM_FUNC_ITEM && item->const_item())\n      new_item= item;\n    else\n      new_item= item->get_tmp_table_item(thd); \n    res_all_fields.push_back(new_item, thd->mem_root);\n    ref_pointer_array[((i < border)? all_fields.elements-i-1 : i-border)]=\n      new_item;\n  }\n  List_iterator_fast<Item> itr(res_all_fields);\n  for (i= 0; i < border; i++)\n    itr++;\n  itr.sublist(res_selected_fields, elements);\n  return thd->is_fatal_error;\n}", "target": 0}
{"code": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }", "target": 1}
{"code": "int mempool_releasebuffer(MemoryPoolHandle handle, void *buf,\n                          size_t released_buffer_size) {\n  struct mempool *pool = (struct mempool *)handle;\n  struct memory_pool_element *pool_item = (struct memory_pool_element *)buf;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_releasebuffer called for invalid \"\n      \"released_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if ((pool == NULL) || (pool_item == NULL)) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n  if (pool->mempool_item_size != released_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               released_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return S3_MEMPOOL_INVALID_ARG;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if ((pool->flags & ZEROED_BUFFER) != 0) {\n    memset(pool_item, 0, pool->mempool_item_size);\n  }\n  pool_item->next = pool->free_list;\n  pool->free_list = pool_item;\n  pool->free_bufs_in_pool++;\n  pool_item = NULL;\n  pool->number_of_bufs_shared--;\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return 0;\n}", "target": 0}
{"code": "static int bson_append_string_base( bson *b, const char *name,\n                                    const char *value, int len, bson_type type ) {\n    int sl = len + 1;\n    if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    bson_append32( b , &sl );\n    bson_append( b , value , sl - 1 );\n    bson_append( b , \"\\0\" , 1 );\n    return BSON_OK;\n}", "target": 1}
{"code": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n  smatch match;\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n    return a;\n  }\n  return none;\n}", "target": 1}
{"code": "GF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;", "target": 0}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "xsltFreePrincipalStylesheetData(xsltPrincipalStylesheetDataPtr data)\n{\n    if (data == NULL)\n\treturn;\n    if (data->inScopeNamespaces != NULL) {\n\tint i;\n\txsltNsListContainerPtr nsi;\n\txsltPointerListPtr list =\n\t    (xsltPointerListPtr) data->inScopeNamespaces;\n\tfor (i = 0; i < list->number; i++) {\n\t    nsi = (xsltNsListContainerPtr) list->items[i];\n\t    if (nsi->list != NULL)\n\t\txmlFree(nsi->list);\n\t    xmlFree(nsi);\n\t}\n\txsltPointerListFree(list);\n\tdata->inScopeNamespaces = NULL;\n    }\n    if (data->exclResultNamespaces != NULL) {\n\tint i;\n\txsltPointerListPtr list = (xsltPointerListPtr)\n\t    data->exclResultNamespaces;\t\n\tfor (i = 0; i < list->number; i++)\n\t    xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n\txsltPointerListFree(list);\n\tdata->exclResultNamespaces = NULL;\n    }\n    if (data->extElemNamespaces != NULL) {\n\txsltPointerListPtr list = (xsltPointerListPtr)\n\t    data->extElemNamespaces;\n\tint i;\n\tfor (i = 0; i < list->number; i++)\n\t    xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n\txsltPointerListFree(list);\n\tdata->extElemNamespaces = NULL;\n    }\n    if (data->effectiveNs) {\n\txsltLREEffectiveNsNodesFree(data->effectiveNs);\n\tdata->effectiveNs = NULL;\n    }\n#ifdef XSLT_REFACTORED_XSLT_NSCOMP\n    xsltFreeNamespaceMap(data->nsMap);\n#endif\n    xmlFree(data);\n}", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& convolve(const CImg<t>& kernel, const bool boundary_conditions=true, const bool is_normalized=false) {\n      if (is_empty() || !kernel) return *this;\n      return get_convolve(kernel,boundary_conditions,is_normalized).move_to(*this);", "target": 0}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "static int pull_client_data (struct conn_s *connptr, long int length, int iehack)\n{\n        char *buffer;\n        ssize_t len;\n        int ret;\n        buffer =\n            (char *) safemalloc (min (MAXBUFFSIZE, (unsigned long int) length));\n        if (!buffer)\n                return -1;\n        do {\n                len = safe_read (connptr->client_fd, buffer,\n                                 min (MAXBUFFSIZE, (unsigned long int) length));\n                if (len <= 0)\n                        goto ERROR_EXIT;\n                if (!connptr->error_variables) {\n                        if (safe_write (connptr->server_fd, buffer, len) < 0)\n                                goto ERROR_EXIT;\n                }\n                length -= len;\n        } while (length > 0);\n        if (iehack) {\n                ret = socket_nonblocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to non-blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                len = recv (connptr->client_fd, buffer, 2, MSG_PEEK);\n                ret = socket_blocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                if (len < 0 && errno != EAGAIN)\n                        goto ERROR_EXIT;\n                if ((len == 2) && CHECK_CRLF (buffer, len)) {\n                        ssize_t bytes_read;\n                        bytes_read = read (connptr->client_fd, buffer, 2);\n                        if (bytes_read == -1) {\n                                log_message\n                                        (LOG_WARNING,\n                                         \"Could not read two bytes from POST message\");\n                        }\n                }\n        }\n        safefree (buffer);\n        return 0;\nERROR_EXIT:\n        safefree (buffer);\n        return -1;\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "nfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}", "target": 0}
{"code": "win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}", "target": 0}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "static void wasm_sec_free(RBinWasmSection *sec) {\n\tif (sec) {\n\t\tfree (sec->name);\n\t\tfree (sec);\n\t}\n}", "target": 0}
{"code": "static inline void constructBidiRunsForSegment(InlineBidiResolver& topResolver, BidiRunList<BidiRun>& bidiRuns, const InlineIterator& endOfRuns, VisualDirectionOverride override, bool previousLineBrokeCleanly)\n{\n    ASSERT(&topResolver.runs() == &bidiRuns);\n    ASSERT(topResolver.position() != endOfRuns);\n    RenderObject* currentRoot = topResolver.position().root();\n    topResolver.createBidiRunsForLine(endOfRuns, override, previousLineBrokeCleanly);\n    while (!topResolver.isolatedRuns().isEmpty()) {\n        BidiRun* isolatedRun = topResolver.isolatedRuns().last();\n        topResolver.isolatedRuns().removeLast();\n        RenderObject* startObj = isolatedRun->object();\n        RenderInline* isolatedInline = toRenderInline(containingIsolate(startObj, currentRoot));\n         InlineBidiResolver isolatedResolver;\n         EUnicodeBidi unicodeBidi = isolatedInline->style()->unicodeBidi();\n        TextDirection direction = isolatedInline->style()->direction();\n        if (unicodeBidi == Plaintext)\n            direction = determinePlaintextDirectionality(isolatedInline, startObj);\n        else {\n            ASSERT(unicodeBidi == Isolate || unicodeBidi == IsolateOverride);\n            direction = isolatedInline->style()->direction();\n        }\n        isolatedResolver.setStatus(statusWithDirection(direction, isOverride(unicodeBidi)));\n        setupResolverToResumeInIsolate(isolatedResolver, isolatedInline, startObj);\n        InlineIterator iter = InlineIterator(isolatedInline, startObj, isolatedRun->m_start);\n        isolatedResolver.setPositionIgnoringNestedIsolates(iter);\n        isolatedResolver.createBidiRunsForLine(endOfRuns, NoVisualOverride, previousLineBrokeCleanly);\n        if (isolatedResolver.runs().runCount())\n            bidiRuns.replaceRunWithRuns(isolatedRun, isolatedResolver.runs());\n        if (!isolatedResolver.isolatedRuns().isEmpty()) {\n            topResolver.isolatedRuns().append(isolatedResolver.isolatedRuns());\n            isolatedResolver.isolatedRuns().clear();\n            currentRoot = isolatedInline;\n        }\n    }\n}", "target": 1}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "String localUserSpecificStorageDirectory()\n{\n    return cachedStorageDirectory(CSIDL_LOCAL_APPDATA);\n}", "target": 0}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "push_spaces(struct readbuffer *obuf, int pre_mode, int width)\n{\n    int i;\n    if (width <= 0)\n\treturn;\n    check_breakpoint(obuf, pre_mode, \" \");\n    for (i = 0; i < width; i++)\n\tStrcat_char(obuf->line, ' ');\n    obuf->pos += width;\n    set_space_to_prevchar(obuf->prevchar);\n    obuf->flag |= RB_NFLUSHED;\n}", "target": 0}
{"code": "static void nvme_flush_ns_cb(void *opaque, int ret)\n{\n    NvmeFlushAIOCB *iocb = opaque;\n    NvmeNamespace *ns = iocb->ns;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto out;\n    } else if (iocb->ret < 0) {\n        goto out;\n    }\n    if (ns) {\n        trace_pci_nvme_flush_ns(iocb->nsid);\n        iocb->ns = NULL;\n        iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);\n        return;\n    }\nout:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_SET) != off)\n\t\t\treturn 0;\n\t} else {\n\t\tfile->f_pos = off;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,\n                                      uint32_t arch,\n                                      int nr,\n                                      unsigned int arg_cnt,\n                                      const struct scmp_arg_cmp arg) {\n        int r;\n        r = seccomp_rule_add_exact(seccomp, SCMP_ACT_ERRNO(EPERM), nr, arg_cnt, arg);\n        if (r < 0) {\n                _cleanup_free_ char *n = NULL;\n                n = seccomp_syscall_resolve_num_arch(arch, nr);\n                log_debug_errno(r, \"Failed to add %s() rule for architecture %s, skipping: %m\",\n                                strna(n),\n                                seccomp_arch_to_string(arch));\n        }\n        return r;\n}", "target": 0}
{"code": "static int ext4_iomap_end(struct inode *inode, loff_t offset, loff_t length,\n\t\t\t  ssize_t written, unsigned flags, struct iomap *iomap)\n{\n\tint ret = 0;\n\thandle_t *handle;\n\tint blkbits = inode->i_blkbits;\n\tbool truncate = false;\n\tif (!(flags & IOMAP_WRITE) || (flags & IOMAP_FAULT))\n\t\treturn 0;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto orphan_del;\n\t}\n\tif (ext4_update_inode_size(inode, offset + written))\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (iomap->offset + iomap->length > \n\t    ALIGN(inode->i_size, 1 << blkbits)) {\n\t\text4_lblk_t written_blk, end_blk;\n\t\twritten_blk = (offset + written) >> blkbits;\n\t\tend_blk = (offset + length) >> blkbits;\n\t\tif (written_blk < end_blk && ext4_can_truncate(inode))\n\t\t\ttruncate = true;\n\t}\n\tif (!truncate && inode->i_nlink &&\n\t    !list_empty(&EXT4_I(inode)->i_orphan))\n\t\text4_orphan_del(handle, inode);\n\text4_journal_stop(handle);\n\tif (truncate) {\n\t\text4_truncate_failed_write(inode);\norphan_del:\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "static uint64_t lru_total_bumps_dropped(void) {\n    uint64_t total = 0;\n    lru_bump_buf *b;\n    pthread_mutex_lock(&bump_buf_lock);\n    for (b = bump_buf_head; b != NULL; b=b->next) {\n        pthread_mutex_lock(&b->mutex);\n        total += b->dropped;\n        pthread_mutex_unlock(&b->mutex);\n    }\n    pthread_mutex_unlock(&bump_buf_lock);\n    return total;\n}", "target": 0}
{"code": "void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tconst unsigned char *sigalgs;\n\tsize_t i, sigalgslen;\n\tint have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tsigalgslen = tls12_get_psigalgs(s, &sigalgs);\n\tfor (i = 0; i < sigalgslen; i += 2, sigalgs += 2)\n\t\t{\n\t\tswitch(sigalgs[1])\n\t\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tcase TLSEXT_signature_rsa:\n\t\t\thave_rsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tcase TLSEXT_signature_dsa:\n\t\t\thave_dsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tcase TLSEXT_signature_ecdsa:\n\t\t\thave_ecdsa = 1;\n\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t}\n\tif (!have_rsa)\n\t\t{\n\t\tc->mask_a |= SSL_aRSA;\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\t\t}\n\tif (!have_dsa)\n\t\t{\n\t\tc->mask_a |= SSL_aDSS;\n\t\tc->mask_k |= SSL_kDHd;\n\t\t}\n\tif (!have_ecdsa)\n\t\t{\n\t\tc->mask_a |= SSL_aECDSA;\n\t\tc->mask_k |= SSL_kECDHe;\n\t\t}\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif \n\tc->valid = 1;\n\t}", "target": 0}
{"code": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n  bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() ||\n                               delegate_->ShouldPreserveAbortedURLs();\n   if (pending_entry != controller_->GetVisibleEntry() ||\n       !should_preserve_entry) {\n     controller_->DiscardPendingEntry(true);\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}", "target": 1}
{"code": "make_clone_setup (GnomeRRScreen *screen)\n{\n        GnomeRRConfig *result;\n        int width, height;\n        int i;\n        if (!get_clone_size (screen, &width, &height))\n                return NULL;\n        result = gnome_rr_config_new_current (screen);\n        for (i = 0; result->outputs[i] != NULL; ++i) {\n                GnomeOutputInfo *info = result->outputs[i];\n                info->on = FALSE;\n                if (info->connected) {\n                        GnomeRROutput *output =\n                                gnome_rr_screen_get_output_by_name (screen, info->name);\n                        GnomeRRMode **modes = gnome_rr_output_list_modes (output);\n                        int j;\n                        int best_rate = 0;\n                        for (j = 0; modes[j] != NULL; ++j) {\n                                GnomeRRMode *mode = modes[j];\n                                int w, h;\n                                w = gnome_rr_mode_get_width (mode);\n                                h = gnome_rr_mode_get_height (mode);\n                                if (w == width && h == height) {\n                                        int r = gnome_rr_mode_get_freq (mode);\n                                        if (r > best_rate)\n                                                best_rate = r;\n                                }\n                        }\n                        if (best_rate > 0) {\n                                info->on = TRUE;\n                                info->width = width;\n                                info->height = height;\n                                info->rate = best_rate;\n                                info->rotation = GNOME_RR_ROTATION_0;\n                                info->x = 0;\n                                info->y = 0;\n                        }\n                }\n        }\n        print_configuration (result, \"clone setup\");\n        return result;\n}", "target": 0}
{"code": "static void csi_X(struct vc_data *vc, int vpar) \n{\t\t\t\t\t  \n\tint count;\n\tif (!vpar)\n\t\tvpar++;\n\tcount = (vpar > vc->vc_cols - vc->vc_x) ? (vc->vc_cols - vc->vc_x) : vpar;\n\tvc_uniscr_clear_line(vc, vc->vc_x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->vc_y, vc->vc_x, 1, count);\n\tvc->vc_need_wrap = 0;\n}", "target": 0}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "static struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}", "target": 0}
{"code": "void pdu_submit(V9fsPDU *pdu, P9MsgHeader *hdr)\n{\n    Coroutine *co;\n    CoroutineEntry *handler;\n    V9fsState *s = pdu->s;\n    pdu->size = le32_to_cpu(hdr->size_le);\n    pdu->id = hdr->id;\n    pdu->tag = le16_to_cpu(hdr->tag_le);\n    if (pdu->id >= ARRAY_SIZE(pdu_co_handlers) ||\n        (pdu_co_handlers[pdu->id] == NULL)) {\n        handler = v9fs_op_not_supp;\n    } else if (is_ro_export(&s->ctx) && !is_read_only_op(pdu)) {\n        handler = v9fs_fs_ro;\n    } else {\n        handler = pdu_co_handlers[pdu->id];\n    }\n    qemu_co_queue_init(&pdu->complete);\n    co = qemu_coroutine_create(handler, pdu);\n    qemu_coroutine_enter(co);\n}", "target": 0}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "static void mod_wstunnel_merge_config(plugin_config * const pconf, const config_plugin_value_t *cpv) {\n    do {\n        mod_wstunnel_merge_config_cpv(pconf, cpv);\n    } while ((++cpv)->k_id != -1);\n}", "target": 0}
{"code": "static int tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\n\t\ttp->rx_opt.saw_tstamp = 1;\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "xmlParseElementEnd(xmlParserCtxtPtr ctxt) {\n    xmlParserNodeInfo node_info;\n    xmlNodePtr ret = ctxt->node;\n    if (ctxt->nameNr <= 0)\n        return;\n    if (ctxt->sax2) {\n        const xmlChar *prefix = ctxt->pushTab[ctxt->nameNr * 3 - 3];\n        const xmlChar *URI = ctxt->pushTab[ctxt->nameNr * 3 - 2];\n        int nsNr = (ptrdiff_t) ctxt->pushTab[ctxt->nameNr * 3 - 1];\n\txmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\txmlParseEndTag1(ctxt, 0);\n#endif \n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}", "target": 0}
{"code": "static void rxfilter_notify(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    if (nc->rxfilter_notify_enabled) {\n        char *path = object_get_canonical_path(OBJECT(n->qdev));\n        qapi_event_send_nic_rx_filter_changed(!!n->netclient_name,\n                                              n->netclient_name, path);\n        g_free(path);\n        nc->rxfilter_notify_enabled = 0;\n    }\n}", "target": 0}
{"code": "PHP_FUNCTION(locale_parse)\n{\n    const char* loc_name        = NULL;\n    int         loc_name_len    = 0;\n    int         grOffset    \t= 0;\n    intl_error_reset( NULL TSRMLS_CC );\n    if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n        &loc_name, &loc_name_len ) == FAILURE)\n    {\n        intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n             \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n        RETURN_FALSE;\n    }\n    if(loc_name_len == 0) {\n        loc_name = intl_locale_get_default(TSRMLS_C);\n    }\n\tarray_init( return_value );\n\tgrOffset =  findOffset( LOC_GRANDFATHERED , loc_name );\n\tif( grOffset >= 0 ){\n\t\tadd_assoc_string( return_value , LOC_GRANDFATHERED_LANG_TAG , estrdup(loc_name) ,FALSE );\n\t}\n\telse{\n\t\tadd_array_entry( loc_name , return_value , LOC_LANG_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_SCRIPT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_REGION_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_VARIANT_TAG TSRMLS_CC);\n\t\tadd_array_entry( loc_name , return_value , LOC_PRIVATE_TAG TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n    if (!sti->nb_index_entries)\n        return -1;\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}", "target": 1}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "static const char *kernel_type_name(const struct btf* btf, u32 id)\n{\n\treturn btf_name_by_offset(btf, btf_type_by_id(btf, id)->name_off);\n}", "target": 0}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "struct page *rmqueue(struct zone *preferred_zone,\n\t\t\tstruct zone *zone, unsigned int order,\n\t\t\tgfp_t gfp_flags, unsigned int alloc_flags,\n\t\t\tint migratetype)\n{\n\tunsigned long flags;\n\tstruct page *page;\n\tif (likely(order == 0)) {\n\t\tpage = rmqueue_pcplist(preferred_zone, zone, order,\n\t\t\t\tgfp_flags, migratetype);\n\t\tgoto out;\n\t}\n\tWARN_ON_ONCE((gfp_flags & __GFP_NOFAIL) && (order > 1));\n\tspin_lock_irqsave(&zone->lock, flags);\n\tdo {\n\t\tpage = NULL;\n\t\tif (alloc_flags & ALLOC_HARDER) {\n\t\t\tpage = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);\n\t\t\tif (page)\n\t\t\t\ttrace_mm_page_alloc_zone_locked(page, order, migratetype);\n\t\t}\n\t\tif (!page)\n\t\t\tpage = __rmqueue(zone, order, migratetype);\n\t} while (page && check_new_pages(page, order));\n\tspin_unlock(&zone->lock);\n\tif (!page)\n\t\tgoto failed;\n\t__mod_zone_freepage_state(zone, -(1 << order),\n\t\t\t\t  get_pcppage_migratetype(page));\n\t__count_zid_vm_events(PGALLOC, page_zonenum(page), 1 << order);\n\tzone_statistics(preferred_zone, zone);\n\tlocal_irq_restore(flags);\nout:\n\tVM_BUG_ON_PAGE(page && bad_range(zone, page), page);\n\treturn page;\nfailed:\n\tlocal_irq_restore(flags);\n\treturn NULL;\n}", "target": 0}
{"code": "static int proc_pid_io_accounting(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer,\n#ifdef CONFIG_TASK_XACCT\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n#endif\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n#ifdef CONFIG_TASK_XACCT\n\t\t\t(unsigned long long)task->rchar,\n\t\t\t(unsigned long long)task->wchar,\n\t\t\t(unsigned long long)task->syscr,\n\t\t\t(unsigned long long)task->syscw,\n#endif\n\t\t\t(unsigned long long)task->ioac.read_bytes,\n\t\t\t(unsigned long long)task->ioac.write_bytes,\n\t\t\t(unsigned long long)task->ioac.cancelled_write_bytes);\n}", "target": 0}
{"code": "static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}", "target": 1}
{"code": "static GF_Filter *locate_alias_sink(GF_Filter *filter, const char *url, const char *mime_type)\n{\n\tu32 i;\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *f;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (!pidi->filter) continue;\n\t\t\tif (pidi->filter->act_as_sink && pidi->filter->freg->use_alias\n\t\t\t\t&& pidi->filter->freg->use_alias(pidi->filter, url, mime_type)\n\t\t\t) {\n\t\t\t\treturn pidi->filter;\n\t\t\t}\n\t\t\tf = locate_alias_sink(pidi->filter, url, mime_type);\n\t\t\tif (f) return f;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "int pam_sm_close_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);\n}    ", "target": 0}
{"code": "TIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\ttif = TIFFFdOpen((int)fd,    \n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\t_TIFFfree(mbname);\n\treturn tif;\n}", "target": 0}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "  void setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n    san_matchers_ = san_matchers;\n  };", "target": 1}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "void builtinFetchurl(const BasicDerivation & drv)\n{\n    auto url = drv.env.find(\"url\");\n    if (url == drv.env.end()) throw Error(\"attribute url missing\");\n    printMsg(lvlInfo, format(\"downloading %1%...\") % url->second);\n    auto data = downloadFile(url->second); \n    auto out = drv.env.find(\"out\");\n    if (out == drv.env.end()) throw Error(\"attribute url missing\");\n    writeFile(out->second, data.data);\n    auto executable = drv.env.find(\"executable\");\n    if (executable != drv.env.end() && executable->second == \"1\") {\n        if (chmod(out->second.c_str(), 0755) == -1)\n            throw SysError(format(\"making %1% executable\") % out->second);\n    }\n}", "target": 1}
{"code": "xsltFreeNamespaceMap(xsltNsMapPtr item)\n{\n    xsltNsMapPtr tmp;\n    while (item) {\n\ttmp = item;\n\titem = item->next;\n\txmlFree(tmp);\n    } \n    return;\n}", "target": 0}
{"code": "rgb2bgr16(UINT8 *out_, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4, out_ += 2) {\n        UINT16 v = ((((UINT16)in[0]) << 8) & 0xf800) +\n                   ((((UINT16)in[1]) << 3) & 0x07e0) +\n                   ((((UINT16)in[2]) >> 3) & 0x001f);\n        memcpy(out_, &v, sizeof(v));\n    }\n}", "target": 0}
{"code": "static int netsnmp_session_gen_sec_key(struct snmp_session *s, char *pass)\n{\n\tint snmp_errno;\n\ts->securityPrivKeyLen = USM_PRIV_KU_LEN;\n\tif ((snmp_errno = generate_Ku(s->securityAuthProto, s->securityAuthProtoLen,\n\t\t\t(u_char *)pass, strlen(pass),\n\t\t\ts->securityPrivKey, &(s->securityPrivKeyLen)))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Error generating a key for privacy pass phrase '%s': %s\", pass, snmp_api_errstring(snmp_errno));\n\t\treturn (-2);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": " _dbus_header_byteswap (DBusHeader *header,\n                        int         new_order)\n {\n   if (header->byte_order == new_order)\n     return;\n   _dbus_marshal_byteswap (&_dbus_header_signature_str,\n                           0, header->byte_order,\n                           new_order,\n                           &header->data, 0);\n   header->byte_order = new_order;\n }", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "static bool reg_type_mismatch(enum bpf_reg_type src, enum bpf_reg_type prev)\n{\n\treturn src != prev && (!reg_type_mismatch_ok(src) ||\n\t\t\t       !reg_type_mismatch_ok(prev));\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleCreateStreamTextureCHROMIUM(\n    uint32 immediate_data_size,\n    const gles2::CreateStreamTextureCHROMIUM& c) {\n  if (!feature_info_->feature_flags().chromium_stream_texture) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glOpenStreamTextureCHROMIUM: \"\n               \"not supported.\");\n    return error::kNoError;\n  }\n  uint32 client_id = c.client_id;\n  typedef gles2::CreateStreamTextureCHROMIUM::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result)\n    return error::kOutOfBounds;\n  *result = GL_ZERO;\n  TextureManager::TextureInfo* info =\n      texture_manager()->GetTextureInfo(client_id);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"bad texture id.\");\n    return error::kNoError;\n  }\n  if (info->IsStreamTexture()) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"is already a stream texture.\");\n    return error::kNoError;\n  }\n  if (info->target() && info->target() != GL_TEXTURE_EXTERNAL_OES) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"is already bound to incompatible target.\");\n    return error::kNoError;\n  }\n  if (!stream_texture_manager_)\n    return error::kInvalidArguments;\n  GLuint object_id = stream_texture_manager_->CreateStreamTexture(\n      info->service_id(), client_id);\n  if (object_id) {\n    info->SetStreamTexture(true);\n  } else {\n    SetGLError(GL_OUT_OF_MEMORY,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"failed to create platform texture.\");\n  }\n  *result = object_id;\n  return error::kNoError;\n}", "target": 0}
{"code": "bool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n  initGlobal();\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    setParam();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err))\n      return false;\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  checkSession();\n  cc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "int posix_cpu_clock_get(const clockid_t which_clock, struct timespec *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint error = -EINVAL;\n\tunion cpu_time_count rtn;\n\tif (pid == 0) {\n\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t current, &rtn);\n\t\t} else {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\terror = cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t       current, &rtn);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p) {\n\t\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\t\tif (same_thread_group(p, current)) {\n\t\t\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t\t\t p, &rtn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_lock(&tasklist_lock);\n\t\t\t\tif (thread_group_leader(p) && p->signal) {\n\t\t\t\t\terror =\n\t\t\t\t\t    cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t\t           p, &rtn);\n\t\t\t\t}\n\t\t\t\tread_unlock(&tasklist_lock);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (error)\n\t\treturn error;\n\tsample_to_timespec(which_clock, rtn, tp);\n\treturn 0;\n}", "target": 0}
{"code": " void ParamTraits<GURL>::Write(Message* m, const GURL& p) {\n   DCHECK(p.possibly_invalid_spec().length() <= content::kMaxURLChars);\n   m->WriteString(p.possibly_invalid_spec());\n }", "target": 1}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "static void dump_thread32(struct pt_regs * regs, struct user32 * dump)\n{\n\tu32 fs,gs;\n\tdump->magic = CMAGIC;\n\tdump->start_code = 0;\n\tdump->start_stack = regs->rsp & ~(PAGE_SIZE - 1);\n\tdump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\n\tdump->u_dsize = ((unsigned long) (current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;\n\tdump->u_dsize -= dump->u_tsize;\n\tdump->u_ssize = 0;\n\tdump->u_debugreg[0] = current->thread.debugreg0;  \n\tdump->u_debugreg[1] = current->thread.debugreg1;  \n\tdump->u_debugreg[2] = current->thread.debugreg2;  \n\tdump->u_debugreg[3] = current->thread.debugreg3;  \n\tdump->u_debugreg[4] = 0;  \n\tdump->u_debugreg[5] = 0;  \n\tdump->u_debugreg[6] = current->thread.debugreg6;  \n\tdump->u_debugreg[7] = current->thread.debugreg7;  \n\tif (dump->start_stack < 0xc0000000)\n\t\tdump->u_ssize = ((unsigned long) (0xc0000000 - dump->start_stack)) >> PAGE_SHIFT;\n\tdump->regs.ebx = regs->rbx;\n\tdump->regs.ecx = regs->rcx;\n\tdump->regs.edx = regs->rdx;\n\tdump->regs.esi = regs->rsi;\n\tdump->regs.edi = regs->rdi;\n\tdump->regs.ebp = regs->rbp;\n\tdump->regs.eax = regs->rax;\n\tdump->regs.ds = current->thread.ds;\n\tdump->regs.es = current->thread.es;\n\tasm(\"movl %%fs,%0\" : \"=r\" (fs)); dump->regs.fs = fs;\n\tasm(\"movl %%gs,%0\" : \"=r\" (gs)); dump->regs.gs = gs; \n\tdump->regs.orig_eax = regs->orig_rax;\n\tdump->regs.eip = regs->rip;\n\tdump->regs.cs = regs->cs;\n\tdump->regs.eflags = regs->eflags;\n\tdump->regs.esp = regs->rsp;\n\tdump->regs.ss = regs->ss;\n#if 1 \n\tdump->u_fpvalid = 0;\n#else\n\tdump->u_fpvalid = dump_fpu (regs, &dump->i387);\n#endif\n}", "target": 0}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "TypedValue HHVM_FUNCTION(array_diff,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args ) {\n  ARRAY_DIFF_PRELUDE()\n  auto st = req::make<c_Set>();\n  st->reserve(largestSize);\n  containerValuesToSetHelper(st, container2);\n  if (UNLIKELY(moreThanTwo)) {\n    for (ArrayIter argvIter(args); argvIter; ++argvIter) {\n      const auto& container = argvIter.secondRef();\n      containerValuesToSetHelper(st, container);\n    }\n  }\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    const auto& val = iter.secondRefPlus();\n    const auto& c = *val.asCell();\n    if (checkSetHelper(st, c, strTv, true)) continue;\n    ret.setWithRef(iter.first(), val, isKey);\n  }\n  return tvReturn(std::move(ret));\n}", "target": 0}
{"code": "find_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"", "target": 1}
{"code": "char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,\n uintptr_t abort_msg_address, bool dump_sibling_threads,\n bool* detach_failed, int* total_sleep_time_usec) {\n log_t log;\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n    _LOG(&log, logtype::ERROR, \"failed to create %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n    _LOG(&log, logtype::ERROR, \"failed to change ownership of %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n   int fd = -1;\n  char* path = NULL;\n  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n    path = find_and_open_tombstone(&fd);\n  } else {\n    _LOG(&log, logtype::ERROR, \"Failed to restore security context, not writing tombstone.\\n\");\n  }\n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \"Skipping tombstone write, nothing to do.\\n\");\n *detach_failed = false;\n return NULL;\n }\n  log.tfd = fd;\n int amfd = activity_manager_connect();\n  log.amfd = amfd;\n *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,\n                              dump_sibling_threads, total_sleep_time_usec);\n  ALOGI(\"\\nTombstone written to: %s\\n\", path);\n  close(amfd);\n  close(fd);\n return path;\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}", "target": 1}
{"code": "static void vnc_display_close(VncDisplay *vd)\n{\n    if (!vd) {\n        return;\n    }\n    vd->is_unix = false;\n    if (vd->listener) {\n        qio_net_listener_disconnect(vd->listener);\n        object_unref(OBJECT(vd->listener));\n    }\n    vd->listener = NULL;\n    if (vd->wslistener) {\n        qio_net_listener_disconnect(vd->wslistener);\n        object_unref(OBJECT(vd->wslistener));\n    }\n    vd->wslistener = NULL;\n    vd->auth = VNC_AUTH_INVALID;\n    vd->subauth = VNC_AUTH_INVALID;\n    if (vd->tlscreds) {\n        object_unparent(OBJECT(vd->tlscreds));\n        vd->tlscreds = NULL;\n    }\n    if (vd->tlsauthz) {\n        object_unparent(OBJECT(vd->tlsauthz));\n        vd->tlsauthz = NULL;\n    }\n    g_free(vd->tlsauthzid);\n    vd->tlsauthzid = NULL;\n    if (vd->lock_key_sync) {\n        qemu_remove_led_event_handler(vd->led);\n        vd->led = NULL;\n    }\n#ifdef CONFIG_VNC_SASL\n    if (vd->sasl.authz) {\n        object_unparent(OBJECT(vd->sasl.authz));\n        vd->sasl.authz = NULL;\n    }\n    g_free(vd->sasl.authzid);\n    vd->sasl.authzid = NULL;\n#endif\n}", "target": 0}
{"code": "METHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  if (source->use_inversion_array) {\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          \n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        \n        outptr += ps;\n      }\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\tlock_sock(sk);\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}", "target": 0}
{"code": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\ttcp_init_metrics(sk);\n\ttcp_init_congestion_control(sk);\n\ttp->lsndtime = tcp_time_stamp;\n\ttcp_init_buffer_space(sk);\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}", "target": 0}
{"code": "static bool torture_winbind_struct_endpwent(struct torture_context *torture)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\ttorture_comment(torture, \"Running WINBINDD_ENDPWENT (struct based)\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_ENDPWENT, &req, &rep);\n\treturn true;\n}", "target": 0}
{"code": "static void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}", "target": 1}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}", "target": 1}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "void sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tif (!conn)\n\t\tgoto drop;\n\tBT_DBG(\"conn %p len %u\", conn, skb->len);\n\tif (skb->len) {\n\t\tsco_recv_frame(conn, skb);\n\t\treturn;\n\t}\ndrop:\n\tkfree_skb(skb);\n}", "target": 0}
{"code": "static size_t vnc_client_read_plain(VncState *vs)\n{\n    size_t ret;\n    VNC_DEBUG(\"Read plain %p size %zd offset %zd\\n\",\n              vs->input.buffer, vs->input.capacity, vs->input.offset);\n    buffer_reserve(&vs->input, 4096);\n    ret = vnc_client_read_buf(vs, buffer_end(&vs->input), 4096);\n    if (!ret)\n        return 0;\n    vs->input.offset += ret;\n    return ret;\n}", "target": 0}
{"code": "CMYK_table_init (void)\n{\n\tg_mutex_lock (&Tables_Mutex);\n\tif (CMYK_Tab == NULL) {\n\t\tint    v, k, i;\n\t\tdouble k1;\n\t\tCMYK_Tab = g_new (unsigned char, 256 * 256);\n\t\ti = 0;\n\t\tfor (k = 0; k <= 255; k++) {\n\t\t\tk1 = (double) k / 255.0;\n\t\t\tfor (v = 0; v <= 255; v++)\n\t\t\t\tCMYK_Tab[i++] = (double) v * k1;\n\t\t}\n\t}\n\tg_mutex_unlock (&Tables_Mutex);\n}", "target": 0}
{"code": " INST_HANDLER (sts) {\t\n \tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\top->cycles = 2;\n}", "target": 1}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "static void sev_flush_guest_memory(struct vcpu_svm *svm, void *va,\n\t\t\t\t   unsigned long len)\n{\n\tif (boot_cpu_has(X86_FEATURE_SME_COHERENT))\n\t\treturn;\n\tif (boot_cpu_has(X86_FEATURE_VM_PAGE_FLUSH)) {\n\t\tstruct kvm_sev_info *sev;\n\t\tunsigned long va_start;\n\t\tu64 start, stop;\n\t\tva_start = (unsigned long)va;\n\t\tstart = (u64)va_start & PAGE_MASK;\n\t\tstop = PAGE_ALIGN((u64)va_start + len);\n\t\tif (start < stop) {\n\t\t\tsev = &to_kvm_svm(svm->vcpu.kvm)->sev_info;\n\t\t\twhile (start < stop) {\n\t\t\t\twrmsrl(MSR_AMD64_VM_PAGE_FLUSH,\n\t\t\t\t       start | sev->asid);\n\t\t\t\tstart += PAGE_SIZE;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tWARN(1, \"Address overflow, using WBINVD\\n\");\n\t}\n\tWARN_ONCE(1, \"Using WBINVD to flush guest memory\\n\");\n\twbinvd_on_all_cpus();\n}", "target": 0}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_ctl_dev_free(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tstruct snd_kcontrol *control;\n\tdown_write(&card->controls_rwsem);\n\twhile (!list_empty(&card->controls)) {\n\t\tcontrol = snd_kcontrol(card->controls.next);\n\t\tsnd_ctl_remove(card, control);\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn 0;\n}", "target": 0}
{"code": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": " void SetUpFontconfig() {\n  std::unique_ptr<Environment> env = Environment::Create();\n  if (!env->HasVar(\"FONTCONFIG_FILE\")) {\n    FilePath dir_module;\n    PathService::Get(DIR_MODULE, &dir_module);\n    FilePath font_cache = dir_module.Append(\"fontconfig_caches\");\n    FilePath test_fonts = dir_module.Append(\"test_fonts\");\n    std::string fonts_conf = ReplaceStringPlaceholders(\n        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n    FilePath fonts_conf_file_temp;\n    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));\n    CHECK(\n        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));\n    FilePath fonts_conf_file = dir_module.Append(\"fonts.conf\");\n    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));\n    env->SetVar(\"FONTCONFIG_FILE\", fonts_conf_file.value());\n  }\n  CHECK(FcInit());\n }", "target": 1}
{"code": "static int virtio_net_ufo_pre_save(void *opaque)\n{\n    struct VirtIONetMigTmp *tmp = opaque;\n    tmp->has_ufo = tmp->parent->has_ufo;\n    return 0;\n}", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag, const UChar** pp,\n\t\t   const UChar* end, UChar* fold, OnigEncoding enc)\n{\n  const UChar* p = *pp;\n  if (ONIGENC_IS_MBC_ASCII(p)) {\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n      if (*p == 0x49) {\n\t*fold++ = 0xc4;\n\t*fold   = 0xb1;\n\t(*pp)++;\n\treturn 2;\n      }\n    }\n#endif\n    *fold = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n    (*pp)++;\n    return 1; \n  }\n  else {\n    return onigenc_unicode_mbc_case_fold(enc, flag, pp, end, fold);\n  }\n}", "target": 0}
{"code": "p2bit(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = (L(&palette[in[x] * 4]) >= 128000) ? 255 : 0;\n    }\n}", "target": 0}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "static AVCodec *find_encdec(enum AVCodecID id, int encoder)\n{\n    AVCodec *p, *experimental = NULL;\n    p = first_avcodec;\n    id= remap_deprecated_codec_id(id);\n    while (p) {\n        if ((encoder ? av_codec_is_encoder(p) : av_codec_is_decoder(p)) &&\n            p->id == id) {\n            if (p->capabilities & CODEC_CAP_EXPERIMENTAL && !experimental) {\n                experimental = p;\n            } else\n                return p;\n        }\n        p = p->next;\n    }\n    return experimental;\n}", "target": 0}
{"code": "static void reset_fdc_info(int mode)\n{\n\tint drive;\n\tFDCS->spec1 = FDCS->spec2 = -1;\n\tFDCS->need_configure = 1;\n\tFDCS->perp_mode = 1;\n\tFDCS->rawcmd = 0;\n\tfor (drive = 0; drive < N_DRIVE; drive++)\n\t\tif (FDC(drive) == fdc && (mode || UDRS->track != NEED_1_RECAL))\n\t\t\tUDRS->track = NEED_2_RECAL;\n}", "target": 0}
{"code": "AcpiNsGetInternalNameLength (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    const char              *NextExternalChar;\n    UINT32                  i;\n    ACPI_FUNCTION_ENTRY ();\n    NextExternalChar = Info->ExternalName;\n    Info->NumCarats = 0;\n    Info->NumSegments = 0;\n    Info->FullyQualified = FALSE;\n    if (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n    {\n        Info->FullyQualified = TRUE;\n        NextExternalChar++;\n        while (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n        {\n            NextExternalChar++;\n        }\n    }\n    else\n    {\n        while (ACPI_IS_PARENT_PREFIX (*NextExternalChar))\n        {\n            Info->NumCarats++;\n            NextExternalChar++;\n        }\n    }\n    if (*NextExternalChar)\n    {\n        Info->NumSegments = 1;\n        for (i = 0; NextExternalChar[i]; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (NextExternalChar[i]))\n            {\n                Info->NumSegments++;\n            }\n        }\n    }\n    Info->Length = (ACPI_NAME_SIZE * Info->NumSegments) +\n        4 + Info->NumCarats;\n    Info->NextExternalChar = NextExternalChar;\n}", "target": 0}
{"code": "int snd_timer_global_new(char *id, int device, struct snd_timer **rtimer)\n{\n\tstruct snd_timer_id tid;\n\ttid.dev_class = SNDRV_TIMER_CLASS_GLOBAL;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = -1;\n\ttid.device = device;\n\ttid.subdevice = 0;\n\treturn snd_timer_new(NULL, id, &tid, rtimer);\n}", "target": 0}
{"code": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n   CalculateVisiblePages();\n   return most_visible_page_;\n }", "target": 1}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "put_mech_oid(unsigned char **buf_out, gss_OID_const mech, unsigned int buflen)\n{\n\tif (buflen < mech->length + 2)\n\t\treturn (-1);\n\t*(*buf_out)++ = MECH_OID;\n\t*(*buf_out)++ = (unsigned char) mech->length;\n\tmemcpy(*buf_out, mech->elements, mech->length);\n\t*buf_out += mech->length;\n\treturn (0);\n}", "target": 0}
{"code": "static int file_lshift(STANZA *s)\n{\n    BIGNUM *a = NULL, *lshift = NULL, *ret = NULL;\n    int n = 0, st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(lshift = getBN(s, \"LShift\"))\n            || !TEST_ptr(ret = BN_new())\n            || !getint(s, &n, \"N\"))\n        goto err;\n    if (!TEST_true(BN_lshift(ret, a, n))\n            || !equalBN(\"A << N\", lshift, ret)\n            || !TEST_true(BN_rshift(ret, lshift, n))\n            || !equalBN(\"A >> N\", a, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(lshift);\n    BN_free(ret);\n    return st;\n}", "target": 0}
{"code": "static int adjust_tp(struct atm_trafprm *tp, unsigned char aal)\n{\n\tint max_sdu;\n\tif (!tp->traffic_class)\n\t\treturn 0;\n\tswitch (aal) {\n\tcase ATM_AAL0:\n\t\tmax_sdu = ATM_CELL_SIZE-1;\n\t\tbreak;\n\tcase ATM_AAL34:\n\t\tmax_sdu = ATM_MAX_AAL34_PDU;\n\t\tbreak;\n\tdefault:\n\t\tpr_warning(\"AAL problems ... (%d)\\n\", aal);\n\tcase ATM_AAL5:\n\t\tmax_sdu = ATM_MAX_AAL5_PDU;\n\t}\n\tif (!tp->max_sdu)\n\t\ttp->max_sdu = max_sdu;\n\telse if (tp->max_sdu > max_sdu)\n\t\treturn -EINVAL;\n\tif (!tp->max_cdv)\n\t\ttp->max_cdv = ATM_MAX_CDV;\n\treturn 0;\n}", "target": 0}
{"code": "void rdma_set_service_type(struct rdma_cm_id *id, int tos)\n{\n\tstruct rdma_id_private *id_priv;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->qp_mutex);\n\tid_priv->tos = (u8) tos;\n\tid_priv->tos_set = true;\n\tmutex_unlock(&id_priv->qp_mutex);\n}", "target": 0}
{"code": "static int wcd9335_codec_enable_ear_pa(struct snd_soc_dapm_widget *w,\n\t\t\t\t       struct snd_kcontrol *kc, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tint ret = 0;\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tusleep_range(5000, 5500);\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9335_CDC_RX0_RX_PATH_CTL,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_EN_MASK,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_DISABLE);\n\t\tif ((snd_soc_component_read32(comp,\n\t\t\t\t\tWCD9335_CDC_RX0_RX_PATH_MIX_CTL)) &\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_EN_MASK)\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9335_CDC_RX0_RX_PATH_MIX_CTL,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_EN_MASK,\n\t\t\t\t\tWCD9335_CDC_RX_PGA_MUTE_DISABLE);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tusleep_range(5000, 5500);\n\t\tbreak;\n\t};\n\treturn ret;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int core_upgrade_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    const char *upgrade;\n    if (c->master) {\n        return DECLINED;\n    }\n    upgrade = apr_table_get(r->headers_in, \"Upgrade\");\n    if (upgrade && *upgrade) {\n        const char *conn = apr_table_get(r->headers_in, \"Connection\");\n        if (ap_find_token(r->pool, conn, \"upgrade\")) {\n            apr_array_header_t *offers = NULL;\n            const char *err;\n            err = ap_parse_token_list_strict(r->pool, upgrade, &offers, 0);\n            if (err) {\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02910)\n                              \"parsing Upgrade header: %s\", err);\n                return DECLINED;\n            }\n            if (offers && offers->nelts > 0) {\n                const char *protocol = ap_select_protocol(c, r, NULL, offers);\n                if (protocol && strcmp(protocol, ap_get_protocol(c))) {\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02909)\n                                  \"Upgrade selects '%s'\", protocol);\n                    apr_table_clear(r->headers_out);\n                    apr_table_setn(r->headers_out, \"Upgrade\", protocol);\n                    apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n                    r->status = HTTP_SWITCHING_PROTOCOLS;\n                    r->status_line = ap_get_status_line(r->status);\n                    ap_send_interim_response(r, 1);\n                    ap_switch_protocol(c, r, r->server, protocol);\n                    c->keepalive = AP_CONN_CLOSE;\n                    return DONE;\n                }\n            }\n        }\n    }\n    else if (!c->keepalives) {\n        const apr_array_header_t *upgrades;\n        ap_get_protocol_upgrades(c, r, NULL, 0, &upgrades);\n        if (upgrades && upgrades->nelts > 0) {\n            char *protocols = apr_array_pstrcat(r->pool, upgrades, ',');\n            apr_table_setn(r->headers_out, \"Upgrade\", protocols);\n            apr_table_setn(r->headers_out, \"Connection\", \"Upgrade\");\n        }\n    }\n    return DECLINED;\n}", "target": 0}
{"code": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\tfree(banner);\n}\t", "target": 1}
{"code": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n    ptr = buf;\n    chunk = 3 * state->xsize;\n    for (;;) {\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\tptr += chunk;\n\tbytes -= chunk;\n    }\n}", "target": 1}
{"code": "static int propagate_liveness(struct bpf_verifier_env *env,\n\t\t\t      const struct bpf_verifier_state *vstate,\n\t\t\t      struct bpf_verifier_state *vparent)\n{\n\tstruct bpf_reg_state *state_reg, *parent_reg;\n\tstruct bpf_func_state *state, *parent;\n\tint i, frame, err = 0;\n\tif (vparent->curframe != vstate->curframe) {\n\t\tWARN(1, \"propagate_live: parent frame %d current frame %d\\n\",\n\t\t     vparent->curframe, vstate->curframe);\n\t\treturn -EFAULT;\n\t}\n\tBUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);\n\tfor (frame = 0; frame <= vstate->curframe; frame++) {\n\t\tparent = vparent->frame[frame];\n\t\tstate = vstate->frame[frame];\n\t\tparent_reg = parent->regs;\n\t\tstate_reg = state->regs;\n\t\tfor (i = frame < vstate->curframe ? BPF_REG_6 : 0; i < BPF_REG_FP; i++) {\n\t\t\terr = propagate_liveness_reg(env, &state_reg[i],\n\t\t\t\t\t\t     &parent_reg[i]);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (err == REG_LIVE_READ64)\n\t\t\t\tmark_insn_zext(env, &parent_reg[i]);\n\t\t}\n\t\tfor (i = 0; i < state->allocated_stack / BPF_REG_SIZE &&\n\t\t\t    i < parent->allocated_stack / BPF_REG_SIZE; i++) {\n\t\t\tparent_reg = &parent->stack[i].spilled_ptr;\n\t\t\tstate_reg = &state->stack[i].spilled_ptr;\n\t\t\terr = propagate_liveness_reg(env, state_reg,\n\t\t\t\t\t\t     parent_reg);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}", "target": 0}
{"code": "static void GetStandardDeviationPixelList(PixelList *pixel_list,\n  MagickPixelPacket *pixel)\n{\n  MagickRealType\n    sum,\n    sum_squared;\n  SkipList\n    *list;\n  ssize_t\n    channel;\n  size_t\n    color;\n  ssize_t\n    count;\n  unsigned short\n    channels[ListChannels];\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    sum=0.0;\n    sum_squared=0.0;\n    do\n    {\n      ssize_t\n        i;\n      color=list->nodes[color].next[0];\n      sum+=(MagickRealType) list->nodes[color].count*color;\n      for (i=0; i < (ssize_t) list->nodes[color].count; i++)\n        sum_squared+=((MagickRealType) color)*((MagickRealType) color);\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    sum/=pixel_list->length;\n    sum_squared/=pixel_list->length;\n    channels[channel]=(unsigned short) sqrt(sum_squared-(sum*sum));\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}", "target": 0}
{"code": "convert_protocol_address(struct sockaddr* saddr, unsigned int saddrlen)\n{\n    PyObject *res_obj = NULL;\n    switch (saddr->sa_family)\n    {\n    case AF_INET:\n        {\n            struct sockaddr_in* sin = (struct sockaddr_in*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin->sin_addr, addr_str, INET_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin->sin_port));\n            PyMem_Free(addr_str);\n       }\n        break;\n    case AF_INET6:\n        {\n            struct sockaddr_in6* sin6 = (struct sockaddr_in6*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET6_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin6->sin6_addr, addr_str, INET6_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin6->sin6_port));\n            PyMem_Free(addr_str);\n        }\n        break;\n    default:\n        PyErr_SetString(ErrorObject, \"Unsupported address family.\");\n    }\nerror:\n    return res_obj;\n}", "target": 0}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "int sysctl_schedstats(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_schedstats);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_schedstats(state);\n\treturn err;\n}", "target": 0}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "DECLAREContigPutFunc(putcontig8bitCIELab)\n{\n\tfloat X, Y, Z;\n\tuint32 r, g, b;\n\t(void) y;\n\tfromskew *= 3;\n\twhile (h-- > 0) {\n\t\tfor (x = w; x-- > 0;) {\n\t\t\tTIFFCIELabToXYZ(img->cielab,\n\t\t\t\t\t(unsigned char)pp[0],\n\t\t\t\t\t(signed char)pp[1],\n\t\t\t\t\t(signed char)pp[2],\n\t\t\t\t\t&X, &Y, &Z);\n\t\t\tTIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);\n\t\t\t*cp++ = PACK(r, g, b);\n\t\t\tpp += 3;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}", "target": 0}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "target": 1}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \tsa->rc_family  = AF_BLUETOOTH;\n \tsa->rc_channel = rfcomm_pi(sk)->channel;\n \tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 1}
{"code": "static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tcfg_opt_t *dupopts;\n\tint n = cfg_numopts(opts);\n\tdupopts = calloc(n + 1, sizeof(cfg_opt_t));\n\tif (!dupopts)\n\t\treturn NULL;\n\tmemcpy(dupopts, opts, n * sizeof(cfg_opt_t));\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = NULL;\n\t\tdupopts[i].subopts = NULL;\n\t\tdupopts[i].def.parsed = NULL;\n\t\tdupopts[i].def.string = NULL;\n\t\tdupopts[i].comment = NULL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = strdup(opts[i].name);\n\t\tif (!dupopts[i].name)\n\t\t\tgoto err;\n\t\tif (opts[i].subopts) {\n\t\t\tdupopts[i].subopts = cfg_dupopt_array(opts[i].subopts);\n\t\t\tif (!dupopts[i].subopts)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.parsed) {\n\t\t\tdupopts[i].def.parsed = strdup(opts[i].def.parsed);\n\t\t\tif (!dupopts[i].def.parsed)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.string) {\n\t\t\tdupopts[i].def.string = strdup(opts[i].def.string);\n\t\t\tif (!dupopts[i].def.string)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].comment) {\n\t\t\tdupopts[i].comment = strdup(opts[i].comment);\n\t\t\tif (!dupopts[i].comment)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn dupopts;\nerr:\n\tcfg_free_opt_array(dupopts);\n\treturn NULL;\n}", "target": 0}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "const u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void unmask_payload(handler_ctx *hctx) {\n    buffer * const b = hctx->frame.payload;\n    for (size_t i = 0, used = buffer_clen(b); i < used; ++i) {\n        b->ptr[i] ^= hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];\n        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;\n    }\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_commit(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_commitargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_commit(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "void DevToolsDownloadManagerDelegate::Shutdown() {\n  if (proxy_download_delegate_)\n    proxy_download_delegate_->Shutdown();\n  download_manager_ = nullptr;\n}", "target": 0}
{"code": "static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}", "target": 1}
{"code": "    bool Photoshop::isIrb(const byte* pPsData,\n                          long        sizePsData)\n    {\n        if (sizePsData < 4) return false;\n        for (size_t i = 0; i < (sizeof irbId_) / (sizeof *irbId_); i++) {\n            assert(strlen(irbId_[i]) == 4);\n            if (memcmp(pPsData, irbId_[i], 4) == 0) return true;\n        }\n        return false;\n    }", "target": 0}
{"code": "SPL_METHOD(Array, offsetUnset)\n{\n\tzval *index;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &index) == FAILURE) {\n\t\treturn;\n\t}\n\tspl_array_unset_dimension_ex(0, getThis(), index TSRMLS_CC);\n} ", "target": 0}
{"code": "void XfccIntegrationTest::initialize() {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        hcm.set_forward_client_cert_details(fcc_);\n        hcm.mutable_set_current_client_cert_details()->CopyFrom(sccd_);\n      });\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    auto transport_socket =\n        bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    transport_socket->set_name(\"envoy.transport_sockets.tls\");\n    transport_socket->mutable_typed_config()->PackFrom(context);\n  });\n  if (tls_) {\n    config_helper_.addSslConfig();\n  }\n  context_manager_ =\n      std::make_unique<Extensions::TransportSockets::Tls::ContextManagerImpl>(timeSystem());\n  client_tls_ssl_ctx_ = createClientSslContext(false);\n  client_mtls_ssl_ctx_ = createClientSslContext(true);\n  HttpIntegrationTest::initialize();\n}", "target": 1}
{"code": "virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                              virMediatedDeviceTypePtr **mdev_types,\n                              size_t *nmdev_types)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n    for (i = 0; i < *nmdev_types; i++)\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n    VIR_FREE(*mdev_types);\n    *nmdev_types = 0;\n    if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n        return -1;\n    *mdev_types = g_steal_pointer(&types);\n    *nmdev_types = ntypes;\n    return 0;\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "static int zipfileComparePath(const char *zA, const char *zB, int nB){\n  int nA = (int)strlen(zA);\n  if( zA[nA-1]=='/' ) nA--;\n  if( zB[nB-1]=='/' ) nB--;\n  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;\n  return 1;\n}", "target": 0}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "static int check_vmentry_postreqs(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t\t  u32 *exit_qual)\n{\n\tbool ia32e;\n\t*exit_qual = ENTRY_FAIL_DEFAULT;\n\tif (!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0) ||\n\t    !nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4))\n\t\treturn 1;\n\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_SHADOW_VMCS) &&\n\t    vmcs12->vmcs_link_pointer != -1ull) {\n\t\t*exit_qual = ENTRY_FAIL_VMCS_LINK_PTR;\n\t\treturn 1;\n\t}\n\tif (to_vmx(vcpu)->nested.nested_run_pending &&\n\t    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME)))\n\t\t\treturn 1;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}", "target": 1}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "mm_answer_rsa_challenge(int socket, Buffer *m)\n{\n\tKey *key = NULL;\n\tu_char *blob;\n\tu_int blen;\n\tdebug3(\"%s entering\", __func__);\n\tif (!authctxt->valid)\n\t\tfatal(\"%s: authctxt not valid\", __func__);\n\tblob = buffer_get_string(m, &blen);\n\tif (!monitor_allowed_key(blob, blen))\n\t\tfatal(\"%s: bad key, not previously allowed\", __func__);\n\tif (key_blobtype != MM_RSAUSERKEY && key_blobtype != MM_RSAHOSTKEY)\n\t\tfatal(\"%s: key type mismatch\", __func__);\n\tif ((key = key_from_blob(blob, blen)) == NULL)\n\t\tfatal(\"%s: received bad key\", __func__);\n\tif (ssh1_challenge)\n\t\tBN_clear_free(ssh1_challenge);\n\tssh1_challenge = auth_rsa_generate_challenge(key);\n\tbuffer_clear(m);\n\tbuffer_put_bignum2(m, ssh1_challenge);\n\tdebug3(\"%s sending reply\", __func__);\n\tmm_request_send(socket, MONITOR_ANS_RSACHALLENGE, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_RSARESPONSE, 1);\n\txfree(blob);\n\tkey_free(key);\n\treturn (0);\n}", "target": 0}
{"code": "static int rx_flow_is_on(struct caifsock *cf_sk)\n{\n\treturn test_bit(RX_FLOW_ON_BIT,\n\t\t\t(void *) &cf_sk->flow_state);\n}", "target": 0}
{"code": "PHP_LIBXML_API xmlNodePtr php_libxml_import_node(zval *object TSRMLS_DC)\n{\n\tzend_class_entry *ce = NULL;\n\txmlNodePtr node = NULL;\n\tphp_libxml_func_handler *export_hnd;\n\tif (object->type == IS_OBJECT) {\n\t\tce = Z_OBJCE_P(object);\n\t\twhile (ce->parent != NULL) {\n\t\t\tce = ce->parent;\n\t\t}\n\t\tif (zend_hash_find(&php_libxml_exports, ce->name, ce->name_length + 1, (void **) &export_hnd)  == SUCCESS) {\n\t\t\tnode = export_hnd->export_func(object TSRMLS_CC);\n\t\t}\n\t}\n\treturn node;\n}", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "static void clearSelect(sqlite3 *db, Select *p, int bFree){\n  while( p ){\n    Select *pPrior = p->pPrior;\n    sqlite3ExprListDelete(db, p->pEList);\n    sqlite3SrcListDelete(db, p->pSrc);\n    sqlite3ExprDelete(db, p->pWhere);\n    sqlite3ExprListDelete(db, p->pGroupBy);\n    sqlite3ExprDelete(db, p->pHaving);\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    sqlite3ExprDelete(db, p->pLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){\n      sqlite3WindowListDelete(db, p->pWinDefn);\n    }\n#endif\n    if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n    if( bFree ) sqlite3DbFreeNN(db, p);\n    p = pPrior;\n    bFree = 1;\n  }\n}", "target": 0}
{"code": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}", "target": 1}
{"code": "mono_class_interface_implements_interface (MonoClass *candidate, MonoClass *iface)\n{\n\tMonoError error;\n\tint i;\n\tdo {\n\t\tif (candidate == iface)\n\t\t\treturn TRUE;\n\t\tmono_class_setup_interfaces (candidate, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\treturn FALSE;\n\t\t}\n\t\tfor (i = 0; i < candidate->interface_count; ++i) {\n\t\t\tif (candidate->interfaces [i] == iface || mono_class_interface_implements_interface (candidate->interfaces [i], iface))\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tcandidate = candidate->parent;\n\t} while (candidate);\n\treturn FALSE;\n}", "target": 0}
{"code": "KeyInfo *sqlite3KeyInfoFromExprList(\n  Parse *pParse,       \n  ExprList *pList,     \n  int iStart,          \n  int nExtra           \n){\n  int nExpr;\n  KeyInfo *pInfo;\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  int i;\n  nExpr = pList->nExpr;\n  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);\n  if( pInfo ){\n    assert( sqlite3KeyInfoIsWriteable(pInfo) );\n    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){\n      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);\n      pInfo->aSortOrder[i-iStart] = pItem->sortOrder;\n    }\n  }\n  return pInfo;\n}", "target": 0}
{"code": "static int verify_ee(const gnutls_datum_t *raw_crt, gnutls_certificate_type_t crt_type,\n\t\t dane_cert_type_t ctype, dane_match_type_t match, gnutls_datum_t * data,\n\t\t unsigned int *verify)\n{\ngnutls_datum_t pubkey = {NULL, 0};\nint ret;\n\tif (ctype == DANE_CERT_X509 && crt_type == GNUTLS_CRT_X509) {\n\t\tif (!matches(raw_crt, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else if (ctype == DANE_CERT_PK && crt_type == GNUTLS_CRT_X509) {\n\t\tret = crt_to_pubkey(raw_crt, &pubkey);\n\t\tif (ret < 0) {\n        \t        gnutls_assert();\n\t\t\tgoto cleanup;\n                }\n\t\tif (!matches(&pubkey, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else {\n\t\tret = gnutls_assert_val(DANE_E_UNKNOWN_DANE_DATA);\n\t\tgoto cleanup;\n\t}\n\tret = 0;\ncleanup:\n\tfree(pubkey.data);\n\treturn ret;\n}", "target": 0}
{"code": "url_escape_1 (const char *s, unsigned char mask, bool allow_passthrough)\n{\n  const char *p1;\n  char *p2, *newstr;\n  int newlen;\n  int addition = 0;\n  for (p1 = s; *p1; p1++)\n    if (urlchr_test (*p1, mask))\n      addition += 2;            \n  if (!addition)\n    return allow_passthrough ? (char *)s : xstrdup (s);\n  newlen = (p1 - s) + addition;\n  newstr = xmalloc (newlen + 1);\n  p1 = s;\n  p2 = newstr;\n  while (*p1)\n    {\n      if (urlchr_test (*p1, mask))\n        {\n          unsigned char c = *p1++;\n          *p2++ = '%';\n          *p2++ = XNUM_TO_DIGIT (c >> 4);\n          *p2++ = XNUM_TO_DIGIT (c & 0xf);\n        }\n      else\n        *p2++ = *p1++;\n    }\n  assert (p2 - newstr == newlen);\n  *p2 = '\\0';\n  return newstr;\n}", "target": 0}
{"code": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static bool hva_to_pfn_fast(unsigned long addr, bool atomic, bool *async,\n\t\t\t    bool write_fault, bool *writable, kvm_pfn_t *pfn)\n{\n\tstruct page *page[1];\n\tint npages;\n\tif (!(async || atomic))\n\t\treturn false;\n\tif (!(write_fault || writable))\n\t\treturn false;\n\tnpages = __get_user_pages_fast(addr, 1, 1, page);\n\tif (npages == 1) {\n\t\t*pfn = page_to_pfn(page[0]);\n\t\tif (writable)\n\t\t\t*writable = true;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static struct page *__page_frag_cache_refill(struct page_frag_cache *nc,\n\t\t\t\t\t     gfp_t gfp_mask)\n{\n\tstruct page *page = NULL;\n\tgfp_t gfp = gfp_mask;\n#if (PAGE_SIZE < PAGE_FRAG_CACHE_MAX_SIZE)\n\tgfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |\n\t\t    __GFP_NOMEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask,\n\t\t\t\tPAGE_FRAG_CACHE_MAX_ORDER);\n\tnc->size = page ? PAGE_FRAG_CACHE_MAX_SIZE : PAGE_SIZE;\n#endif\n\tif (unlikely(!page))\n\t\tpage = alloc_pages_node(NUMA_NO_NODE, gfp, 0);\n\tnc->va = page ? page_address(page) : NULL;\n\treturn page;\n}", "target": 0}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n  ssize_t\n    intensity;\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "static int vsock_create(struct net *net, struct socket *sock,\n\t\t\tint protocol, int kern)\n{\n\tif (!sock)\n\t\treturn -EINVAL;\n\tif (protocol && protocol != PF_VSOCK)\n\t\treturn -EPROTONOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &vsock_dgram_ops;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsock->ops = &vsock_stream_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock->state = SS_UNCONNECTED;\n\treturn __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;\n}", "target": 0}
{"code": "exit_policy_is_general_exit_helper(smartlist_t *policy, int port)\n{\n  uint32_t mask, ip, i;\n  char subnet_status[256];\n  memset(subnet_status, 0, sizeof(subnet_status));\n  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {\n    if (tor_addr_family(&p->addr) != AF_INET)\n      continue; \n    if (p->prt_min > port || p->prt_max < port)\n      continue; \n    mask = 0;\n    tor_assert(p->maskbits <= 32);\n    if (p->maskbits)\n      mask = UINT32_MAX<<(32-p->maskbits);\n    ip = tor_addr_to_ipv4h(&p->addr);\n    for (i = ((mask & ip)>>24); i <= (~((mask & ip) ^ mask)>>24); ++i) {\n      tor_addr_t addr;\n      if (subnet_status[i] != 0)\n        continue; \n      tor_addr_from_ipv4h(&addr, i<<24);\n      if (tor_addr_is_internal(&addr, 0))\n        continue; \n      if (p->policy_type == ADDR_POLICY_ACCEPT) {\n        if (p->maskbits > 8)\n          continue; \n        return 1;\n      } else if (p->policy_type == ADDR_POLICY_REJECT) {\n        subnet_status[i] = 1;\n      }\n    }\n  });\n  return 0;\n}", "target": 0}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "pa2l(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = L(&palette[in[0] * 4]) / 1000;\n    }\n}", "target": 0}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "static inline struct page *__skb_alloc_pages(gfp_t gfp_mask,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      unsigned int order)\n{\n\tstruct page *page;\n\tgfp_mask |= __GFP_COLD;\n\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\tpage = alloc_pages_node(NUMA_NO_NODE, gfp_mask, order);\n\tif (skb && page && page->pfmemalloc)\n\t\tskb->pfmemalloc = true;\n\treturn page;\n}", "target": 0}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 1}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "PgUser *add_user(const char *name, const char *passwd)\n{\n\tPgUser *user = find_user(name);\n\tif (user == NULL) {\n\t\tuser = slab_alloc(user_cache);\n\t\tif (!user)\n\t\t\treturn NULL;\n\t\tlist_init(&user->head);\n\t\tlist_init(&user->pool_list);\n\t\tsafe_strcpy(user->name, name, sizeof(user->name));\n\t\tput_in_order(&user->head, &user_list, cmp_user);\n\t\taatree_insert(&user_tree, (uintptr_t)user->name, &user->tree_node);\n\t}\n\tsafe_strcpy(user->passwd, passwd, sizeof(user->passwd));\n\treturn user;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n \tlong err;\n \tint i;\n\tif (nsops < 1)\n \t\treturn -EINVAL;\n \tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n \tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "static inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\t*entity     = table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}", "target": 0}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 1}
{"code": "int __parse_rtattr_nested_compat(struct rtattr *tb[], int max,\n\t\t\t\t struct rtattr *rta,\n\t\t\t\t int len)\n{\n\tif (RTA_PAYLOAD(rta) < len)\n\t\treturn -1;\n\tif (RTA_PAYLOAD(rta) >= RTA_ALIGN(len) + sizeof(struct rtattr)) {\n\t\trta = RTA_DATA(rta) + RTA_ALIGN(len);\n\t\treturn parse_rtattr_nested(tb, max, rta);\n\t}\n\tmemset(tb, 0, sizeof(struct rtattr *) * (max + 1));\n\treturn 0;\n}", "target": 0}
{"code": "_dbus_printf_string_upper_bound (const char *format,\n                                 va_list     args)\n{\n  char static_buf[1024];\n  int bufsize = sizeof (static_buf);\n  int len;\n  len = vsnprintf (static_buf, bufsize, format, args);\n  if (len == bufsize)\n    {\n      if (vsnprintf (static_buf, 1, format, args) == 1)\n        len = -1;\n    }\n  while (len < 0)\n    {\n      char *buf;\n      bufsize *= 2;\n      buf = dbus_malloc (bufsize);\n      if (buf == NULL)\n        return -1;\n      len = vsnprintf (buf, bufsize, format, args);\n      dbus_free (buf);\n      if (len == bufsize)\n        len = -1;\n    }\n  return len;\n}", "target": 1}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}", "target": 1}
{"code": "cdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\tif (i == dir->dir_len)\n\t\tgoto out;\n\td = &dir->dir_tab[i];\n\t*root = d;\n\tif (d->d_stream_first_sector < 0)\n\t\tgoto out;\n\treturn\tcdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\treturn 0;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::CalculateNumberOfPages(blink::WebLocalFrame* frame,\n                                                const blink::WebNode& node,\n                                                int* number_of_pages) {\n  DCHECK(frame);\n  bool fit_to_paper_size = !(PrintingNodeOrPdfFrame(frame, node));\n  if (!InitPrintSettings(fit_to_paper_size)) {\n    notify_browser_of_print_failure_ = false;\n    Send(new PrintHostMsg_ShowInvalidPrinterSettingsError(routing_id()));\n    return false;\n  }\n  const PrintMsg_Print_Params& params = print_pages_params_->params;\n  PrepareFrameAndViewForPrint prepare(params, frame, node, ignore_css_margins_);\n  prepare.StartPrinting();\n  *number_of_pages = prepare.GetExpectedPageCount();\n  return true;\n}", "target": 0}
{"code": "int git_config_perm(const char *var, const char *value)\n{\n\tif (value) {\n\t\tint i;\n\t\tif (!strcmp(value, \"umask\"))\n\t\t\treturn PERM_UMASK;\n\t\tif (!strcmp(value, \"group\"))\n\t\t\treturn PERM_GROUP;\n\t\tif (!strcmp(value, \"all\") ||\n\t\t    !strcmp(value, \"world\") ||\n\t\t    !strcmp(value, \"everybody\"))\n\t\t\treturn PERM_EVERYBODY;\n\t\ti = atoi(value);\n\t\tif (i > 1)\n\t\t\treturn i;\n\t}\n\treturn git_config_bool(var, value);\n}", "target": 0}
{"code": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif \n\treturn 0;\n}", "target": 0}
{"code": "static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    problem_data_t *pd = problem_data_new();\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        problem_data_add_text_editable(pd, key, value);\n    }\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   \n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n    problem_data_add_basics(pd);\n    char *problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n    problem_data_free(pd);\n    return problem_id;\n}", "target": 1}
{"code": "   Convert an 8-bit string to a quoted-printable string */\nPHP_FUNCTION(imap_8bit)\n{\n\tzend_string *text;\n\tchar *decode;\n\tunsigned long newlength;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &text) == FAILURE) {\n\t\treturn;\n\t}\n\tdecode = (char *) rfc822_8bit((unsigned char *) ZSTR_VAL(text), ZSTR_LEN(text), &newlength);\n\tif (decode == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(decode, newlength);\n\tfs_give((void**) &decode);", "target": 0}
{"code": "static bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\tif (level == PT_PAGE_TABLE_LEVEL) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\treturn r || curr_pte != gw->ptes[level - 1];\n}", "target": 0}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "std::tuple<net::inet_address, int, client_type> cql_server::connection::make_client_key(const service::client_state& cli_state) {\n    return std::make_tuple(cli_state.get_client_address().addr(),\n            cli_state.get_client_port(),\n            cli_state.is_thrift() ? client_type::thrift : client_type::cql);\n}", "target": 0}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "populate_lr_context(struct intel_context *ce,\n\t\t    struct drm_i915_gem_object *ctx_obj,\n\t\t    struct intel_engine_cs *engine,\n\t\t    struct intel_ring *ring)\n{\n\tbool inhibit = true;\n\tvoid *vaddr;\n\tu32 *regs;\n\tint ret;\n\tvaddr = i915_gem_object_pin_map(ctx_obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\tret = PTR_ERR(vaddr);\n\t\tDRM_DEBUG_DRIVER(\"Could not map object pages! (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tset_redzone(vaddr, engine);\n\tif (engine->default_state) {\n\t\tvoid *defaults;\n\t\tdefaults = i915_gem_object_pin_map(engine->default_state,\n\t\t\t\t\t\t   I915_MAP_WB);\n\t\tif (IS_ERR(defaults)) {\n\t\t\tret = PTR_ERR(defaults);\n\t\t\tgoto err_unpin_ctx;\n\t\t}\n\t\tmemcpy(vaddr, defaults, engine->context_size);\n\t\ti915_gem_object_unpin_map(engine->default_state);\n\t\tinhibit = false;\n\t}\n\tregs = vaddr + LRC_STATE_PN * PAGE_SIZE;\n\texeclists_init_reg_state(regs, ce, engine, ring, inhibit);\n\tif (inhibit)\n\t\tregs[CTX_CONTEXT_CONTROL] |=\n\t\t\t_MASKED_BIT_ENABLE(CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT);\n\tret = 0;\nerr_unpin_ctx:\n\t__i915_gem_object_flush_map(ctx_obj, 0, engine->context_size);\n\ti915_gem_object_unpin_map(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "static int ssl_get_remaining_space_in_datagram( mbedtls_ssl_context const *ssl )\n{\n    size_t const bytes_written = ssl->out_left;\n    size_t const mtu           = ssl_get_maximum_datagram_size( ssl );\n    if( bytes_written > mtu )\n    {\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    return( (int) ( mtu - bytes_written ) );\n}", "target": 0}
{"code": "static int ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ps_data *ps, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tif (local->tim_in_locked_section) {\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb);\n\t} else {\n\t\tspin_lock_bh(&local->tim_lock);\n\t\t__ieee80211_beacon_add_tim(sdata, ps, skb);\n\t\tspin_unlock_bh(&local->tim_lock);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "header_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\t} ;\n} ", "target": 1}
{"code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}", "target": 1}
{"code": "    bool chunked() const { return has(Http::HdrType::TRANSFER_ENCODING); }", "target": 0}
{"code": "static int pfkey_do_dump(struct pfkey_sock *pfk)\n{\n\tstruct sadb_msg *hdr;\n\tint rc;\n\trc = pfk->dump.dump(pfk);\n\tif (rc == -ENOBUFS)\n\t\treturn 0;\n\tif (pfk->dump.skb) {\n\t\tif (!pfkey_can_dump(&pfk->sk))\n\t\t\treturn 0;\n\t\thdr = (struct sadb_msg *) pfk->dump.skb->data;\n\t\thdr->sadb_msg_seq = 0;\n\t\thdr->sadb_msg_errno = rc;\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\t\tpfk->dump.skb = NULL;\n\t}\n\tpfkey_terminate_dump(pfk);\n\treturn rc;\n}", "target": 0}
{"code": "   static void  Ins_JMPR( INS_ARG )\n   {\n     CUR.IP      += (Int)(args[0]);\n     CUR.step_ins = FALSE;\n     * allow for simple cases here by just checking the preceding byte.\n     * Fonts with this problem are not uncommon.\n     */\n      CUR.IP -= 1;\n  }", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n}", "target": 1}
{"code": "static int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\tSCTP_DEBUG_PRINTK(\"sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)\\n\",\n\t\t\t  sk, addrs, addrcnt);\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tsa_addr = (union sctp_addr *)addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void Document::open()\n{\n    ASSERT(!importLoader());\n    if (m_frame) {\n        if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {\n            if (parser->isParsing()) {\n                if (parser->isExecutingScript())\n                    return;\n                if (!parser->wasCreatedByScript() && parser->hasInsertionPoint())\n                    return;\n            }\n        }\n        if (m_frame->loader().provisionalDocumentLoader())\n            m_frame->loader().stopAllLoaders();\n    }\n    removeAllEventListenersRecursively();\n    implicitOpen(ForceSynchronousParsing);\n    if (ScriptableDocumentParser* parser = scriptableDocumentParser())\n        parser->setWasCreatedByScript(true);\n     if (m_frame)\n         m_frame->loader().didExplicitOpen();\n    if (m_loadEventProgress != LoadEventInProgress && m_loadEventProgress != UnloadEventInProgress)\n         m_loadEventProgress = LoadEventNotRun;\n }", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "_parse_pat (GstMpegtsSection * section)\n{\n  GPtrArray *pat;\n  guint16 i = 0, nb_programs;\n  GstMpegtsPatProgram *program;\n  guint8 *data, *end;\n  data = section->data + 8;\n  end = section->data + section->section_length;\n  nb_programs = (end - 4 - data) / 4;\n  pat =\n      g_ptr_array_new_full (nb_programs,\n      (GDestroyNotify) _mpegts_pat_program_free);\n  while (data < end - 4) {\n    program = g_slice_new0 (GstMpegtsPatProgram);\n    program->program_number = GST_READ_UINT16_BE (data);\n    data += 2;\n    program->network_or_program_map_PID = GST_READ_UINT16_BE (data) & 0x1FFF;\n    data += 2;\n    g_ptr_array_index (pat, i) = program;\n    i++;\n  }\n  pat->len = nb_programs;\n  if (data != end - 4) {\n    GST_ERROR (\"at the end of PAT data != end - 4\");\n    g_ptr_array_unref (pat);\n    return NULL;\n  }\n  return (gpointer) pat;\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tresult = current_dir + filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\\n\";\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\\n\";\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\\n\";\n\treturn result;\n}", "target": 1}
{"code": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                           \"Control character detected in URL.\");\n             return HTTP_BAD_REQUEST;\n         }\n     }\n     return OK;\n}", "target": 1}
{"code": "static struct nft_chain *nf_tables_chain_lookup(const struct nft_table *table,\n\t\t\t\t\t\tconst struct nlattr *nla)\n{\n\tstruct nft_chain *chain;\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\tlist_for_each_entry(chain, &table->chains, list) {\n\t\tif (!nla_strcmp(nla, chain->name))\n\t\t\treturn chain;\n\t}\n\treturn ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const\n{\n if (mHeap == 0) {\n Parcel data, reply;\n        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());\n if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {\n            sp<IBinder> heap = reply.readStrongBinder();\n ssize_t o = reply.readInt32();\n size_t s = reply.readInt32();\n             if (heap != 0) {\n                 mHeap = interface_cast<IMemoryHeap>(heap);\n                 if (mHeap != 0) {\n                    mOffset = o;\n                    mSize = s;\n                 }\n             }\n         }\n     }\n     if (offset) *offset = mOffset;\n     if (size) *size = mSize;\n    return mHeap;\n }", "target": 1}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": " static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n {\n \t++vcpu->stat.insn_emulation_fail;\n \ttrace_kvm_emulate_insn_failed(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\tvcpu->run->internal.ndata = 0;\n \tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn EMULATE_FAIL;\n }", "target": 1}
{"code": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }", "target": 1}
{"code": "int local_memory_node(int node)\n{\n\tstruct zoneref *z;\n\tz = first_zones_zonelist(node_zonelist(node, GFP_KERNEL),\n\t\t\t\t   gfp_zone(GFP_KERNEL),\n\t\t\t\t   NULL);\n\treturn z->zone->node;\n}", "target": 0}
{"code": "HttpStateData::finishingBrokenPost()\n{\n#if USE_HTTP_VIOLATIONS\n    if (!Config.accessList.brokenPosts) {\n        debugs(11, 5, HERE << \"No brokenPosts list\");\n        return false;\n    }\n    ACLFilledChecklist ch(Config.accessList.brokenPosts, originalRequest(), NULL);\n    ch.al = fwd->al;\n    ch.syncAle(originalRequest(), nullptr);\n    if (!ch.fastCheck().allowed()) {\n        debugs(11, 5, HERE << \"didn't match brokenPosts\");\n        return false;\n    }\n    if (!Comm::IsConnOpen(serverConnection)) {\n        debugs(11, 3, HERE << \"ignoring broken POST for closed \" << serverConnection);\n        assert(closeHandler != NULL);\n        return true; \n    }\n    debugs(11, 3, \"finishingBrokenPost: fixing broken POST\");\n    typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;\n    requestSender = JobCallback(11,5,\n                                Dialer, this, HttpStateData::wroteLast);\n    Comm::Write(serverConnection, \"\\r\\n\", 2, requestSender, NULL);\n    return true;\n#else\n    return false;\n#endif \n}", "target": 0}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "static int create_srq_ring(PCIDevice *pci_dev, PvrdmaRing **ring,\n                           uint64_t pdir_dma, uint32_t max_wr,\n                           uint32_t max_sge, uint32_t nchunks)\n{\n    uint64_t *dir = NULL, *tbl = NULL;\n    PvrdmaRing *r;\n    int rc = -EINVAL;\n    char ring_name[MAX_RING_NAME_SZ];\n    uint32_t wqe_sz;\n    if (!nchunks || nchunks > PVRDMA_MAX_FAST_REG_PAGES) {\n        rdma_error_report(\"Got invalid page count for SRQ ring: %d\",\n                          nchunks);\n        return rc;\n    }\n    dir = rdma_pci_dma_map(pci_dev, pdir_dma, TARGET_PAGE_SIZE);\n    if (!dir) {\n        rdma_error_report(\"Failed to map to SRQ page directory\");\n        goto out;\n    }\n    tbl = rdma_pci_dma_map(pci_dev, dir[0], TARGET_PAGE_SIZE);\n    if (!tbl) {\n        rdma_error_report(\"Failed to map to SRQ page table\");\n        goto out;\n    }\n    r = g_malloc(sizeof(*r));\n    *ring = r;\n    r->ring_state = (PvrdmaRingState *)\n            rdma_pci_dma_map(pci_dev, tbl[0], TARGET_PAGE_SIZE);\n    if (!r->ring_state) {\n        rdma_error_report(\"Failed to map tp SRQ ring state\");\n        goto out_free_ring_mem;\n    }\n    wqe_sz = pow2ceil(sizeof(struct pvrdma_rq_wqe_hdr) +\n                      sizeof(struct pvrdma_sge) * max_sge - 1);\n    sprintf(ring_name, \"srq_ring_%\" PRIx64, pdir_dma);\n    rc = pvrdma_ring_init(r, ring_name, pci_dev, &r->ring_state[1], max_wr,\n                          wqe_sz, (dma_addr_t *)&tbl[1], nchunks - 1);\n    if (rc) {\n        goto out_unmap_ring_state;\n    }\n    goto out;\nout_unmap_ring_state:\n    rdma_pci_dma_unmap(pci_dev, r->ring_state, TARGET_PAGE_SIZE);\nout_free_ring_mem:\n    g_free(r);\nout:\n    rdma_pci_dma_unmap(pci_dev, tbl, TARGET_PAGE_SIZE);\n    rdma_pci_dma_unmap(pci_dev, dir, TARGET_PAGE_SIZE);\n    return rc;\n}", "target": 0}
{"code": "static void kvm_guest_cpu_offline(void *dummy)\n{\n\tkvm_disable_steal_time();\n\tif (kvm_para_has_feature(KVM_FEATURE_PV_EOI))\n\t\twrmsrl(MSR_KVM_PV_EOI_EN, 0);\n\tkvm_pv_disable_apf();\n\tapf_task_wake_all();\n}", "target": 0}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 1}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "static ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CONSISTENCY_CHECKS));\n}", "target": 0}
{"code": " static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n \tut32 i = 0;\n \twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n \t}\n \tif (buf[i] != eoc) {\n \t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 1}
{"code": "static void zipfileResetCursor(ZipfileCsr *pCsr){\n  ZipfileEntry *p;\n  ZipfileEntry *pNext;\n  pCsr->bEof = 0;\n  if( pCsr->pFile ){\n    fclose(pCsr->pFile);\n    pCsr->pFile = 0;\n    zipfileEntryFree(pCsr->pCurrent);\n    pCsr->pCurrent = 0;\n  }\n  for(p=pCsr->pFreeEntry; p; p=pNext){\n    pNext = p->pNext;\n    zipfileEntryFree(p);\n  }\n}", "target": 0}
{"code": "authdir_wants_to_reject_router(routerinfo_t *ri, const char **msg,\n                               int complain, int *valid_out)\n{\n  time_t now;\n  int severity = (complain && ri->contact_info) ? LOG_NOTICE : LOG_INFO;\n  uint32_t status = dirserv_router_get_status(ri, msg, severity);\n  tor_assert(msg);\n  if (status & FP_REJECT)\n    return -1; \n  now = time(NULL);\n  if (ri->cache_info.published_on > now+ROUTER_ALLOW_SKEW) {\n    log_fn(severity, LD_DIRSERV, \"Publication time for %s is too \"\n           \"far (%d minutes) in the future; possible clock skew. Not adding \"\n           \"(%s)\",\n           router_describe(ri),\n           (int)((ri->cache_info.published_on-now)/60),\n           esc_router_info(ri));\n    *msg = \"Rejected: Your clock is set too far in the future, or your \"\n      \"timezone is not correct.\";\n    return -1;\n  }\n  if (ri->cache_info.published_on < now-ROUTER_MAX_AGE_TO_PUBLISH) {\n    log_fn(severity, LD_DIRSERV,\n           \"Publication time for %s is too far \"\n           \"(%d minutes) in the past. Not adding (%s)\",\n           router_describe(ri),\n           (int)((now-ri->cache_info.published_on)/60),\n           esc_router_info(ri));\n    *msg = \"Rejected: Server is expired, or your clock is too far in the past,\"\n      \" or your timezone is not correct.\";\n    return -1;\n  }\n  if (dirserv_router_has_valid_address(ri) < 0) {\n    log_fn(severity, LD_DIRSERV,\n           \"Router %s has invalid address. Not adding (%s).\",\n           router_describe(ri),\n           esc_router_info(ri));\n    *msg = \"Rejected: Address is a private address.\";\n    return -1;\n  }\n  *valid_out = ! (status & FP_INVALID);\n  return 0;\n}", "target": 0}
{"code": "static void uivector_init(uivector* p)\n{\n  p->data = NULL;\n  p->size = p->allocsize = 0;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "uint8_t WasmBinaryBuilder::getLaneIndex(size_t lanes) {\n  BYN_TRACE(\"<==\\n\");\n  auto ret = getInt8();\n  if (ret >= lanes) {\n    throwError(\"Illegal lane index\");\n  }\n  BYN_TRACE(\"getLaneIndex(\" << lanes << \"): \" << ret << \" ==>\" << std::endl);\n  return ret;\n}", "target": 0}
{"code": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "static int find_subprog(struct bpf_verifier_env *env, int off)\n{\n\tstruct bpf_subprog_info *p;\n\tp = bsearch(&off, env->subprog_info, env->subprog_cnt,\n\t\t    sizeof(env->subprog_info[0]), cmp_subprogs);\n\tif (!p)\n\t\treturn -ENOENT;\n\treturn p - env->subprog_info;\n}", "target": 0}
{"code": "fill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (sourcing_a_script(eap))\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}", "target": 0}
{"code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n }", "target": 1}
{"code": "bool NavigationController::RendererDidNavigate(\n    const ViewHostMsg_FrameNavigate_Params& params,\n    int extra_invalidate_flags,\n    LoadCommittedDetails* details) {\n  if (GetLastCommittedEntry()) {\n    details->previous_url = GetLastCommittedEntry()->url();\n    details->previous_entry_index = last_committed_entry_index();\n  } else {\n    details->previous_url = GURL();\n    details->previous_entry_index = -1;\n  }\n  if (pending_entry_index_ >= 0 && !pending_entry_->site_instance()) {\n    DCHECK(pending_entry_->restore_type() != NavigationEntry::RESTORE_NONE);\n    pending_entry_->set_site_instance(tab_contents_->GetSiteInstance());\n    pending_entry_->set_restore_type(NavigationEntry::RESTORE_NONE);\n  }\n  details->is_in_page = IsURLInPageNavigation(params.url);\n  details->type = ClassifyNavigation(params);\n  switch (details->type) {\n    case NavigationType::NEW_PAGE:\n      RendererDidNavigateToNewPage(params, &(details->did_replace_entry));\n      break;\n    case NavigationType::EXISTING_PAGE:\n      RendererDidNavigateToExistingPage(params);\n      break;\n    case NavigationType::SAME_PAGE:\n      RendererDidNavigateToSamePage(params);\n      break;\n    case NavigationType::IN_PAGE:\n      RendererDidNavigateInPage(params, &(details->did_replace_entry));\n      break;\n    case NavigationType::NEW_SUBFRAME:\n      RendererDidNavigateNewSubframe(params);\n      break;\n    case NavigationType::AUTO_SUBFRAME:\n      if (!RendererDidNavigateAutoSubframe(params))\n         return false;\n       break;\n     case NavigationType::NAV_IGNORE:\n       return false;\n     default:\n       NOTREACHED();\n  }\n  DCHECK(!params.content_state.empty());\n  NavigationEntry* active_entry = GetActiveEntry();\n  active_entry->set_content_state(params.content_state);\n  DCHECK(active_entry->site_instance() == tab_contents_->GetSiteInstance());\n  details->is_auto = (PageTransition::IsRedirect(params.transition) &&\n                      !pending_entry()) ||\n      params.gesture == NavigationGestureAuto;\n  details->entry = active_entry;\n  details->is_main_frame = PageTransition::IsMainFrame(params.transition);\n  details->serialized_security_info = params.security_info;\n  details->http_status_code = params.http_status_code;\n  NotifyNavigationEntryCommitted(details, extra_invalidate_flags);\n  return true;\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "SPL_METHOD(SplObjectStorage, rewind)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} ", "target": 0}
{"code": "static void sco_sock_clear_timer(struct sock *sk)\n{\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tsk_stop_timer(sk, &sk->sk_timer);\n}", "target": 0}
{"code": "isdn_minor2drv(int minor)\n{\n\treturn (dev->drvmap[minor]);\n}", "target": 0}
{"code": "update_job_run (updateJobPtr job)\n{\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\tif (strstr (job->request->source, \":\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "static void __init check_tylersburg_isoch(void)\n{\n\tstruct pci_dev *pdev;\n\tuint32_t vtisochctrl;\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x3a3e, NULL);\n\tif (!pdev)\n\t\treturn;\n\tpci_dev_put(pdev);\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x342e, NULL);\n\tif (!pdev)\n\t\treturn;\n\tif (pci_read_config_dword(pdev, 0x188, &vtisochctrl)) {\n\t\tpci_dev_put(pdev);\n\t\treturn;\n\t}\n\tpci_dev_put(pdev);\n\tif (vtisochctrl & 1)\n\t\treturn;\n\tvtisochctrl &= 0x1c;\n\tif (vtisochctrl == 0x10)\n\t\treturn;\n\tif (!vtisochctrl) {\n\t\tWARN(1, \"Your BIOS is broken; DMA routed to ISOCH DMAR unit but no TLB space.\\n\"\n\t\t     \"BIOS vendor: %s; Ver: %s; Product Version: %s\\n\",\n\t\t     dmi_get_system_info(DMI_BIOS_VENDOR),\n\t\t     dmi_get_system_info(DMI_BIOS_VERSION),\n\t\t     dmi_get_system_info(DMI_PRODUCT_VERSION));\n\t\tiommu_identity_mapping |= IDENTMAP_AZALIA;\n\t\treturn;\n\t}\n\tpr_warn(\"Recommended TLB entries for ISOCH unit is 16; your BIOS set %d\\n\",\n\t       vtisochctrl);\n}", "target": 0}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "void disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\tpiter->flags = flags;\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static struct k_itimer *__posix_timers_find(struct hlist_head *head,\n\t\t\t\t\t    struct signal_struct *sig,\n\t\t\t\t\t    timer_t id)\n{\n\tstruct k_itimer *timer;\n\thlist_for_each_entry_rcu(timer, head, t_hash) {\n\t\tif ((timer->it_signal == sig) && (timer->it_id == id))\n\t\t\treturn timer;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tctxt->eip = ctxt->_eip;\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = 0;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "static cfg_value_t *cfg_opt_getval(cfg_opt_t *opt, unsigned int index)\n{\n\tcfg_value_t *val = NULL;\n\tif (index != 0 && !is_set(CFGF_LIST, opt->flags) && !is_set(CFGF_MULTI, opt->flags)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (opt->simple_value.ptr)\n\t\tval = (cfg_value_t *)opt->simple_value.ptr;\n\telse {\n\t\tif (is_set(CFGF_RESET, opt->flags)) {\n\t\t\tcfg_free_value(opt);\n\t\t\topt->flags &= ~CFGF_RESET;\n\t\t}\n\t\tif (index >= opt->nvalues)\n\t\t\tval = cfg_addval(opt);\n\t\telse\n\t\t\tval = opt->values[index];\n\t}\n\treturn val;\n}", "target": 0}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "static ChannelSecurityOptions *reds_find_channel_security(RedsState *reds, int id)\n{\n    ChannelSecurityOptions *now = reds->config->channels_security;\n    while (now && now->channel_id != id) {\n        now = now->next;\n    }\n    return now;\n}", "target": 0}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "rgb2rgba(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = 255;\n        in++;\n    }\n}", "target": 0}
{"code": "static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res)\n\t\treturn -ENOMEM;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t}\nout:\n\tkfree(child_res);\n\treturn ret;\n}", "target": 1}
{"code": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}", "target": 1}
{"code": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}", "target": 0}
{"code": "posix_acl_xattr_list(struct dentry *dentry)\n{\n\treturn IS_POSIXACL(d_backing_inode(dentry));\n}", "target": 0}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "httpd_compress(isc_httpd_t *httpd) {\n\tz_stream zstr;\n\tisc_region_t r;\n\tint ret;\n\tint inputlen;\n\tinputlen = isc_buffer_usedlength(&httpd->bodybuffer);\n\talloc_compspace(httpd, inputlen);\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tmemset(&zstr, 0, sizeof(zstr));\n\tzstr.total_in = zstr.avail_in = zstr.total_out = zstr.avail_out =\n\t\tinputlen;\n\tzstr.next_in = isc_buffer_base(&httpd->bodybuffer);\n\tzstr.next_out = r.base;\n\tret = deflateInit(&zstr, Z_DEFAULT_COMPRESSION);\n\tif (ret == Z_OK) {\n\t\tret = deflate(&zstr, Z_FINISH);\n\t}\n\tdeflateEnd(&zstr);\n\tif (ret == Z_STREAM_END) {\n\t\tisc_buffer_add(&httpd->compbuffer, inputlen - zstr.avail_out);\n\t\treturn (ISC_R_SUCCESS);\n\t} else {\n\t\treturn (ISC_R_FAILURE);\n\t}\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 1}
{"code": "static int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %d; voff[%d] = %d\\n\", compno,\n\t\t  comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static DBusConnection *si_dbus_get_system_bus(void)\n{\n    DBusConnection *connection;\n    DBusError error;\n    dbus_error_init(&error);\n    connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, &error);\n    if (connection == NULL || dbus_error_is_set(&error)) {\n        if (dbus_error_is_set(&error)) {\n            syslog(LOG_WARNING, \"Unable to connect to system bus: %s\",\n                   error.message);\n            dbus_error_free(&error);\n        } else {\n            syslog(LOG_WARNING, \"Unable to connect to system bus\");\n        }\n        return NULL;\n    }\n    return connection;\n}", "target": 0}
{"code": "    CImg<ulongT> get_label(const bool is_high_connectivity=false,\n                           const Tfloat tolerance=0) const {\n      if (is_empty()) return CImg<ulongT>();\n      int dx[13], dy[13], dz[13], nb = 0;\n      dx[nb] = 1; dy[nb] = 0; dz[nb++] = 0;\n      dx[nb] = 0; dy[nb] = 1; dz[nb++] = 0;\n      if (is_high_connectivity) {\n        dx[nb] = 1; dy[nb] = 1; dz[nb++] = 0;\n        dx[nb] = 1; dy[nb] = -1; dz[nb++] = 0;\n      }\n      if (_depth>1) { \n        dx[nb] = 0; dy[nb] = 0; dz[nb++]=1;\n        if (is_high_connectivity) {\n          dx[nb] = 1; dy[nb] = 1; dz[nb++] = -1;\n          dx[nb] = 1; dy[nb] = 0; dz[nb++] = -1;\n          dx[nb] = 1; dy[nb] = -1; dz[nb++] = -1;\n          dx[nb] = 0; dy[nb] = 1; dz[nb++] = -1;\n          dx[nb] = 0; dy[nb] = 1; dz[nb++] = 1;\n          dx[nb] = 1; dy[nb] = -1; dz[nb++] = 1;\n          dx[nb] = 1; dy[nb] = 0; dz[nb++] = 1;\n          dx[nb] = 1; dy[nb] = 1; dz[nb++] = 1;\n        }\n      }\n      return _label(nb,dx,dy,dz,tolerance);", "target": 0}
{"code": "PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ENCHANT_GET_BROKER;\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\tif (!s)\n\t\treturn NULL;\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}", "target": 1}
{"code": "void SVGImage::setContainerSize(const IntSize& size)\n{\n    if (!m_page || !usesContainerSize())\n        return;\n    LocalFrame* frame = m_page->mainFrame();\n     SVGSVGElement* rootElement = toSVGDocument(frame->document())->rootElement();\n     if (!rootElement)\n         return;\n    RenderSVGRoot* renderer = toRenderSVGRoot(rootElement->renderer());\n    if (!renderer)\n        return;\n     FrameView* view = frameView();\n     view->resize(this->containerSize());\n     renderer->setContainerSize(size);\n }", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static void apply_independent_coupling(AACContext *ac,\n                                       SingleChannelElement *target,\n                                       ChannelElement *cce, int index)\n{\n    int i;\n    const float gain = cce->coup.gain[index][0];\n    const float *src = cce->ch[0].ret;\n    float *dest = target->ret;\n    const int len = 1024 << (ac->oc[1].m4ac.sbr == 1);\n    for (i = 0; i < len; i++)\n        dest[i] += gain * src[i];\n}", "target": 0}
{"code": "yang_fill_include(struct lys_module *trg, char *value, struct lys_include *inc,\n                  struct unres_schema *unres)\n{\n    const char *str;\n    int rc;\n    int ret = 0;\n    str = lydict_insert_zc(trg->ctx, value);\n    rc = lyp_check_include(trg, str, inc, unres);\n    if (!rc) {\n        memcpy(&trg->inc[trg->inc_size], inc, sizeof *inc);\n        if (yang_check_ext_instance(trg, &trg->inc[trg->inc_size].ext, trg->inc[trg->inc_size].ext_size,\n                                    &trg->inc[trg->inc_size], unres)) {\n            ret = -1;\n        }\n        trg->inc_size++;\n    } else if (rc == -1) {\n        lys_extension_instances_free(trg->ctx, inc->ext, inc->ext_size, NULL);\n        ret = -1;\n    }\n    lydict_remove(trg->ctx, str);\n    return ret;\n}", "target": 0}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "BOOL license_read_product_info(wStream* s, PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, productInfo->dwVersion); \n\tStream_Read_UINT32(s, productInfo->cbCompanyName); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName + 4)\n\t\treturn FALSE;\n\tproductInfo->pbCompanyName = (BYTE*) malloc(productInfo->cbCompanyName);\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\tStream_Read_UINT32(s, productInfo->cbProductId); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tproductInfo->pbCompanyName = NULL;\n\t\treturn FALSE;\n\t}\n\tproductInfo->pbProductId = (BYTE*) malloc(productInfo->cbProductId);\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n}", "target": 0}
{"code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n    memset(&txcq_descr, 0, sizeof(txcq_descr));\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n    txcq_descr.val1 = cpu_to_le32(txcq_descr.val1);\n    txcq_descr.val2 = cpu_to_le32(txcq_descr.val2);\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n    smp_wmb();\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}", "target": 0}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "\tTEST_METHOD(7) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation = dir.newGeneration(true,\n\t\t\t\"nobody\", nobodyGroup, 0, 0);\n\t\tstring path = generation->getPath();\n\t\tgeneration.reset();\n\t\tensure_equals(getFileType(path), FT_NONEXISTANT);\n\t}", "target": 0}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}", "target": 0}
{"code": "adium_info_dup_path_for_variant (GHashTable *info,\n\t\t\t\t const gchar *variant)\n{\n\tguint version = adium_info_get_version (info);\n\tconst gchar *no_variant = adium_info_get_no_variant_name (info);\n\tGPtrArray *variants;\n\tguint i;\n\tif (version <= 2 && !tp_strdiff (variant, no_variant)) {\n\t\treturn g_strdup (\"main.css\");\n\t}\n\tvariants = empathy_adium_info_get_available_variants (info);\n\tif (variants->len == 0)\n\t\treturn g_strdup (\"main.css\");\n\tfor (i = 0; i < variants->len; i++) {\n\t\tif (!tp_strdiff (variant, g_ptr_array_index (variants, i))) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == variants->len) {\n\t\tDEBUG (\"Variant %s does not exist\", variant);\n\t\tvariant = g_ptr_array_index (variants, 0);\n\t}\n\treturn g_strdup_printf (\"Variants/%s.css\", variant);\n}", "target": 0}
{"code": "xfs_perag_clear_reclaim_tag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tlockdep_assert_held(&pag->pag_ici_lock);\n\tif (--pag->pag_ici_reclaimable)\n\t\treturn;\n\tspin_lock(&mp->m_perag_lock);\n\tradix_tree_tag_clear(&mp->m_perag_tree, pag->pag_agno,\n\t\t\t     XFS_ICI_RECLAIM_TAG);\n\tspin_unlock(&mp->m_perag_lock);\n\ttrace_xfs_perag_clear_reclaim(mp, pag->pag_agno, -1, _RET_IP_);\n}", "target": 0}
{"code": "static int pfifo_fast_init(struct Qdisc *qdisc, struct nlattr *opt)\n{\n\tint prio;\n\tstruct sk_buff_head *list = qdisc_priv(qdisc);\n\tfor (prio = 0; prio < PFIFO_FAST_BANDS; prio++)\n\t\tskb_queue_head_init(list + prio);\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, tmpName, to_read);\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "TEST(QuantizedUInt8PoolingOpTest, MaxPoolActivationRelu1) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU_N1_TO_1);\n  m.SetInput({\n      -1.7, -6, 2, 4,  \n      -3, -2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({-1.0, 1.0})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({120, 136}));\n  m.SetInput({\n      0, -6, -0.2, -0.4,    \n      -3, -2, 0.75, -0.99,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 134}));\n}", "target": 0}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "sec_connect(char *server, char *username, char *domain, char *password, RD_BOOL reconnect)\n{\n\tuint32 selected_proto;\n\tstruct stream mcs_data;\n\tif (!mcs_connect_start(server, username, domain, password, reconnect, &selected_proto))\n\t\treturn False;\n\tmcs_data.size = 512;\n\tmcs_data.p = mcs_data.data = (uint8 *) xmalloc(mcs_data.size);\n\tsec_out_mcs_data(&mcs_data, selected_proto);\n\tif (!mcs_connect_finalize(&mcs_data))\n\t\treturn False;\n\tif (g_encryption)\n\t\tsec_establish_key();\n\txfree(mcs_data.data);\n\treturn True;\n}", "target": 0}
{"code": "static void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}", "target": 0}
{"code": "static inline float *VMUL2S(float *dst, const float *v, unsigned idx,\n                            unsigned sign, const float *scale)\n{\n    union av_intfloat32 s0, s1;\n    s0.f = s1.f = *scale;\n    s0.i ^= sign >> 1 << 31;\n    s1.i ^= sign      << 31;\n    *dst++ = v[idx    & 15] * s0.f;\n    *dst++ = v[idx>>4 & 15] * s1.f;\n    return dst;\n}", "target": 0}
{"code": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}", "target": 1}
{"code": "xfs_iunlink_init(\n\tstruct xfs_perag\t*pag)\n{\n\treturn rhashtable_init(&pag->pagi_unlinked_hash,\n\t\t\t&xfs_iunlink_hash_params);\n}", "target": 0}
{"code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n \t\tRETURN_FALSE;\n \t}\n \tZ_STRVAL_P(return_value) = emalloc(len + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 1}
{"code": "static ssize_t tx_maxrate_store(struct netdev_queue *queue,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct net_device *dev = queue->dev;\n\tint err, index = get_netdev_queue_index(queue);\n\tu32 rate = 0;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\terr = kstrtou32(buf, 10, &rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\terr = -EOPNOTSUPP;\n\tif (dev->netdev_ops->ndo_set_tx_maxrate)\n\t\terr = dev->netdev_ops->ndo_set_tx_maxrate(dev, index, rate);\n\trtnl_unlock();\n\tif (!err) {\n\t\tqueue->tx_maxrate = rate;\n\t\treturn len;\n\t}\n\treturn err;", "target": 0}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "PHPAPI int php_lint_script(zend_file_handle *file)\n{\n\tzend_op_array *op_array;\n\tint retval = FAILURE;\n\tzend_try {\n\t\top_array = zend_compile_file(file, ZEND_INCLUDE);\n\t\tzend_destroy_file_handle(file);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t\tretval = SUCCESS;\n\t\t}\n\t} zend_end_try();\n\tif (EG(exception)) {\n\t\tzend_exception_error(EG(exception), E_ERROR);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static unsigned int floppy_check_events(struct gendisk *disk,\n\t\t\t\t\tunsigned int clearing)\n{\n\tint drive = (long)disk->private_data;\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\tif (time_after(jiffies, UDRS->last_checked + UDP->checkfreq)) {\n\t\tif (lock_fdc(drive))\n\t\t\treturn 0;\n\t\tpoll_drive(false, 0);\n\t\tprocess_fd_request();\n\t}\n\tif (test_bit(FD_DISK_CHANGED_BIT, &UDRS->flags) ||\n\t    test_bit(FD_VERIFY_BIT, &UDRS->flags) ||\n\t    test_bit(drive, &fake_change) ||\n\t    drive_no_geom(drive))\n\t\treturn DISK_EVENT_MEDIA_CHANGE;\n\treturn 0;\n}", "target": 0}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tint type = cb->nlh->nlmsg_type-RTM_BASE;\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\t\tif (rtnl_msg_handlers[idx] == NULL ||\n\t\t    rtnl_msg_handlers[idx][type].dumpit == NULL)\n\t\t\tcontinue;\n\t\tif (idx > s_idx) {\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\t\tcb->prev_seq = 0;\n\t\t\tcb->seq = 0;\n\t\t}\n\t\tif (rtnl_msg_handlers[idx][type].dumpit(skb, cb))\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *visual = NULL;\t\n\tPyObject *result = NULL;\t\n\tint length = PyUnicode_GET_SIZE (unicode);\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\treturn result;\n}", "target": 1}
{"code": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "static void __exit packet_exit(void)\n{\n\tunregister_netdevice_notifier(&packet_netdev_notifier);\n\tunregister_pernet_subsys(&packet_net_ops);\n\tsock_unregister(PF_PACKET);\n\tproto_unregister(&packet_proto);\n}", "target": 0}
{"code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "static void* socketio_CloneOption(const char* name, const void* value)\n{\n    void* result;\n    if (name != NULL)\n    {\n        result = NULL;\n        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n            if (value == NULL)\n            {\n                LogError(\"Failed cloning option %s (value is NULL)\", name);\n            }\n            else\n            {\n                if ((result = malloc(sizeof(char) * (strlen((char*)value) + 1))) == NULL)\n                {\n                    LogError(\"Failed cloning option %s (malloc failed)\", name);\n                }\n                else\n                {\n                    strcpy((char *)result, (char *)value);\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Cannot clone option %s (not suppported)\", name);\n        }\n    }\n    else\n    {\n        result = NULL;\n    }\n    return result;\n}", "target": 1}
{"code": "static void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}", "target": 0}
{"code": "static int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int evdev_open_device(struct evdev *evdev)\n{\n\tint retval;\n\tretval = mutex_lock_interruptible(&evdev->mutex);\n\tif (retval)\n\t\treturn retval;\n\tif (!evdev->exist)\n\t\tretval = -ENODEV;\n\telse if (!evdev->open++) {\n\t\tretval = input_open_device(&evdev->handle);\n\t\tif (retval)\n\t\t\tevdev->open--;\n\t}\n\tmutex_unlock(&evdev->mutex);\n\treturn retval;\n}", "target": 0}
{"code": "static void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}", "target": 0}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "int _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel,\n                           uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_off;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "static int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn err;\n}", "target": 0}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n\tstring->space = 1;\n       else\n\tstring->space *= 2;\n      if (string->space < 0)\n \t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n \t}\n     }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "static int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; \n\tif (addr_size == 1) \n\t\t*ret &= 0xffffffff;\n\treturn 0;\n}", "target": 0}
{"code": "static int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n        sep = \", \";\n        sep_len = 2;\n        cur = cur->next;\n    }\n    *p = '\\0';\n    *size = n;\n    *buf = p;\n    return( 0 );\n}", "target": 0}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "void ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isAttributeSupported(JSStringRef attribute)\n{\n    return false;\n}", "target": 0}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "cdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static int domain_update_iommu_superpage(struct intel_iommu *skip)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tint mask = 0xf;\n\tif (!intel_iommu_superpage) {\n\t\treturn 0;\n\t}\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (iommu != skip) {\n\t\t\tmask &= cap_super_page_val(iommu->cap);\n\t\t\tif (!mask)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn fls(mask);\n}", "target": 0}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n  if (*re_ast == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n   (*re_ast)->flags = 0;\n   (*re_ast)->root_node = NULL;\n   return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static ssize_t show_rxbuf(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", NET_RX_RING_SIZE);\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n {\n     void **ptrptr = ptr;\n     *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n         return AVERROR(ENOMEM);\n     return 0;\n }", "target": 1}
{"code": "SampleEncrypter::EncryptAudioSample(AP4_DataBuffer& sample, AP4_SampleDescription* sample_description)\n{\n    if (sample.GetDataSize() <= 16) {\n        return AP4_SUCCESS;\n    }\n    if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n        AP4_UI08*    data      = sample.UseData();\n        unsigned int data_size = sample.GetDataSize();\n        while (data_size > 4) {\n            unsigned int syncword = (data[0]<<8) | data[1];\n            if (syncword != 0x0b77) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            unsigned int frmsiz = 1+(((data[2]<<8)|(data[3]))&0x7FF);\n            unsigned int frame_size = 2*frmsiz;\n            if (data_size < frame_size) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            if (frame_size > 16) {\n                unsigned int encrypted_block_count = (frame_size-16)/16;\n                AP4_Size encrypted_size = encrypted_block_count*16;\n                m_StreamCipher->SetIV(m_IV);\n                m_StreamCipher->ProcessBuffer(data+16, encrypted_size, data+16, &encrypted_size);\n            }\n            data      += frame_size;\n            data_size -= frame_size;\n        }\n    } else {\n        unsigned int encrypted_block_count = (sample.GetDataSize()-16)/16;\n        AP4_Size encrypted_size = encrypted_block_count*16;\n        m_StreamCipher->SetIV(m_IV);\n        m_StreamCipher->ProcessBuffer(sample.UseData()+16, encrypted_size, sample.UseData()+16, &encrypted_size);\n    }\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "int read_record_hdr(int ifd, void *buffer, struct record_header *record_hdr,\n\t\t    struct file_header *file_hdr, int arch_64, int endian_mismatch,\n\t\t    int oneof, size_t b_size)\n{\n\tint rc;\n\tdo {\n\t\tif ((rc = sa_fread(ifd, buffer, (size_t) file_hdr->rec_size, SOFT_SIZE, oneof)) != 0)\n\t\t\treturn rc;\n\t\tif (remap_struct(rec_types_nr, file_hdr->rec_types_nr, buffer,\n\t\t\t\t file_hdr->rec_size, RECORD_HEADER_SIZE, b_size) < 0)\n\t\t\treturn 2;\n\t\tmemcpy(record_hdr, buffer, RECORD_HEADER_SIZE);\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(rec_types_nr, record_hdr, arch_64);\n\t\t}\n\t\tif ((record_hdr->record_type != R_COMMENT) && (record_hdr->record_type != R_RESTART) &&\n\t\t    record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 2;\n\t}\n\twhile (record_hdr->record_type == R_EXTRA);\n\treturn 0;\n}", "target": 0}
{"code": "kadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n    CHECK_HANDLE(server_handle);\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n    return KADM5_OK;\n}", "target": 0}
{"code": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_tab = NULL;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\tscn->sst_ss = ss;\n\tif (scn->sst_len == (size_t)-1)\n\t\tgoto out;\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn cdf_zero_stream(scn);\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sector chain loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= scn->sst_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\",\n\t\t\t    i, scn->sst_len));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n\t\t    sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sector chain %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)ssat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn cdf_zero_stream(scn);\n}", "target": 0}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n    return match;\n}", "target": 1}
{"code": "void mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\treturn;\n}", "target": 0}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "static int mxf_uid_to_str(UID uid, char **str)\n{\n    int i;\n    char *p;\n    p = *str = av_mallocz(sizeof(UID) * 2 + 4 + 1);\n    if (!p)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sizeof(UID); i++) {\n        snprintf(p, 2 + 1, \"%.2x\", uid[i]);\n        p += 2;\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            snprintf(p, 1 + 1, \"-\");\n            p++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "LuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}", "target": 0}
{"code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "    static bool is4ByteType(uint16_t type)\n    {\n        return isLongType(type)\n            || isRationalType(type)\n            ;\n    }", "target": 0}
{"code": " NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(\n     BrowserFrame* browser_frame,\n     BrowserView* browser_view) {\n  if (views::Widget::IsPureViews())\n     return new BrowserFrameViews(browser_frame, browser_view);\n   return new BrowserFrameGtk(browser_frame, browser_view);\n }", "target": 1}
{"code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}", "target": 1}
{"code": "void MoveTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m\",x1,y1);\n}", "target": 1}
{"code": "std::unique_ptr<MatchExpression> InMatchExpression::shallowClone() const {\n    auto next = stdx::make_unique<InMatchExpression>(path());\n    next->setCollator(_collator);\n    if (getTag()) {\n        next->setTag(getTag()->clone());\n    }\n    next->_hasNull = _hasNull;\n    next->_hasEmptyArray = _hasEmptyArray;\n    next->_equalitySet = _equalitySet;\n    next->_originalEqualityVector = _originalEqualityVector;\n    for (auto&& regex : _regexes) {\n        std::unique_ptr<RegexMatchExpression> clonedRegex(\n            static_cast<RegexMatchExpression*>(regex->shallowClone().release()));\n        next->_regexes.push_back(std::move(clonedRegex));\n    }\n    return std::move(next);\n}", "target": 0}
{"code": "static void iommu_enable_dev_iotlb(struct device_domain_info *info)\n{\n\tstruct pci_dev *pdev;\n\tassert_spin_locked(&device_domain_lock);\n\tif (!info || !dev_is_pci(info->dev))\n\t\treturn;\n\tpdev = to_pci_dev(info->dev);\n\tif (!ecap_dit(info->iommu->ecap))\n\t\tinfo->pfsid = 0;\n\telse {\n\t\tstruct pci_dev *pf_pdev;\n\t\tpf_pdev = pci_physfn(pdev);\n\t\tinfo->pfsid = PCI_DEVID(pf_pdev->bus->number, pf_pdev->devfn);\n\t}\n#ifdef CONFIG_INTEL_IOMMU_SVM\n\tif (info->pasid_supported && !pci_enable_pasid(pdev, info->pasid_supported & ~1))\n\t\tinfo->pasid_enabled = 1;\n\tif (info->pri_supported && !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))\n\t\tinfo->pri_enabled = 1;\n#endif\n\tif (!pdev->untrusted && info->ats_supported &&\n\t    !pci_enable_ats(pdev, VTD_PAGE_SHIFT)) {\n\t\tinfo->ats_enabled = 1;\n\t\tdomain_update_iotlb(info->domain);\n\t\tinfo->ats_qdep = pci_ats_queue_depth(pdev);\n\t}\n}", "target": 0}
{"code": "Status ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return errors::Internal(\"Node \", node.name(), \" is not a Reshape node\");\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return errors::Internal(\"Node \", node.name(), \" has shape \",\n                            new_shape->DebugString(),\n                            \" which is not a constant\");\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return errors::Internal(\"Could not evaluate node \", node.name());\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return errors::Internal(\"Node \", node.name(), \" has no properties\");\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return errors::Internal(\"Node \", node.name(), \" has property \",\n                            prop.DebugString(), \" with invalid dtype\");\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return errors::Internal(\"Node \", node.name(), \" has property \",\n                            prop.DebugString(), \" with shape \",\n                            shape.DebugString(), \" which is not fully defined\");\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\tsk->sk_send_head\t=\tNULL;\n\tinit_timer(&sk->sk_timer);\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_wq\t=\tsock->wq;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_wq\t=\tNULL;\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\tsk->sk_peek_off\t\t=\t-1;\n\tsk->sk_peer_pid \t=\tNULL;\n\tsk->sk_peer_cred\t=\tNULL;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}", "target": 0}
{"code": "static int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\tstruct cma_work *work;\n\tdev_addr = &id_priv->id.route.addr.dev_addr;\n\tif ((dev_addr->bound_dev_if == ndev->ifindex) &&\n\t    (net_eq(dev_net(ndev), dev_addr->net)) &&\n\t    memcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\n\t\tpr_info(\"RDMA CM addr change for ndev %s used by id %p\\n\",\n\t\t\tndev->name, &id_priv->id);\n\t\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, cma_work_handler);\n\t\twork->id = id_priv;\n\t\twork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\n\t\tcma_id_get(id_priv);\n\t\tqueue_work(cma_wq, &work->work);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "irc_server_get_name_without_port (const char *name)\n{\n    char *pos;\n    if (!name)\n        return NULL;\n    pos = strchr (name, '/');\n    if (pos && (pos != name))\n        return weechat_strndup (name, pos - name);\n    return strdup (name);\n}", "target": 0}
{"code": "void Triangle(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m %12.3f %12.3f l %12.3f %12.3f l h\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\tresv_map_dup_hugetlb_cgroup_uncharge_info(resv);\n\t\tkref_get(&resv->refs);\n\t}\n}", "target": 0}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "    bool triggered() const { return m_triggered; }", "target": 0}
{"code": "int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n        if( crt != chain )\n            mbedtls_free( crt );\n        return( ret );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "int kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\tread_lock(&tasklist_lock);\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif ((info == SEND_SIG_NOINFO ||\n\t     (!is_si_special(info) && SI_FROMUSER(info))) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\tif (sig && p->sighand) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}", "target": 0}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n \t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n }", "target": 1}
{"code": "START_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}", "target": 1}
{"code": "static struct dentry *__d_obtain_alias(struct inode *inode, int disconnected)\n{\n\tstatic const struct qstr anonstring = QSTR_INIT(\"/\", 1);\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\tunsigned add_flags;\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\ttmp = __d_alloc(inode->i_sb, &anonstring);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(tmp);\n\t\tgoto out_iput;\n\t}\n\tadd_flags = d_flags_for_inode(inode);\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\tspin_lock(&tmp->d_lock);\n\t__d_set_inode_and_type(tmp, inode, add_flags);\n\thlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);\n\thlist_bl_lock(&tmp->d_sb->s_anon);\n\thlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);\n\thlist_bl_unlock(&tmp->d_sb->s_anon);\n\tspin_unlock(&tmp->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(tmp, inode);\n\treturn tmp;\n out_iput:\n\tif (res && !IS_ERR(res))\n\t\tsecurity_d_instantiate(res, inode);\n\tiput(inode);\n\treturn res;\n}", "target": 0}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_basic_constraints(const gnutls_datum_t * ext,\n\t\t\t\t\t  unsigned int *ca, int *pathlen)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tchar str[128]=\"\";\n\tint len, result;\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.BasicConstraints\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tlen = sizeof(str) - 1;\n\tresult = asn1_read_value(c2, \"cA\", str, &len);\n\tif (result == ASN1_SUCCESS && strcmp(str, \"TRUE\") == 0)\n\t\t*ca = 1;\n\telse\n\t\t*ca = 0;\n\tresult = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn result;\n}", "target": 0}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "static int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  PixelChannels\n    **pixels;\n  register ssize_t\n    i;\n   size_t\n     columns,\n    number_threads;\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (PixelChannels **) NULL)\n     return((PixelChannels **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  columns=images->columns;\n   for (next=images; next != (Image *) NULL; next=next->next)\n     columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     register ssize_t\n       j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 1}
{"code": "static int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm)\n\t\t\tif (v == vcpu)\n\t\t\t\tdata = r;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tdefault:\n\t\tpr_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}", "target": 0}
{"code": "static int virtio_net_tx_waiting_pre_load(void *opaque)\n{\n    struct VirtIONetMigTmp *tmp = opaque;\n    virtio_net_tx_waiting_pre_save(opaque);\n    if (tmp->parent->curr_queues > tmp->parent->max_queues) {\n        error_report(\"virtio-net: curr_queues %x > max_queues %x\",\n            tmp->parent->curr_queues, tmp->parent->max_queues);\n        return -EINVAL;\n    }\n    return 0; \n}", "target": 0}
{"code": "void RenderSVGImage::paint(PaintInfo& paintInfo, const LayoutPoint&)\n{\n    ANNOTATE_GRAPHICS_CONTEXT(paintInfo, this);\n    if (paintInfo.context->paintingDisabled() || style()->visibility() == HIDDEN || !m_imageResource->hasImage())\n        return;\n    FloatRect boundingBox = repaintRectInLocalCoordinates();\n    if (!SVGRenderSupport::paintInfoIntersectsRepaintRect(boundingBox, m_localTransform, paintInfo))\n        return;\n    PaintInfo childPaintInfo(paintInfo);\n    bool drawsOutline = style()->outlineWidth() && (childPaintInfo.phase == PaintPhaseOutline || childPaintInfo.phase == PaintPhaseSelfOutline);\n    if (drawsOutline || childPaintInfo.phase == PaintPhaseForeground) {\n         GraphicsContextStateSaver stateSaver(*childPaintInfo.context);\n         childPaintInfo.applyTransform(m_localTransform);\n        if (childPaintInfo.phase == PaintPhaseForeground) {\n             SVGRenderingContext renderingContext(this, childPaintInfo);\n             if (renderingContext.isRenderingPrepared()) {\n                if (style()->svgStyle()->bufferedRendering() == BR_STATIC  && renderingContext.bufferForeground(m_bufferedForeground))\n                     return;\n                 paintForeground(childPaintInfo);\n            }\n        }\n        if (drawsOutline)\n            paintOutline(childPaintInfo, IntRect(boundingBox));\n    }\n}", "target": 1}
{"code": "static int _gnutls_verify_crl2(gnutls_x509_crl_t crl,\n\t\t\t       const gnutls_x509_crt_t * trusted_cas,\n\t\t\t       int tcas_size, unsigned int flags,\n\t\t\t       unsigned int *output)\n{\n    gnutls_datum_t crl_signed_data = { NULL, 0 };\n    gnutls_datum_t crl_signature = { NULL, 0 };\n    gnutls_x509_crt_t issuer;\n    int ret, result;\n    if (output)\n\t*output = 0;\n    if (tcas_size >= 1)\n\tissuer = find_crl_issuer(crl, trusted_cas, tcas_size);\n    else {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (issuer == NULL) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (!(flags & GNUTLS_VERIFY_DISABLE_CA_SIGN)) {\n\tif (gnutls_x509_crt_get_ca_status(issuer, NULL) != 1) {\n\t    gnutls_assert();\n\t    if (output)\n\t\t*output |= GNUTLS_CERT_SIGNER_NOT_CA | GNUTLS_CERT_INVALID;\n\t    return 0;\n\t}\n    }\n    result =\n\t_gnutls_x509_get_signed_data(crl->crl, \"tbsCertList\",\n\t\t\t\t     &crl_signed_data);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    result =\n\t_gnutls_x509_get_signature(crl->crl, \"signature\", &crl_signature);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    ret =\n\t_gnutls_x509_verify_signature(&crl_signed_data, &crl_signature,\n\t\t\t\t      issuer);\n    if (ret < 0) {\n\tgnutls_assert();\n    } else if (ret == 0) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_INVALID;\n\tret = 0;\n    }\n    result = ret;\n  cleanup:\n    _gnutls_free_datum(&crl_signed_data);\n    _gnutls_free_datum(&crl_signature);\n    return result;\n}", "target": 0}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                     return 0;\n                 }\n                 i+=2;\n                block_length = data[i] * 256 + data[i+1];\n             }\n         }\n     }\n    return -1;\n}", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n  int\n    c;\n  register ssize_t\n    i;\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}", "target": 1}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "smb3_is_transform_hdr(void *buf)\n{\n\tstruct smb2_transform_hdr *trhdr = buf;\n\treturn trhdr->ProtocolId == SMB2_TRANSFORM_PROTO_NUM;\n}", "target": 0}
{"code": "void nl80211_send_mgmt_tx_status(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t const u8 *buf, size_t len, bool ack,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME_TX_STATUS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie) ||\n\t    (ack && nla_put_flag(msg, NL80211_ATTR_ACK)))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(msg, 0, nl80211_mlme_mcgrp.id, gfp);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "uint16_t read16(uint8_t* arr, int pos,  int swapBytes)\n{\n    uint8_t b1 = arr[pos];\n    uint8_t b2 = arr[pos+1];\n    return (swapBytes) ?  ((b2 << 8) | b1) : ((b1 << 8) | b2);\n}", "target": 0}
{"code": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https:\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 );\n    }\n}", "target": 1}
{"code": "int nfs4_proc_destroy_session(struct nfs4_session *session,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_SESSION],\n\t\t.rpc_argp = session,\n\t\t.rpc_cred = cred,\n\t};\n\tint status = 0;\n\tdprintk(\"--> nfs4_proc_destroy_session\\n\");\n\tif (session->clp->cl_cons_state != NFS_CS_READY)\n\t\treturn status;\n\tstatus = rpc_call_sync(session->clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server on DESTROY_SESSION. \"\n\t\t\t\"Session has been destroyed regardless...\\n\", status);\n\tdprintk(\"<-- nfs4_proc_destroy_session\\n\");\n\treturn status;\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagecropauto)\n{\n\tzval *IM;\n\tlong mode = -1;\n\tlong color = -1;\n\tdouble threshold = 0.5f;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ldl\", &IM, &mode, &threshold, &color) == FAILURE)  {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tswitch (mode) {\n\t\tcase -1:\n\t\t\tmode = GD_CROP_DEFAULT;\n\t\tcase GD_CROP_DEFAULT:\n\t\tcase GD_CROP_TRANSPARENT:\n\t\tcase GD_CROP_BLACK:\n\t\tcase GD_CROP_WHITE:\n\t\tcase GD_CROP_SIDES:\n\t\t\tim_crop = gdImageCropAuto(im, mode);\n\t\t\tbreak;\n\t\tcase GD_CROP_THRESHOLD:\n\t\t\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color argument missing with threshold mode\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tim_crop = gdImageCropThreshold(im, color, (float) threshold);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown crop mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}", "target": 0}
{"code": "static inline void note_cmpxchg_failure(const char *n,\n\t\tconst struct kmem_cache *s, unsigned long tid)\n{\n#ifdef SLUB_DEBUG_CMPXCHG\n\tunsigned long actual_tid = __this_cpu_read(s->cpu_slab->tid);\n\tpr_info(\"%s %s: cmpxchg redo \", n, s->name);\n#ifdef CONFIG_PREEMPTION\n\tif (tid_to_cpu(tid) != tid_to_cpu(actual_tid))\n\t\tpr_warn(\"due to cpu change %d -> %d\\n\",\n\t\t\ttid_to_cpu(tid), tid_to_cpu(actual_tid));\n\telse\n#endif\n\tif (tid_to_event(tid) != tid_to_event(actual_tid))\n\t\tpr_warn(\"due to cpu running other code. Event %ld->%ld\\n\",\n\t\t\ttid_to_event(tid), tid_to_event(actual_tid));\n\telse\n\t\tpr_warn(\"for unknown reason: actual=%lx was=%lx target=%lx\\n\",\n\t\t\tactual_tid, tid, next_tid(tid));\n#endif\n\tstat(s, CMPXCHG_DOUBLE_CPU_FAIL);\n}", "target": 0}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "struct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}", "target": 0}
{"code": "static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}", "target": 1}
{"code": "  absl::optional<uint64_t> evaluate(const Network::Address::Instance*,\n                                    const RequestHeaderMap& headers,\n                                    const HashPolicy::AddCookieCallback add_cookie,\n                                    const StreamInfo::FilterStateSharedPtr) const override {\n    absl::optional<uint64_t> hash;\n    std::string value = Utility::parseCookieValue(headers, key_);\n    if (value.empty() && ttl_.has_value()) {\n      value = add_cookie(key_, path_, ttl_.value(), attributes_);\n      hash = HashUtil::xxHash64(value);\n    } else if (!value.empty()) {\n      hash = HashUtil::xxHash64(value);\n    }\n    return hash;\n  }", "target": 1}
{"code": "static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value)\n {\n    if (*pStackPtr >= CDL_STACK_SIZE)\n         return EAS_ERROR_FILE_FORMAT;\n     *pStackPtr = *pStackPtr + 1;\n    pStack[*pStackPtr] = value;\n return EAS_SUCCESS;\n}", "target": 1}
{"code": "  bool List::operator== (const Expression& rhs) const\n  {\n    if (List_Ptr_Const r = Cast<List>(&rhs)) {\n      if (length() != r->length()) return false;\n      if (separator() != r->separator()) return false;\n      for (size_t i = 0, L = length(); i < L; ++i) {\n        Expression_Obj rv = r->at(i);\n        Expression_Obj lv = this->at(i);\n        if (!lv || !rv) return false;\n        if (!(*lv == *rv)) return false;\n      }\n      return true;\n    }\n    return false;\n  }", "target": 0}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n}", "target": 1}
{"code": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    const char *ptr_url;\n    int rc;\n    close (STDIN_FILENO);\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    rc = EXIT_SUCCESS;\n    if (strncmp (HOOK_PROCESS(hook_process, command), \"url:\", 4) == 0)\n    {\n        ptr_url = HOOK_PROCESS(hook_process, command) + 4;\n        while (ptr_url[0] == ' ')\n        {\n            ptr_url++;\n        }\n        rc = weeurl_download (ptr_url, HOOK_PROCESS(hook_process, options));\n        if (rc != 0)\n            fprintf (stderr, \"Error with URL '%s'\\n\", ptr_url);\n    }\n    else\n    {\n        exec_args[2] = HOOK_PROCESS(hook_process, command);\n        execvp (exec_args[0], exec_args);\n        fprintf (stderr, \"Error with command '%s'\\n\",\n                 HOOK_PROCESS(hook_process, command));\n        rc = EXIT_FAILURE;\n    }\n    fflush (stdout);\n    fflush (stderr);\n    _exit (rc);\n}", "target": 1}
{"code": "PHPAPI void php_store_class_name(zval *object, const char *name, zend_uint len)\n{\n\tzval *val;\n\tTSRMLS_FETCH();\n\tMAKE_STD_ZVAL(val);\n\tZ_TYPE_P(val)   = IS_STRING;\n\tZ_STRVAL_P(val) = estrndup(name, len);\n\tZ_STRLEN_P(val) = len;\n\tzend_hash_update(Z_OBJPROP_P(object), MAGIC_MEMBER, sizeof(MAGIC_MEMBER), &val, sizeof(val), NULL);\n}", "target": 0}
{"code": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}", "target": 1}
