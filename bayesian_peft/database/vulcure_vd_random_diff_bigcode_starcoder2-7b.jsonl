{"code": "GfxAxialShading::GfxAxialShading(double x0A, double y0A, double x1A, double y1A, double t0A, double t1A, std::vector<std::unique_ptr<Function>> &&funcsA, bool extend0A, bool extend1A)\n    : GfxUnivariateShading(2, t0A, t1A, std::move(funcsA), extend0A, extend1A)\n{\n    x0 = x0A;\n    y0 = y0A;\n    x1 = x1A;\n    y1 = y1A;\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "  base::Time IncrementMockTime() {\n    ++mock_time_counter_;\n    return base::Time::FromDoubleT(mock_time_counter_ * 10.0);\n  }", "target": 0}
{"code": "PHP_FUNCTION(xsl_xsltprocessor_set_security_prefs)\n{\n\tzval *id;\n\txsl_object *intern;\n\tlong securityPrefs, oldSecurityPrefs;\n\tDOM_GET_THIS(id);\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &securityPrefs) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n\toldSecurityPrefs = intern->securityPrefs;\n\tintern->securityPrefs = securityPrefs;\n\tintern->securityPrefsSet = 1;\n\tRETURN_LONG(oldSecurityPrefs);\n}", "target": 0}
{"code": "static char *make_filename_safe(const char *filename TSRMLS_DC)\n{\n\tif (*filename && strncmp(filename, \":memory:\", sizeof(\":memory:\")-1)) {\n\t\tchar *fullpath = expand_filepath(filename, NULL TSRMLS_CC);\n\t\tif (!fullpath) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (php_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fullpath;\n\t}\n\treturn estrdup(filename);\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "static int nft_delflowtable_hook(struct nft_ctx *ctx,\n\t\t\t\t struct nft_flowtable *flowtable)\n{\n\tconst struct nlattr * const *nla = ctx->nla;\n\tstruct nft_flowtable_hook flowtable_hook;\n\tLIST_HEAD(flowtable_del_list);\n\tstruct nft_hook *this, *hook;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nft_flowtable_parse_hook(ctx, nla[NFTA_FLOWTABLE_HOOK],\n\t\t\t\t       &flowtable_hook, flowtable, false);\n\tif (err < 0)\n\t\treturn err;\n\tlist_for_each_entry(this, &flowtable_hook.list, list) {\n\t\thook = nft_hook_list_find(&flowtable->hook_list, this);\n\t\tif (!hook) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto err_flowtable_del_hook;\n\t\t}\n\t\tlist_move(&hook->list, &flowtable_del_list);\n\t}\n\ttrans = nft_trans_alloc(ctx, NFT_MSG_DELFLOWTABLE,\n\t\t\t\tsizeof(struct nft_trans_flowtable));\n\tif (!trans) {\n\t\terr = -ENOMEM;\n\t\tgoto err_flowtable_del_hook;\n\t}\n\tnft_trans_flowtable(trans) = flowtable;\n\tnft_trans_flowtable_update(trans) = true;\n\tINIT_LIST_HEAD(&nft_trans_flowtable_hooks(trans));\n\tlist_splice(&flowtable_del_list, &nft_trans_flowtable_hooks(trans));\n\tnft_flowtable_hook_release(&flowtable_hook);\n\tnft_trans_commit_list_add_tail(ctx->net, trans);\n\treturn 0;\nerr_flowtable_del_hook:\n\tlist_splice(&flowtable_del_list, &flowtable->hook_list);\n\tnft_flowtable_hook_release(&flowtable_hook);\n\treturn err;\n}", "target": 0}
{"code": "static void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\t\treturn;\n\t}\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}", "target": 1}
{"code": "  virtual bool ethernet_available() const { return true; }", "target": 0}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir,\n\t\t\t\t\tstruct dentry *dentry,\n\t\t\t\t\tfmode_t fmode,\n\t\t\t\t\tint flags,\n\t\t\t\t\tstruct iattr *sattr,\n\t\t\t\t\tstruct rpc_cred *cred,\n\t\t\t\t\tstruct nfs4_threshold **ctx_th)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tfmode &= FMODE_READ|FMODE_WRITE|FMODE_EXEC;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, dentry, fmode, flags, sattr, cred,\n\t\t\t\t       &res, ctx_th);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tpr_warn_ratelimited(\"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 0}
{"code": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = to_hv_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}", "target": 1}
{"code": "static inline int http_parse_chunk_size(struct http_msg *msg)\n{\n\tconst struct buffer *buf = msg->chn->buf;\n\tconst char *ptr = b_ptr(buf, msg->next);\n\tconst char *ptr_old = ptr;\n\tconst char *end = buf->data + buf->size;\n\tconst char *stop = bi_end(buf);\n\tunsigned int chunk = 0;\n\twhile (1) {\n\t\tint c;\n\t\tif (ptr == stop)\n\t\t\treturn 0;\n\t\tc = hex2i(*ptr);\n\t\tif (c < 0) \n\t\t\tbreak;\n\t\tif (unlikely(++ptr >= end))\n\t\t\tptr = buf->data;\n\t\tif (chunk & 0xF8000000) \n\t\t\tgoto error;\n\t\tchunk = (chunk << 4) + c;\n\t}\n\tif (unlikely(ptr == ptr_old))\n\t\tgoto error;\n\twhile (http_is_spht[(unsigned char)*ptr]) {\n\t\tif (++ptr >= end)\n\t\t\tptr = buf->data;\n\t\tif (unlikely(ptr == stop))\n\t\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tif (likely(*ptr == '\\r')) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (*ptr != '\\n')\n\t\t\t\tgoto error;\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*ptr == ';') {\n\t\t\tif (++ptr >= end)\n\t\t\t\tptr = buf->data;\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\t\t\twhile (!HTTP_IS_CRLF(*ptr)) {\n\t\t\t\tif (++ptr >= end)\n\t\t\t\t\tptr = buf->data;\n\t\t\t\tif (ptr == stop)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t\tgoto error;\n\t}\n\tif (unlikely(ptr < ptr_old))\n\t\tmsg->sov += buf->size;\n\tmsg->sov += ptr - ptr_old;\n\tmsg->next = buffer_count(buf, buf->p, ptr);\n\tmsg->chunk_len = chunk;\n\tmsg->body_len += chunk;\n\tmsg->msg_state = chunk ? HTTP_MSG_DATA : HTTP_MSG_TRAILERS;\n\treturn 1;\n error:\n\tmsg->err_pos = buffer_count(buf, buf->p, ptr);\n\treturn -1;\n}", "target": 0}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n    mrb->num_writes++;\n}", "target": 1}
{"code": "merge_public_with_secret (KBNODE pubblock, KBNODE secblock)\n{\n  KBNODE pub;\n  assert (pubblock->pkt->pkttype == PKT_PUBLIC_KEY);\n  assert (secblock->pkt->pkttype == PKT_SECRET_KEY);\n  for (pub = pubblock; pub; pub = pub->next)\n    {\n      if (pub->pkt->pkttype == PKT_PUBLIC_KEY)\n\t{\n\t  PKT_public_key *pk = pub->pkt->pkt.public_key;\n\t  PKT_secret_key *sk = secblock->pkt->pkt.secret_key;\n\t  assert (pub == pubblock); \n\t  copy_public_parts_to_secret_key (pk, sk);\n\t  free_public_key (pk);\n\t  pub->pkt->pkttype = PKT_SECRET_KEY;\n\t  pub->pkt->pkt.secret_key = copy_secret_key (NULL, sk);\n\t}\n      else if (pub->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  KBNODE sec;\n\t  PKT_public_key *pk = pub->pkt->pkt.public_key;\n\t  for (sec = secblock->next; sec; sec = sec->next)\n\t    {\n\t      if (sec->pkt->pkttype == PKT_SECRET_SUBKEY)\n\t\t{\n\t\t  PKT_secret_key *sk = sec->pkt->pkt.secret_key;\n\t\t  if (!cmp_public_secret_key (pk, sk))\n\t\t    {\n\t\t      copy_public_parts_to_secret_key (pk, sk);\n\t\t      free_public_key (pk);\n\t\t      pub->pkt->pkttype = PKT_SECRET_SUBKEY;\n\t\t      pub->pkt->pkt.secret_key = copy_secret_key (NULL, sk);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  if (!sec)\n\t    BUG (); \n\t}\n    }\n}", "target": 0}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "static int legacy_get_tree(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,\n\t\t\t\t      fc->source, ctx->legacy_data);\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tfc->root = root;\n\treturn 0;\n}", "target": 0}
{"code": "bool mysql_explain_union(THD *thd, SELECT_LEX_UNIT *unit, select_result *result)\n{\n  DBUG_ENTER(\"mysql_explain_union\");\n  bool res= 0;\n  SELECT_LEX *first= unit->first_select();\n  bool is_pushed_union= unit->derived && unit->derived->pushdown_derived;\n  for (SELECT_LEX *sl= first; sl; sl= sl->next_select())\n  {\n    sl->set_explain_type(FALSE);\n    sl->options|= SELECT_DESCRIBE;\n  }\n  if (unit->is_unit_op() || unit->fake_select_lex)\n  {\n    ulonglong save_options= 0;\n    if (unit->union_needs_tmp_table() && unit->fake_select_lex)\n    {\n      save_options= unit->fake_select_lex->options;\n      unit->fake_select_lex->select_number= FAKE_SELECT_LEX_ID; \n      unit->fake_select_lex->type= unit_operation_text[unit->common_op()];\n      unit->fake_select_lex->options|= SELECT_DESCRIBE;\n    }\n    if (!(res= unit->prepare(unit->derived, result,\n                             SELECT_NO_UNLOCK | SELECT_DESCRIBE)))\n    {\n      if (!is_pushed_union)\n        res= unit->exec();\n    }\n    if (unit->union_needs_tmp_table() && unit->fake_select_lex)\n      unit->fake_select_lex->options= save_options;\n  }\n  else\n  {\n    thd->lex->current_select= first;\n    unit->set_limit(unit->global_parameters());\n    res= mysql_select(thd, \n                      first->table_list.first,\n                      first->with_wild, first->item_list,\n                      first->where,\n                      first->order_list.elements + first->group_list.elements,\n                      first->order_list.first,\n                      first->group_list.first,\n                      first->having,\n                      thd->lex->proc_list.first,\n                      first->options | thd->variables.option_bits | SELECT_DESCRIBE,\n                      result, unit, first);\n  }\n  if (unit->derived && unit->derived->pushdown_derived)\n  {\n    delete unit->derived->pushdown_derived;\n    unit->derived->pushdown_derived= NULL;\n  }\n  DBUG_RETURN(res || thd->is_error());\n}", "target": 0}
{"code": "RenderThreadImpl::SharedMainThreadContextProvider() {\n  DCHECK(IsMainThread());\n  if (!shared_main_thread_contexts_.get() ||\n      shared_main_thread_contexts_->DestroyedOnMainThread()) {\n    shared_main_thread_contexts_ = NULL;\n#if defined(OS_ANDROID)\n    if (SynchronousCompositorFactory* factory =\n            SynchronousCompositorFactory::GetInstance()) {\n      shared_main_thread_contexts_ = factory->CreateOffscreenContextProvider(\n          GetOffscreenAttribs(), \"Offscreen-MainThread\");\n    }\n#endif\n    if (!shared_main_thread_contexts_.get()) {\n      shared_main_thread_contexts_ = ContextProviderCommandBuffer::Create(\n          CreateOffscreenContext3d(), \"Offscreen-MainThread\");\n    }\n    if (shared_main_thread_contexts_.get() &&\n        !shared_main_thread_contexts_->BindToCurrentThread())\n      shared_main_thread_contexts_ = NULL;\n  }\n  return shared_main_thread_contexts_;\n}", "target": 0}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "is_device_installed(gx_device *dev, const char *name)\n{\n    while (dev) {\n        if (!strcmp(dev->dname, name)) {\n            return true;\n        }\n        dev = dev->child;\n    }\n    return false;\n}", "target": 0}
{"code": "    PreviewImage::PreviewImage(const PreviewImage& rhs)\n    {\n        properties_ = rhs.properties_;\n        pData_ = new byte[rhs.size_];\n        memcpy(pData_, rhs.pData_, rhs.size_);\n        size_ = rhs.size_;\n    }", "target": 0}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_send_interim_response(request_rec *r, int send_headers)\n{\n    hdr_ptr x;\n    char *status_line = NULL;\n    request_rec *rr;\n    if (r->proto_num < HTTP_VERSION(1,1)) {\n        return;\n    }\n    if (!ap_is_HTTP_INFO(r->status)) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00575)\n                      \"Status is %d - not sending interim response\", r->status);\n        return;\n    }\n    if ((r->status == HTTP_CONTINUE) && !r->expecting_100) {\n        return;\n    }\n    for (rr = r; rr != NULL; rr = rr->main) {\n        rr->expecting_100 = 0;\n    }\n    status_line = apr_pstrcat(r->pool, AP_SERVER_PROTOCOL, \" \", r->status_line, CRLF, NULL);\n    ap_xlate_proto_to_ascii(status_line, strlen(status_line));\n    x.f = r->connection->output_filters;\n    x.bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    ap_fputs(x.f, x.bb, status_line);\n    if (send_headers) {\n        apr_table_do(send_header, &x, r->headers_out, NULL);\n        apr_table_clear(r->headers_out);\n    }\n    ap_fputs(x.f, x.bb, CRLF_ASCII);\n    ap_fflush(x.f, x.bb);\n    apr_brigade_destroy(x.bb);\n}", "target": 0}
{"code": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\tget_bh(iloc->bh);\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "static unsigned short muscle_parse_singleAcl(const sc_acl_entry_t* acl)\n{\n\tunsigned short acl_entry = 0;\n\twhile(acl) {\n\t\tint key = acl->key_ref;\n\t\tint method = acl->method;\n\t\tswitch(method) {\n\t\tcase SC_AC_NEVER:\n\t\t\treturn 0xFFFF;\n\t\tcase SC_AC_NONE:\n\t\tcase SC_AC_UNKNOWN:\n\t\t\tbreak;\n\t\tcase SC_AC_CHV:\n\t\t\tacl_entry |= (1 << key); \n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\tcase SC_AC_TERM:\n\t\tcase SC_AC_PRO:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tacl = acl->next;\n\t}\n\treturn acl_entry;\n}", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static ssize_t slab_attr_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct slab_attribute *attribute;\n\tstruct kmem_cache *s;\n\tint err;\n\tattribute = to_slab_attr(attr);\n\ts = to_slab(kobj);\n\tif (!attribute->show)\n\t\treturn -EIO;\n\terr = attribute->show(s, buf);\n\treturn err;\n}", "target": 0}
{"code": "  void dumpState(std::ostream& os, int indent_level = 0) const override {\n    header_map_->dumpState(os, indent_level);\n  }", "target": 0}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "static void mod_wstunnel_merge_config(plugin_config * const pconf, const config_plugin_value_t *cpv) {\n    do {\n        mod_wstunnel_merge_config_cpv(pconf, cpv);\n    } while ((++cpv)->k_id != -1);\n}", "target": 0}
{"code": "void mce_setup(struct mce *m)\n{\n\tmemset(m, 0, sizeof(struct mce));\n\tm->cpu = m->extcpu = smp_processor_id();\n\tm->time = get_seconds();\n\tm->cpuvendor = boot_cpu_data.x86_vendor;\n\tm->cpuid = cpuid_eax(1);\n\tm->socketid = cpu_data(m->extcpu).phys_proc_id;\n\tm->apicid = cpu_data(m->extcpu).initial_apicid;\n\trdmsrl(MSR_IA32_MCG_CAP, m->mcgcap);\n\tif (this_cpu_has(X86_FEATURE_INTEL_PPIN))\n\t\trdmsrl(MSR_PPIN, m->ppin);\n\tm->microcode = boot_cpu_data.microcode;\n}", "target": 0}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "static int kvp_process_ip_address(void *addrp,\n\t\t\t\tint family, char *buffer,\n\t\t\t\tint length,  int *offset)\n{\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tint addr_length;\n\tchar tmp[50];\n\tconst char *str;\n\tif (family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)addrp;\n\t\tstr = inet_ntop(family, &addr->sin_addr, tmp, 50);\n\t\taddr_length = INET_ADDRSTRLEN;\n\t} else {\n\t\taddr6 = (struct sockaddr_in6 *)addrp;\n\t\tstr = inet_ntop(family, &addr6->sin6_addr.s6_addr, tmp, 50);\n\t\taddr_length = INET6_ADDRSTRLEN;\n\t}\n\tif ((length - *offset) < addr_length + 2)\n\t\treturn HV_E_FAIL;\n\tif (str == NULL) {\n\t\tstrcpy(buffer, \"inet_ntop failed\\n\");\n\t\treturn HV_E_FAIL;\n\t}\n\tif (*offset == 0)\n\t\tstrcpy(buffer, tmp);\n\telse {\n\t\tstrcat(buffer, \";\");\n\t\tstrcat(buffer, tmp);\n\t}\n\t*offset += strlen(str) + 1;\n\treturn 0;\n}", "target": 0}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}", "target": 1}
{"code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "static int snd_usb_accessmusic_boot_quirk(struct usb_device *dev)\n{\n\tint err, actual_length;\n\tstatic const u8 seq[] = { 0x4e, 0x73, 0x52, 0x01 };\n\tvoid *buf = kmemdup(seq, ARRAY_SIZE(seq), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = usb_interrupt_msg(dev, usb_sndintpipe(dev, 0x05), buf,\n\t\t\tARRAY_SIZE(seq), &actual_length, 1000);\n\tkfree(buf);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "close_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}", "target": 0}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "sync_path (struct url *u)\n{\n  char *newpath, *efile, *edir;\n  xfree (u->path);\n  edir = url_escape_dir (u->dir);\n  efile = url_escape_1 (u->file, urlchr_unsafe | urlchr_reserved, 1);\n  if (!*edir)\n    newpath = xstrdup (efile);\n  else\n    {\n      int dirlen = strlen (edir);\n      int filelen = strlen (efile);\n      char *p = newpath = xmalloc (dirlen + 1 + filelen + 1);\n      memcpy (p, edir, dirlen);\n      p += dirlen;\n      *p++ = '/';\n      memcpy (p, efile, filelen);\n      p += filelen;\n      *p = '\\0';\n    }\n  u->path = newpath;\n  if (edir != u->dir)\n    xfree (edir);\n  if (efile != u->file)\n    xfree (efile);\n  xfree (u->url);\n  u->url = url_string (u, URL_AUTH_SHOW);\n}", "target": 0}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "static bool reds_send_link_error(RedLinkInfo *link, uint32_t error)\n{\n    struct {\n        SpiceLinkHeader header;\n        SpiceLinkReply reply;\n    } msg;\n    SPICE_VERIFY(sizeof(msg) == sizeof(SpiceLinkHeader) + sizeof(SpiceLinkReply));\n    msg.header.magic = SPICE_MAGIC;\n    msg.header.size = GUINT32_TO_LE(sizeof(msg.reply));\n    msg.header.major_version = GUINT32_TO_LE(SPICE_VERSION_MAJOR);\n    msg.header.minor_version = GUINT32_TO_LE(SPICE_VERSION_MINOR);\n    memset(&msg.reply, 0, sizeof(msg.reply));\n    msg.reply.error = GUINT32_TO_LE(error);\n    return red_stream_write_all(link->stream, &msg, sizeof(msg));\n}", "target": 0}
{"code": "static void __init taa_select_mitigation(void)\n{\n\tu64 ia32_cap;\n\tif (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\ttaa_mitigation = TAA_MITIGATION_TSX_DISABLED;\n\t\tgoto out;\n\t}\n\tif (cpu_mitigations_off()) {\n\t\ttaa_mitigation = TAA_MITIGATION_OFF;\n\t\treturn;\n\t}\n\tif (taa_mitigation == TAA_MITIGATION_OFF &&\n\t    mds_mitigation == MDS_MITIGATION_OFF)\n\t\tgoto out;\n\tif (boot_cpu_has(X86_FEATURE_MD_CLEAR))\n\t\ttaa_mitigation = TAA_MITIGATION_VERW;\n\telse\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tia32_cap = x86_read_arch_cap_msr();\n\tif ( (ia32_cap & ARCH_CAP_MDS_NO) &&\n\t    !(ia32_cap & ARCH_CAP_TSX_CTRL_MSR))\n\t\ttaa_mitigation = TAA_MITIGATION_UCODE_NEEDED;\n\tstatic_branch_enable(&mds_user_clear);\n\tif (taa_nosmt || cpu_mitigations_auto_nosmt())\n\t\tcpu_smt_disable(false);\n\tif (mds_mitigation == MDS_MITIGATION_OFF &&\n\t    boot_cpu_has_bug(X86_BUG_MDS)) {\n\t\tmds_mitigation = MDS_MITIGATION_FULL;\n\t\tmds_select_mitigation();\n\t}\nout:\n\tpr_info(\"%s\\n\", taa_strings[taa_mitigation]);\n}", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tms = 0;\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\tdec->state = JPC_MT;\n\treturn 1;\n}", "target": 0}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "vte_sequence_handler_sc (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tscreen->cursor_saved.col = screen->cursor_current.col;\n\tscreen->cursor_saved.row = CLAMP(screen->cursor_current.row -\n\t\t\t\t\t screen->insert_delta,\n\t\t\t\t\t 0, terminal->row_count - 1);\n}", "target": 0}
{"code": "void SSH_Access::LogSSHMessage()\n{\n   const char *b;\n   int s;\n   pty_recv_buf->Get(&b,&s);\n   const char *eol=find_char(b,s,'\\n');\n   if(!eol)\n   {\n      if(pty_recv_buf->Eof())\n      {\n\t if(s>0)\n\t    LogRecv(4,b);\n\t LogError(0,_(\"Peer closed connection\"));\n      }\n      if(pty_recv_buf->Error())\n\t LogError(4,\"pty read: %s\",pty_recv_buf->ErrorText());\n      if(pty_recv_buf->Eof() || pty_recv_buf->Error()) {\n\t if(last_ssh_message && time_t(now)-last_ssh_message_time<4)\n\t    LogError(0,\"%s\",last_ssh_message.get());\n\t Disconnect(last_ssh_message);\n      }\n      return;\n   }\n   s=eol-b+1;\n   int chomp_cr=(s>=2 && b[s-2]=='\\r');\n   last_ssh_message.nset(b,s-1-chomp_cr);\n   last_ssh_message_time=now;\n   pty_recv_buf->Skip(s);\n   LogRecv(4,last_ssh_message);\n   if(last_ssh_message.begins_with(\"ssh: \"))\n      last_ssh_message.set(last_ssh_message+5);\n   if(!received_greeting && last_ssh_message.eq(greeting))\n      received_greeting=true;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImagePngCtxEx (im, out, -1);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\treturn rv;\n}", "target": 1}
{"code": "static void floppy_shutdown(struct work_struct *arg)\n{\n\tunsigned long flags;\n\tif (initialized)\n\t\tshow_floppy();\n\tcancel_activity();\n\tflags = claim_dma_lock();\n\tfd_disable_dma();\n\trelease_dma_lock(flags);\n\tif (initialized)\n\t\tDPRINT(\"floppy timeout called\\n\");\n\tFDCS->reset = 1;\n\tif (cont) {\n\t\tcont->done(0);\n\t\tcont->redo();\t\n\t} else {\n\t\tpr_info(\"no cont in shutdown!\\n\");\n\t\tprocess_fd_request();\n\t}\n\tis_alive(__func__, \"\");\n}", "target": 0}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\treturn -ENODATA;\n\t}\n\tof_overlay_mutex_lock();\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\tof_overlay_mutex_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "static bool arg_type_is_mem_ptr(enum bpf_arg_type type)\n{\n\treturn base_type(type) == ARG_PTR_TO_MEM ||\n\t       base_type(type) == ARG_PTR_TO_UNINIT_MEM;\n}", "target": 0}
{"code": "krb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n    ret[princ_ent->old_key_len] = NULL;\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "    void TiffReader::visitSizeEntry(TiffSizeEntry* object)\n    {\n        assert(object != 0);\n        readTiffEntry(object);\n        TiffFinder finder(object->dtTag(), object->dtGroup());\n        pRoot_->accept(finder);\n        TiffDataEntryBase* te = dynamic_cast<TiffDataEntryBase*>(finder.result());\n        if (te && te->pValue()) {\n            te->setStrips(object->pValue(), pData_, size_, baseOffset());\n        }\n    }", "target": 0}
{"code": "int sldns_str2wire_dname_buf_origin(const char* str, uint8_t* buf, size_t* len,\n\tuint8_t* origin, size_t origin_len)\n{\n\tsize_t dlen = *len;\n\tint rel = 0;\n\tint s = sldns_str2wire_dname_buf_rel(str, buf, &dlen, &rel);\n\tif(s) return s;\n\tif(rel && origin && dlen > 0) {\n\t\tif(dlen + origin_len - 1 > LDNS_MAX_DOMAINLEN)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_DOMAINNAME_OVERFLOW,\n\t\t\t\tLDNS_MAX_DOMAINLEN);\n\t\tif(dlen + origin_len - 1 > *len)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\t*len);\n\t\tmemmove(buf+dlen-1, origin, origin_len);\n\t\t*len = dlen + origin_len - 1;\n\t} else\n\t\t*len = dlen;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 1}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "static int is_branch32_taken(struct bpf_reg_state *reg, u32 val, u8 opcode)\n{\n\tstruct tnum subreg = tnum_subreg(reg->var_off);\n\ts32 sval = (s32)val;\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !!tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JNE:\n\t\tif (tnum_is_const(subreg))\n\t\t\treturn !tnum_equals_const(subreg, val);\n\t\tbreak;\n\tcase BPF_JSET:\n\t\tif ((~subreg.mask & subreg.value) & val)\n\t\t\treturn 1;\n\t\tif (!((subreg.mask | subreg.value) & val))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGT:\n\t\tif (reg->u32_min_value > val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value <= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGT:\n\t\tif (reg->s32_min_value > sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value <= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLT:\n\t\tif (reg->u32_max_value < val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value >= val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLT:\n\t\tif (reg->s32_max_value < sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value >= sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JGE:\n\t\tif (reg->u32_min_value >= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_max_value < val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSGE:\n\t\tif (reg->s32_min_value >= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_max_value < sval)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JLE:\n\t\tif (reg->u32_max_value <= val)\n\t\t\treturn 1;\n\t\telse if (reg->u32_min_value > val)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BPF_JSLE:\n\t\tif (reg->s32_max_value <= sval)\n\t\t\treturn 1;\n\t\telse if (reg->s32_min_value > sval)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1}
{"code": "storageConnectGetCapabilities(virConnectPtr conn)\n{\n    if (virConnectGetCapabilitiesEnsureACL(conn) < 0)\n        return NULL;\n    return virCapabilitiesFormatXML(driver->caps);\n}", "target": 0}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p, 0, min_size + FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n  register ssize_t\n    x;\n  ssize_t\n    center,\n    y;\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}", "target": 0}
{"code": "int nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void clear_tables(JOIN *join)\n{\n  for (uint i= 0 ; i < join->table_count ; i++)\n  {\n    if (!(join->table[i]->map & join->const_table_map))\n      mark_as_null_row(join->table[i]);\t\t\n  }\n}", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "    Jp2Image::Jp2Image(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::jp2, mdExif | mdIptc | mdXmp, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::Jp2Image:: Creating JPEG2000 image to memory\" << std::endl;\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(Jp2Blank, sizeof(Jp2Blank)) != sizeof(Jp2Blank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::Jp2Image:: Failed to create JPEG2000 image on memory\" << std::endl;\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "MagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n  const char\n    *element;\n  LinkedListInfo\n    *messages,\n    *paths;\n  StringInfo\n    *xml;\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}", "target": 0}
{"code": "xfs_attr3_leaf_read_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tif ((xfs_sb_version_hascrc(&mp->m_sb) &&\n\t     !xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\t\t  XFS_ATTR3_LEAF_CRC_OFF)) ||\n\t    !xfs_attr3_leaf_verify(bp)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp->b_addr);\n\t\txfs_buf_ioerror(bp, EFSCORRUPTED);\n\t}\n}", "target": 0}
{"code": "struct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc)\n{\n\tstruct file_list *flist = cur_flist;\n\tif (!flist && !(flist = first_flist))\n\t\tgoto not_found;\n\twhile (ndx < flist->ndx_start-1) {\n\t\tif (flist == first_flist)\n\t\t\tgoto not_found;\n\t\tflist = flist->prev;\n\t}\n\twhile (ndx >= flist->ndx_start + flist->used) {\n\t\tif (!(flist = flist->next))\n\t\t\tgoto not_found;\n\t}\n\treturn flist;\n  not_found:\n\tif (fatal_error_loc) {\n\t\tint first, last;\n\t\tif (first_flist) {\n\t\t\tfirst = first_flist->ndx_start - 1;\n\t\t\tlast = first_flist->prev->ndx_start + first_flist->prev->used - 1;\n\t\t} else {\n\t\t\tfirst = 0;\n\t\t\tlast = -1;\n\t\t}\n\t\trprintf(FERROR,\n\t\t\t\"File-list index %d not in %d - %d (%s) [%s]\\n\",\n\t\t\tndx, first, last, fatal_error_loc, who_am_i());\n\t\texit_cleanup(RERR_PROTOCOL);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int neigh_fill_info(struct sk_buff *skb, struct neighbour *n,\n\t\t\t   u32 pid, u32 seq, int event, unsigned int flags)\n{\n\tunsigned long now = jiffies;\n\tunsigned char *b = skb->tail;\n\tstruct nda_cacheinfo ci;\n\tint locked = 0;\n\tu32 probes;\n\tstruct nlmsghdr *nlh = NLMSG_NEW(skb, pid, seq, event,\n\t\t\t\t\t sizeof(struct ndmsg), flags);\n\tstruct ndmsg *ndm = NLMSG_DATA(nlh);\n\tndm->ndm_family\t = n->ops->family;\n\tndm->ndm_flags\t = n->flags;\n\tndm->ndm_type\t = n->type;\n\tndm->ndm_ifindex = n->dev->ifindex;\n\tRTA_PUT(skb, NDA_DST, n->tbl->key_len, n->primary_key);\n\tread_lock_bh(&n->lock);\n\tlocked\t\t = 1;\n\tndm->ndm_state\t = n->nud_state;\n\tif (n->nud_state & NUD_VALID)\n\t\tRTA_PUT(skb, NDA_LLADDR, n->dev->addr_len, n->ha);\n\tci.ndm_used\t = now - n->used;\n\tci.ndm_confirmed = now - n->confirmed;\n\tci.ndm_updated\t = now - n->updated;\n\tci.ndm_refcnt\t = atomic_read(&n->refcnt) - 1;\n\tprobes = atomic_read(&n->probes);\n\tread_unlock_bh(&n->lock);\n\tlocked\t\t = 0;\n\tRTA_PUT(skb, NDA_CACHEINFO, sizeof(ci), &ci);\n\tRTA_PUT(skb, NDA_PROBES, sizeof(probes), &probes);\n\tnlh->nlmsg_len\t = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tif (locked)\n\t\tread_unlock_bh(&n->lock);\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "init(void)\n{\n#ifdef USE_CALLOUT\n    int id;\n    OnigEncoding enc;\n    char* name;\n    unsigned int args[4];\n    OnigValue opts[4];\n    enc = ONIG_ENCODING_UTF16_BE;\n    name = \"\\000F\\000A\\000I\\000L\\000\\000\";            BC0_P(name, fail);\n    name = \"\\000M\\000I\\000S\\000M\\000A\\000T\\000C\\000H\\000\\000\"; BC0_P(name, mismatch);\n    name = \"\\000M\\000A\\000X\\000\\000\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_CHAR;\n    opts[0].c = 'X';\n    BC_B_O(name, max, 2, args, 1, opts);\n    name = \"\\000E\\000R\\000R\\000O\\000R\\000\\000\";\n    args[0] = ONIG_TYPE_LONG; opts[0].l = ONIG_ABORT;\n    BC_P_O(name, error, 1, args, 1, opts);\n    name = \"\\000C\\000O\\000U\\000N\\000T\\000\\000\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, count, 1, args, 1, opts);\n    name = \"\\000T\\000O\\000T\\000A\\000L\\000_\\000C\\000O\\000U\\000N\\000T\\000\\000\";\n    args[0] = ONIG_TYPE_CHAR; opts[0].c = '>';\n    BC_B_O(name, total_count, 1, args, 1, opts);\n    name = \"\\000C\\000M\\000P\\000\\000\";\n    args[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    args[1] = ONIG_TYPE_STRING;\n    args[2] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;\n    BC_P(name, cmp, 3, args);\n#endif \n  return ONIG_NORMAL;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "cmsToneCurve* CMSEXPORT cmsDupToneCurve(const cmsToneCurve* In)\n{\n    if (In == NULL) return NULL;\n    return  AllocateToneCurveStruct(In ->InterpParams ->ContextID, In ->nEntries, In ->nSegments, In ->Segments, In ->Table16);\n}", "target": 0}
{"code": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1}
{"code": "static inline int tty_put_user(struct tty_struct *tty, unsigned char x,\n\t\t\t       unsigned char __user *ptr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\ttty_audit_add_data(tty, &x, 1, ldata->icanon);\n\treturn put_user(x, ptr);\n}", "target": 0}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "  virtual bool offline_mode() const { return offline_mode_; }", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "    DWORD FileIo::Impl::winNumberOfLinks() const\n    {\n        DWORD nlink = 1;\n        HANDLE hFd = (HANDLE)_get_osfhandle(fileno(fp_));\n        if (hFd != INVALID_HANDLE_VALUE) {\n            typedef BOOL (WINAPI * GetFileInformationByHandle_t)(HANDLE, LPBY_HANDLE_FILE_INFORMATION);\n            HMODULE hKernel = ::GetModuleHandleA(\"kernel32.dll\");\n            if (hKernel) {\n                GetFileInformationByHandle_t pfcn_GetFileInformationByHandle = (GetFileInformationByHandle_t)GetProcAddress(hKernel, \"GetFileInformationByHandle\");\n                if (pfcn_GetFileInformationByHandle) {\n                    BY_HANDLE_FILE_INFORMATION fi = {0,0,0,0,0,0,0,0,0,0,0,0,0};\n                    if (pfcn_GetFileInformationByHandle(hFd, &fi)) {\n                        nlink = fi.nNumberOfLinks;\n                    }\n#ifdef DEBUG\n                    else EXV_DEBUG << \"GetFileInformationByHandle failed\\n\";\n#endif\n                }\n#ifdef DEBUG\n                else EXV_DEBUG << \"GetProcAddress(hKernel, \\\"GetFileInformationByHandle\\\") failed\\n\";\n#endif\n            }\n#ifdef DEBUG\n            else EXV_DEBUG << \"GetModuleHandleA(\\\"kernel32.dll\\\") failed\\n\";\n#endif\n        }\n#ifdef DEBUG\n        else EXV_DEBUG << \"_get_osfhandle failed: INVALID_HANDLE_VALUE\\n\";\n#endif\n        return nlink;\n    } ", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "bool task_blocks_signal(pid_t pid, int signal)\n{\n\tint ret;\n\tchar status[__PROC_STATUS_LEN];\n\tFILE *f;\n\tuint64_t sigblk = 0, one = 1;\n\tsize_t n = 0;\n\tbool bret = false;\n\tchar *line = NULL;\n\tret = snprintf(status, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);\n\tif (ret < 0 || ret >= __PROC_STATUS_LEN)\n\t\treturn bret;\n\tf = fopen(status, \"r\");\n\tif (!f)\n\t\treturn bret;\n\twhile (getline(&line, &n, f) != -1) {\n\t\tchar *numstr;\n\t\tif (strncmp(line, \"SigBlk:\", 7))\n\t\t\tcontinue;\n\t\tnumstr = lxc_trim_whitespace_in_place(line + 7);\n\t\tret = lxc_safe_uint64(numstr, &sigblk, 16);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (sigblk & (one << (signal - 1)))\n\t\tbret = true;\nout:\n\tfree(line);\n\tfclose(f);\n\treturn bret;\n}", "target": 0}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int ExecuteHelp( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable )\n{\n    char            szTable[250]                        = \"\";\n    SQLHSTMT        hStmt;\n    SQLTCHAR        szSepLine[32001];   \n    SQLLEN          nRows               = 0;\n    szSepLine[ 0 ] = 0;\n    if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS )\n    {\n        if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 );\n        fprintf( stderr, \"[ISQL]ERROR: Could not SQLAllocStmt\\n\" );\n        return 0;\n    }\n    if ( iniElement( szSQL, ' ', '\\0', 1, szTable, sizeof(szTable) ) == INI_SUCCESS )\n    {\n        SQLWCHAR tname[ 1024 ];\n        ansi_to_unicode( szTable, tname );\n        if ( SQLColumns( hStmt, NULL, 0, NULL, 0, tname, SQL_NTS, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLColumns\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    else\n    {\n        if ( SQLTables( hStmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 ) != SQL_SUCCESS )\n        {\n            if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt );\n            fprintf( stderr, \"[ISQL]ERROR: Could not SQLTables\\n\" );\n            SQLFreeStmt( hStmt, SQL_DROP );\n            return 0;\n        }\n    }\n    if ( bHTMLTable )\n        WriteHeaderHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteHeaderNormal( hStmt, szSepLine );\n    else if ( cDelimiter && bColumnNames )\n        WriteHeaderDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteBodyHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        nRows = WriteBodyNormal( hStmt );\n    else\n        WriteBodyDelimited( hStmt, cDelimiter );\n    if ( bHTMLTable )\n        WriteFooterHTMLTable( hStmt );\n    else if ( cDelimiter == 0 )\n        UWriteFooterNormal( hStmt, szSepLine, nRows );\n    SQLFreeStmt( hStmt, SQL_DROP );\n    return 1;\n}", "target": 0}
{"code": "PS_SERIALIZER_DECODE_FUNC(php_binary) \n{\n\tconst char *p;\n\tchar *name;\n\tconst char *endptr = val + vallen;\n\tzval *current;\n\tint namelen;\n\tint has_value;\n\tphp_unserialize_data_t var_hash;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tfor (p = val; p < endptr; ) {\n\t\tzval **tmp;\n                namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);\n                if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {\n                        return FAILURE;\n                }\n\t\tname = estrndup(p + 1, namelen);\n\t\tp += namelen + 1;\n\t\tif (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {\n\t\t\tif ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {\n\t\t\t\tefree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (has_value) {\n\t\t\tALLOC_INIT_ZVAL(current);\n\t\t\tif (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {\n\t\t\t\tphp_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tvar_push_dtor_no_addref(&var_hash, &current);\n\t\t}\n\t\tPS_ADD_VARL(name, namelen);\n\t\tefree(name);\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "xface2xpm(char *xface)\n{\n    Image image;\n    ImageCache *cache;\n    FILE *f;\n    struct stat st;\n    SKIP_BLANKS(xface);\n    image.url = xface;\n    image.ext = \".xpm\";\n    image.width = 48;\n    image.height = 48;\n    image.cache = NULL;\n    cache = getImage(&image, NULL, IMG_FLAG_AUTO);\n    if (cache->loaded & IMG_FLAG_LOADED && !stat(cache->file, &st))\n\treturn cache->file;\n    cache->loaded = IMG_FLAG_ERROR;\n    f = popen(Sprintf(\"%s > %s\", shell_quote(auxbinFile(XFACE2XPM)),\n\t\t      shell_quote(cache->file))->ptr, \"w\");\n    if (!f)\n\treturn NULL;\n    fputs(xface, f);\n    pclose(f);\n    if (stat(cache->file, &st) || !st.st_size)\n\treturn NULL;\n    cache->loaded = IMG_FLAG_LOADED | IMG_FLAG_DONT_REMOVE;\n    cache->index = 0;\n    return cache->file;\n}", "target": 0}
{"code": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n    list_remove(&pair->list);\n    json_decref(pair->value);\n    jsonp_free(pair);\n    hashtable->size--;\n    return 0;\n}", "target": 1}
{"code": "static struct socket *get_raw_socket(int fd)\n{\n\tstruct {\n\t\tstruct sockaddr_ll sa;\n\t\tchar  buf[MAX_ADDR_LEN];\n\t} uaddr;\n\tint r;\n\tstruct socket *sock = sockfd_lookup(fd, &r);\n\tif (!sock)\n\t\treturn ERR_PTR(-ENOTSOCK);\n\tif (sock->sk->sk_type != SOCK_RAW) {\n\t\tr = -ESOCKTNOSUPPORT;\n\t\tgoto err;\n\t}\n\tr = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0);\n\tif (r < 0)\n\t\tgoto err;\n\tif (uaddr.sa.sll_family != AF_PACKET) {\n\t\tr = -EPFNOSUPPORT;\n\t\tgoto err;\n\t}\n\treturn sock;\nerr:\n\tsockfd_put(sock);\n\treturn ERR_PTR(r);\n}", "target": 1}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 1}
{"code": "sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)\n{\n\tsg_io_hdr_t *hp = &srp->header;\n\tint err = 0, err2;\n\tint len;\n\tif (in_compat_syscall()) {\n\t\tif (count < sizeof(struct compat_sg_io_hdr)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t} else if (count < SZ_SG_IO_HDR) {\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\thp->sb_len_wr = 0;\n\tif ((hp->mx_sb_len > 0) && hp->sbp) {\n\t\tif ((CHECK_CONDITION & hp->masked_status) ||\n\t\t    (DRIVER_SENSE & hp->driver_status)) {\n\t\t\tint sb_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tsb_len = (hp->mx_sb_len > sb_len) ? sb_len : hp->mx_sb_len;\n\t\t\tlen = 8 + (int) srp->sense_b[7];\t\n\t\t\tlen = (len > sb_len) ? sb_len : len;\n\t\t\tif (copy_to_user(hp->sbp, srp->sense_b, len)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thp->sb_len_wr = len;\n\t\t}\n\t}\n\tif (hp->masked_status || hp->host_status || hp->driver_status)\n\t\thp->info |= SG_INFO_CHECK;\n\terr = put_sg_io_hdr(hp, buf);\nerr_out:\n\terr2 = sg_finish_rem_req(srp);\n\tsg_remove_request(sfp, srp);\n\treturn err ? : err2 ? : count;\n}", "target": 0}
{"code": "int set_binfmt(struct linux_binfmt *new)\n{\n\tstruct linux_binfmt *old = current->binfmt;\n\tif (new) {\n\t\tif (!try_module_get(new->module))\n\t\t\treturn -1;\n\t}\n\tcurrent->binfmt = new;\n\tif (old)\n\t\tmodule_put(old->module);\n\treturn 0;\n}", "target": 0}
{"code": "int http_remove_header2(struct http_msg *msg, struct buffer *buf,\n\t\t\tstruct hdr_idx *idx, struct hdr_ctx *ctx)\n{\n\tint cur_idx = ctx->idx;\n\tchar *sol = ctx->line;\n\tstruct hdr_idx_elem *hdr;\n\tint delta, skip_comma;\n\tif (!cur_idx)\n\t\treturn 0;\n\thdr = &idx->v[cur_idx];\n\tif (sol[ctx->del] == ':' && ctx->val + ctx->vlen + ctx->tws == hdr->len) {\n\t\tdelta = buffer_replace2(buf, sol, sol + hdr->len + hdr->cr + 1, NULL, 0);\n\t\thttp_msg_move_end(msg, delta);\n\t\tidx->used--;\n\t\thdr->len = 0;   \n\t\tidx->v[ctx->prev].next = idx->v[ctx->idx].next;\n\t\tif (idx->tail == ctx->idx)\n\t\t\tidx->tail = ctx->prev;\n\t\tctx->idx = ctx->prev;    \n\t\tctx->line -= idx->v[ctx->idx].len + idx->v[cur_idx].cr + 1;\n\t\tctx->val = idx->v[ctx->idx].len; \n\t\tctx->tws = ctx->vlen = 0;\n\t\treturn ctx->idx;\n\t}\n\tskip_comma = (ctx->val + ctx->vlen + ctx->tws == hdr->len) ? 0 : 1;\n\tdelta = buffer_replace2(buf, sol + ctx->del + skip_comma,\n\t\t\t\tsol + ctx->val + ctx->vlen + ctx->tws + skip_comma,\n\t\t\t\tNULL, 0);\n\thdr->len += delta;\n\thttp_msg_move_end(msg, delta);\n\tctx->val = ctx->del;\n\tctx->tws = ctx->vlen = 0;\n\treturn ctx->idx;\n}", "target": 0}
{"code": "static void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t   struct dj_report *dj_report)\n{\n\tkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\n\tif (schedule_work(&djrcv_dev->work) == 0) {\n\t\tdbg_hid(\"%s: did not schedule the work item, was already \"\n\t\t\t\"queued\\n\", __func__);\n\t}\n}", "target": 0}
{"code": "fmtfloat(double value, char type, int forcesign, int leftjust,\n\t\t int minlen, int zpad, int precision, int pointflag,\n\t\t PrintfTarget *target)\n{\n\tint\t\t\tsignvalue = 0;\n\tint\t\t\tvallen;\n\tchar\t\tfmt[32];\n\tchar\t\tconvert[512];\n\tint\t\t\tpadlen = 0;\t\t\n\tif (pointflag)\n\t\tsprintf(fmt, \"%%.%d%c\", precision, type);\n\telse\n\t\tsprintf(fmt, \"%%%c\", type);\n\tif (adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tvallen = sprintf(convert, fmt, value);\n\tadjust_padlen(minlen, vallen, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\tdostr(convert, vallen, target);\n\ttrailing_pad(&padlen, target);\n}", "target": 1}
{"code": "void AudioContext::notifyNodeStartedProcessing(AudioNode* node)\n{\n    refNode(node);\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "set_string (char **strp, const char *value)\n{\n\tif (*strp)\n\t\tfree (*strp);\n\t*strp = value ? strdup (value) : NULL;\n}", "target": 0}
{"code": "  int size() const override { return value_ == nullptr ? 0 : value_->size(); }", "target": 0}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "fetch_indexed_string (dwarf_vma           idx,\n\t\t      struct cu_tu_set *  this_set,\n\t\t      dwarf_vma           offset_size,\n\t\t      bool                dwo,\n\t\t      dwarf_vma           str_offsets_base)\n{\n  enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;\n  enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;\n  struct dwarf_section *index_section = &debug_displays [idx_sec_idx].section;\n  struct dwarf_section *str_section = &debug_displays [str_sec_idx].section;\n  dwarf_vma index_offset;\n  dwarf_vma str_offset;\n  const char * ret;\n  if (index_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str_offsets.dwo section>\")\n\t\t: _(\"<no .debug_str_offsets section>\"));\n  if (str_section->start == NULL)\n    return (dwo ? _(\"<no .debug_str.dwo section>\")\n\t\t: _(\"<no .debug_str section>\"));\n  index_offset = idx * offset_size;\n  if (this_set != NULL)\n    index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];\n  index_offset += str_offsets_base;\n  if (index_offset + offset_size > index_section->size)\n    {\n      warn (_(\"string index of %s converts to an offset of 0x%s which is too big for section %s\"),\n\t    dwarf_vmatoa (\"d\", idx),\n\t    dwarf_vmatoa (\"x\", index_offset),\n\t    str_section->name);\n      return _(\"<string index too big>\");\n    }\n  str_offset = byte_get (index_section->start + index_offset, offset_size);\n  str_offset -= str_section->address;\n  if (str_offset >= str_section->size)\n    {\n      warn (_(\"indirect offset too big: 0x%s\\n\"),\n\t    dwarf_vmatoa (\"x\", str_offset));\n      return _(\"<indirect index offset is too big>\");\n    }\n  ret = (const char *) str_section->start + str_offset;\n  if (strnlen (ret, str_section->size - str_offset)\n      == str_section->size - str_offset)\n    return _(\"<no NUL byte at end of section>\");\n  return ret;\n}", "target": 0}
{"code": "static void nvme_flush_ns_cb(void *opaque, int ret)\n{\n    NvmeFlushAIOCB *iocb = opaque;\n    NvmeNamespace *ns = iocb->ns;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto out;\n    } else if (iocb->ret < 0) {\n        goto out;\n    }\n    if (ns) {\n        trace_pci_nvme_flush_ns(iocb->nsid);\n        iocb->ns = NULL;\n        iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);\n        return;\n    }\nout:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag, const UChar** pp,\n\t\t   const UChar* end, UChar* fold, OnigEncoding enc)\n{\n  const UChar* p = *pp;\n  if (ONIGENC_IS_MBC_ASCII(p)) {\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n      if (*p == 0x49) {\n\t*fold++ = 0xc4;\n\t*fold   = 0xb1;\n\t(*pp)++;\n\treturn 2;\n      }\n    }\n#endif\n    *fold = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n    (*pp)++;\n    return 1; \n  }\n  else {\n    return onigenc_unicode_mbc_case_fold(enc, flag, pp, end, fold);\n  }\n}", "target": 0}
{"code": "int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long addr, int new_below)\n{\n\tstruct vm_area_struct *new;\n\tint err;\n\tif (is_vm_hugetlb_page(vma) && (addr &\n\t\t\t\t\t~(huge_page_mask(hstate_vma(vma)))))\n\t\treturn -EINVAL;\n\tnew = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\t*new = *vma;\n\tINIT_LIST_HEAD(&new->anon_vma_chain);\n\tif (new_below)\n\t\tnew->vm_end = addr;\n\telse {\n\t\tnew->vm_start = addr;\n\t\tnew->vm_pgoff += ((addr - vma->vm_start) >> PAGE_SHIFT);\n\t}\n\terr = vma_dup_policy(vma, new);\n\tif (err)\n\t\tgoto out_free_vma;\n\terr = anon_vma_clone(new, vma);\n\tif (err)\n\t\tgoto out_free_mpol;\n\tif (new->vm_file)\n\t\tget_file(new->vm_file);\n\tif (new->vm_ops && new->vm_ops->open)\n\t\tnew->vm_ops->open(new);\n\tif (new_below)\n\t\terr = vma_adjust(vma, addr, vma->vm_end, vma->vm_pgoff +\n\t\t\t((addr - new->vm_start) >> PAGE_SHIFT), new);\n\telse\n\t\terr = vma_adjust(vma, vma->vm_start, addr, vma->vm_pgoff, new);\n\tif (!err)\n\t\treturn 0;\n\tif (new->vm_ops && new->vm_ops->close)\n\t\tnew->vm_ops->close(new);\n\tif (new->vm_file)\n\t\tfput(new->vm_file);\n\tunlink_anon_vmas(new);\n out_free_mpol:\n\tmpol_put(vma_policy(new));\n out_free_vma:\n\tkmem_cache_free(vm_area_cachep, new);\n\treturn err;\n}", "target": 0}
{"code": "XML_MemMalloc(XML_Parser parser, size_t size)\n{\n  if (parser == NULL)\n    return NULL;\n  return MALLOC(parser, size);\n}", "target": 0}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "void EditorClientBlackBerry::undo()\n{\n    if (canUndo()) {\n        EditCommandStack::iterator back = --m_undoStack.end();\n        RefPtr<UndoStep> command(*back);\n        m_undoStack.remove(back);\n        command->unapply();\n    }\n}", "target": 0}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "gplotCreate(const char  *rootname,\n            l_int32      outformat,\n            const char  *title,\n            const char  *xlabel,\n            const char  *ylabel)\n{\nchar    *newroot;\nchar     buf[L_BUF_SIZE];\nl_int32  badchar;\nGPLOT   *gplot;\n    PROCNAME(\"gplotCreate\");\n    if (!rootname)\n        return (GPLOT *)ERROR_PTR(\"rootname not defined\", procName, NULL);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return (GPLOT *)ERROR_PTR(\"outformat invalid\", procName, NULL);\n    stringCheckForChars(rootname, \"`;&|><\\\"?*\", &badchar);\n    if (badchar)  \n        return (GPLOT *)ERROR_PTR(\"invalid rootname\", procName, NULL);\n    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    gplot->cmddata = sarrayCreate(0);\n    gplot->datanames = sarrayCreate(0);\n    gplot->plotdata = sarrayCreate(0);\n    gplot->plottitles = sarrayCreate(0);\n    gplot->plotstyles = numaCreate(0);\n    newroot = genPathname(rootname, NULL);\n    gplot->rootname = newroot;\n    gplot->outformat = outformat;\n    snprintf(buf, L_BUF_SIZE, \"%s.cmd\", rootname);\n    gplot->cmdname = stringNew(buf);\n    if (outformat == GPLOT_PNG)\n        snprintf(buf, L_BUF_SIZE, \"%s.png\", newroot);\n    else if (outformat == GPLOT_PS)\n        snprintf(buf, L_BUF_SIZE, \"%s.ps\", newroot);\n    else if (outformat == GPLOT_EPS)\n        snprintf(buf, L_BUF_SIZE, \"%s.eps\", newroot);\n    else if (outformat == GPLOT_LATEX)\n        snprintf(buf, L_BUF_SIZE, \"%s.tex\", newroot);\n    gplot->outname = stringNew(buf);\n    if (title) gplot->title = stringNew(title);\n    if (xlabel) gplot->xlabel = stringNew(xlabel);\n    if (ylabel) gplot->ylabel = stringNew(ylabel);\n    return gplot;\n}", "target": 1}
{"code": "static void spl_pqueue_it_get_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC) \n{\n\tspl_heap_it  *iterator = (spl_heap_it *)iter;\n\tzval        **element  = (zval **)&iterator->object->heap->elements[0];\n\tif (iterator->object->heap->flags & SPL_HEAP_CORRUPTED) {\n\t\tzend_throw_exception(spl_ce_RuntimeException, \"Heap is corrupted, heap properties are no longer ensured.\", 0 TSRMLS_CC);\n\t\treturn;\n\t}\n\tif (iterator->object->heap->count == 0 || !*element) {\n\t\t*data = NULL;\n\t} else {\n\t\t*data = spl_pqueue_extract_helper(element, iterator->object->flags);\n\t\tif (!*data) {\n\t\t\tzend_error(E_RECOVERABLE_ERROR, \"Unable to extract from the PriorityQueue node\");\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}", "target": 1}
{"code": "static void nvme_aio_err(NvmeRequest *req, int ret)\n{\n    uint16_t status = NVME_SUCCESS;\n    Error *local_err = NULL;\n    switch (req->cmd.opcode) {\n    case NVME_CMD_READ:\n        status = NVME_UNRECOVERED_READ;\n        break;\n    case NVME_CMD_FLUSH:\n    case NVME_CMD_WRITE:\n    case NVME_CMD_WRITE_ZEROES:\n    case NVME_CMD_ZONE_APPEND:\n        status = NVME_WRITE_FAULT;\n        break;\n    default:\n        status = NVME_INTERNAL_DEV_ERROR;\n        break;\n    }\n    trace_pci_nvme_err_aio(nvme_cid(req), strerror(-ret), status);\n    error_setg_errno(&local_err, -ret, \"aio failed\");\n    error_report_err(local_err);\n    if (req->status && status != NVME_INTERNAL_DEV_ERROR) {\n        return;\n    }\n    req->status = status;\n}", "target": 0}
{"code": "CreateMultiStringPopUp (\n  IN  UINTN                       RequestedWidth,\n  IN  UINTN                       NumberOfLines,\n  ...\n  )\n{\n  VA_LIST Marker;\n  VA_START (Marker, NumberOfLines);\n  CreateSharedPopUp (RequestedWidth, NumberOfLines, Marker);\n  VA_END (Marker);\n}", "target": 0}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n \tstruct oz_app_hdr *app_hdr;\n \tstruct oz_serial_ctx *ctx;\n \tspin_lock_bh(&g_cdev.lock);\n \tpd = g_cdev.active_pd;\n \tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 1}
{"code": "void ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\tqsDNSActive.remove(unresolved);\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}", "target": 0}
{"code": "print_address_information(address_item *addr, FILE *f, uschar *si, uschar *sc,\n  uschar *se)\n{\nBOOL yield = TRUE;\nuschar *printed = US\"\";\naddress_item *ancestor = addr;\nwhile (ancestor->parent) ancestor = ancestor->parent;\nfprintf(f, \"%s\", CS si);\nif (addr->parent && testflag(addr, af_hide_child))\n  {\n  printed = US\"an undisclosed address\";\n  yield = FALSE;\n  }\nelse if (!testflag(addr, af_pfr) || !addr->parent)\n  printed = addr->address;\nelse\n  {\n  uschar *s = addr->address;\n  uschar *ss;\n  if (addr->address[0] == '>') { ss = US\"mail\"; s++; }\n  else if (addr->address[0] == '|') ss = US\"pipe\";\n  else ss = US\"save\";\n  fprintf(f, \"%s to %s%sgenerated by \", ss, s, sc);\n  printed = addr->parent->address;\n  }\nfprintf(f, \"%s\", CS string_printing(printed));\nif (ancestor != addr)\n  {\n  uschar *original = ancestor->onetime_parent;\n  if (!original) original= ancestor->address;\n  if (strcmpic(original, printed) != 0)\n    fprintf(f, \"%s(%sgenerated from %s)\", sc,\n      ancestor != addr->parent ? \"ultimately \" : \"\",\n      string_printing(original));\n  }\nif (addr->host_used)\n  fprintf(f, \"\\n    host %s [%s]\",\n\t  addr->host_used->name, addr->host_used->address);\nfprintf(f, \"%s\", CS se);\nreturn yield;\n}", "target": 0}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "monitor_allowed_key(u_char *blob, u_int bloblen)\n{\n\tif (key_blob == NULL || key_bloblen != bloblen ||\n\t    memcmp(key_blob, blob, key_bloblen))\n\t\treturn (0);\n\treturn (1);\n}", "target": 0}
{"code": "int RGWHandler_REST_S3Website::error_handler(int err_no,\n\t\t\t\t\t    string* error_content) {\n  int new_err_no = -1;\n  rgw_http_errors::const_iterator r = rgw_http_s3_errors.find(err_no > 0 ? err_no : -err_no);\n  int http_error_code = -1;\n  if (r != rgw_http_s3_errors.end()) {\n    http_error_code = r->second.first;\n  }\n  ldpp_dout(s, 10) << \"RGWHandler_REST_S3Website::error_handler err_no=\" << err_no << \" http_ret=\" << http_error_code << dendl;\n  RGWBWRoutingRule rrule;\n  bool should_redirect =\n    s->bucket_info.website_conf.should_redirect(original_object_name,\n                                                http_error_code, &rrule);\n  if (should_redirect) {\n    const string& hostname = s->info.env->get(\"HTTP_HOST\", \"\");\n    const string& protocol =\n      (s->info.env->get(\"SERVER_PORT_SECURE\") ? \"https\" : \"http\");\n    int redirect_code = 0;\n    rrule.apply_rule(protocol, hostname, original_object_name,\n                     &s->redirect, &redirect_code);\n    if (redirect_code > 0)\n      s->err.http_ret = redirect_code; \n    ldpp_dout(s, 10) << \"error handler redirect code=\" << redirect_code\n\t\t      << \" proto+host:\" << protocol << \":\n\t\t      << \" -> \" << s->redirect << dendl;\n    return -ERR_WEBSITE_REDIRECT;\n  } else if (err_no == -ERR_WEBSITE_REDIRECT) {\n  } else if (!s->bucket_info.website_conf.error_doc.empty()) {\n    new_err_no = RGWHandler_REST_S3Website::serve_errordoc(http_error_code, s->bucket_info.website_conf.error_doc);\n    if (new_err_no && new_err_no != -1) {\n      err_no = new_err_no;\n    }\n  } else {\n    ldpp_dout(s, 20) << \"No special error handling today!\" << dendl;\n  }\n  return err_no;\n}", "target": 0}
{"code": "GF_Err vpcc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPConfigurationBox *ptr = (GF_VPConfigurationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tif (!ptr->config) return GF_OK;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\treturn gf_odf_vp_cfg_write_bs(ptr->config, bs, ptr->version == 0);\n}", "target": 0}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "void *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr done = 0;\n    hwaddr l, xlat, base;\n    MemoryRegion *mr, *this_mr;\n    ram_addr_t raddr;\n    if (len == 0) {\n        return NULL;\n    }\n    l = len;\n    rcu_read_lock();\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            rcu_read_unlock();\n            return NULL;\n        }\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n        rcu_read_unlock();\n        *plen = l;\n        return bounce.buffer;\n    }\n    base = xlat;\n    raddr = memory_region_get_ram_addr(mr);\n    for (;;) {\n        len -= l;\n        addr += l;\n        done += l;\n        if (len == 0) {\n            break;\n        }\n        l = len;\n        this_mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            break;\n        }\n    }\n    memory_region_ref(mr);\n    rcu_read_unlock();\n    *plen = done;\n    return qemu_ram_ptr_length(raddr + base, plen);\n}", "target": 0}
{"code": "static int __init lp_setup (char *str)\n{\n\tstatic int parport_ptr;\n\tint x;\n\tif (get_option(&str, &x)) {\n\t\tif (x == 0) {\n\t\t\tparport_nr[0] = LP_PARPORT_OFF;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strncmp(str, \"parport\", 7)) {\n\t\tint n = simple_strtoul(str+7, NULL, 10);\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = n;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"auto\")) {\n\t\tparport_nr[0] = LP_PARPORT_AUTO;\n\t} else if (!strcmp(str, \"none\")) {\n\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n\t} else if (!strcmp(str, \"reset\")) {\n\t\treset = 1;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void ff_layout_write_release(void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tff_layout_write_record_layoutstats_done(&hdr->task, hdr);\n\tif (test_bit(NFS_IOHDR_RESEND_PNFS, &hdr->flags)) {\n\t\tff_layout_send_layouterror(hdr->lseg);\n\t\tff_layout_reset_write(hdr, true);\n\t} else if (test_bit(NFS_IOHDR_RESEND_MDS, &hdr->flags))\n\t\tff_layout_reset_write(hdr, false);\n\tpnfs_generic_rw_release(data);\n}", "target": 0}
{"code": "static void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,\n\t\t\t\tu64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\tpt_element_t *gptep = gw->prefetch_ptes;\n\tu64 *spte;\n\tint i;\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\tif (sp->role.direct)\n\t\treturn __direct_pte_prefetch(vcpu, sp, sptep);\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (spte == sptep)\n\t\t\tcontinue;\n\t\tif (is_shadow_present_pte(*spte))\n\t\t\tcontinue;\n\t\tif (!FNAME(prefetch_gpte)(vcpu, sp, spte, gptep[i], true))\n\t\t\tbreak;\n\t}\n}", "target": 0}
{"code": "void sk_setup_caps(struct sock *sk, struct dst_entry *dst)\n{\n\t__sk_dst_set(sk, dst);\n\tsk->sk_route_caps = dst->dev->features;\n\tif (sk->sk_route_caps & NETIF_F_GSO)\n\t\tsk->sk_route_caps |= NETIF_F_GSO_SOFTWARE;\n\tsk->sk_route_caps &= ~sk->sk_route_nocaps;\n\tif (sk_can_gso(sk)) {\n\t\tif (dst->header_len) {\n\t\t\tsk->sk_route_caps &= ~NETIF_F_GSO_MASK;\n\t\t} else {\n\t\t\tsk->sk_route_caps |= NETIF_F_SG | NETIF_F_HW_CSUM;\n\t\t\tsk->sk_gso_max_size = dst->dev->gso_max_size;\n\t\t}\n\t}\n}", "target": 0}
{"code": "parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n{\n\tsize_t level = 0;\n\tsize_t i, end, skip;\n\twhile (level < size && level < 6 && data[level] == '#')\n\t\tlevel++;\n\tfor (i = level; i < size && data[i] == ' '; i++);\n\tfor (end = i; end < size && data[end] != '\\n'; end++);\n\tskip = end;\n\twhile (end && data[end - 1] == '#')\n\t\tend--;\n\twhile (end && data[end - 1] == ' ')\n\t\tend--;\n\tif (end > i) {\n\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\tparse_inline(work, rndr, data + i, end - i);\n\t\tif (rndr->cb.header)\n\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t}\n\treturn skip;\n}", "target": 0}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "      _cimg_math_parser(const _cimg_math_parser& mp):\n        mem(mp.mem),code(mp.code),p_code_end(mp.p_code_end),p_break(mp.p_break),\n        imgin(mp.imgin),listin(mp.listin),imgout(mp.imgout),listout(mp.listout),img_stats(mp.img_stats),\n        list_stats(mp.list_stats),list_median(mp.list_median),debug_indent(0),result_dim(mp.result_dim),\n        break_type(0),constcache_size(0),is_parallelizable(mp.is_parallelizable),is_fill(mp.is_fill),\n        need_input_copy(mp.need_input_copy), result(mem._data + (mp.result - mp.mem._data)),calling_function(0) {\n#ifdef cimg_use_openmp\n        mem[17] = omp_get_thread_num();\n#endif\n        opcode.assign();\n        opcode._is_shared = true;", "target": 0}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "compile_length_string_node(Node* node, regex_t* reg)\n{\n  int rlen, r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p, sn->end);\n  p += prev_len;\n  slen = 1;\n  rlen = 0;\n  for (; p < sn->end; ) {\n    len = enclen(enc, p, sn->end);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n      rlen += r;\n      prev = p;\n      slen = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  r = add_compile_string_length(prev, prev_len, slen, reg, ambig);\n  rlen += r;\n  return rlen;\n}", "target": 0}
{"code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  FlushRstStream();\n}", "target": 1}
{"code": "void OutOfMem(size_t size)\n{\n    FatalError(\"Out of memory on allocating %d bytes.\", size);\n}", "target": 0}
{"code": "static inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_HWPOISON | FOLL_WRITE;\n\trc = get_user_pages(addr, 1, flags, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}", "target": 0}
{"code": "hash_findi_add(struct hash_table *hash, const char *str)\n{\n    struct hash_insert hi;\n    void **r;\n    char *strx;\n    size_t l = strlen(str) + 1;\n    r = hash_findib(hash, str, l, &hi);\n    if (r)\n        return r;\n    strx = nasm_malloc(l);  \n    memcpy(strx, str, l);\n    return hash_add(&hi, strx, NULL);\n}", "target": 0}
{"code": "    Classifier (const char *&ptr, int size)\n    {\n        if (size <= 0) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        {\n            char suffix[Name::SIZE+1];\n            memset (suffix, 0, Name::SIZE+1);\n            Xdr::read<CharPtrIO> (ptr, std::min(size, Name::SIZE-1), suffix);\n            _suffix = std::string(suffix);\n        }\n        if (static_cast<size_t>(size) < _suffix.length() + 1 + 2*Xdr::size<char>()) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (truncated rule).\");\n        char value;\n        Xdr::read<CharPtrIO> (ptr, value);\n        _cscIdx = (int)(value >> 4) - 1;\n        if (_cscIdx < -1 || _cscIdx >= 3) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt cscIdx rule).\");\n        _scheme = (CompressorScheme)((value >> 2) & 3);\n        if (_scheme < 0 || _scheme >= NUM_COMPRESSOR_SCHEMES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt scheme rule).\");\n        _caseInsensitive = (value & 1 ? true : false);\n        Xdr::read<CharPtrIO> (ptr, value);\n        if (value < 0 || value >= NUM_PIXELTYPES) \n            throw IEX_NAMESPACE::InputExc(\"Error uncompressing DWA data\"\n                                \" (corrupt rule).\");\n        _type = (PixelType)value;\n    }", "target": 0}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "static int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}", "target": 0}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int fdt_include_supernodes(struct fdt_region_state *info, int depth)\n{\n\tint base = fdt_off_dt_struct(info->fdt);\n\tint start, stop_at;\n\tint i;\n\tfor (i = 0; i <= depth; i++) {\n\t\tif (!info->stack[i].included) {\n\t\t\tstart = info->stack[i].offset;\n\t\t\tfdt_next_tag(info->fdt, start, &stop_at);\n\t\t\tif (fdt_add_region(info, base + start, stop_at - start))\n\t\t\t\treturn -1;\n\t\t\tinfo->stack[i].included = 1;\n\t\t\tinfo->can_merge = 1;\n\t\t}\n\t\tif (!info->stack[i].want)\n\t\t\tinfo->stack[i].want = WANT_NODES_ONLY;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "int qemu_can_send_packet(NetClientState *sender)\n{\n    int vm_running = runstate_is_running();\n    if (!vm_running) {\n        return 0;\n    }\n    if (!sender->peer) {\n        return 1;\n    }\n    if (sender->peer->receive_disabled) {\n        return 0;\n    } else if (sender->peer->info->can_receive &&\n               !sender->peer->info->can_receive(sender->peer)) {\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "static int check_vmentry_postreqs(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12,\n\t\t\t\t  u32 *exit_qual)\n{\n\tbool ia32e;\n\t*exit_qual = ENTRY_FAIL_DEFAULT;\n\tif (!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0) ||\n\t    !nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4))\n\t\treturn 1;\n\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_SHADOW_VMCS) &&\n\t    vmcs12->vmcs_link_pointer != -1ull) {\n\t\t*exit_qual = ENTRY_FAIL_VMCS_LINK_PTR;\n\t\treturn 1;\n\t}\n\tif (to_vmx(vcpu)->nested.nested_run_pending &&\n\t    (vmcs12->vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER)) {\n\t\tia32e = (vmcs12->vm_entry_controls & VM_ENTRY_IA32E_MODE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->guest_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->guest_ia32_efer & EFER_LMA) ||\n\t\t    ((vmcs12->guest_cr0 & X86_CR0_PG) &&\n\t\t     ia32e != !!(vmcs12->guest_ia32_efer & EFER_LME)))\n\t\t\treturn 1;\n\t}\n\tif (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {\n\t\tia32e = (vmcs12->vm_exit_controls &\n\t\t\t VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;\n\t\tif (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||\n\t\t    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "sg_vma_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tSg_fd *sfp;\n\tunsigned long offset, len, sa;\n\tSg_scatter_hold *rsv_schp;\n\tint k, length;\n\tif ((NULL == vma) || (!(sfp = (Sg_fd *) vma->vm_private_data)))\n\t\treturn VM_FAULT_SIGBUS;\n\trsv_schp = &sfp->reserve;\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= rsv_schp->bufflen)\n\t\treturn VM_FAULT_SIGBUS;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_vma_fault: offset=%lu, scatg=%d\\n\",\n\t\t\t\t      offset, rsv_schp->k_use_sg));\n\tsa = vma->vm_start;\n\tlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\n\tfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\n\t\tlen = vma->vm_end - sa;\n\t\tlen = (len < length) ? len : length;\n\t\tif (offset < len) {\n\t\t\tstruct page *page = nth_page(rsv_schp->pages[k],\n\t\t\t\t\t\t     offset >> PAGE_SHIFT);\n\t\t\tget_page(page);\t\n\t\t\tvmf->page = page;\n\t\t\treturn 0; \n\t\t}\n\t\tsa += len;\n\t\toffset -= len;\n\t}\n\treturn VM_FAULT_SIGBUS;\n}", "target": 0}
{"code": "strncmpic(uschar *s, uschar *t, int n)\n{\nwhile (n--)\n  {\n  int c = tolower(*s++) - tolower(*t++);\n  if (c) return c;\n  }\nreturn 0;\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "static void irda_connect_confirm(void *instance, void *sap,\n\t\t\t\t struct qos_info *qos,\n\t\t\t\t __u32 max_sdu_size, __u8 max_header_size,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev_kfree_skb(skb);\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    return AVIF_TRUE;\n}", "target": 1}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ax)\n\t\treturn;\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\tnetif_stop_queue(ax->dev);\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\tax->tty = NULL;\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}", "target": 1}
{"code": "static PyObject *convert_slist(struct curl_slist *slist, int free_flags)\n{\n    PyObject *ret = NULL;\n    struct curl_slist *slist_start = slist;\n    ret = PyList_New((Py_ssize_t)0);\n    if (ret == NULL) goto error;\n    for ( ; slist != NULL; slist = slist->next) {\n        PyObject *v = NULL;\n        if (slist->data == NULL) {\n            v = Py_None; Py_INCREF(v);\n        } else {\n            v = PyText_FromString(slist->data);\n        }\n        if (v == NULL || PyList_Append(ret, v) != 0) {\n            Py_XDECREF(v);\n            goto error;\n        }\n        Py_DECREF(v);\n    }\n    if ((free_flags & 1) && slist_start)\n        curl_slist_free_all(slist_start);\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    if ((free_flags & 2) && slist_start)\n        curl_slist_free_all(slist_start);\n    return NULL;\n}", "target": 0}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n    rb_scan_args(argc, argv, \"31:\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"args\", RARRAY_LENINT(args));\n    rb_iv_set(self, \"@ptr\", ptr);\n    rb_iv_set(self, \"@args\", args);\n    rb_iv_set(self, \"@return_type\", ret_type);\n    rb_iv_set(self, \"@abi\", abi);\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n    if (result)\n\trb_raise(rb_eRuntimeError, \"error creating CIF %d\", result);\n    return self;\n}", "target": 1}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "_gnutls_x509_oid2mac_algorithm (const char *oid)\n{\n  gnutls_mac_algorithm_t ret = 0;\n  GNUTLS_HASH_LOOP (if (strcmp (oid, p->oid) == 0)\n\t\t    {\n\t\t    ret = p->id; break;}\n  );\n  if (ret == 0)\n    return GNUTLS_MAC_UNKNOWN;\n  return ret;\n}", "target": 1}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "static void mptsas_soft_reset(MPTSASState *s)\n{\n    uint32_t save_mask;\n    trace_mptsas_reset(s);\n    save_mask = s->intr_mask;\n    s->intr_mask = MPI_HIM_DIM | MPI_HIM_RIM;\n    mptsas_update_interrupt(s);\n    qbus_reset_all(BUS(&s->bus));\n    s->intr_status = 0;\n    s->intr_mask = save_mask;\n    s->reply_free_tail = 0;\n    s->reply_free_head = 0;\n    s->reply_post_tail = 0;\n    s->reply_post_head = 0;\n    s->request_post_tail = 0;\n    s->request_post_head = 0;\n    qemu_bh_cancel(s->request_bh);\n    s->state = MPI_IOC_STATE_READY;\n}", "target": 0}
{"code": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushboolean(J, 0);\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tunregister_netdev(sp->dev);\n}", "target": 1}
{"code": "RegexMatchExpression::RegexMatchExpression(StringData path, StringData regex, StringData options)\n    : LeafMatchExpression(REGEX, path),\n      _regex(regex.toString()),\n      _flags(options.toString()),\n      _re(new pcrecpp::RE(_regex.c_str(), flags2options(_flags.c_str()))) {\n    _init();\n}", "target": 0}
{"code": "void Splash::pipeRunAAMono8(SplashPipe *pipe) {\n  Guchar aSrc, aDest, alpha2, aResult;\n  SplashColor cDest;\n  Guchar cResult0;\n  cDest[0] = *pipe->destColorPtr;\n  aDest = *pipe->destAlphaPtr;\n  aSrc = div255(pipe->aInput * pipe->shape);\n  aResult = aSrc + aDest - div255(aSrc * aDest);\n  alpha2 = aResult;\n  if (alpha2 == 0) {\n    cResult0 = 0;\n  } else {\n    cResult0 = state->grayTransfer[(Guchar)(((alpha2 - aSrc) * cDest[0] +\n\t\t\t\t\t     aSrc * pipe->cSrc[0]) / alpha2)];\n  }\n  *pipe->destColorPtr++ = cResult0;\n  *pipe->destAlphaPtr++ = aResult;\n  ++pipe->x;\n}", "target": 0}
{"code": "FILE *mingw_fopen (const char *filename, const char *otype)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfopen(wfilename, wotype);\n\tif (!file && GetLastError() == ERROR_INVALID_NAME)\n\t\terrno = ENOENT;\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "int RGWGetObj_ObjStore_S3Website::send_response_data(bufferlist& bl, off_t bl_ofs, off_t bl_len) {\n  map<string, bufferlist>::iterator iter;\n  iter = attrs.find(RGW_ATTR_AMZ_WEBSITE_REDIRECT_LOCATION);\n  if (iter != attrs.end()) {\n    bufferlist &bl = iter->second;\n    s->redirect = bl.c_str();\n    s->err.http_ret = 301;\n    ldout(s->cct, 20) << __CEPH_ASSERT_FUNCTION << \" redirecting per x-amz-website-redirect-location=\" << s->redirect << dendl;\n    op_ret = -ERR_WEBSITE_REDIRECT;\n    set_req_state_err(s, op_ret);\n    dump_errno(s);\n    dump_content_length(s, 0);\n    dump_redirect(s, s->redirect);\n    end_header(s, this);\n    return op_ret;\n  } else {\n    return RGWGetObj_ObjStore_S3::send_response_data(bl, bl_ofs, bl_len);\n  }\n}", "target": 0}
{"code": "decode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; \n\tif (24 > plen)\n\t\treturn -1;\n        plen-=24; \n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 4 + plenbytes;\ntrunc:\n\treturn -2;\nbadtlv:\n\treturn -3;\n}", "target": 0}
{"code": "acceptableEncoding()\n{\n    static Str encodings = NULL;\n    struct compression_decoder *d;\n    TextList *l;\n    char *p;\n    if (encodings != NULL)\n\treturn encodings->ptr;\n    l = newTextList();\n    for (d = compression_decoders; d->type != CMP_NOCOMPRESS; d++) {\n\tif (check_command(d->cmd, d->auxbin_p)) {\n\t    pushText(l, d->encoding);\n\t}\n    }\n    encodings = Strnew();\n    while ((p = popText(l)) != NULL) {\n\tif (encodings->length)\n\t    Strcat_charp(encodings, \", \");\n\tStrcat_charp(encodings, p);\n    }\n    return encodings->ptr;\n}", "target": 0}
{"code": "static int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_blkcipher *ci;\n\t_enter(\"%zu\", prep->datalen);\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\tmemcpy(&prep->type_data, prep->data, 8);\n\tci = crypto_alloc_blkcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\tif (crypto_blkcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\tprep->payload[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}", "target": 0}
{"code": "static inline void *freelist_dereference(const struct kmem_cache *s,\n\t\t\t\t\t void *ptr_addr)\n{\n\treturn freelist_ptr(s, (void *)*(unsigned long *)(ptr_addr),\n\t\t\t    (unsigned long)ptr_addr);\n}", "target": 0}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "static int _nfs4_proc_readdir(struct dentry *dentry, struct rpc_cred *cred,\n\t\tu64 cookie, struct page **pages, unsigned int count, int plus)\n{\n\tstruct inode\t\t*dir = dentry->d_inode;\n\tstruct nfs4_readdir_arg args = {\n\t\t.fh = NFS_FH(dir),\n\t\t.pages = pages,\n\t\t.pgbase = 0,\n\t\t.count = count,\n\t\t.bitmask = NFS_SERVER(dentry->d_inode)->attr_bitmask,\n\t\t.plus = plus,\n\t};\n\tstruct nfs4_readdir_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READDIR],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = cred,\n\t};\n\tint\t\t\tstatus;\n\tdprintk(\"%s: dentry = %s/%s, cookie = %Lu\\n\", __func__,\n\t\t\tdentry->d_parent->d_name.name,\n\t\t\tdentry->d_name.name,\n\t\t\t(unsigned long long)cookie);\n\tnfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);\n\tres.pgbase = args.pgbase;\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (status >= 0) {\n\t\tmemcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);\n\t\tstatus += args.pgbase;\n\t}\n\tnfs_invalidate_atime(dir);\n\tdprintk(\"%s: returns %d\\n\", __func__, status);\n\treturn status;\n}", "target": 0}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\tle32_to_cpu(raw_inode->i_size_lo);", "target": 1}
{"code": "u32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\tif (!movie || !movie->moov) return 0;\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "guardfraction_file_parse_guard_line(const char *guard_line,\n                                    smartlist_t *vote_routerstatuses,\n                                    char **err_msg)\n{\n  char guard_id[DIGEST_LEN];\n  uint32_t guardfraction;\n  char *inputs_tmp = NULL;\n  int num_ok = 1;\n  smartlist_t *sl = smartlist_new();\n  int retval = -1;\n  tor_assert(err_msg);\n  smartlist_split_string(sl, guard_line, \" \",\n                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 3);\n  if (smartlist_len(sl) < 3) {\n    tor_asprintf(err_msg, \"bad line '%s'\", guard_line);\n    goto done;\n  }\n  inputs_tmp = smartlist_get(sl, 0);\n  if (strlen(inputs_tmp) != HEX_DIGEST_LEN ||\n      base16_decode(guard_id, DIGEST_LEN,\n                    inputs_tmp, HEX_DIGEST_LEN) != DIGEST_LEN) {\n    tor_asprintf(err_msg, \"bad digest '%s'\", inputs_tmp);\n    goto done;\n  }\n  inputs_tmp = smartlist_get(sl, 1);\n  guardfraction =\n    (uint32_t) tor_parse_long(inputs_tmp, 10, 0, 100, &num_ok, NULL);\n  if (!num_ok) {\n    tor_asprintf(err_msg, \"wrong percentage '%s'\", inputs_tmp);\n    goto done;\n  }\n  if (vote_routerstatuses) {\n    retval = guardfraction_line_apply(guard_id, guardfraction,\n                                      vote_routerstatuses);\n  } else {\n    retval = 0; \n  }\n done:\n  SMARTLIST_FOREACH(sl, char *, cp, tor_free(cp));\n  smartlist_free(sl);\n  return retval;\n}", "target": 0}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "static inline void RelinquishDCMMemory(DCMInfo *info,DCMMap *map,\n  DCMStreamInfo *stream_info,LinkedListInfo *stack,unsigned char *data)\n{\n  if (info->scale != (Quantum *) NULL)\n    info->scale=(Quantum *) RelinquishMagickMemory(info->scale);\n  if (map->gray != (int *) NULL)\n    map->gray=(int *) RelinquishMagickMemory(map->gray);\n  if (map->blue != (int *) NULL)\n    map->blue=(int *) RelinquishMagickMemory(map->blue);\n  if (map->green != (int *) NULL)\n    map->green=(int *) RelinquishMagickMemory(map->green);\n  if (map->red != (int *) NULL)\n    map->red=(int *) RelinquishMagickMemory(map->red);\n  if (stream_info->offsets != (ssize_t *) NULL)\n    stream_info->offsets=(ssize_t *) RelinquishMagickMemory(\n      stream_info->offsets);\n  if (stream_info != (DCMStreamInfo *) NULL)\n    stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);\n  if (stack != (LinkedListInfo *) NULL)\n    stack=DestroyLinkedList(stack,RelinquishDCMInfo);\n  if (data != (unsigned char *) NULL)\n    data=(unsigned char *) RelinquishMagickMemory(data);\n}", "target": 0}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){\n  int i;\n  Select *pNew;\n  Select *pX;\n  sqlite3 *db;\n  struct ExprList_item *a;\n  SrcList *pNewSrc;\n  Parse *pParse;\n  Token dummy;\n  if( p->pPrior==0 ) return WRC_Continue;\n  if( p->pOrderBy==0 ) return WRC_Continue;\n  for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}\n  if( pX==0 ) return WRC_Continue;\n  a = p->pOrderBy->a;\n  for(i=p->pOrderBy->nExpr-1; i>=0; i--){\n    if( a[i].pExpr->flags & EP_Collate ) break;\n  }\n  if( i<0 ) return WRC_Continue;\n  pParse = pWalker->pParse;\n  db = pParse->db;\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n  if( pNew==0 ) return WRC_Abort;\n  memset(&dummy, 0, sizeof(dummy));\n  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);\n  if( pNewSrc==0 ) return WRC_Abort;\n  *pNew = *p;\n  p->pSrc = pNewSrc;\n  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));\n  p->op = TK_SELECT;\n  p->pWhere = 0;\n  pNew->pGroupBy = 0;\n  pNew->pHaving = 0;\n  pNew->pOrderBy = 0;\n  p->pPrior = 0;\n  p->pNext = 0;\n  p->pWith = 0;\n  p->selFlags &= ~SF_Compound;\n  assert( (p->selFlags & SF_Converted)==0 );\n  p->selFlags |= SF_Converted;\n  assert( pNew->pPrior!=0 );\n  pNew->pPrior->pNext = pNew;\n  pNew->pLimit = 0;\n  return WRC_Continue;\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "redraw_buf_and_status_later(buf_T *buf, int type)\n{\n    win_T\t*wp;\n#ifdef FEAT_WILDMENU\n    if (wild_menu_showing != 0)\n\treturn;\n#endif\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp->w_buffer == buf)\n\t{\n\t    redraw_win_later(wp, type);\n\t    wp->w_redr_status = TRUE;\n\t}\n    }\n}", "target": 0}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 1}
{"code": "rb_reg_fixed_encoding_p(VALUE re)\n{\n    if (FL_TEST(re, KCODE_FIXED))\n        return Qtrue;\n    else\n        return Qfalse;\n}", "target": 0}
{"code": "static void bluetooth_client_finalize(GObject *object)\n{\n\tBluetoothClient *client = BLUETOOTH_CLIENT (object);\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE (client);\n\tif (priv->cancellable != NULL) {\n\t\tg_cancellable_cancel (priv->cancellable);\n\t\tg_clear_object (&priv->cancellable);\n\t}\n\tg_clear_object (&priv->manager);\n\tg_object_unref (priv->store);\n\tg_clear_pointer (&priv->default_adapter, gtk_tree_row_reference_free);\n\tG_OBJECT_CLASS(bluetooth_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "static void bnx2x_set_reset_done(struct bnx2x *bp)\n{\n\tu32 val;\n\tu32 bit = BP_PATH(bp) ?\n\t\tBNX2X_PATH1_RST_IN_PROG_BIT : BNX2X_PATH0_RST_IN_PROG_BIT;\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n\tval = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tval &= ~bit;\n\tREG_WR(bp, BNX2X_RECOVERY_GLOB_REG, val);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_RECOVERY_REG);\n}", "target": 0}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t show_constraint_name(struct device *dev,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tchar *buf)\n{\n\tconst char *name;\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\tint id;\n\tssize_t len = -ENODATA;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id))\n\t\treturn -EINVAL;\n\tif (id >= power_zone->const_id_cnt)\n\t\treturn -EINVAL;\n\tpconst = &power_zone->constraints[id];\n\tif (pconst && pconst->ops && pconst->ops->get_name) {\n\t\tname = pconst->ops->get_name(power_zone, id);\n\t\tif (name) {\n\t\t\tsnprintf(buf, POWERCAP_CONSTRAINT_NAME_LEN,\n\t\t\t\t\t\t\t\t\"%s\\n\", name);\n\t\t\tbuf[POWERCAP_CONSTRAINT_NAME_LEN] = '\\0';\n\t\t\tlen = strlen(buf);\n\t\t}\n\t}\n\treturn len;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NegatedRangeIntGTE) {\n    addIndex(BSON(\"i\" << 1));\n    runQuery(fromjson(\"{i: {$not: {$gte: 5}}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {i:1}, \"\n        \"bounds: {i: [['MinKey',5,true,false], \"\n        \"[Infinity,'MaxKey',false,true]]}}}}}\");\n}", "target": 0}
{"code": "static int pull_client_data (struct conn_s *connptr, long int length, int iehack)\n{\n        char *buffer;\n        ssize_t len;\n        int ret;\n        buffer =\n            (char *) safemalloc (min (MAXBUFFSIZE, (unsigned long int) length));\n        if (!buffer)\n                return -1;\n        do {\n                len = safe_read (connptr->client_fd, buffer,\n                                 min (MAXBUFFSIZE, (unsigned long int) length));\n                if (len <= 0)\n                        goto ERROR_EXIT;\n                if (!connptr->error_variables) {\n                        if (safe_write (connptr->server_fd, buffer, len) < 0)\n                                goto ERROR_EXIT;\n                }\n                length -= len;\n        } while (length > 0);\n        if (iehack) {\n                ret = socket_nonblocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to non-blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                len = recv (connptr->client_fd, buffer, 2, MSG_PEEK);\n                ret = socket_blocking (connptr->client_fd);\n                if (ret != 0) {\n                        log_message(LOG_ERR, \"Failed to set the client socket \"\n                                    \"to blocking: %s\", strerror(errno));\n                        goto ERROR_EXIT;\n                }\n                if (len < 0 && errno != EAGAIN)\n                        goto ERROR_EXIT;\n                if ((len == 2) && CHECK_CRLF (buffer, len)) {\n                        ssize_t bytes_read;\n                        bytes_read = read (connptr->client_fd, buffer, 2);\n                        if (bytes_read == -1) {\n                                log_message\n                                        (LOG_WARNING,\n                                         \"Could not read two bytes from POST message\");\n                        }\n                }\n        }\n        safefree (buffer);\n        return 0;\nERROR_EXIT:\n        safefree (buffer);\n        return -1;\n}", "target": 0}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "int read_record_hdr(int ifd, void *buffer, struct record_header *record_hdr,\n\t\t    struct file_header *file_hdr, int arch_64, int endian_mismatch,\n\t\t    int oneof, size_t b_size)\n{\n\tint rc;\n\tdo {\n\t\tif ((rc = sa_fread(ifd, buffer, (size_t) file_hdr->rec_size, SOFT_SIZE, oneof)) != 0)\n\t\t\treturn rc;\n\t\tif (remap_struct(rec_types_nr, file_hdr->rec_types_nr, buffer,\n\t\t\t\t file_hdr->rec_size, RECORD_HEADER_SIZE, b_size) < 0)\n\t\t\treturn 2;\n\t\tmemcpy(record_hdr, buffer, RECORD_HEADER_SIZE);\n\t\tif (endian_mismatch) {\n\t\t\tswap_struct(rec_types_nr, record_hdr, arch_64);\n\t\t}\n\t\tif ((record_hdr->record_type != R_COMMENT) && (record_hdr->record_type != R_RESTART) &&\n\t\t    record_hdr->extra_next && (skip_extra_struct(ifd, endian_mismatch, arch_64) < 0))\n\t\t\treturn 2;\n\t}\n\twhile (record_hdr->record_type == R_EXTRA);\n\treturn 0;\n}", "target": 0}
{"code": "int OutputValueSampler(CMSREGISTER const cmsUInt16Number In[], CMSREGISTER cmsUInt16Number Out[], CMSREGISTER void* Cargo)\n{\n    cmsPsSamplerCargo* sc = (cmsPsSamplerCargo*) Cargo;\n    cmsUInt32Number i;\n    if (sc -> FixWhite) {\n        if (In[0] == 0xFFFF) {  \n            if ((In[1] >= 0x7800 && In[1] <= 0x8800) &&\n                (In[2] >= 0x7800 && In[2] <= 0x8800)) {\n                cmsUInt16Number* Black;\n                cmsUInt16Number* White;\n                cmsUInt32Number nOutputs;\n                if (!_cmsEndPointsBySpace(sc ->ColorSpace, &White, &Black, &nOutputs))\n                        return 0;\n                for (i=0; i < nOutputs; i++)\n                        Out[i] = White[i];\n            }\n        }\n    }\n    if (In[0] != sc ->FirstComponent) {\n            if (sc ->FirstComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n                    sc ->SecondComponent = -1;\n                    _cmsIOPrintf(sc ->m, sc ->PostMaj);\n            }\n            _cmsPSActualColumn = 0;\n            _cmsIOPrintf(sc ->m, sc ->PreMaj);\n            sc ->FirstComponent = In[0];\n    }\n      if (In[1] != sc ->SecondComponent) {\n            if (sc ->SecondComponent != -1) {\n                    _cmsIOPrintf(sc ->m, sc ->PostMin);\n            }\n            _cmsIOPrintf(sc ->m, sc ->PreMin);\n            sc ->SecondComponent = In[1];\n    }\n      for (i=0; i < sc -> Pipeline ->Params->nOutputs; i++) {\n          cmsUInt16Number wWordOut = Out[i];\n          cmsUInt8Number wByteOut;           \n          wByteOut = Word2Byte(wWordOut);\n          WriteByte(sc -> m, wByteOut);\n      }\n      return 1;\n}", "target": 0}
{"code": "CLua &CLua::get_vm(lua_State *ls)\n{\n    lua_stack_cleaner clean(ls);\n    _getregistry(ls, \"__clua\");\n    CLua *vm = clua_get_lightuserdata<CLua>(ls, -1);\n    if (!vm)\n        luaL_error(ls, \"Could not find matching clua for lua state\");\n    return *vm;\n}", "target": 0}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "EnableLimitedSchedulingLatency(void)\n{\n    ++SmartScheduleLatencyLimited;\n    SmartScheduleSlice = SmartScheduleInterval;\n}", "target": 0}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "static bool mnt_ns_loop(struct dentry *dentry)\n{\n\tstruct mnt_namespace *mnt_ns;\n\tif (!is_mnt_ns_file(dentry))\n\t\treturn false;\n\tmnt_ns = get_proc_ns(dentry->d_inode)->ns;\n\treturn current->nsproxy->mnt_ns->seq >= mnt_ns->seq;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_setting_resizable_textareas_set(Evas_Object* ewkView, Eina_Bool enable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    enable = !!enable;\n    if (priv->settings.resizableTextareas != enable) {\n        priv->pageSettings->setTextAreasAreResizable(enable);\n        priv->settings.resizableTextareas = enable;\n    }\n    return true;\n}", "target": 0}
{"code": "vreader_slot (int vrdr)\n{\n  if (vrdr == -1 || !(vrdr >= 0 && vrdr < DIM(vreader_table)))\n    return -1;\n  if (!vreader_table [vrdr].valid)\n    return -1;\n  return vreader_table[vrdr].slot;\n}", "target": 0}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "PartitionInstallUdfChildHandles (\n  IN  EFI_DRIVER_BINDING_PROTOCOL  *This,\n  IN  EFI_HANDLE                   Handle,\n  IN  EFI_DISK_IO_PROTOCOL         *DiskIo,\n  IN  EFI_DISK_IO2_PROTOCOL        *DiskIo2,\n  IN  EFI_BLOCK_IO_PROTOCOL        *BlockIo,\n  IN  EFI_BLOCK_IO2_PROTOCOL       *BlockIo2,\n  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath\n  )\n{\n  UINT32                       RemainderByMediaBlockSize;\n  EFI_STATUS                   Status;\n  EFI_BLOCK_IO_MEDIA           *Media;\n  EFI_PARTITION_INFO_PROTOCOL  PartitionInfo;\n  EFI_LBA                      StartingLBA;\n  EFI_LBA                      EndingLBA;\n  BOOLEAN                      ChildCreated;\n  Media = BlockIo->Media;\n  ChildCreated = FALSE;\n  DivU64x32Remainder (\n    UDF_LOGICAL_SECTOR_SIZE,   \n    Media->BlockSize,          \n    &RemainderByMediaBlockSize \n    );\n  if (RemainderByMediaBlockSize != 0) {\n    return EFI_NOT_FOUND;\n  }\n  Status = PartitionInstallElToritoChildHandles (\n             This,\n             Handle,\n             DiskIo,\n             DiskIo2,\n             BlockIo,\n             BlockIo2,\n             DevicePath\n             );\n  if (!EFI_ERROR (Status)) {\n    DEBUG ((DEBUG_INFO, \"PartitionDxe: El Torito standard found on handle 0x%p.\\n\", Handle));\n    ChildCreated = TRUE;\n  }\n  Status = FindUdfFileSystem (BlockIo, DiskIo, &StartingLBA, &EndingLBA);\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : EFI_NOT_FOUND);\n  }\n  ZeroMem (&PartitionInfo, sizeof (EFI_PARTITION_INFO_PROTOCOL));\n  PartitionInfo.Revision = EFI_PARTITION_INFO_PROTOCOL_REVISION;\n  PartitionInfo.Type = PARTITION_TYPE_OTHER;\n  Status = PartitionInstallChildHandle (\n    This,\n    Handle,\n    DiskIo,\n    DiskIo2,\n    BlockIo,\n    BlockIo2,\n    DevicePath,\n    (EFI_DEVICE_PATH_PROTOCOL *)&gUdfDevicePath,\n    &PartitionInfo,\n    StartingLBA,\n    EndingLBA,\n    Media->BlockSize,\n    NULL\n    );\n  if (EFI_ERROR (Status)) {\n    return (ChildCreated ? EFI_SUCCESS : Status);\n  }\n  return EFI_SUCCESS;\n}", "target": 0}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "static int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tcrash_enable_local_vmclear(cpu);\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\tif ((old & test_bits) != test_bits) {\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); \n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\tnative_store_gdt(this_cpu_ptr(&host_gdt));\n\treturn 0;\n}", "target": 0}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n     case EXPR_INVERT:\n     case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n         if (ok)\n             *set_rtrn = !*set_rtrn;\n         return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "cp1251_apply_all_case_fold(OnigCaseFoldType flag,\n\t\t\t       OnigApplyAllCaseFoldFunc f, void* arg, OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n             flag, f, arg);\n}", "target": 0}
{"code": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}", "target": 1}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }", "target": 1}
{"code": "ExprResolveString(struct xkb_context *ctx, const ExprDef *expr,\n                  xkb_atom_t *val_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_STRING) {\n            log_err(ctx, \"Found constant of type %s, expected a string\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *val_rtrn = expr->string.str;\n        return true;\n    case EXPR_IDENT:\n        log_err(ctx, \"Identifier \\\"%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->ident.ident));\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type string not found\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_INVERT:\n    case EXPR_NOT:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of strings not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        return false;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveString\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 0}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "static void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}", "target": 0}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "static void bnx2x_ptp_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, ptp_task);\n\tint port = BP_PORT(bp);\n\tu32 val_seq;\n\tu64 timestamp, ns;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tval_seq = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t\t\t NIG_REG_P0_TLLH_PTP_BUF_SEQID);\n\tif (val_seq & 0x10000) {\n\t\ttimestamp = REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_MSB :\n\t\t\t\t   NIG_REG_P0_TLLH_PTP_BUF_TS_MSB);\n\t\ttimestamp <<= 32;\n\t\ttimestamp |= REG_RD(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_TS_LSB :\n\t\t\t\t    NIG_REG_P0_TLLH_PTP_BUF_TS_LSB);\n\t\tREG_WR(bp, port ? NIG_REG_P1_TLLH_PTP_BUF_SEQID :\n\t\t       NIG_REG_P0_TLLH_PTP_BUF_SEQID, 0x10000);\n\t\tns = timecounter_cyc2time(&bp->timecounter, timestamp);\n\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\t\tskb_tstamp_tx(bp->ptp_tx_skb, &shhwtstamps);\n\t\tdev_kfree_skb_any(bp->ptp_tx_skb);\n\t\tbp->ptp_tx_skb = NULL;\n\t\tDP(BNX2X_MSG_PTP, \"Tx timestamp, timestamp cycles = %llu, ns = %llu\\n\",\n\t\t   timestamp, ns);\n\t} else {\n\t\tDP(BNX2X_MSG_PTP, \"There is no valid Tx timestamp yet\\n\");\n\t\tschedule_work(&bp->ptp_task);\n\t}\n}", "target": 0}
{"code": "KeyInfo *sqlite3KeyInfoFromExprList(\n  Parse *pParse,       \n  ExprList *pList,     \n  int iStart,          \n  int nExtra           \n){\n  int nExpr;\n  KeyInfo *pInfo;\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  int i;\n  nExpr = pList->nExpr;\n  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);\n  if( pInfo ){\n    assert( sqlite3KeyInfoIsWriteable(pInfo) );\n    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){\n      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);\n      pInfo->aSortOrder[i-iStart] = pItem->sortOrder;\n    }\n  }\n  return pInfo;\n}", "target": 0}
{"code": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}", "target": 0}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  IndexPacket\n    *indexes;\n  PixelPacket\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "JANET_CORE_FN(cfun_array_ensure,\n              \"(array/ensure arr capacity growth)\",\n              \"Ensures that the memory backing the array is large enough for `capacity` \"\n              \"items at the given rate of growth. `capacity` and `growth` must be integers. \"\n              \"If the backing capacity is already enough, then this function does nothing. \"\n              \"Otherwise, the backing memory will be reallocated so that there is enough space.\") {\n    janet_fixarity(argc, 3);\n    JanetArray *array = janet_getarray(argv, 0);\n    int32_t newcount = janet_getinteger(argv, 1);\n    int32_t growth = janet_getinteger(argv, 2);\n    if (newcount < 1) janet_panic(\"expected positive integer\");\n    janet_array_ensure(array, newcount, growth);\n    return argv[0];\n}", "target": 0}
{"code": "yang_check_choice(struct lys_module *module, struct lys_node_choice *choice, struct lys_node **child,\n                  int options, struct unres_schema *unres)\n{\n    char *value;\n    if (yang_check_iffeatures(module, NULL, choice, CHOICE_KEYWORD, unres)) {\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    if (yang_check_nodes(module, (struct lys_node *)choice, *child, options, unres)) {\n        *child = NULL;\n        free(choice->dflt);\n        choice->dflt = NULL;\n        goto error;\n    }\n    *child = NULL;\n    if (choice->dflt) {\n        value = (char *)choice->dflt;\n        choice->dflt = NULL;\n        if (unres_schema_add_str(module, unres, choice, UNRES_CHOICE_DFLT, value) == -1) {\n            free(value);\n            goto error;\n        }\n        free(value);\n    }\n    if (choice->when && yang_check_ext_instance(module, &choice->when->ext, choice->when->ext_size, choice->when, unres)) {\n        goto error;\n    }\n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && choice->when) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)choice)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, choice, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "BIGNUM *BN_dup(const BIGNUM *a)\n{\n    BIGNUM *t;\n    if (a == NULL)\n        return NULL;\n    bn_check_top(a);\n    t = BN_get_flags(a, BN_FLG_SECURE) ? BN_secure_new() : BN_new();\n    if (t == NULL)\n        return NULL;\n    if (!BN_copy(t, a)) {\n        BN_free(t);\n        return NULL;\n    }\n    bn_check_top(t);\n    return t;\n}", "target": 0}
{"code": "static inline v8::Local<v8::Context> contextForWorld(ScriptController* scriptController, DOMWrapperWorld* world)\n{\n    return scriptController->windowShell(world)->context();\n}", "target": 0}
{"code": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n   CalculateVisiblePages();\n   return most_visible_page_;\n }", "target": 1}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"%p\\n\", sock);\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static RBinWasmElementEntry *parse_element_entry(RBinWasmObj *bin, ut64 bound, ut32 index) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmElementEntry *elem = R_NEW0 (RBinWasmElementEntry);\n\tif (elem) {\n\t\telem->sec_i = index;\n\t\telem->file_offset = r_buf_tell (b);\n\t\tif (!consume_u32_r (b, bound, &elem->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_init_expr_r (b, bound, R_BIN_WASM_END_OF_CODE, NULL)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_u32_r (b, bound, &elem->num_elem)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (r_buf_tell (b) <= bound && j < elem->num_elem) {\n\t\t\tif (!consume_u32_r (b, bound, NULL)) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t}\n\treturn elem;\nbeach:\n\tfree (elem);\n\treturn NULL;\n}", "target": 0}
{"code": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint r = 1;\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\tnr = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\ta0 = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\ta1 = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\ta2 = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\ta3 = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\tif (!is_long_mode(vcpu)) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n\t++vcpu->stat.hypercalls;\n\treturn r;\n}", "target": 0}
{"code": "static unsigned rb_calculate_event_length(unsigned length)\n{\n\tstruct ring_buffer_event event; \n\tif (!length)\n\t\tlength++;\n\tif (length > RB_MAX_SMALL_DATA || RB_FORCE_8BYTE_ALIGNMENT)\n\t\tlength += sizeof(event.array[0]);\n\tlength += RB_EVNT_HDR_SIZE;\n\tlength = ALIGN(length, RB_ARCH_ALIGNMENT);\n\tif (length == RB_LEN_TIME_EXTEND + RB_ALIGNMENT)\n\t\tlength += RB_ALIGNMENT;\n\treturn length;\n}", "target": 0}
{"code": "static int cmp_database(struct List *i1, struct List *i2)\n{\n\tPgDatabase *db1 = container_of(i1, PgDatabase, head);\n\tPgDatabase *db2 = container_of(i2, PgDatabase, head);\n\treturn strcmp(db1->name, db2->name);\n}", "target": 0}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "SMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb_rqst rqst;\n\tstruct smb2_flush_req *req;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\tunsigned int total_len;\n\tcifs_dbg(FYI, \"Flush\\n\");\n\tif (!ses || !(ses->server))\n\t\treturn -EIO;\n\trc = smb2_plain_req_init(SMB2_FLUSH, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (smb3_encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\t\ttrace_smb3_flush_err(xid, persistent_fid, tcon->tid, ses->Suid,\n\t\t\t\t     rc);\n\t}\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\treturn err;\n}", "target": 1}
{"code": "static int kvm_mmu_notifier_test_young(struct mmu_notifier *mn,\n\t\t\t\t       struct mm_struct *mm,\n\t\t\t\t       unsigned long address)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint young, idx;\n\tidx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\tyoung = kvm_test_age_hva(kvm, address);\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn young;\n}", "target": 0}
{"code": "static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen)\n\t\t\t\tjs_rangeerror(J, \"array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto readonly;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref && ref->setter) {\n\t\tjs_pushobject(J, ref->setter);\n\t\tjs_pushobject(J, obj);\n\t\tjs_pushvalue(J, *value);\n\t\tjs_call(J, 1);\n\t\tjs_pop(J, 1);\n\t\treturn;\n\t}\n\tif (!ref || !own)\n\t\tref = jsV_setproperty(J, obj, name);\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\treturn;\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}", "target": 0}
{"code": "static void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}", "target": 0}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "int is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tint result;\n\tunsigned seq;\n\tif (new_dentry == old_dentry)\n\t\treturn 1;\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = 1;\n\t\telse\n\t\t\tresult = 0;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn result;\n}", "target": 0}
{"code": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}", "target": 1}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "static bool io_wq_worker_affinity(struct io_worker *worker, void *data)\n{\n\tstruct online_data *od = data;\n\tif (od->online)\n\t\tcpumask_set_cpu(od->cpu, worker->wqe->cpu_mask);\n\telse\n\t\tcpumask_clear_cpu(od->cpu, worker->wqe->cpu_mask);\n\treturn false;\n}", "target": 0}
{"code": "_tiffReadProc(thandle_t hdata, tdata_t buf, tsize_t size) {\n    TIFFSTATE *state = (TIFFSTATE *)hdata;\n    tsize_t to_read;\n    TRACE((\"_tiffReadProc: %d \\n\", (int)size));\n    dump_state(state);\n    to_read = min(size, min(state->size, (tsize_t)state->eof) - (tsize_t)state->loc);\n    TRACE((\"to_read: %d\\n\", (int)to_read));\n    _TIFFmemcpy(buf, (UINT8 *)state->data + state->loc, to_read);\n    state->loc += (toff_t)to_read;\n    TRACE((\"location: %u\\n\", (uint)state->loc));\n    return to_read;\n}", "target": 1}
{"code": "void WebGraphicsContext3DDefaultImpl::activeTexture(unsigned long texture)\n{\n    if (texture < GL_TEXTURE0 || texture > GL_TEXTURE0+32)\n        return;\n    makeContextCurrent();\n    glActiveTexture(texture);\n}", "target": 0}
{"code": "void getconsxy(struct vc_data *vc, unsigned char *p)\n{\n\tp[0] = min(vc->vc_x, 0xFFu);\n\tp[1] = min(vc->vc_y, 0xFFu);\n}", "target": 0}
{"code": "void LIRGenerator::do_If(If* x) {\n  assert(x->number_of_sux() == 2, \"inconsistency\");\n  ValueTag tag = x->x()->type()->tag();\n  bool is_safepoint = x->is_safepoint();\n  If::Condition cond = x->cond();\n  LIRItem xitem(x->x(), this);\n  LIRItem yitem(x->y(), this);\n  LIRItem* xin = &xitem;\n  LIRItem* yin = &yitem;\n  if (tag == longTag) {\n    if (cond == If::gtr || cond == If::leq) {\n      cond = Instruction::mirror(cond);\n      xin = &yitem;\n      yin = &xitem;\n    }\n    xin->set_destroys_register();\n  }\n  xin->load_item();\n  if (tag == longTag && yin->is_constant() && yin->get_jlong_constant() == 0 && (cond == If::eql || cond == If::neq)) {\n    yin->dont_load_item();\n  } else if (tag == longTag || tag == floatTag || tag == doubleTag) {\n    yin->load_item();\n  } else {\n    yin->dont_load_item();\n  }\n  LIR_Opr left = xin->result();\n  LIR_Opr right = yin->result();\n  set_no_result(x);\n  if (x->is_safepoint()) {\n    increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x->state_before()),\n        x->tsux()->bci(), x->fsux()->bci(), x->profiled_bci());\n    __ safepoint(safepoint_poll_register(), state_for(x, x->state_before()));\n  }\n  __ cmp(lir_cond(cond), left, right);\n  profile_branch(x, cond);\n  move_to_phi(x->state());\n  if (x->x()->type()->is_float_kind()) {\n    __ branch(lir_cond(cond), right->type(), x->tsux(), x->usux());\n  } else {\n    __ branch(lir_cond(cond), right->type(), x->tsux());\n  }\n  assert(x->default_sux() == x->fsux(), \"wrong destination above\");\n  __ jump(x->default_sux());\n}", "target": 0}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "  QuotaManager* quota_manager() const { return quota_manager_.get(); }", "target": 0}
{"code": "static void fuse_lib_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *value = (char *) malloc(size);\n        if (value == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_getxattr(f, req, ino, name, value, size);\n        if (res > 0)\n            fuse_reply_buf(req, value, res);\n        else\n            reply_err(req, res);\n        free(value);\n    } else {\n        res = common_getxattr(f, req, ino, name, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "GF_Box *sgpd_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleGroupDescriptionBox, GF_ISOM_BOX_TYPE_SGPD);\n\ttmp->version = 1;\n\ttmp->group_descriptions = gf_list_new();\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tkenter(\"{%d}\", key->serial);\n\tBUG_ON(key != ctx->match_data);\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}", "target": 1}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "static int nft_set_desc_concat_parse(const struct nlattr *attr,\n\t\t\t\t     struct nft_set_desc *desc)\n{\n\tstruct nlattr *tb[NFTA_SET_FIELD_MAX + 1];\n\tu32 len;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_SET_FIELD_MAX, attr,\n\t\t\t\t\t  nft_concat_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_SET_FIELD_LEN])\n\t\treturn -EINVAL;\n\tlen = ntohl(nla_get_be32(tb[NFTA_SET_FIELD_LEN]));\n\tif (len * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)\n\t\treturn -E2BIG;\n\tdesc->field_len[desc->field_count++] = len;\n\treturn 0;\n}", "target": 1}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int geom[])\n{\n\tint heads=-1;\n\tint sectors=-1;\n\tint cylinders=-1;\n\tif (capacity < 0x2000 ) {\t\n\t\theads = 18;\n\t\tsectors = 2;\n\t} \n\telse if (capacity < 0x20000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\telse if (capacity < 0x40000) {\n\t\theads = 65;\n\t\tsectors = 63;\n\t}\n\telse if (capacity < 0x80000) {\n\t\theads = 128;\n\t\tsectors = 63;\n\t}\n\telse {\n\t\theads = 255;\n\t\tsectors = 63;\n\t}\n\tcylinders = sector_div(capacity, heads * sectors);\n\tif(sdev->type == 5) {  \n\t\theads = 252;\n\t\tsectors = 63;\n\t\tcylinders = 1111;\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\tPDEBUG(\"adpt_bios_param: exit\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "static pid_t get_task_reaper_pid(pid_t task)\n{\n\tint sock[2];\n\tpid_t pid;\n\tpid_t ret = -1;\n\tchar v = '0';\n\tstruct ucred cred;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\treturn -1;\n\t}\n\tpid = fork();\n\tif (pid < 0)\n\t\tgoto out;\n\tif (!pid) {\n\t\tclose(sock[1]);\n\t\twrite_task_init_pid_exit(sock[0], task);\n\t}\n\tif (!recv_creds(sock[1], &cred, &v))\n\t\tgoto out;\n\tret = cred.pid;\nout:\n\tclose(sock[0]);\n\tclose(sock[1]);\n\treturn ret;\n}", "target": 0}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\n{\n\tif (pskb_may_pull(skb, 2)) {\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (PPP_PROTO(skb) == PPP_MP)\n\t\t\tppp_receive_mp_frame(ppp, skb, pch);\n\t\telse\n#endif \n\t\t\tppp_receive_nonmp_frame(ppp, skb);\n\t\treturn;\n\t}\n\tif (skb->len > 0)\n\t\t++ppp->dev->stats.rx_length_errors;\n\tkfree_skb(skb);\n\tppp_receive_error(ppp);\n}", "target": 0}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": " */\nstatic xmlNodePtr\nxmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                              xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur == NULL)\n            return (NULL);\n        if (cur->type == XML_NAMESPACE_DECL)\n            return (NULL);\n        ctxt->ancestor = cur->parent;\n    }\n    if (cur->type == XML_NAMESPACE_DECL)\n        return(NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;", "target": 0}
{"code": "TIFFjpeg_data_dest(JPEGState* sp, TIFF* tif)\n{\n\t(void) tif;\n\tsp->cinfo.c.dest = &sp->dest;\n\tsp->dest.init_destination = std_init_destination;\n\tsp->dest.empty_output_buffer = std_empty_output_buffer;\n\tsp->dest.term_destination = std_term_destination;\n}", "target": 0}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "SWFShape_drawScaledLine(SWFShape shape, int dx, int dy)\n{\n\tShapeRecord record;\n\tif ( shape->isEnded )\n\t\treturn;\n\tif ( dx == 0 && dy == 0 )\n\t\treturn;\n\trecord = newShapeRecord(shape, SHAPERECORD_LINETO);\n\tSWF_assert(SWFOutput_numSBits(dx) < 18);\n\tSWF_assert(SWFOutput_numSBits(dy) < 18);\n\trecord.record.lineTo->dx = dx;\n\trecord.record.lineTo->dy = dy;\n\tshape->xpos += dx;\n\tshape->ypos += dy;\n\tSWFRect_includePoint(SWFCharacter_getBounds(CHARACTER(shape)),\n\t\t\t\t\t\t\t\t\t\t\t shape->xpos, shape->ypos, shape->lineWidth);\n\tSWFRect_includePoint(shape->edgeBounds, shape->xpos, shape->ypos, 0);\n}", "target": 0}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "static int __vhost_add_used_n(struct vhost_virtqueue *vq,\n\t\t\t    struct vring_used_elem *heads,\n\t\t\t    unsigned count)\n{\n\tstruct vring_used_elem __user *used;\n\tu16 old, new;\n\tint start;\n\tstart = vq->last_used_idx % vq->num;\n\tused = vq->used->ring + start;\n\tif (__copy_to_user(used, heads, count * sizeof *used)) {\n\t\tvq_err(vq, \"Failed to write used\");\n\t\treturn -EFAULT;\n\t}\n\tif (unlikely(vq->log_used)) {\n\t\tsmp_wmb();\n\t\tlog_write(vq->log_base,\n\t\t\t  vq->log_addr +\n\t\t\t   ((void __user *)used - (void __user *)vq->used),\n\t\t\t  count * sizeof *used);\n\t}\n\told = vq->last_used_idx;\n\tnew = (vq->last_used_idx += count);\n\tif (unlikely((u16)(new - vq->signalled_used) < (u16)(new - old)))\n\t\tvq->signalled_used_valid = false;\n\treturn 0;\n}", "target": 0}
{"code": "update_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}", "target": 0}
{"code": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\treturn 0;\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;", "target": 1}
{"code": "void show_opcodes(u8 *rip, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\tif (probe_kernel_read(opcodes, rip - PROLOGUE_SIZE, OPCODE_BUFSIZE)) {\n\t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n\t} else {\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t}\n}", "target": 1}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 1}
{"code": "static void sr_write_reg_async(struct usbnet *dev, u8 reg, u8 value)\n{\n\tusbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t       value, reg, NULL, 0);\n}", "target": 0}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "xmlFreeElementTable(xmlElementTablePtr table) {\n    xmlHashFree(table, (xmlHashDeallocator) xmlFreeElement);\n}", "target": 0}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "vhost_user_set_vring_kick(struct virtio_net **pdev, struct VhostUserMsg *pmsg)\n{\n\tstruct vhost_vring_file file;\n\tstruct vhost_virtqueue *vq;\n\tstruct virtio_net *dev = *pdev;\n\tfile.index = pmsg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\tif (pmsg->payload.u64 & VHOST_USER_VRING_NOFD_MASK)\n\t\tfile.fd = VIRTIO_INVALID_EVENTFD;\n\telse\n\t\tfile.fd = pmsg->fds[0];\n\tRTE_LOG(INFO, VHOST_CONFIG,\n\t\t\"vring kick idx:%d file:%d\\n\", file.index, file.fd);\n\tdev = translate_ring_addresses(dev, file.index);\n\tif (!dev)\n\t\treturn;\n\t*pdev = dev;\n\tvq = dev->virtqueue[file.index];\n\tif (!(dev->features & (1ULL << VHOST_USER_F_PROTOCOL_FEATURES)))\n\t\tvq->enabled = 1;\n\tif (vq->kickfd >= 0)\n\t\tclose(vq->kickfd);\n\tvq->kickfd = file.fd;\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static apr_status_t lua_websocket_readbytes(conn_rec* c, char* buffer, \n        apr_off_t len) \n{\n    apr_bucket_brigade *brigade = apr_brigade_create(c->pool, c->bucket_alloc);\n    apr_status_t rv;\n    rv = ap_get_brigade(c->input_filters, brigade, AP_MODE_READBYTES, \n            APR_BLOCK_READ, len);\n    if (rv == APR_SUCCESS) {\n        if (!APR_BRIGADE_EMPTY(brigade)) {\n            apr_bucket* bucket = APR_BRIGADE_FIRST(brigade);\n            const char* data = NULL;\n            apr_size_t data_length = 0;\n            rv = apr_bucket_read(bucket, &data, &data_length, APR_BLOCK_READ);\n            if (rv == APR_SUCCESS) {\n                memcpy(buffer, data, len);\n            }\n            apr_bucket_delete(bucket);\n        }\n    }\n    apr_brigade_cleanup(brigade);\n    return rv;\n}", "target": 0}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}", "target": 1}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "            Status readCString( StringData* out ) {\n                const void* x = memchr( _buffer + _position, 0, _maxLength - _position );\n                if ( !x )\n                    return makeError(\"no end of c-string\", _idElem);\n                uint64_t len = static_cast<uint64_t>( static_cast<const char*>(x) - ( _buffer + _position ) );\n                StringData data( _buffer + _position, len );\n                _position += len + 1;\n                if ( out ) {\n                    *out = data;\n                }\n                return Status::OK();\n            }", "target": 0}
{"code": "test_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}", "target": 1}
{"code": "join_path_from_pattern(struct glob_pattern **beg)\n{\n    struct glob_pattern *p;\n    char *path = NULL;\n    size_t path_len = 0;\n    for (p = *beg; p; p = p->next) {\n\tconst char *str;\n\tswitch (p->type) {\n\t  case RECURSIVE:\n\t    str = \"**\";\n\t    break;\n\t  case MATCH_DIR:\n\t    str = \"\";\n\t    break;\n\t  default:\n\t    str = p->str;\n\t    if (!str) continue;\n\t}\n\tif (!path) {\n\t    path_len = strlen(str);\n\t    path = GLOB_ALLOC_N(char, path_len + 1);\n\t    memcpy(path, str, path_len);\n\t    path[path_len] = '\\0';\n        }\n        else {\n\t    size_t len = strlen(str);\n\t    char *tmp;\n\t    tmp = GLOB_REALLOC(path, path_len + len + 2);\n\t    if (tmp) {\n\t\tpath = tmp;\n\t\tpath[path_len++] = '/';\n\t\tmemcpy(path + path_len, str, len);\n\t\tpath_len += len;\n\t\tpath[path_len] = '\\0';\n\t    }\n\t}\n    }\n    return path;\n}", "target": 0}
{"code": "void _WM_do_control_channel_sound_off(struct _mdi *mdi,\n                                      struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->active = 0;\n                if (note_data->replay) {\n                    note_data->replay = NULL;\n                }\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "systemd_unit_name_escape (const gchar *in)\n{\n  GString * const str = g_string_sized_new (strlen (in));\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}", "target": 0}
{"code": "static void nf_tables_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(trans->ctx.chain);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(nft_trans_set(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}", "target": 0}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "const u8 *tcp_parse_md5sig_option(const struct tcphdr *th)\n{\n\tint length = (th->doff << 2) - sizeof(*th);\n\tconst u8 *ptr = (const u8 *)(th + 1);\n\tif (length < TCPOLEN_MD5SIG)\n\t\treturn NULL;\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn NULL;\n\t\tcase TCPOPT_NOP:\n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2 || opsize > length)\n\t\t\t\treturn NULL;\n\t\t\tif (opcode == TCPOPT_MD5SIG)\n\t\t\t\treturn opsize == TCPOLEN_MD5SIG ? ptr : NULL;\n\t\t}\n\t\tptr += opsize - 2;\n\t\tlength -= opsize;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "    Image::UniquePtr ImageFactory::create(ImageType type,\n                                        const std::wstring& wpath)\n    {\n        std::unique_ptr<FileIo> fileIo(new FileIo(wpath));\n        if (fileIo->open(\"w+b\") != 0) {\n            throw WError(kerFileOpenFailed, wpath, \"w+b\", strError().c_str());\n        }\n        fileIo->close();\n        BasicIo::UniquePtr io(std::move(fileIo));\n        Image::UniquePtr image = create(type, std::move(io));\n        if (image.get() == 0) throw Error(kerUnsupportedImageType, static_cast<int>(type));\n        return image;\n    }", "target": 0}
{"code": "init_line_list(line_list *ll, gs_memory_t * mem)\n{\n    ll->memory = mem;\n    ll->active_area = 0;\n    ll->next_active = ll->local_active;\n    ll->limit = ll->next_active + MAX_LOCAL_ACTIVE;\n    ll->close_count = 0;\n    ll->y_list = 0;\n    ll->y_line = 0;\n    ll->h_list0 = ll->h_list1 = 0;\n    ll->x_head.prev = NULL;\n    ll->x_head.start.x = 0;\n    ll->x_head.start.y = 0;\n    ll->x_head.end.x = 0;\n    ll->x_head.end.y = 0;\n    INCR(fill);\n}", "target": 0}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \tsa->rc_family  = AF_BLUETOOTH;\n \tsa->rc_channel = rfcomm_pi(sk)->channel;\n \tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 1}
{"code": "static void tcp_new_space(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_should_expand_sndbuf(sk)) {\n\t\ttcp_sndbuf_expand(sk);\n\t\ttp->snd_cwnd_stamp = tcp_time_stamp;\n\t}\n\tsk->sk_write_space(sk);\n}", "target": 0}
{"code": "static int hash_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_ahash_setkey(private, key, keylen);\n}", "target": 0}
{"code": "coolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}", "target": 0}
{"code": "  static Config::DecodedResourcesWrapper decodeResources(\n      const Protobuf::RepeatedPtrField<envoy::service::discovery::v3::Resource>& resources,\n      const std::string& name_field = \"name\") {\n    Config::DecodedResourcesWrapper decoded_resources;\n    TestOpaqueResourceDecoderImpl<MessageType> resource_decoder(name_field);\n    for (const auto& resource : resources) {\n      decoded_resources.owned_resources_.emplace_back(\n          new Config::DecodedResourceImpl(resource_decoder, resource));\n      decoded_resources.refvec_.emplace_back(*decoded_resources.owned_resources_.back());\n    }\n    return decoded_resources;\n  }", "target": 0}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "    TiffComponent* newPentaxDngMn2(uint16_t tag,\n                                IfdId    group,\n                                IfdId    mnGroup)\n    {\n        return new TiffIfdMakernote(tag, group, mnGroup, new PentaxDngMnHeader);\n    }", "target": 0}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "gif_main_loop (GifContext *context)\n{\n\tgint retval = 0;\n\tdo {\n\t\tswitch (context->state) {\n\t\tcase GIF_START:\n                        LOG(\"start\\n\");\n\t\t\tretval = gif_init (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP:\n                        LOG(\"get_colormap\\n\");\n\t\t\tretval = gif_get_colormap (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_NEXT_STEP:\n                        LOG(\"next_step\\n\");\n\t\t\tretval = gif_get_next_step (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_FRAME_INFO:\n                        LOG(\"frame_info\\n\");\n\t\t\tretval = gif_get_frame_info (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_EXTENSION:\n                        LOG(\"get_extension\\n\");\n\t\t\tretval = gif_get_extension (context);\n\t\t\tif (retval == 0)\n\t\t\t\tcontext->state = GIF_GET_NEXT_STEP;\n\t\t\tbreak;\n\t\tcase GIF_GET_COLORMAP2:\n                        LOG(\"get_colormap2\\n\");\n\t\t\tretval = gif_get_colormap2 (context);\n\t\t\tif (retval == 0)\n\t\t\t\tgif_set_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_PREPARE_LZW:\n                        LOG(\"prepare_lzw\\n\");\n\t\t\tretval = gif_prepare_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_FILL_BUFFER:\n                        LOG(\"fill_buffer\\n\");\n\t\t\tretval = gif_lzw_fill_buffer (context);\n\t\t\tbreak;\n\t\tcase GIF_LZW_CLEAR_CODE:\n                        LOG(\"clear_code\\n\");\n\t\t\tretval = gif_lzw_clear_code (context);\n\t\t\tbreak;\n\t\tcase GIF_GET_LZW:\n                        LOG(\"get_lzw\\n\");\n\t\t\tretval = gif_get_lzw (context);\n\t\t\tbreak;\n\t\tcase GIF_DONE:\n                        LOG(\"done\\n\");\n\t\tdefault:\n\t\t\tretval = 0;\n\t\t\tgoto done;\n\t\t};\n\t} while ((retval == 0) || (retval == -3));\n done:\n\treturn retval;\n}", "target": 0}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "void html_link_open(const char *url, const char *title, const char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ContainedOrPathLevelMultikeyCannotCombineTrailingFields) {\n    MultikeyPaths multikeyPaths{{}, {0U}};\n    addIndex(BSON(\"b\" << 1 << \"a\" << 1), multikeyPaths);\n    addIndex(BSON(\"c\" << 1));\n    runQuery(\n        fromjson(\"{$and: [{a: {$gte: 0}}, {$or: [{$and: [{a: {$lte: 10}}, {b: 6}]}, {c: 7}]}]}\"));\n    assertNumSolutions(2);\n    std::vector<std::string> alternates;\n    alternates.push_back(\n        \"{fetch: {filter: {a: {$gte: 0}}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[-Infinity, 10, \"\n        \"true, true]]}}},\"\n        \"{ixscan: {pattern: {c: 1}, bounds: {c: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    alternates.push_back(\n        \"{fetch: {filter: {a: {$gte: 0}}, node: {or: {nodes: [\"\n        \"{ixscan: {pattern: {b: 1, a: 1}, bounds: {b: [[6, 6, true, true]], a: [[0, Infinity, \"\n        \"true, true]]}}},\"\n        \"{ixscan: {pattern: {c: 1}, bounds: {c: [[7, 7, true, true]]}}}\"\n        \"]}}}}\");\n    assertHasOneSolutionOf(alternates);\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EquivalentAndsOne) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(fromjson(\"{$and: [{a: 1}, {b: {$all: [10, 20]}}]}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {$and:[{a:1},{b:10},{b:20}]}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {a: 1, b: 1}}}}}\");\n}", "target": 0}
{"code": "gfx::SwapResult GLSurfaceOzoneSurfaceless::PostSubBuffer(int x,\n                                                         int y,\n                                                         int width,\n                                                         int height) {\n  NOTREACHED();\n  return gfx::SwapResult::SWAP_FAILED;\n}", "target": 0}
{"code": "static int cma_addr_cmp(const struct sockaddr *src, const struct sockaddr *dst)\n{\n\tif (src->sa_family != dst->sa_family)\n\t\treturn -1;\n\tswitch (src->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *)src)->sin_addr.s_addr !=\n\t\t       ((struct sockaddr_in *)dst)->sin_addr.s_addr;\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *src_addr6 = (struct sockaddr_in6 *)src;\n\t\tstruct sockaddr_in6 *dst_addr6 = (struct sockaddr_in6 *)dst;\n\t\tbool link_local;\n\t\tif (ipv6_addr_cmp(&src_addr6->sin6_addr,\n\t\t\t\t\t  &dst_addr6->sin6_addr))\n\t\t\treturn 1;\n\t\tlink_local = ipv6_addr_type(&dst_addr6->sin6_addr) &\n\t\t\t     IPV6_ADDR_LINKLOCAL;\n\t\treturn link_local ? (src_addr6->sin6_scope_id !=\n\t\t\t\t     dst_addr6->sin6_scope_id) :\n\t\t\t\t    0;\n\t}\n\tdefault:\n\t\treturn ib_addr_cmp(&((struct sockaddr_ib *) src)->sib_addr,\n\t\t\t\t   &((struct sockaddr_ib *) dst)->sib_addr);\n\t}\n}", "target": 0}
{"code": "cdf_tole8(uint64_t sv)\n{\n\treturn CDF_TOLE8(sv);\n}", "target": 0}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "static const char *fault_name(unsigned int esr)\n{\n\tconst struct fault_info *inf = fault_info + (esr & 63);\n\treturn inf->name;\n}", "target": 0}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "static int __init init_vdso(void)\n{\n\tinit_vdso_image(&vdso_image_64);\n#ifdef CONFIG_X86_X32_ABI\n\tinit_vdso_image(&vdso_image_x32);\n#endif\n\tcpu_notifier_register_begin();\n\ton_each_cpu(vgetcpu_cpu_init, NULL, 1);\n\t__hotcpu_notifier(vgetcpu_cpu_notifier, 30);\n\tcpu_notifier_register_done();\n\treturn 0;\n}", "target": 0}
{"code": "static int set_next_request(void)\n{\n\tcurrent_req = list_first_entry_or_null(&floppy_reqs, struct request,\n\t\t\t\t\t       queuelist);\n\tif (current_req) {\n\t\tcurrent_req->error_count = 0;\n\t\tlist_del_init(&current_req->queuelist);\n\t}\n\treturn current_req != NULL;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_zoom_animated_set(Evas_Object* ewkView, float zoom, float duration, Evas_Coord centerX, Evas_Coord centerY)\n{\n    double now;\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->zoom_weak_set, false);\n    if (!priv->settings.zoomRange.userScalable) {\n        WRN(\"userScalable is false\");\n        return false;\n    }\n    if (zoom < priv->settings.zoomRange.minScale) {\n        WRN(\"zoom level is < %f : %f\", priv->settings.zoomRange.minScale, zoom);\n        return false;\n    }\n    if (zoom > priv->settings.zoomRange.maxScale) {\n        WRN(\"zoom level is > %f : %f\", priv->settings.zoomRange.maxScale, zoom);\n        return false;\n    }\n    if (priv->animatedZoom.animator)\n        priv->animatedZoom.zoom.start = _ewk_view_zoom_animated_current(priv);\n    else {\n        priv->animatedZoom.zoom.start = ewk_frame_page_zoom_get(smartData->main_frame);\n        _ewk_view_zoom_animation_start(smartData);\n    }\n    if (centerX < 0)\n        centerX = 0;\n    if (centerY < 0)\n        centerY = 0;\n    now = ecore_loop_time_get();\n    priv->animatedZoom.time.start = now;\n    priv->animatedZoom.time.end = now + duration;\n    priv->animatedZoom.time.duration = duration;\n    priv->animatedZoom.zoom.end = zoom;\n    priv->animatedZoom.zoom.range = (priv->animatedZoom.zoom.end - priv->animatedZoom.zoom.start);\n    priv->animatedZoom.center.x = centerX;\n    priv->animatedZoom.center.y = centerY;\n    smartData->animated_zoom.zoom.current = priv->animatedZoom.zoom.start;\n    smartData->animated_zoom.zoom.start = priv->animatedZoom.zoom.start;\n    smartData->animated_zoom.zoom.end = priv->animatedZoom.zoom.end;\n    return true;\n}", "target": 0}
{"code": "Bool gf_filter_send_gf_event(GF_Filter *filter, GF_Event *evt)\n{\n\treturn gf_filter_forward_gf_event(filter, evt, GF_FALSE, GF_FALSE);\n}", "target": 0}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "void QuotaManager::GetGlobalUsage(\n    StorageType type,\n    GlobalUsageCallback* callback) {\n  LazyInitialize();\n  GetUsageTracker(type)->GetGlobalUsage(callback);\n}", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "static int date_object_compare_date(zval *d1, zval *d2 TSRMLS_DC)\n{\n\tphp_date_obj *o1 = zend_object_store_get_object(d1 TSRMLS_CC);\n\tphp_date_obj *o2 = zend_object_store_get_object(d2 TSRMLS_CC);\n\tif (!o1->time || !o2->time) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to compare an incomplete DateTime or DateTimeImmutable object\");\n\t\treturn 1;\n\t}\n\tif (!o1->time->sse_uptodate) {\n\t\ttimelib_update_ts(o1->time, o1->time->tz_info);\n\t}\n\tif (!o2->time->sse_uptodate) {\n\t\ttimelib_update_ts(o2->time, o2->time->tz_info);\n\t}\n\treturn (o1->time->sse == o2->time->sse) ? 0 : ((o1->time->sse < o2->time->sse) ? -1 : 1);", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": " ImageLoader::ImageLoader(Element* element)\n     : m_element(element),\n      m_derefElementTimer(TaskRunnerHelper::get(TaskType::Networking,\n                                                element->document().frame()),\n                          this,\n                          &ImageLoader::timerFired),\n       m_hasPendingLoadEvent(false),\n       m_hasPendingErrorEvent(false),\n       m_imageComplete(true),\n      m_loadingImageDocument(false),\n      m_elementIsProtected(false),\n      m_suppressErrorEvents(false) {\n  RESOURCE_LOADING_DVLOG(1) << \"new ImageLoader \" << this;\n}", "target": 0}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": "void cred_to_ucred(struct pid *pid, const struct cred *cred,\n\t\t   struct ucred *ucred)\n{\n\tucred->pid = pid_vnr(pid);\n\tucred->uid = ucred->gid = -1;\n\tif (cred) {\n\t\tstruct user_namespace *current_ns = current_user_ns();\n\t\tucred->uid = from_kuid(current_ns, cred->euid);\n\t\tucred->gid = from_kgid(current_ns, cred->egid);\n\t}\n}", "target": 0}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n \tstruct sock *sk;\n \tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "int PackLinuxElf32::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf32help1(fi);\n    }\n    return false;\n}", "target": 1}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "void ompl::geometric::VFRRT::clear()\n{\n    RRT::clear();\n    efficientCount_ = 0;\n    inefficientCount_ = 0;\n    explorationInefficiency_ = 0.;\n    step_ = 0;\n}", "target": 0}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "EC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)\n{\n    EC_GROUP *group = NULL;\n    ECPKPARAMETERS *params = NULL;\n    if ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);\n        ECPKPARAMETERS_free(params);\n        return NULL;\n    }\n    if ((group = ec_asn1_pkparameters2group(params)) == NULL) {\n        ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);\n        return NULL;\n    }\n    if (a && *a)\n        EC_GROUP_clear_free(*a);\n    if (a)\n        *a = group;\n    ECPKPARAMETERS_free(params);\n    return (group);\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "njs_string_decode_base64_core(njs_vm_t *vm, njs_value_t *value,\n    const njs_str_t *src, njs_bool_t url)\n{\n    size_t     length;\n    const u_char *basis;\n    njs_str_t  dst;\n    basis = (url) ? njs_basis64url : njs_basis64;\n    length = njs_decode_base64_length_core(src, basis, &dst.length);\n    if (njs_slow_path(dst.length == 0)) {\n        vm->retval = njs_string_empty;\n        return NJS_OK;\n    }\n    dst.start = njs_string_alloc(vm, value, dst.length, length);\n    if (njs_slow_path(dst.start == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_decode_base64_core(&dst, src, basis);\n    return NJS_OK;\n}", "target": 0}
{"code": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\tbprm->mm = NULL;\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\tdo_close_on_exec(current->files);\n\treturn 0;\nout:\n\treturn retval;\n}", "target": 0}
{"code": "gxps_images_guess_content_type (GXPSArchive *zip,\n\t\t\t\tconst gchar *image_uri)\n{\n\tGInputStream *stream;\n\tguchar        buffer[1024];\n\tgssize        bytes_read;\n\tgchar        *mime_type;\n\tstream = gxps_archive_open (zip, image_uri);\n\tif (!stream)\n\t\treturn NULL;\n\tbytes_read = g_input_stream_read (stream, buffer, 1024, NULL, NULL);\n\tmime_type = g_content_type_guess (NULL, buffer, bytes_read, NULL);\n\tg_object_unref (stream);\n\treturn mime_type;\n}", "target": 0}
{"code": "__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tint size = NLMSG_LENGTH(len);\n\tnlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\treturn nlh;\n}", "target": 1}
{"code": "static inline void DetectRunPrefilterPkt(\n    ThreadVars *tv,\n    DetectEngineCtx *de_ctx,\n    DetectEngineThreadCtx *det_ctx,\n    Packet *p,\n    DetectRunScratchpad *scratch\n)\n{\n    DetectPrefilterSetNonPrefilterList(p, det_ctx, scratch);\n    PacketCreateMask(p, &scratch->pkt_mask, scratch->alproto, scratch->app_decoder_events);\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_NONMPMLIST);\n    det_ctx->non_pf_id_cnt = 0;\n    if (likely(det_ctx->non_pf_store_cnt > 0)) {\n        DetectPrefilterBuildNonPrefilterList(det_ctx, scratch->pkt_mask, scratch->alproto);\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_NONMPMLIST);\n    Prefilter(det_ctx, scratch->sgh, p, scratch->flow_flags);\n    if (det_ctx->non_pf_store_cnt || det_ctx->pmq.rule_id_array_cnt) {\n        PACKET_PROFILING_DETECT_START(p, PROF_DETECT_PF_SORT2);\n        DetectPrefilterMergeSort(de_ctx, det_ctx);\n        PACKET_PROFILING_DETECT_END(p, PROF_DETECT_PF_SORT2);\n    }\n#ifdef PROFILING\n    if (tv) {\n        StatsAddUI64(tv, det_ctx->counter_mpm_list,\n                             (uint64_t)det_ctx->pmq.rule_id_array_cnt);\n        StatsAddUI64(tv, det_ctx->counter_nonmpm_list,\n                             (uint64_t)det_ctx->non_pf_store_cnt);\n        StatsAddUI64(tv, det_ctx->counter_fnonmpm_list,\n                             (uint64_t)det_ctx->non_pf_id_cnt);\n    }\n#endif\n}", "target": 0}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                   (unsigned long) strip, (unsigned long)rows);\n                         return 0;\n                 }\n                bufp += bytes_read;\n         }\n         return 1;\n} ", "target": 1}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)\n{\n    uint8_t **p = ptr;\n    if (min_size > SIZE_MAX - FF_INPUT_BUFFER_PADDING_SIZE) {\n        av_freep(p);\n        *size = 0;\n        return;\n    }\n    if (!ff_fast_malloc(p, size, min_size + FF_INPUT_BUFFER_PADDING_SIZE, 1))\n        memset(*p + min_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n}", "target": 0}
{"code": "  virtual void ConnectToWifiNetwork(const WifiNetwork* network,\n                                    const std::string& password,\n                                    const std::string& identity,\n                                    const std::string& certpath) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded())\n      return;\n    if (ConnectToNetworkWithCertInfo(network->service_path().c_str(),\n        password.empty() ? NULL : password.c_str(),\n        identity.empty() ? NULL : identity.c_str(),\n        certpath.empty() ? NULL : certpath.c_str())) {\n      WifiNetwork* wifi = GetWirelessNetworkByPath(\n          wifi_networks_, network->service_path());\n      if (wifi) {\n        wifi->set_passphrase(password);\n        wifi->set_identity(identity);\n        wifi->set_cert_path(certpath);\n        wifi->set_connecting(true);\n        wifi_ = wifi;\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "fbFetch_a1b1g1r1 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  p = Fetch4(bits, i + x);\n        CARD32  a,r,g,b;\n        a = ((p & 0x8) * 0xff) << 21;\n        r = ((p & 0x4) * 0xff) >> 3;\n        g = ((p & 0x2) * 0xff) << 7;\n        b = ((p & 0x1) * 0xff) << 16;\n        WRITE(buffer++, a|r|g|b);\n    }\n}", "target": 0}
{"code": "der_to_ldap_BitString (struct berval *berValue,\n                                   struct berval *ldapValue)\n{\n\tber_len_t bitPadding=0;\n\tber_len_t bits, maxBits;\n\tchar *tmpStr;\n\tunsigned char byte;\n\tber_len_t bitLength;\n\tber_len_t valLen;\n\tunsigned char* valPtr;\n\tldapValue->bv_len=0;\n\tldapValue->bv_val=NULL;\n\tvalLen=berValue->bv_len;\n\tvalPtr=(unsigned char*)berValue->bv_val;\n\tif (valLen) {\n\t\tbitPadding=(ber_len_t)(valPtr[0]);\n\t\tvalLen--;\n\t\tvalPtr++;\n\t}\n\tif (bitPadding >= BITS_PER_BYTE) {\n\t\tif (valLen*BITS_PER_BYTE > bitPadding ) {\n\t\t\tvalLen-=(bitPadding/BITS_PER_BYTE);\n\t\t\tbitPadding%=BITS_PER_BYTE;\n\t\t} else {\n\t\t\tvalLen=0;\n\t\t\tbitPadding=0;\n\t\t}\n\t}\n\tif (valLen*BITS_PER_BYTE < bitPadding ) {\n\t\tbitPadding=0;\n\t\tvalLen=0;\n\t}\n\tbitLength=valLen*BITS_PER_BYTE-bitPadding;\n\ttmpStr=LDAP_MALLOC(bitLength + STR_OVERHEAD + 1);\n\tif (!tmpStr)\n\t\treturn LDAP_NO_MEMORY;\n\tldapValue->bv_val=tmpStr;\n\tldapValue->bv_len=bitLength + STR_OVERHEAD;\n\tmaxBits=BITS_PER_BYTE;\n\t*tmpStr++ ='\\'';\n\twhile(valLen) {\n\t\tbyte=*valPtr;\n\t\tif (valLen==1)\n\t\t\tmaxBits-=bitPadding;\n\t\tfor (bits=0; bits<maxBits; bits++) {\n\t\t\tif (0x80 & byte)\n\t\t\t\t*tmpStr='1';\n\t\t\telse\n\t\t\t\t*tmpStr='0';\n\t\t\ttmpStr++;\n\t\t\tbyte<<=1;\n\t\t}\n\t\tvalPtr++;\n\t\tvalLen--;\n\t}\n\t*tmpStr++ ='\\'';\n\t*tmpStr++ ='B';\n\t*tmpStr=0;\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "static struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}", "target": 0}
{"code": "irc_server_sasl_enabled (struct t_irc_server *server)\n{\n    int sasl_mechanism, rc;\n    char *sasl_username, *sasl_password;\n    const char *sasl_key;\n    sasl_mechanism = IRC_SERVER_OPTION_INTEGER(\n        server, IRC_SERVER_OPTION_SASL_MECHANISM);\n    sasl_username = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_USERNAME));\n    sasl_password = irc_server_eval_expression (\n        server,\n        IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_PASSWORD));\n    sasl_key = IRC_SERVER_OPTION_STRING(server, IRC_SERVER_OPTION_SASL_KEY);\n    rc = ((sasl_mechanism == IRC_SASL_MECHANISM_EXTERNAL)\n          || ((sasl_mechanism == IRC_SASL_MECHANISM_ECDSA_NIST256P_CHALLENGE)\n              && sasl_username && sasl_username[0]\n              && sasl_key && sasl_key[0])\n          || (sasl_username && sasl_username[0]\n              && sasl_password && sasl_password[0])) ? 1 : 0;\n    if (sasl_username)\n        free (sasl_username);\n    if (sasl_password)\n        free (sasl_password);\n    return rc;\n}", "target": 0}
{"code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}", "target": 1}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "void Browser::SetWebContentsBlocked(content::WebContents* web_contents,\n                                    bool blocked) {\n  int index = tab_strip_model_->GetIndexOfWebContents(web_contents);\n  if (index == TabStripModel::kNoTab) {\n     return;\n   }\n   tab_strip_model_->SetTabBlocked(index, blocked);\n   bool browser_active = BrowserList::GetInstance()->GetLastActive() == this;\n  bool contents_is_active =\n      tab_strip_model_->GetActiveWebContents() == web_contents;\n  if (!blocked && contents_is_active && browser_active)\n    web_contents->Focus();\n}", "target": 1}
{"code": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "  String_Obj Parser::parse_ie_property()\n  {\n    lex< ie_property >();\n    Token str(lexed);\n    const char* i = str.begin;\n    const char* p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(str.begin, str.end);\n    if (!p) {\n      return SASS_MEMORY_NEW(String_Quoted, pstate, std::string(str.begin, str.end));\n    }\n    String_Schema* schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    while (i < str.end) {\n      p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(i, str.end);\n      if (p) {\n        if (i < p) {\n          schema->append(SASS_MEMORY_NEW(String_Constant, pstate, std::string(i, p))); \n        }\n        if (peek < sequence < optional_spaces, exactly<rbrace> > >(p+2)) { position = p+2;\n          css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n        }\n        const char* j = skip_over_scopes< exactly<hash_lbrace>, exactly<rbrace> >(p+2, str.end); \n        if (j) {\n          Expression_Obj interp_node = Parser::from_token(Token(p+2, j), ctx, traces, pstate, source).parse_list();\n          interp_node->is_interpolant(true);\n          schema->append(interp_node);\n          i = j;\n        }\n        else {\n          error(\"unterminated interpolant inside IE function \" + str.to_string());\n        }\n      }\n      else { \n        if (i < str.end) {\n          schema->append(SASS_MEMORY_NEW(String_Constant, pstate, std::string(i, str.end)));\n        }\n        break;\n      }\n    }\n    return schema;\n  }", "target": 0}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n    return match;\n}", "target": 1}
{"code": "static void nvme_format_bh(void *opaque)\n{\n    NvmeFormatAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    uint32_t dw10 = le32_to_cpu(req->cmd.cdw10);\n    uint8_t lbaf = dw10 & 0xf;\n    uint8_t pi = (dw10 >> 5) & 0x7;\n    uint16_t status;\n    int i;\n    if (iocb->ret < 0) {\n        goto done;\n    }\n    if (iocb->broadcast) {\n        for (i = iocb->nsid + 1; i <= NVME_MAX_NAMESPACES; i++) {\n            iocb->ns = nvme_ns(n, i);\n            if (iocb->ns) {\n                iocb->nsid = i;\n                break;\n            }\n        }\n    }\n    if (!iocb->ns) {\n        goto done;\n    }\n    status = nvme_format_check(iocb->ns, lbaf, pi);\n    if (status) {\n        req->status = status;\n        goto done;\n    }\n    iocb->ns->status = NVME_FORMAT_IN_PROGRESS;\n    nvme_format_ns_cb(iocb, 0);\n    return;\ndone:\n    qemu_bh_delete(iocb->bh);\n    iocb->bh = NULL;\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n    qemu_aio_unref(iocb);\n}", "target": 0}
{"code": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int mov_read_SA3D(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int i, version, type;\n    int ambisonic_order, channel_order, normalization, channel_count;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    if (atom.size < 16) {\n        av_log(c->fc, AV_LOG_ERROR, \"SA3D audio box too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported SA3D box version %d\\n\", version);\n        return 0;\n    }\n    type = avio_r8(pb);\n    if (type) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported ambisonic type %d\\n\", type);\n        return 0;\n    }\n    ambisonic_order = avio_rb32(pb);\n    channel_order = avio_r8(pb);\n    if (channel_order) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported channel_order %d\\n\", channel_order);\n        return 0;\n    }\n    normalization = avio_r8(pb);\n    if (normalization) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"Unsupported normalization %d\\n\", normalization);\n        return 0;\n    }\n    channel_count = avio_rb32(pb);\n    if (ambisonic_order < 0 || channel_count != (ambisonic_order + 1LL) * (ambisonic_order + 1LL)) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Invalid number of channels (%d / %d)\\n\",\n               channel_count, ambisonic_order);\n        return 0;\n    }\n    for (i = 0; i < channel_count; i++) {\n        if (i != avio_rb32(pb)) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Ambisonic channel reordering is not supported\\n\");\n            return 0;\n        }\n    }\n    av_channel_layout_uninit(&st->codecpar->ch_layout);\n    st->codecpar->ch_layout.order = AV_CHANNEL_ORDER_AMBISONIC;\n    st->codecpar->ch_layout.nb_channels = channel_count;\n    return 0;\n}", "target": 0}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}", "target": 1}
{"code": "    constexpr uint32_t Nikon3MnHeader::sizeOfSignature()\n    {\n        return sizeof(signature_);\n    }", "target": 0}
{"code": "do_sleep(long msec, int hide_cursor)\n{\n    long\tdone = 0;\n    long\twait_now;\n# ifdef ELAPSED_FUNC\n    elapsed_T\tstart_tv;\n    ELAPSED_INIT(start_tv);\n# endif\n    if (hide_cursor)\n        cursor_sleep();\n    else\n        cursor_on();\n    out_flush_cursor(FALSE, FALSE);\n    while (!got_int && done < msec)\n    {\n\twait_now = msec - done > 1000L ? 1000L : msec - done;\n#ifdef FEAT_TIMERS\n\t{\n\t    long    due_time = check_due_timer();\n\t    if (due_time > 0 && due_time < wait_now)\n\t\twait_now = due_time;\n\t}\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n#ifdef FEAT_SOUND\n\tif (has_any_sound_callback() && wait_now > 20L)\n\t    wait_now = 20L;\n#endif\n\tui_delay(wait_now, TRUE);\n#ifdef FEAT_JOB_CHANNEL\n\tif (has_any_channel())\n\t    ui_breakcheck_force(TRUE);\n\telse\n#endif\n\t    ui_breakcheck();\n#ifdef MESSAGE_QUEUE\n\tparse_queued_messages();\n#endif\n# ifdef ELAPSED_FUNC\n\tdone = ELAPSED_FUNC(start_tv);\n# else\n\tdone += wait_now;\n# endif\n    }\n    if (got_int)\n\t(void)vpeekc();\n    if (hide_cursor)\n        cursor_unsleep();\n}", "target": 0}
{"code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1}
{"code": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "para_macro_process(uschar *p, uschar *q)\n{\nint length = q - p;\nargstr **pp;\nmacrodef *md;\nmacroexe *me;\nfor (md = macrolist; md != NULL; md = md->next)\n  {\n  if (length == md->namelength && Ustrncmp(p, md->name, length) == 0) break;\n  }\nif (md == NULL)\n  {\n  error(23, length, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\nme = misc_malloc(sizeof(macroexe));\nme->prev = macrocurrent;\nmacrocurrent = me;\nme->macro = md;\nme->nextline = md->lines;\nif (from_type_ptr >= FROM_TYPE_STACKSIZE - 1) error(32);  \nfrom_type[++from_type_ptr] = FROM_MACRO;\nme->args = NULL;\npp = &(me->args);\nwhile (isspace(*(++q)));\nwhile (*q != 0 && *q != ')')\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(q, US\",)\", &length, NULL, 0);\n  q += length;\n  if (*q == ',') while (isspace(*(++q)));\n  }\nif (*q != ')')\n  {\n  error(24, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\npara_inline_macro++;\nfor (;;)\n  {\n  uschar buffer[INBUFFSIZE];\n  read_process_macroline(macrocurrent->nextline->string, buffer);\n  if (*buffer == '.')\n    {\n    dot_process(buffer);\n    if (macrocurrent != me) break;\n    }\n  else\n    {\n    uschar *qq = buffer + Ustrlen(buffer);\n    while (qq > buffer && isspace(qq[-1])) qq--;\n    *qq = 0;\n    para_process(buffer);\n    }\n  macrocurrent->nextline = macrocurrent->nextline->next;\n  if (macrocurrent->nextline == NULL)\n    {\n    macroexe *temp = macrocurrent;\n    macrocurrent = macrocurrent->prev;\n    macro_free(temp);\n    from_type_ptr--;\n    break;\n    }\n  }\npara_inline_macro--;\nreturn q + 1;\n}", "target": 1}
{"code": "void AXTree::PopulateOrderedSetItems(const AXNode* ordered_set,\n                                     const AXNode* local_parent,\n                                     std::vector<const AXNode*>& items,\n                                     bool node_is_radio_button) const {\n  if (!(ordered_set == local_parent)) {\n    if (local_parent->data().role == ordered_set->data().role)\n      return;\n  }\n   for (int i = 0; i < local_parent->child_count(); ++i) {\n     const AXNode* child = local_parent->GetUnignoredChildAtIndex(i);\n     if (node_is_radio_button &&\n         child->data().role == ax::mojom::Role::kRadioButton)\n      items.push_back(child);\n    if (!node_is_radio_button && child->SetRoleMatchesItemRole(ordered_set))\n      items.push_back(child);\n    if (child->data().role == ax::mojom::Role::kGenericContainer ||\n        child->data().role == ax::mojom::Role::kIgnored) {\n      PopulateOrderedSetItems(ordered_set, child, items, node_is_radio_button);\n    }\n  }\n}", "target": 1}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "plugin_init (Ekiga::KickStart& kickstart)\n{\n#ifdef DEBUG\n  gchar* path = g_build_path (G_DIR_SEPARATOR_S,\n\t\t\t      g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL);\n  plugin_parse_directory (kickstart, path);\n  g_free (path);\n#else\n  plugin_parse_directory (kickstart,\n\t\t\t  EKIGA_PLUGIN_DIR);\n#endif\n}", "target": 1}
{"code": "errorProcessor(XML_Parser parser, const char *s, const char *end,\n               const char **nextPtr) {\n  UNUSED_P(s);\n  UNUSED_P(end);\n  UNUSED_P(nextPtr);\n  return parser->m_errorCode;\n}", "target": 0}
{"code": "static int em_popa(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint reg = VCPU_REGS_RDI;\n\twhile (reg >= VCPU_REGS_RAX) {\n\t\tif (reg == VCPU_REGS_RSP) {\n\t\t\tregister_address_increment(ctxt, &ctxt->regs[VCPU_REGS_RSP],\n\t\t\t\t\t\t\tctxt->op_bytes);\n\t\t\t--reg;\n\t\t}\n\t\trc = emulate_pop(ctxt, &ctxt->regs[reg], ctxt->op_bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\tbreak;\n\t\t--reg;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n    avio_rb24(pb); \n    if (avio_read(pb, buf, sizeof(buf)) != sizeof(buf)) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read FLAC metadata block header\\n\");\n        return pb->error < 0 ? pb->error : AVERROR_INVALIDDATA;\n    }\n    flac_parse_block_header(buf, &last, &type, &size);\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n    return 0;\n}", "target": 0}
{"code": "vote_routerstatus_find_microdesc_hash(char *digest256_out,\n                                      const vote_routerstatus_t *vrs,\n                                      int method,\n                                      digest_algorithm_t alg)\n{\n  const vote_microdesc_hash_t *h;\n  char mstr[64];\n  size_t mlen;\n  char dstr[64];\n  tor_snprintf(mstr, sizeof(mstr), \"%d\", method);\n  mlen = strlen(mstr);\n  tor_snprintf(dstr, sizeof(dstr), \" %s=\",\n               crypto_digest_algorithm_get_name(alg));\n  for (h = vrs->microdesc; h; h = h->next) {\n    const char *cp = h->microdesc_hash_line;\n    size_t num_len;\n    while (1) {\n      num_len = strspn(cp, \"1234567890\");\n      if (num_len == mlen && fast_memeq(mstr, cp, mlen)) {\n        char buf[BASE64_DIGEST256_LEN+1];\n        cp = strstr(cp, dstr);\n        if (!cp)\n          return -1;\n        cp += strlen(dstr);\n        strlcpy(buf, cp, sizeof(buf));\n        return digest256_from_base64(digest256_out, buf);\n      }\n      if (num_len == 0 || cp[num_len] != ',')\n        break;\n      cp += num_len + 1;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "int git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\t\ti++;\n\t}\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\treturn git_pkt_buffer_flush(buf);\n}", "target": 0}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "storageStateInitialize(bool privileged,\n                       const char *root,\n                       virStateInhibitCallback callback G_GNUC_UNUSED,\n                       void *opaque G_GNUC_UNUSED)\n{\n    g_autofree char *configdir = NULL;\n    g_autofree char *rundir = NULL;\n    bool autostart = true;\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n    driver = g_new0(virStorageDriverState, 1);\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n    storageDriverLock();\n    if (!(driver->pools = virStoragePoolObjListNew()))\n        goto error;\n    if (privileged) {\n        driver->configDir = g_strdup(SYSCONFDIR \"/libvirt/storage\");\n        driver->autostartDir = g_strdup(SYSCONFDIR \"/libvirt/storage/autostart\");\n        driver->stateDir = g_strdup(RUNSTATEDIR \"/libvirt/storage\");\n    } else {\n        configdir = virGetUserConfigDirectory();\n        rundir = virGetUserRuntimeDirectory();\n        driver->configDir = g_strdup_printf(\"%s/storage\", configdir);\n        driver->autostartDir = g_strdup_printf(\"%s/storage/autostart\", configdir);\n        driver->stateDir = g_strdup_printf(\"%s/storage/run\", rundir);\n    }\n    driver->privileged = privileged;\n    if (g_mkdir_with_parents(driver->stateDir, 0777) < 0) {\n        virReportError(errno,\n                       _(\"cannot create directory %s\"),\n                       driver->stateDir);\n        goto error;\n    }\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\",\n                           false, getpid())) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllState(driver->pools,\n                                      driver->stateDir) < 0)\n        goto error;\n    if (virStoragePoolObjLoadAllConfigs(driver->pools,\n                                        driver->configDir,\n                                        driver->autostartDir) < 0)\n        goto error;\n    storagePoolUpdateAllState();\n    if (virDriverShouldAutostart(driver->stateDir, &autostart) < 0)\n        goto error;\n    if (autostart)\n        storageDriverAutostart();\n    driver->storageEventState = virObjectEventStateNew();\n    if (!(driver->caps = virStorageBackendGetCapabilities()))\n        goto error;\n    storageDriverUnlock();\n    return VIR_DRV_STATE_INIT_COMPLETE;\n error:\n    storageDriverUnlock();\n    storageStateCleanup();\n    return VIR_DRV_STATE_INIT_ERROR;\n}", "target": 0}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "static CURLcode imap_state_fetch_resp(struct connectdata *conn, int imapcode,\n                                      imapstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct pingpong *pp = &imapc->pp;\n  const char *ptr = data->state.buffer;\n  bool parsed = FALSE;\n  curl_off_t size = 0;\n  (void)instate; \n  if(imapcode != '*') {\n    Curl_pgrsSetDownloadSize(data, -1);\n    state(conn, IMAP_STOP);\n    return CURLE_REMOTE_FILE_NOT_FOUND; \n  }\n  while(*ptr && (*ptr != '{'))\n    ptr++;\n  if(*ptr == '{') {\n    char *endptr;\n    if(!curlx_strtoofft(ptr + 1, &endptr, 10, &size)) {\n      if(endptr - ptr > 1 && endptr[0] == '}' &&\n         endptr[1] == '\\r' && endptr[2] == '\\0')\n        parsed = TRUE;\n    }\n  }\n  if(parsed) {\n    infof(data, \"Found %\" CURL_FORMAT_CURL_OFF_TU \" bytes to download\\n\",\n          size);\n    Curl_pgrsSetDownloadSize(data, size);\n    if(pp->cache) {\n      size_t chunk = pp->cache_size;\n      if(chunk > (size_t)size)\n        chunk = (size_t)size;\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, pp->cache, chunk);\n      if(result)\n        return result;\n      data->req.bytecount += chunk;\n      infof(data, \"Written %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes, %\" CURL_FORMAT_CURL_OFF_TU\n            \" bytes are left for transfer\\n\", (curl_off_t)chunk,\n            size - chunk);\n      if(pp->cache_size > chunk) {\n        memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);\n        pp->cache_size -= chunk;\n      }\n      else {\n        Curl_safefree(pp->cache);\n        pp->cache_size = 0;\n      }\n    }\n    if(data->req.bytecount == size)\n      Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n    else {\n      data->req.maxdownload = size;\n      Curl_setup_transfer(conn, FIRSTSOCKET, size, FALSE, NULL, -1, NULL);\n    }\n  }\n  else {\n    failf(pp->conn->data, \"Failed to parse FETCH response.\");\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  state(conn, IMAP_STOP);\n  return result;\n}", "target": 1}
{"code": "static int iommu_init_domains(struct intel_iommu *iommu)\n{\n\tu32 ndomains, nlongs;\n\tsize_t size;\n\tndomains = cap_ndoms(iommu->cap);\n\tpr_debug(\"%s: Number of Domains supported <%d>\\n\",\n\t\t iommu->name, ndomains);\n\tnlongs = BITS_TO_LONGS(ndomains);\n\tspin_lock_init(&iommu->lock);\n\tiommu->domain_ids = kcalloc(nlongs, sizeof(unsigned long), GFP_KERNEL);\n\tif (!iommu->domain_ids) {\n\t\tpr_err(\"%s: Allocating domain id array failed\\n\",\n\t\t       iommu->name);\n\t\treturn -ENOMEM;\n\t}\n\tsize = (ALIGN(ndomains, 256) >> 8) * sizeof(struct dmar_domain **);\n\tiommu->domains = kzalloc(size, GFP_KERNEL);\n\tif (iommu->domains) {\n\t\tsize = 256 * sizeof(struct dmar_domain *);\n\t\tiommu->domains[0] = kzalloc(size, GFP_KERNEL);\n\t}\n\tif (!iommu->domains || !iommu->domains[0]) {\n\t\tpr_err(\"%s: Allocating domain array failed\\n\",\n\t\t       iommu->name);\n\t\tkfree(iommu->domain_ids);\n\t\tkfree(iommu->domains);\n\t\tiommu->domain_ids = NULL;\n\t\tiommu->domains    = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tset_bit(0, iommu->domain_ids);\n\treturn 0;\n}", "target": 0}
{"code": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\tif (netif_carrier_ok(dev)) {\n\t\trtnl_lock();\n\t\tnetif_carrier_off(dev); \n\t\tif (netif_running(dev))\n\t\t\txenvif_down(vif);\n\t\trtnl_unlock();\n\t\txenvif_put(vif);\n\t}\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\tdel_timer_sync(&vif->credit_timeout);\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\tunregister_netdev(vif->dev);\n\txen_netbk_unmap_frontend_rings(vif);\n\tfree_netdev(vif->dev);\n}", "target": 1}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "void RenderFrameHostImpl::OnDidFailProvisionalLoadWithError(\n    const FrameHostMsg_DidFailProvisionalLoadWithError_Params& params) {\n  frame_tree_node_->navigator()->DidFailProvisionalLoadWithError(this, params);\n}", "target": 0}
{"code": "static int multipart_buffer_headers(multipart_buffer *self, zend_llist *header TSRMLS_DC)\n{\n\tchar *line;\n\tmime_header_entry prev_entry = {0}, entry;\n\tint prev_len, cur_len;\n\tif (!find_boundary(self, self->boundary TSRMLS_CC)) {\n\t\treturn 0;\n\t}\n\twhile( (line = get_line(self TSRMLS_CC)) && strlen(line) > 0 )\n\t{\n\t\tchar *key = line;\n\t\tchar *value = NULL;\n\t\tif (php_rfc1867_encoding_translation(TSRMLS_C)) {\n\t\t\tself->input_encoding = zend_multibyte_encoding_detector(line, strlen(line), self->detect_order, self->detect_order_size TSRMLS_CC);\n\t\t}\n\t\tif (!isspace(line[0])) {\n\t\t\tvalue = strchr(line, ':');\n\t\t}\n\t\tif (value) {\n\t\t\t*value = 0;\n\t\t\tdo { value++; } while(isspace(*value));\n\t\t\tentry.value = estrdup(value);\n\t\t\tentry.key = estrdup(key);\n\t\t} else if (zend_llist_count(header)) { \n\t\t\tprev_len = strlen(prev_entry.value);\n\t\t\tcur_len = strlen(line);\n\t\t\tentry.value = emalloc(prev_len + cur_len + 1);\n\t\t\tmemcpy(entry.value, prev_entry.value, prev_len);\n\t\t\tmemcpy(entry.value + prev_len, line, cur_len);\n\t\t\tentry.value[cur_len + prev_len] = '\\0';\n\t\t\tentry.key = estrdup(prev_entry.key);\n\t\t\tzend_llist_remove_tail(header);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tzend_llist_add_element(header, &entry);\n\t\tprev_entry = entry;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "vte_sequence_handler_reset_mode (VteTerminal *terminal, GValueArray *params)\n{\n\tguint i;\n\tlong setting;\n\tGValue *value;\n\tif ((params == NULL) || (params->n_values == 0)) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < params->n_values; i++) {\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsetting = g_value_get_long(value);\n\t\tvte_sequence_handler_set_mode_internal(terminal, setting, FALSE);\n\t}\n}", "target": 0}
{"code": "static int read_file(const char *path, char *buf, size_t size,\n\t\t     struct file_info *d)\n{\n\tsize_t linelen = 0, total_len = 0, rv = 0;\n\tchar *line = NULL;\n\tchar *cache = d->buf;\n\tsize_t cache_size = d->buflen;\n\tFILE *f = fopen(path, \"r\");\n\tif (!f)\n\t\treturn 0;\n\twhile (getline(&line, &linelen, f) != -1) {\n\t\tsize_t l = snprintf(cache, cache_size, \"%s\", line);\n\t\tif (l < 0) {\n\t\t\tperror(\"Error writing to cache\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l >= cache_size) {\n\t\t\tfprintf(stderr, \"Internal error: truncated write to cache\\n\");\n\t\t\trv = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (l < cache_size) {\n\t\t\tcache += l;\n\t\t\tcache_size -= l;\n\t\t\ttotal_len += l;\n\t\t} else {\n\t\t\tcache += cache_size;\n\t\t\ttotal_len += cache_size;\n\t\t\tcache_size = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\td->size = total_len;\n\tif (total_len > size ) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\trv = total_len;\n  err:\n\tfclose(f);\n\tfree(line);\n\treturn rv;\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "static inline int check_user_page_hwpoison(unsigned long addr)\n{\n\tint rc, flags = FOLL_TOUCH | FOLL_HWPOISON | FOLL_WRITE;\n\trc = __get_user_pages(current, current->mm, addr, 1,\n\t\t\t      flags, NULL, NULL, NULL);\n\treturn rc == -EHWPOISON;\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "libxlDomainEventHandler(void *data, libxl_event *event)\n{\n    libxlDriverPrivate *driver = data;\n    libxl_shutdown_reason xl_reason = event->u.domain_shutdown.shutdown_reason;\n    virDomainObj *vm = NULL;\n    g_autoptr(libxlDriverConfig) cfg = NULL;\n    VIR_DEBUG(\"Received libxl event '%d' for domid '%d'\", event->type, event->domid);\n    if (event->type != LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN &&\n            event->type != LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        VIR_INFO(\"Unhandled event type %d\", event->type);\n        goto cleanup;\n    }\n    if (xl_reason == LIBXL_SHUTDOWN_REASON_SUSPEND)\n        goto cleanup;\n    vm = virDomainObjListFindByID(driver->domains, event->domid);\n    if (!vm) {\n        goto cleanup;\n    }\n    if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {\n        struct libxlEventHandlerThreadInfo *shutdown_info = NULL;\n        virThread thread;\n        g_autofree char *name = NULL;\n        shutdown_info = g_new0(struct libxlEventHandlerThreadInfo, 1);\n        shutdown_info->driver = driver;\n        shutdown_info->vm = vm;\n        shutdown_info->event = (libxl_event *)event;\n        name = g_strdup_printf(\"ev-%d\", event->domid);\n        if (virThreadCreateFull(&thread, false, libxlDomainShutdownThread,\n                                name, false, shutdown_info) < 0) {\n            VIR_ERROR(_(\"Failed to create thread to handle domain shutdown\"));\n            VIR_FREE(shutdown_info);\n            goto cleanup;\n        }\n        return;\n    } else if (event->type == LIBXL_EVENT_TYPE_DOMAIN_DEATH) {\n        libxlDomainHandleDeath(driver, vm);\n    }\n cleanup:\n    virDomainObjEndAPI(&vm);\n    cfg = libxlDriverConfigGet(driver);\n    libxl_event_free(cfg->ctx, (libxl_event *)event);\n}", "target": 1}
{"code": "static int selinux_sb_alloc_security(struct super_block *sb)\n{\n\tstruct superblock_security_struct *sbsec;\n\tsbsec = kzalloc(sizeof(struct superblock_security_struct), GFP_KERNEL);\n\tif (!sbsec)\n\t\treturn -ENOMEM;\n\tmutex_init(&sbsec->lock);\n\tINIT_LIST_HEAD(&sbsec->isec_head);\n\tspin_lock_init(&sbsec->isec_lock);\n\tsbsec->sb = sb;\n\tsbsec->sid = SECINITSID_UNLABELED;\n\tsbsec->def_sid = SECINITSID_FILE;\n\tsbsec->mntpoint_sid = SECINITSID_UNLABELED;\n\tsb->s_security = sbsec;\n\treturn 0;\n}", "target": 0}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n{\n  mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n  mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n  if (nlimbs > 2*m->size)\n    {\n      mp_limb_t hi = rp[2*m->size];\n      assert (nlimbs == 2*m->size + 1);\n      hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n      assert (hi <= 1);\n      hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n      assert (hi == 0);\n    }\n  m->mod (m, rp, rp);\n}", "target": 1}
{"code": "sigalrm_handler(int sig)\n{\nsig = sig;            \nsigalrm_seen = TRUE;\n}", "target": 0}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "ScriptProcessorNode* BaseAudioContext::createScriptProcessor(\n    uint32_t buffer_size,\n    uint32_t number_of_input_channels,\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return ScriptProcessorNode::Create(*this, buffer_size,\n                                     number_of_input_channels, exception_state);\n}", "target": 0}
{"code": "static int rm_sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n    while(!avio_feof(pb)){\n        int len, num, i;\n        int mlti_id;\n        *pos= avio_tell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            mlti_id = 0;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + avio_r8(pb);\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                int n_pkts, expected_len;\n                len = avio_rb32(pb);\n                avio_skip(pb, 2);\n                n_pkts = avio_rb32(pb);\n                expected_len = 20 + n_pkts * 14;\n                if (len == 20)\n                    len = expected_len;\n                else if (len != expected_len)\n                    av_log(s, AV_LOG_WARNING,\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n                           len, n_pkts, expected_len);\n                len -= 14; \n                if(len<0)\n                    continue;\n                goto skip;\n            } else if (state == MKBETAG('D','A','T','A')) {\n                av_log(s, AV_LOG_WARNING,\n                       \"DATA tag in middle of chunk, file may be broken.\\n\");\n            }\n            if(state > (unsigned)0xFFFF || state <= 12)\n                continue;\n            len=state - 12;\n            state= 0xFFFFFFFF;\n            num = avio_rb16(pb);\n            *timestamp = avio_rb32(pb);\n            mlti_id = (avio_r8(pb)>>1)-1<<16;\n            mlti_id = FFMAX(mlti_id, 0);\n            *flags = avio_r8(pb); \n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (mlti_id + num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            avio_skip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n        return len;\n    }\n    return -1;\n}", "target": 0}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "static int ioapic_mmio_read(struct kvm_io_device *this, gpa_t addr, int len,\n\t\t\t    void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "static inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n  ssize_t\n    count;\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}", "target": 0}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tif (sk->sk_family == AF_INET6)\n\t\tsk->sk_ipv6only = 1;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "    void DateValue::setDate(const Date& src)\n    {\n        date_.year = src.year;\n        date_.month = src.month;\n        date_.day = src.day;\n    }", "target": 0}
{"code": "static CustomStreamInfo *TIFFAcquireCustomStreamForWriting(\n  PhotoshopProfile *profile,ExceptionInfo *exception)\n{\n  CustomStreamInfo\n    *custom_stream;\n  custom_stream=AcquireCustomStreamInfo(exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    return(custom_stream);\n  SetCustomStreamData(custom_stream,(void *) profile);\n  SetCustomStreamWriter(custom_stream,TIFFWriteCustomStream);\n  SetCustomStreamSeeker(custom_stream,TIFFSeekCustomStream);\n  SetCustomStreamTeller(custom_stream,TIFFTellCustomStream);\n  return(custom_stream);\n}", "target": 0}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tint need_size = (int) ((char *) offset - memory + size);\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool lua_datum::is_number() const\n{\n    LUA_CHECK_TYPE(lua_isnumber);\n}", "target": 0}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 0}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "int __pte_alloc(struct mm_struct *mm, pmd_t *pmd, unsigned long address)\n{\n\tpgtable_t new = pte_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n\tif (!pmd_present(*pmd)) {\t\n\t\tmm->nr_ptes++;\n\t\tpmd_populate(mm, pmd, new);\n\t\tnew = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tif (new)\n\t\tpte_free(mm, new);\n\treturn 0;\n}", "target": 0}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "dirserv_free_fingerprint_list(void)\n{\n  if (!fingerprint_list)\n    return;\n  strmap_free(fingerprint_list->fp_by_name, _tor_free);\n  digestmap_free(fingerprint_list->status_by_digest, _tor_free);\n  tor_free(fingerprint_list);\n}", "target": 0}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "xfs_iunlink_remove(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_agi\t\t*agi;\n\tstruct xfs_buf\t\t*agibp;\n\tstruct xfs_buf\t\t*last_ibp;\n\tstruct xfs_dinode\t*last_dip = NULL;\n\txfs_agnumber_t\t\tagno = XFS_INO_TO_AGNO(mp, ip->i_ino);\n\txfs_agino_t\t\tagino = XFS_INO_TO_AGINO(mp, ip->i_ino);\n\txfs_agino_t\t\tnext_agino;\n\txfs_agino_t\t\thead_agino;\n\tshort\t\t\tbucket_index = agino % XFS_AGI_UNLINKED_BUCKETS;\n\tint\t\t\terror;\n\ttrace_xfs_iunlink_remove(ip);\n\terror = xfs_read_agi(mp, tp, agno, &agibp);\n\tif (error)\n\t\treturn error;\n\tagi = agibp->b_addr;\n\thead_agino = be32_to_cpu(agi->agi_unlinked[bucket_index]);\n\tif (!xfs_verify_agino(mp, agno, head_agino)) {\n\t\tXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp,\n\t\t\t\tagi, sizeof(*agi));\n\t\treturn -EFSCORRUPTED;\n\t}\n\terror = xfs_iunlink_update_inode(tp, ip, agno, NULLAGINO, &next_agino);\n\tif (error)\n\t\treturn error;\n\tif (next_agino != NULLAGINO) {\n\t\terror = xfs_iunlink_change_backref(agibp->b_pag, next_agino,\n\t\t\t\tNULLAGINO);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (head_agino != agino) {\n\t\tstruct xfs_imap\timap;\n\t\txfs_agino_t\tprev_agino;\n\t\terror = xfs_iunlink_map_prev(tp, agno, head_agino, agino,\n\t\t\t\t&prev_agino, &imap, &last_dip, &last_ibp,\n\t\t\t\tagibp->b_pag);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_iunlink_update_dinode(tp, agno, prev_agino, last_ibp,\n\t\t\t\tlast_dip, &imap, next_agino);\n\t\treturn xfs_iunlink_change_backref(agibp->b_pag, agino,\n\t\t\t\tnext_agino);\n\t}\n\treturn xfs_iunlink_update_bucket(tp, agno, agibp, bucket_index,\n\t\t\tnext_agino);\n}", "target": 0}
{"code": "void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ttcp_set_state(sk, TCP_ESTABLISHED);\n\tif (skb) {\n\t\ticsk->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\t\tsecurity_inet_conn_established(sk, skb);\n\t}\n\ticsk->icsk_af_ops->rebuild_header(sk);\n\ttcp_init_metrics(sk);\n\ttcp_init_congestion_control(sk);\n\ttp->lsndtime = tcp_time_stamp;\n\ttcp_init_buffer_space(sk);\n\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tp));\n\tif (!tp->rx_opt.snd_wscale)\n\t\t__tcp_fast_path_on(tp, tp->snd_wnd);\n\telse\n\t\ttp->pred_flags = 0;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t}\n}", "target": 0}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "void fib6_run_gc(unsigned long expires, struct net *net)\n{\n\tif (expires != ~0UL) {\n\t\tspin_lock_bh(&fib6_gc_lock);\n\t\tgc_args.timeout = expires ? (int)expires :\n\t\t\tnet->ipv6.sysctl.ip6_rt_gc_interval;\n\t} else {\n\t\tif (!spin_trylock_bh(&fib6_gc_lock)) {\n\t\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\t\treturn;\n\t\t}\n\t\tgc_args.timeout = net->ipv6.sysctl.ip6_rt_gc_interval;\n\t}\n\tgc_args.more = icmp6_dst_gc();\n\tfib6_clean_all(net, fib6_age, 0, NULL);\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(jiffies\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&fib6_gc_lock);\n}", "target": 0}
{"code": "vhost_user_reset_owner(struct virtio_net *dev)\n{\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tdev->flags &= ~VIRTIO_DEV_RUNNING;\n\t\tdev->notify_ops->destroy_device(dev->vid);\n\t}\n\tcleanup_device(dev, 0);\n\treset_device(dev);\n\treturn 0;\n}", "target": 0}
{"code": "static void rtl8139_transfer_frame(RTL8139State *s, uint8_t *buf, int size,\n    int do_interrupt, const uint8_t *dot1q_buf)\n{\n    struct iovec *iov = NULL;\n    struct iovec vlan_iov[3];\n    if (!size)\n    {\n        DPRINTF(\"+++ empty ethernet frame\\n\");\n        return;\n    }\n    if (dot1q_buf && size >= ETH_ALEN * 2) {\n        iov = (struct iovec[3]) {\n            { .iov_base = buf, .iov_len = ETH_ALEN * 2 },\n            { .iov_base = (void *) dot1q_buf, .iov_len = VLAN_HLEN },\n            { .iov_base = buf + ETH_ALEN * 2,\n                .iov_len = size - ETH_ALEN * 2 },\n        };\n        memcpy(vlan_iov, iov, sizeof(vlan_iov));\n        iov = vlan_iov;\n    }\n    if (TxLoopBack == (s->TxConfig & TxLoopBack))\n    {\n        size_t buf2_size;\n        uint8_t *buf2;\n        if (iov) {\n            buf2_size = iov_size(iov, 3);\n            buf2 = g_malloc(buf2_size);\n            iov_to_buf(iov, 3, 0, buf2, buf2_size);\n            buf = buf2;\n        }\n        DPRINTF(\"+++ transmit loopback mode\\n\");\n        rtl8139_do_receive(qemu_get_queue(s->nic), buf, size, do_interrupt);\n        if (iov) {\n            g_free(buf2);\n        }\n    }\n    else\n    {\n        if (iov) {\n            qemu_sendv_packet(qemu_get_queue(s->nic), iov, 3);\n        } else {\n            qemu_send_packet(qemu_get_queue(s->nic), buf, size);\n        }\n    }\n}", "target": 1}
{"code": "int service_init(int argc __attribute__((unused)),\n\t\t char **argv __attribute__((unused)),\n\t\t char **envp __attribute__((unused)))\n{\n    int opt;\n    const char *prefix;\n    initialize_nntp_error_table();\n    if (geteuid() == 0) fatal(\"must run as the Cyrus user\", EC_USAGE);\n    setproctitle_init(argc, argv, envp);\n    signals_set_shutdown(&shut_down);\n    signal(SIGPIPE, SIG_IGN);\n    global_sasl_init(1, 1, mysasl_cb);\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(newsprefix, sizeof(newsprefix), \"%s.\", prefix);\n    newsgroups = split_wildmats((char *) config_getstring(IMAPOPT_NEWSGROUPS));\n    if (duplicate_init(NULL, 0) != 0) {\n\tsyslog(LOG_ERR, \n\t       \"unable to init duplicate delivery database\\n\");\n\tfatal(\"unable to init duplicate delivery database\", EC_SOFTWARE);\n    }\n    mboxlist_init(0);\n    mboxlist_open(NULL);\n    quotadb_init(0);\n    quotadb_open(NULL);\n    denydb_init(0);\n    denydb_open(NULL);\n    idle_enabled();\n    while ((opt = getopt(argc, argv, \"srfp:\")) != EOF) {\n\tswitch(opt) {\n\tcase 's': \n\t    nntps = 1;\n\t    if (!tls_enabled()) {\n\t\tsyslog(LOG_ERR, \"nntps: required OpenSSL options not present\");\n\t\tfatal(\"nntps: required OpenSSL options not present\",\n\t\t      EC_CONFIG);\n\t    }\n\t    break;\n\tcase 'r': \n\t    nntp_capa = MODE_READ;\n\t    break;\n\tcase 'f': \n\t    nntp_capa = MODE_FEED;\n\t    break;\n\tcase 'p': \n\t    extprops_ssf = atoi(optarg);\n\t    break;\n\tdefault:\n\t    usage();\n\t}\n    }\n    annotatemore_init(NULL, NULL);\n    annotatemore_open();\n    newsmaster = (char *) config_getstring(IMAPOPT_NEWSMASTER);\n    newsmaster_authstate = auth_newstate(newsmaster);\n    singleinstance = config_getswitch(IMAPOPT_SINGLEINSTANCESTORE);\n    protin = protgroup_new(2);\n    return 0;\n}", "target": 0}
{"code": "static xmlParserCtxtPtr createMemoryParser(xmlSAXHandlerPtr handlers, void* userData, const char* chunk)\n{\n    if (!didInit) {\n        xmlInitParser();\n        xmlRegisterInputCallbacks(matchFunc, openFunc, readFunc, closeFunc);\n        xmlRegisterOutputCallbacks(matchFunc, openFunc, writeFunc, closeFunc);\n        libxmlLoaderThread = currentThread();\n        didInit = true;\n    }\n    xmlParserCtxtPtr parser = xmlCreateMemoryParserCtxt(chunk, xmlStrlen((const xmlChar*)chunk));\n    if (!parser)\n        return 0;\n    memcpy(parser->sax, handlers, sizeof(xmlSAXHandler));\n    xmlCtxtUseOptions(parser, XML_PARSE_NODICT | XML_PARSE_NOENT);\n    parser->sax2 = 1;\n    parser->instate = XML_PARSER_CONTENT; \n    parser->depth = 0;\n    parser->str_xml = xmlDictLookup(parser->dict, BAD_CAST \"xml\", 3);\n    parser->str_xmlns = xmlDictLookup(parser->dict, BAD_CAST \"xmlns\", 5);\n    parser->str_xml_ns = xmlDictLookup(parser->dict, XML_XML_NAMESPACE, 36);\n    parser->_private = userData;\n    return parser;\n}", "target": 0}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "int LibRaw::cameraCount()\n{\n  return (sizeof(static_camera_list) / sizeof(static_camera_list[0])) - 1;\n}", "target": 0}
{"code": "void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tconst unsigned char *sigalgs;\n\tsize_t i, sigalgslen;\n\tint have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tsigalgslen = tls12_get_psigalgs(s, &sigalgs);\n\tfor (i = 0; i < sigalgslen; i += 2, sigalgs += 2)\n\t\t{\n\t\tswitch(sigalgs[1])\n\t\t\t{\n#ifndef OPENSSL_NO_RSA\n\t\tcase TLSEXT_signature_rsa:\n\t\t\thave_rsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tcase TLSEXT_signature_dsa:\n\t\t\thave_dsa = 1;\n\t\t\tbreak;\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tcase TLSEXT_signature_ecdsa:\n\t\t\thave_ecdsa = 1;\n\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t}\n\tif (!have_rsa)\n\t\t{\n\t\tc->mask_a |= SSL_aRSA;\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\t\t}\n\tif (!have_dsa)\n\t\t{\n\t\tc->mask_a |= SSL_aDSS;\n\t\tc->mask_k |= SSL_kDHd;\n\t\t}\n\tif (!have_ecdsa)\n\t\t{\n\t\tc->mask_a |= SSL_aECDSA;\n\t\tc->mask_k |= SSL_kECDHe;\n\t\t}\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif \n\tc->valid = 1;\n\t}", "target": 0}
{"code": "void OmniboxViewWin::OnKeyUp(TCHAR key,\n                             UINT repeat_count,\n                             UINT flags) {\n  if (key == VK_CONTROL)\n    model_->OnControlKeyChanged(false);\n  if (!(flags & KF_ALTDOWN) &&\n      (((key == VK_CONTROL) && (GetKeyState(VK_SHIFT) < 0)) ||\n       ((key == VK_SHIFT) && (GetKeyState(VK_CONTROL) < 0)))) {\n    ScopedFreeze freeze(this, GetTextObjectModel());\n    string16 saved_text(GetText());\n    CHARRANGE saved_sel;\n    GetSelection(saved_sel);\n    SetWindowText(L\"\");\n    DefWindowProc(WM_KEYUP, key, MAKELPARAM(repeat_count, flags));\n    SetWindowText(saved_text.c_str());\n    SetSelectionRange(saved_sel);\n    return;\n  }\n  SetMsgHandled(false);\n}", "target": 0}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "skip_string(char_u *p)\n{\n    int\t    i;\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    \n\t{\n\t    if (p[1] == NUL)\t\t    \n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    \n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   \n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    \n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    \n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    \n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; \n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; \n\t    }\n\t}\n\tbreak;\t\t\t\t    \n    }\n    if (!*p)\n\t--p;\t\t\t\t    \n    return p;\n}", "target": 1}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "void http_return_srv_error(struct session *s, struct stream_interface *si)\n{\n\tint err_type = si->err_type;\n\tif (err_type & SI_ET_QUEUE_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ABRT)\n\t\thttp_server_error(s, si, SN_ERR_CLICL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_QUEUE_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_Q,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_TO)\n\t\thttp_server_error(s, si, SN_ERR_SRVTO, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse if (err_type & SI_ET_CONN_ERR)\n\t\thttp_server_error(s, si, SN_ERR_SRVCL, SN_FINST_C,\n\t\t\t\t  503, http_error_message(s, HTTP_ERR_503));\n\telse \n\t\thttp_server_error(s, si, SN_ERR_INTERNAL, SN_FINST_C,\n\t\t\t\t  500, http_error_message(s, HTTP_ERR_500));\n}", "target": 0}
{"code": "LuaSettings::LuaSettings(const std::string &filename, bool write_allowed) :\n\tm_filename(filename),\n\tm_is_own_settings(true),\n\tm_write_allowed(write_allowed)\n{\n\tm_settings = new Settings();\n\tm_settings->readConfigFile(filename.c_str());\n}", "target": 0}
{"code": "RSAES_PKCS1v1_5Encode(\n\t\t      TPM2B       *padded,        \n\t\t      TPM2B       *message,       \n\t\t      RAND_STATE  *rand\n\t\t      )\n{\n    UINT32      ps = padded->size - message->size - 3;\n    if(message->size > padded->size - 11)\n\treturn TPM_RC_VALUE;\n    memcpy(&padded->buffer[padded->size - message->size], message->buffer,\n\t   message->size);\n    padded->buffer[0] = 0;\n    padded->buffer[1] = 2;\n    DRBG_Generate(rand, &padded->buffer[2], (UINT16)ps);\n    padded->buffer[2 + ps] = 0;\n    for(ps++; ps > 1; ps--)\n\t{\n\t    if(padded->buffer[ps] == 0)\n\t\tpadded->buffer[ps] = 0x55;  \n\t}\n    return TPM_RC_SUCCESS;\n}", "target": 0}
{"code": "date_s__valid_nth_kday_p(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE vy, vm, vn, vk, vsg;\n    VALUE argv2[5];\n    rb_scan_args(argc, argv, \"41\", &vy, &vm, &vn, &vk, &vsg);\n    argv2[0] = vy;\n    argv2[1] = vm;\n    argv2[2] = vn;\n    argv2[3] = vk;\n    if (argc < 5)\n\targv2[4] = DBL2NUM(GREGORIAN);\n    else\n\targv2[4] = vsg;\n    return valid_nth_kday_sub(5, argv2, klass, 1);\n}", "target": 0}
{"code": "int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\tmemcpy(ep->auth_hmacs_list->hmac_ids, &hmacs->shmac_idents[0],\n\t\thmacs->shmac_num_idents * sizeof(__u16));\n\tep->auth_hmacs_list->param_hdr.length = htons(sizeof(sctp_paramhdr_t) +\n\t\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}", "target": 1}
{"code": "static void wcd9335_codec_hph_mode_config(struct snd_soc_component *component,\n\t\t\t\t\t  int event, int mode)\n{\n\tswitch (mode) {\n\tcase CLS_H_LP:\n\t\twcd9335_codec_hph_lp_config(component, event);\n\t\tbreak;\n\tcase CLS_H_LOHIFI:\n\t\twcd9335_codec_hph_lohifi_config(component, event);\n\t\tbreak;\n\tcase CLS_H_HIFI:\n\t\twcd9335_codec_hph_hifi_config(component, event);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "MATCHER_P(MapEqValue, rhs, \"\") {\n  const ProtobufWkt::Struct& obj = arg;\n  EXPECT_TRUE(!rhs.empty());\n  for (auto const& entry : rhs) {\n    EXPECT_TRUE(TestUtility::protoEqual(obj.fields().at(entry.first), entry.second));\n  }\n  return true;\n}", "target": 0}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static int iommu_dummy(struct device *dev)\n{\n\treturn dev->archdata.iommu == DUMMY_DEVICE_DOMAIN_INFO;\n}", "target": 0}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "wb_write_padding_to_temp(struct archive_write *a, int64_t csize)\n{\n\tsize_t ns;\n\tint ret;\n\tns = (size_t)(csize % LOGICAL_BLOCK_SIZE);\n\tif (ns != 0)\n\t\tret = write_null(a, LOGICAL_BLOCK_SIZE - ns);\n\telse\n\t\tret = ARCHIVE_OK;\n\treturn (ret);\n}", "target": 0}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "int lxc_pclose(struct lxc_popen_FILE *fp)\n{\n\tpid_t wait_pid;\n\tint wstatus = 0;\n\tif (!fp)\n\t\treturn -1;\n\tdo {\n\t\twait_pid = waitpid(fp->child_pid, &wstatus, 0);\n\t} while (wait_pid < 0 && errno == EINTR);\n\tfclose(fp->f);\n\tfree(fp);\n\tif (wait_pid < 0)\n\t\treturn -1;\n\treturn wstatus;\n}", "target": 0}
{"code": "static int tcp_match_skb_to_sack(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t u32 start_seq, u32 end_seq)\n{\n\tint in_sack, err;\n\tunsigned int pkt_len;\n\tunsigned int mss;\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\tif (tcp_skb_pcount(skb) > 1 && !in_sack &&\n\t    after(TCP_SKB_CB(skb)->end_seq, start_seq)) {\n\t\tmss = tcp_skb_mss(skb);\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\tpkt_len = start_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\tpkt_len = mss;\n\t\t} else {\n\t\t\tpkt_len = end_seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (pkt_len < mss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt_len > mss) {\n\t\t\tunsigned int new_len = (pkt_len / mss) * mss;\n\t\t\tif (!in_sack && new_len < pkt_len) {\n\t\t\t\tnew_len += mss;\n\t\t\t\tif (new_len > skb->len)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpkt_len = new_len;\n\t\t}\n\t\terr = tcp_fragment(sk, skb, pkt_len, mss);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn in_sack;\n}", "target": 0}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "    SigmaMnHeader::~SigmaMnHeader()\n    {\n    }", "target": 0}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "int RGWPutObj_ObjStore_S3::get_decrypt_filter(\n    std::unique_ptr<RGWGetObj_Filter>* filter,\n    RGWGetObj_Filter* cb,\n    map<string, bufferlist>& attrs,\n    bufferlist* manifest_bl)\n{\n  std::map<std::string, std::string> crypt_http_responses_unused;\n  int res = 0;\n  std::unique_ptr<BlockCrypt> block_crypt;\n  res = rgw_s3_prepare_decrypt(s, attrs, &block_crypt, crypt_http_responses_unused);\n  if (res == 0) {\n    if (block_crypt != nullptr) {\n      auto f = std::unique_ptr<RGWGetObj_BlockDecrypt>(new RGWGetObj_BlockDecrypt(s->cct, cb, std::move(block_crypt)));\n      if (f != nullptr) {\n        if (manifest_bl != nullptr) {\n          res = f->read_manifest(*manifest_bl);\n          if (res == 0) {\n            *filter = std::move(f);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}", "target": 0}
{"code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}", "target": 1}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}", "target": 1}
{"code": "static ssize_t _nfsd_copy_file_range(struct nfsd4_copy *copy)\n{\n\tssize_t bytes_copied = 0;\n\tsize_t bytes_total = copy->cp_count;\n\tu64 src_pos = copy->cp_src_pos;\n\tu64 dst_pos = copy->cp_dst_pos;\n\tdo {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tbytes_copied = nfsd_copy_file_range(copy->file_src, src_pos,\n\t\t\t\tcopy->file_dst, dst_pos, bytes_total);\n\t\tif (bytes_copied <= 0)\n\t\t\tbreak;\n\t\tbytes_total -= bytes_copied;\n\t\tcopy->cp_res.wr_bytes_written += bytes_copied;\n\t\tsrc_pos += bytes_copied;\n\t\tdst_pos += bytes_copied;\n\t} while (bytes_total > 0 && !copy->cp_synchronous);\n\treturn bytes_copied;\n}", "target": 0}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "make_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n  ns[1] = absent;\n  ns[3] = step_one; \n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  ns[0] = x;\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n  if (possessive != 0) {\n    x = node_new_enclosure(ENCLOSURE_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n  ns[1] = x; ns[2] = NULL_NODE;\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, NST_SUPER);\n  *node = x;\n  return ONIG_NORMAL;\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}", "target": 0}
{"code": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushnull(J);\n}", "target": 1}
{"code": "static int file_modsqrt(STANZA *s)\n{\n    BIGNUM *a = NULL, *p = NULL, *mod_sqrt = NULL, *ret = NULL, *ret2 = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(p = getBN(s, \"P\"))\n            || !TEST_ptr(mod_sqrt = getBN(s, \"ModSqrt\"))\n            || !TEST_ptr(ret = BN_new())\n            || !TEST_ptr(ret2 = BN_new()))\n        goto err;\n    if (!TEST_true(BN_mod_sqrt(ret, a, p, ctx))\n            || !TEST_true(BN_sub(ret2, p, ret)))\n        goto err;\n    if (BN_cmp(ret2, mod_sqrt) != 0\n            && !equalBN(\"sqrt(A) (mod P)\", mod_sqrt, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(p);\n    BN_free(mod_sqrt);\n    BN_free(ret);\n    BN_free(ret2);\n    return st;\n}", "target": 0}
{"code": "win_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\tif (after == 1)\n\t{\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n#if defined(FEAT_GUI)\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}", "target": 0}
{"code": "bool Alter_table_prelocking_strategy::\nhandle_routine(THD *thd, Query_tables_list *prelocking_ctx,\n               Sroutine_hash_entry *rt, sp_head *sp, bool *need_prelocking)\n{\n  return FALSE;\n}", "target": 0}
{"code": "return_enc_padata(krb5_context context, krb5_data *req_pkt,\n                  krb5_kdc_req *request, krb5_keyblock *reply_key,\n                  krb5_db_entry *server, krb5_enc_kdc_rep_part *reply_encpart,\n                  krb5_boolean is_referral)\n{\n    krb5_error_code code = 0;\n    assert(reply_encpart->enc_padata == NULL);\n    if (is_referral) {\n        code = return_referral_enc_padata(context, reply_encpart, server);\n        if (code)\n            return code;\n    }\n    code = kdc_handle_protected_negotiation(context, req_pkt, request, reply_key,\n                                            &reply_encpart->enc_padata);\n    if (code)\n        goto cleanup;\ncleanup:\n    return code;\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "static int domain_add_dev_info(struct dmar_domain *domain, struct device *dev)\n{\n\tstruct dmar_domain *ndomain;\n\tstruct intel_iommu *iommu;\n\tu8 bus, devfn;\n\tiommu = device_to_iommu(dev, &bus, &devfn);\n\tif (!iommu)\n\t\treturn -ENODEV;\n\tndomain = dmar_insert_one_dev_info(iommu, bus, devfn, dev, domain);\n\tif (ndomain != domain)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "bool PrintWebViewHelper::CalculateNumberOfPages(blink::WebLocalFrame* frame,\n                                                const blink::WebNode& node,\n                                                int* number_of_pages) {\n  DCHECK(frame);\n  bool fit_to_paper_size = !(PrintingNodeOrPdfFrame(frame, node));\n  if (!InitPrintSettings(fit_to_paper_size)) {\n    notify_browser_of_print_failure_ = false;\n    Send(new PrintHostMsg_ShowInvalidPrinterSettingsError(routing_id()));\n    return false;\n  }\n  const PrintMsg_Print_Params& params = print_pages_params_->params;\n  PrepareFrameAndViewForPrint prepare(params, frame, node, ignore_css_margins_);\n  prepare.StartPrinting();\n  *number_of_pages = prepare.GetExpectedPageCount();\n  return true;\n}", "target": 0}
{"code": "int gdCompareInt (const void *a, const void *b)\n{\n\treturn (*(const int *) a) - (*(const int *) b);\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "bool HTMLMediaElement::seeking() const {\n  return seeking_;\n}", "target": 0}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static int ssl_flight_append( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_flight_item *msg;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> ssl_flight_append\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"message appended to flight\",\n                           ssl->out_msg, ssl->out_msglen );\n    if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                            sizeof( mbedtls_ssl_flight_item ) ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc %\" MBEDTLS_PRINTF_SIZET \" bytes failed\",\n                                    ssl->out_msglen ) );\n        mbedtls_free( msg );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n    memcpy( msg->p, ssl->out_msg, ssl->out_msglen );\n    msg->len = ssl->out_msglen;\n    msg->type = ssl->out_msgtype;\n    msg->next = NULL;\n    if( ssl->handshake->flight == NULL )\n        ssl->handshake->flight = msg;\n    else\n    {\n        mbedtls_ssl_flight_item *cur = ssl->handshake->flight;\n        while( cur->next != NULL )\n            cur = cur->next;\n        cur->next = msg;\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= ssl_flight_append\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n  if (stl->error) return;\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       \n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     \n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     \n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}", "target": 1}
{"code": "static int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\n{\n\tswitch (var->bits_per_pixel) {\n\tcase 8:\n\t\tvar->red.offset\t= var->green.offset = var->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (var->green.length) {\n\t\tdefault:\n\t\tcase 5:\n\t\t\tvar->red.offset = 10;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length\t= 5;\n\t\t\tvar->green.length = 5;\n\t\t\tvar->blue.length = 5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tvar->red.offset = 11;\n\t\t\tvar->green.offset = 5;\n\t\t\tvar->blue.offset = 0;\n\t\t\tvar->red.length = var->blue.length = 5;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->red.length\t= var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tcase 32:\n\t\tvar->transp.offset = 24;\n\t\tvar->red.offset = 16;\n\t\tvar->green.offset = 8;\n\t\tvar->blue.offset = 0;\n\t\tvar->transp.length = 8;\n\t\tvar->red.length = var->green.length = var->blue.length = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (var->xres > var->xres_virtual)\n\t\tvar->xres_virtual = var->xres;\n\tif (var->yres > var->yres_virtual)\n\t\tvar->yres_virtual = var->yres;\n\tif (info->monspecs.hfmax && info->monspecs.vfmax &&\n\t    info->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int create_vcpu_fd(struct kvm_vcpu *vcpu)\n{\n\treturn anon_inode_getfd(\"kvm-vcpu\", &kvm_vcpu_fops, vcpu, O_RDWR);\n}", "target": 0}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "static __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\treturn err_code;\n}", "target": 0}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n \tw = image->comps[0].w;\n \th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n \tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "void in6_dev_finish_destroy(struct inet6_dev *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\tWARN_ON(!list_empty(&idev->addr_list));\n\tWARN_ON(idev->mc_list != NULL);\n\tWARN_ON(timer_pending(&idev->rs_timer));\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %s\\n\", __func__, dev ? dev->name : \"NIL\");\n#endif\n\tdev_put(dev);\n\tif (!idev->dead) {\n\t\tpr_warn(\"Freeing alive inet6 device %p\\n\", idev);\n\t\treturn;\n\t}\n\tsnmp6_free_dev(idev);\n\tkfree_rcu(idev, rcu);\n}", "target": 0}
{"code": "void gdImagePaletteCopy (gdImagePtr to, gdImagePtr from)\n{\n\tint i;\n\tint x, y, p;\n\tint xlate[256];\n\tif (to->trueColor || from->trueColor) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < 256; i++) {\n\t\txlate[i] = -1;\n\t}\n\tfor (y = 0; y < to->sy; y++) {\n\t\tfor (x = 0; x < to->sx; x++) {\n\t\t\tp = gdImageGetPixel(to, x, y);\n\t\t\tif (xlate[p] == -1) {\n\t\t\t\txlate[p] = gdImageColorClosestAlpha (from, to->red[p], to->green[p], to->blue[p], to->alpha[p]);\n\t\t\t}\n\t\t\tgdImageSetPixel(to, x, y, xlate[p]);\n\t\t}\n\t}\n\tfor (i = 0; i < from->colorsTotal; i++) {\n\t\tto->red[i] = from->red[i];\n\t\tto->blue[i] = from->blue[i];\n\t\tto->green[i] = from->green[i];\n\t\tto->alpha[i] = from->alpha[i];\n\t\tto->open[i] = 0;\n\t}\n\tfor (i = from->colorsTotal; i < to->colorsTotal; i++) {\n\t\tto->open[i] = 1;\n\t}\n\tto->colorsTotal = from->colorsTotal;\n}", "target": 0}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "resolve_fstab_device (guestfs_h *g, const char *spec, Hash_table *md_map)\n{\n  char *device = NULL;\n  char *type, *slice, *disk, *part;\n  int r;\n  if (STRPREFIX (spec, \"/dev/mapper/\") && guestfs_exists (g, spec) > 0) {\n    device = guestfs_lvm_canonical_lv_name (g, spec);\n  }\n  else if (match3 (g, spec, re_xdev, &type, &disk, &part)) {\n    r = resolve_fstab_device_xdev (g, type, disk, part, &device);\n    free (type);\n    free (disk);\n    free (part);\n    if (r == -1)\n      return NULL;\n  }\n  else if (match2 (g, spec, re_cciss, &disk, &part)) {\n    r = resolve_fstab_device_cciss (g, disk, part, &device);\n    free (disk);\n    free (part);\n    if (r == -1)\n      return NULL;\n  }\n  else if (md_map && (disk = match1 (g, spec, re_mdN)) != NULL) {\n    mdadm_app entry;\n    entry.mdadm = disk;\n    mdadm_app *app = hash_lookup (md_map, &entry);\n    if (app) device = safe_strdup (g, app->app);\n    free (disk);\n  }\n  else if (match3 (g, spec, re_freebsd, &disk, &slice, &part)) {\n    int disk_i = guestfs___parse_unsigned_int (g, disk);\n    int slice_i = guestfs___parse_unsigned_int (g, slice);\n    int part_i = part[0] - 'a' ;\n    free (disk);\n    free (slice);\n    free (part);\n    if (disk_i != -1 && disk_i <= 26 &&\n        slice_i > 0 && slice_i <= 1  &&\n        part_i >= 0 && part_i < 26) {\n      device = safe_asprintf (g, \"/dev/sd%c%d\", disk_i + 'a', part_i + 5);\n    }\n  }\n  else if ((part = match1 (g, spec, re_diskbyid)) != NULL) {\n    r = resolve_fstab_device_diskbyid (g, part, &device);\n    free (part);\n    if (r == -1)\n      return NULL;\n  }\n  if (device == NULL)\n    device = safe_strdup (g, spec);\n  return device;\n}", "target": 0}
{"code": "decode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif ((24+64) > plen)\n\t\treturn -1;\n        plen-=(24+64); \n\tif (152 < plen)\n\t\treturn -1;\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 12 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 0}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "    size_t operator()(const ArrayOrObject data) const {\n      return data.toOpaque();\n    }", "target": 0}
{"code": "date_initialize(int argc, VALUE *argv, VALUE self)\n{\n    VALUE vy, vm, vd, vsg, y, fr, fr2, ret;\n    int m, d;\n    double sg;\n    struct SimpleDateData *dat = rb_check_typeddata(self, &d_lite_type);\n    if (!simple_dat_p(dat)) {\n\trb_raise(rb_eTypeError, \"Date expected\");\n    }\n    rb_scan_args(argc, argv, \"04\", &vy, &vm, &vd, &vsg);\n    y = INT2FIX(-4712);\n    m = 1;\n    d = 1;\n    fr2 = INT2FIX(0);\n    sg = DEFAULT_SG;\n    switch (argc) {\n      case 4:\n\tval2sg(vsg, sg);\n      case 3:\n        check_numeric(vd, \"day\");\n\tnum2int_with_frac(d, positive_inf);\n      case 2:\n        check_numeric(vm, \"month\");\n\tm = NUM2INT(vm);\n      case 1:\n        check_numeric(vy, \"year\");\n\ty = vy;\n    }\n    if (guess_style(y, sg) < 0) {\n\tVALUE nth;\n\tint ry, rm, rd;\n\tif (!valid_gregorian_p(y, m, d,\n\t\t\t       &nth, &ry,\n\t\t\t       &rm, &rd))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, 0, sg, ry, rm, rd, HAVE_CIVIL);\n    }\n    else {\n\tVALUE nth;\n\tint ry, rm, rd, rjd, ns;\n\tif (!valid_civil_p(y, m, d, sg,\n\t\t\t   &nth, &ry,\n\t\t\t   &rm, &rd, &rjd,\n\t\t\t   &ns))\n\t    rb_raise(eDateError, \"invalid date\");\n\tset_to_simple(self, dat, nth, rjd, sg, ry, rm, rd, HAVE_JD | HAVE_CIVIL);\n    }\n    ret = self;\n    add_frac();\n    return ret;\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "decompileGOTOFRAME(int n, SWF_ACTION *actions,int maxn,int islabel)\n{\n\tint i=0;\n\tstruct SWF_ACTIONGOTOLABEL *sactv2;\n\tOUT_BEGIN2(SWF_ACTIONGOTOFRAME);\n\tsactv2 = (struct SWF_ACTIONGOTOLABEL*)sact;\n\tINDENT\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_PLAY)\n\t{\n\t\ti=1;\n\t\tputs(\"gotoAndPlay(\");\n\t}\n\telse\n\t{\n\t\tif (OpCode(actions, n+1, maxn) == SWFACTION_STOP)\n\t\t\ti=1;\n\t\tputs(\"gotoAndStop(\");\n\t}\n\tif (islabel)\n\t\tprintln(\"'%s');\", sactv2->FrameLabel);\n\telse\n\t\tprintln(\"%d);\", sact->Frame+1); \n\treturn i;\n}", "target": 0}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "static GF_Err gf_isom_svc_mvc_config_del(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool is_mvc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (is_mvc && entry->mvc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->mvc_config);\n\t\tentry->mvc_config = NULL;\n\t}\n\telse if (!is_mvc && entry->svc_config) {\n\t\tgf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)entry->svc_config);\n\t\tentry->svc_config = NULL;\n\t}\n\tAVC_RewriteESDescriptor(entry);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void terminate(int sig)\n{\n    unlink(socket_file);\n    exit(0);\n}", "target": 0}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "xfs_perag_clear_reclaim_tag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\tlockdep_assert_held(&pag->pag_ici_lock);\n\tif (--pag->pag_ici_reclaimable)\n\t\treturn;\n\tspin_lock(&mp->m_perag_lock);\n\tradix_tree_tag_clear(&mp->m_perag_tree, pag->pag_agno,\n\t\t\t     XFS_ICI_RECLAIM_TAG);\n\tspin_unlock(&mp->m_perag_lock);\n\ttrace_xfs_perag_clear_reclaim(mp, pag->pag_agno, -1, _RET_IP_);\n}", "target": 0}
{"code": "find_reserved_job_in_conn(conn c, job j)\n{\n    return (j && j->reserver == c && j->state == JOB_STATE_RESERVED) ? j : NULL;\n}", "target": 0}
{"code": "elg_get_info( int algo, int *npkey, int *nskey, int *nenc, int *nsig,\n\t\t\t\t\t\t\t int *use )\n{\n    *npkey = 3;\n    *nskey = 4;\n    *nenc = 2;\n    *nsig = 2;\n    switch( algo ) {\n      case PUBKEY_ALGO_ELGAMAL_E:\n\t*use = PUBKEY_USAGE_ENC;\n\treturn \"ELG-E\";\n      default: *use = 0; return NULL;\n    }\n}", "target": 0}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = (uint8_t*)p_data;\n   uint8_t reason = SMP_INVALID_PARAMETERS;\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->status = *(uint8_t*)p_data;\n   if (smp_command_has_invalid_parameters(p_cb)) {\n     smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);\n     return;\n   }\n   if (p != NULL) {\n     STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);\n   } else {\n    p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;\n }\n  p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;\n}", "target": 1}
{"code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\ttemp = bridge->current_size;\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\treturn -EINVAL;\n\t}\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1}
{"code": "static int32_t virtio_net_rsc_coalesce4(VirtioNetRscChain *chain,\n                                        VirtioNetRscSeg *seg,\n                                        const uint8_t *buf, size_t size,\n                                        VirtioNetRscUnit *unit)\n{\n    struct ip_header *ip1, *ip2;\n    ip1 = (struct ip_header *)(unit->ip);\n    ip2 = (struct ip_header *)(seg->unit.ip);\n    if ((ip1->ip_src ^ ip2->ip_src) || (ip1->ip_dst ^ ip2->ip_dst)\n        || (unit->tcp->th_sport ^ seg->unit.tcp->th_sport)\n        || (unit->tcp->th_dport ^ seg->unit.tcp->th_dport)) {\n        chain->stat.no_match++;\n        return RSC_NO_MATCH;\n    }\n    return virtio_net_rsc_coalesce_data(chain, seg, buf, unit);\n}", "target": 0}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "void PacketReader::copyRecord(unsigned char* dest, uint16_t len)\n{\n  if(d_pos + len > d_content.size())\n    throw std::out_of_range(\"Attempt to copy outside of packet\");\n  memcpy(dest, &d_content.at(d_pos), len);\n  d_pos+=len;\n}", "target": 0}
{"code": "int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_context_destroy *args = data;\n\tstruct drm_i915_file_private *file_priv = file->driver_priv;\n\tstruct i915_gem_context *ctx;\n\tint ret;\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\tif (args->ctx_id == DEFAULT_CONTEXT_HANDLE)\n\t\treturn -ENOENT;\n\tctx = i915_gem_context_lookup(file_priv, args->ctx_id);\n\tif (!ctx)\n\t\treturn -ENOENT;\n\tret = mutex_lock_interruptible(&dev->struct_mutex);\n\tif (ret)\n\t\tgoto out;\n\tidr_remove(&file_priv->context_idr, ctx->user_handle);\n\tcontext_close(ctx);\n\tmutex_unlock(&dev->struct_mutex);\nout:\n\ti915_gem_context_put(ctx);\n\treturn 0;\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "static Token *make_tok_num(Token *next, int64_t val)\n{\n    char numbuf[32];\n    int len = snprintf(numbuf, sizeof(numbuf), \"%\"PRId64\"\", val);\n    return new_Token(next, TOK_NUMBER, numbuf, len);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MinValid) {\n    addIndex(BSON(\"a\" << 1));\n    runQueryHintMinMax(BSONObj(), BSONObj(), fromjson(\"{a: 1}\"), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{fetch: {filter: null, \"\n        \"node: {ixscan: {filter: null, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\tif (p > end)\n\t\treturn 0;\n\tlen = *p++;\n\tif (p + len > end)\n\t\treturn 0;\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\t*data += 1 + len;\n\treturn len;\n}", "target": 1}
{"code": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "UINT rdpgfx_read_rect16(wStream* s, RECTANGLE_16* rect16)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tWLog_ERR(TAG, \"not enough data!\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\tStream_Read_UINT16(s, rect16->left);   \n\tStream_Read_UINT16(s, rect16->top);    \n\tStream_Read_UINT16(s, rect16->right);  \n\tStream_Read_UINT16(s, rect16->bottom); \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_nullfunc(hdr->frame_control))\n\t\treturn TX_DROP;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_WDS)\n\t\treturn TX_CONTINUE;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\treturn TX_CONTINUE;\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {\n\t\treturn TX_DROP;\n\t}\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "vhost_user_set_features(struct virtio_net *dev, uint64_t features)\n{\n\tuint64_t vhost_features = 0;\n\trte_vhost_driver_get_features(dev->ifname, &vhost_features);\n\tif (features & ~vhost_features) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"(%d) received invalid negotiated features.\\n\",\n\t\t\tdev->vid);\n\t\treturn -1;\n\t}\n\tif (dev->flags & VIRTIO_DEV_RUNNING) {\n\t\tif (dev->features == features)\n\t\t\treturn 0;\n\t\tif ((dev->features ^ features) & ~(1ULL << VHOST_F_LOG_ALL)) {\n\t\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\t\"(%d) features changed while device is running.\\n\",\n\t\t\t\tdev->vid);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dev->notify_ops->features_changed)\n\t\t\tdev->notify_ops->features_changed(dev->vid, features);\n\t}\n\tdev->features = features;\n\tif (dev->features &\n\t\t((1 << VIRTIO_NET_F_MRG_RXBUF) | (1ULL << VIRTIO_F_VERSION_1))) {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr_mrg_rxbuf);\n\t} else {\n\t\tdev->vhost_hlen = sizeof(struct virtio_net_hdr);\n\t}\n\tLOG_DEBUG(VHOST_CONFIG,\n\t\t\"(%d) mergeable RX buffers %s, virtio 1 %s\\n\",\n\t\tdev->vid,\n\t\t(dev->features & (1 << VIRTIO_NET_F_MRG_RXBUF)) ? \"on\" : \"off\",\n\t\t(dev->features & (1ULL << VIRTIO_F_VERSION_1)) ? \"on\" : \"off\");\n\tif ((dev->flags & VIRTIO_DEV_BUILTIN_VIRTIO_NET) &&\n\t    !(dev->features & (1ULL << VIRTIO_NET_F_MQ))) {\n\t\twhile (dev->nr_vring > 2) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvq = dev->virtqueue[--dev->nr_vring];\n\t\t\tif (!vq)\n\t\t\t\tcontinue;\n\t\t\tdev->virtqueue[dev->nr_vring] = NULL;\n\t\t\tcleanup_vq(vq, 1);\n\t\t\tfree_vq(vq);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int sanity_check_raw_super(struct super_block *sb,\n\t\t\tstruct f2fs_super_block *raw_super)\n{\n\tunsigned int blocksize;\n\tif (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Magic Mismatch, valid(0x%x) - read(0x%x)\",\n\t\t\tF2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));\n\t\treturn 1;\n\t}\n\tif (F2FS_BLKSIZE != PAGE_CACHE_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid page_cache_size (%lu), supports only 4KB\\n\",\n\t\t\tPAGE_CACHE_SIZE);\n\t\treturn 1;\n\t}\n\tblocksize = 1 << le32_to_cpu(raw_super->log_blocksize);\n\tif (blocksize != F2FS_BLKSIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid blocksize (%u), supports only 4KB\\n\",\n\t\t\tblocksize);\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectorsize) >\n\t\t\t\tF2FS_MAX_LOG_SECTOR_SIZE ||\n\t\tle32_to_cpu(raw_super->log_sectorsize) <\n\t\t\t\tF2FS_MIN_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\tif (le32_to_cpu(raw_super->log_sectors_per_block) +\n\t\tle32_to_cpu(raw_super->log_sectorsize) !=\n\t\t\tF2FS_MAX_LOG_SECTOR_SIZE) {\n\t\tf2fs_msg(sb, KERN_INFO,\n\t\t\t\"Invalid log sectors per block(%u) log sectorsize(%u)\",\n\t\t\tle32_to_cpu(raw_super->log_sectors_per_block),\n\t\t\tle32_to_cpu(raw_super->log_sectorsize));\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "_gnutls_x509_read_value(ASN1_TYPE c, const char *root,\n\t\t\tgnutls_datum_t * ret)\n{\n\tint len = 0, result;\n\tuint8_t *tmp = NULL;\n\tunsigned int etype;\n\tresult = asn1_read_value_type(c, root, NULL, &len, &etype);\n\tif (result == 0 && len == 0) {\n\t\treturn gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t}\n\tif (result != ASN1_MEM_ERROR) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\treturn result;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tlen = (len + 7)/8;\n\t}\n\ttmp = gnutls_malloc((size_t) len + 1);\n\tif (tmp == NULL) {\n\t\tgnutls_assert();\n\t\tresult = GNUTLS_E_MEMORY_ERROR;\n\t\tgoto cleanup;\n\t}\n\tresult = asn1_read_value(c, root, tmp, &len);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (etype == ASN1_ETYPE_BIT_STRING) {\n\t\tret->size = (len+7) / 8;\n\t} else {\n\t\tret->size = (unsigned) len;\n\t}\n\ttmp[ret->size] = 0;\n\tret->data = tmp;\n\treturn 0;\n      cleanup:\n\tgnutls_free(tmp);\n\treturn result;\n}", "target": 0}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "ring_set_paused(const struct intel_engine_cs *engine, int state)\n{\n\tengine->status_page.addr[I915_GEM_HWS_PREEMPT] = state;\n\tif (state)\n\t\twmb();\n}", "target": 0}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) {\n  pdfdocLocker();\n  if (str->getLength() <= 0)\n  {\n    error(errSyntaxError, -1, \"Document stream is empty\");\n    return false;\n  }\n  str->setPos(0, -1);\n  if (str->getPos() < 0)\n  {\n    error(errSyntaxError, -1, \"Document base stream is not seekable\");\n    return false;\n  }\n  str->reset();\n  checkHeader();\n  bool wasReconstructed = false;\n  xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed);\n  if (!xref->isOk()) {\n    if (wasReconstructed) {\n      delete xref;\n      startXRefPos = -1;\n      xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed);\n    }\n    if (!xref->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read xref table\");\n      errCode = xref->getErrorCode();\n      return false;\n    }\n  }\n  if (!checkEncryption(ownerPassword, userPassword)) {\n    errCode = errEncrypted;\n    return false;\n  }\n  catalog = new Catalog(this);\n  if (catalog && !catalog->isOk()) {\n    if (!wasReconstructed)\n    {\n      delete catalog;\n      delete xref;\n      xref = new XRef(str, 0, 0, nullptr, true);\n      catalog = new Catalog(this);\n    }\n    if (catalog && !catalog->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read page catalog\");\n      errCode = errBadCatalog;\n      return false;\n    }\n  }\n  extractPDFSubtype();\n  return xref->isOk();\n}", "target": 1}
{"code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!message_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t\tmessage = NULL;\n\t}\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "display_debug_links (struct dwarf_section *  section,\n\t\t     void *                  file ATTRIBUTE_UNUSED)\n{\n  const unsigned char * filename;\n  unsigned int          filelen;\n  introduce (section, false);\n  filename =  section->start;\n  filelen = strnlen ((const char *) filename, section->size);\n  if (filelen == section->size)\n    {\n      warn (_(\"The debuglink filename is corrupt/missing\\n\"));\n      return 0;\n    }\n  printf (_(\"  Separate debug info file: %s\\n\"), filename);\n  if (startswith (section->name, \".gnu_debuglink\"))\n    {\n      unsigned int          crc32;\n      unsigned int          crc_offset;\n      crc_offset = filelen + 1;\n      crc_offset = (crc_offset + 3) & ~3;\n      if (crc_offset + 4 > section->size)\n\t{\n\t  warn (_(\"CRC offset missing/truncated\\n\"));\n\t  return 0;\n\t}\n      crc32 = byte_get (filename + crc_offset, 4);\n      printf (_(\"  CRC value: %#x\\n\"), crc32);\n      if (crc_offset + 4 < section->size)\n\t{\n\t  warn (_(\"There are %#lx extraneous bytes at the end of the section\\n\"),\n\t\t(long)(section->size - (crc_offset + 4)));\n\t  return 0;\n\t}\n    }\n  else \n    {\n      const unsigned char * build_id = section->start + filelen + 1;\n      bfd_size_type         build_id_len = section->size - (filelen + 1);\n      bfd_size_type         printed;\n      if (build_id_len < 0x14)\n\t{\n\t  warn (_(\"Build-ID is too short (%#lx bytes)\\n\"), (long) build_id_len);\n\t  return 0;\n\t}\n      printed = printf (_(\"  Build-ID (%#lx bytes):\"), (long) build_id_len);\n      display_data (printed, build_id, build_id_len);\n      putchar ('\\n');\n    }\n  putchar ('\\n');\n  return 1;\n}", "target": 0}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "int kill_pid_info_as_uid(int sig, struct siginfo *info, struct pid *pid,\n\t\t      uid_t uid, uid_t euid, u32 secid)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tconst struct cred *pcred;\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\tread_lock(&tasklist_lock);\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tpcred = __task_cred(p);\n\tif ((info == SEND_SIG_NOINFO ||\n\t     (!is_si_special(info) && SI_FROMUSER(info))) &&\n\t    euid != pcred->suid && euid != pcred->uid &&\n\t    uid  != pcred->suid && uid  != pcred->uid) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, secid);\n\tif (ret)\n\t\tgoto out_unlock;\n\tif (sig && p->sighand) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tret = __send_signal(sig, info, p, 1, 0);\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\nout_unlock:\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n    conn = data;\n    ogs_assert(conn);\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n    return realsize;\n}", "target": 1}
{"code": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather *tlb;\n\tstruct vm_area_struct *vma = mm->mmap;\n\tunsigned long nr_accounted = 0;\n\tunsigned long end;\n\tarch_exit_mmap(mm);\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb = tlb_gather_mmu(mm, 1);\n\tend = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL);\n\tvm_unacct_memory(nr_accounted);\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, 0);\n\ttlb_finish_mmu(tlb, 0, end);\n\twhile (vma)\n\t\tvma = remove_vma(vma);\n\tBUG_ON(mm->nr_ptes > (FIRST_USER_ADDRESS+PMD_SIZE-1)>>PMD_SHIFT);\n}", "target": 0}
{"code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n        numTiles[i] = (l + size - 1) / size;\n    }\n}", "target": 1}
{"code": "static void can_can_gw_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct cgw_job *gwj = (struct cgw_job *)data;\n\tstruct can_frame *cf;\n\tstruct sk_buff *nskb;\n\tint modidx = 0;\n#define cgw_hops(skb) ((skb)->csum_start)\n\tBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\n\tif (cgw_hops(skb) >= max_hops) {\n\t\tgwj->deleted_frames++;\n\t\treturn;\n\t}\n\tif (!(gwj->dst.dev->flags & IFF_UP)) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\tif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\n\t    can_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\n\t\treturn;\n\tif (gwj->mod.modfunc[0])\n\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\tcgw_hops(nskb) = cgw_hops(skb) + 1;\n\tif (gwj->limit_hops && cgw_hops(nskb) == 1)\n\t\tcgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\n\tnskb->dev = gwj->dst.dev;\n\tcf = (struct can_frame *)nskb->data;\n\twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n\t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n\tif (modidx) {\n\t\tif (gwj->mod.csumfunc.crc8)\n\t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n\t\tif (gwj->mod.csumfunc.xor)\n\t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n\t}\n\tif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\n\t\tnskb->tstamp = 0;\n\tif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\n\t\tgwj->dropped_frames++;\n\telse\n\t\tgwj->handled_frames++;\n}", "target": 1}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 1}
{"code": "    size_t PentaxDngMnHeader::write(IoWrapper& ioWrapper,\n                                   ByteOrder ) const\n    {\n        ioWrapper.write(signature_, sizeOfSignature());\n        return sizeOfSignature();\n    } ", "target": 0}
{"code": "static inline s16 fixp_mult(s16 a, s16 b)\n{\n\ta = ((s32)a * 0x100) / 0x7fff;\n\treturn ((s32)(a * b)) >> FRAC_N;\n}", "target": 0}
{"code": "static int selinux_key_permission(key_ref_t key_ref,\n\t\t\t\t  const struct cred *cred,\n\t\t\t\t  unsigned perm)\n{\n\tstruct key *key;\n\tstruct key_security_struct *ksec;\n\tu32 sid;\n\tif (perm == 0)\n\t\treturn 0;\n\tsid = cred_sid(cred);\n\tkey = key_ref_to_ptr(key_ref);\n\tksec = key->security;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sid, ksec->sid, SECCLASS_KEY, perm, NULL);\n}", "target": 0}
{"code": "static int rx_flow_is_on(struct caifsock *cf_sk)\n{\n\treturn test_bit(RX_FLOW_ON_BIT,\n\t\t\t(void *) &cf_sk->flow_state);\n}", "target": 0}
{"code": "status_t SampleTable::setSampleToChunkParams(\n off64_t data_offset, size_t data_size) {\n if (mSampleToChunkOffset >= 0) {\n return ERROR_MALFORMED;\n }\n    mSampleToChunkOffset = data_offset;\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n         return ERROR_MALFORMED;\n     }\n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n uint8_t buffer[12];\n if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n != (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n        CHECK(U32_AT(buffer) >= 1); \n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n }\n return OK;\n}", "target": 1}
{"code": "void freeClient(redisClient *c) {\n    listNode *ln;\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.vm_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.vm_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        server.replstate = REDIS_REPL_CONNECT;\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}", "target": 1}
{"code": "free_indexed(fz_context *ctx, fz_colorspace *cs)\n{\n\tstruct indexed *idx = cs->data;\n\tfz_drop_colorspace(ctx, idx->base);\n\tfz_free(ctx, idx->lookup);\n\tfz_free(ctx, idx);\n}", "target": 0}
{"code": "void connection_graceful_shutdown_maint (server *srv) {\n    connections * const conns = &srv->conns;\n    const int graceful_expire =\n      (srv->graceful_expire_ts && srv->graceful_expire_ts < log_epoch_secs);\n    for (uint32_t ndx = 0; ndx < conns->used; ++ndx) {\n        connection * const con = conns->ptr[ndx];\n        int changed = 0;\n        request_st * const r = &con->request;\n        if (r->state == CON_STATE_CLOSE) {\n            if (HTTP_LINGER_TIMEOUT > 1)\n                con->close_timeout_ts -= (HTTP_LINGER_TIMEOUT - 1);\n            if (log_epoch_secs - con->close_timeout_ts > HTTP_LINGER_TIMEOUT)\n                changed = 1;\n        }\n        else if (con->h2 && r->state == CON_STATE_WRITE) {\n            h2_send_goaway(con, H2_E_NO_ERROR);\n            if (0 == con->h2->rused && chunkqueue_is_empty(con->write_queue)) {\n                connection_set_state(r, CON_STATE_RESPONSE_END);\n                changed = 1;\n            }\n        }\n        else if (r->state == CON_STATE_READ && con->request_count > 1\n                 && chunkqueue_is_empty(con->read_queue)) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        if (graceful_expire) {\n            connection_set_state_error(r, CON_STATE_ERROR);\n            changed = 1;\n        }\n        r->keep_alive = 0;            \n        r->conf.bytes_per_second = 0;         \n        r->conf.global_bytes_per_second = 0;  \n        if (con->traffic_limit_reached) {\n            con->traffic_limit_reached = 0;\n            changed = 1;\n        }\n        if (changed) {\n            connection_state_machine(con);\n        }\n    }\n}", "target": 0}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}", "target": 0}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    HttpIo::HttpImpl::HttpImpl(const std::string& url, size_t blockSize)\n        : Impl(url, blockSize)\n        , hostInfo_(Exiv2::Uri::Parse(url))\n    {\n        Exiv2::Uri::Decode(hostInfo_);\n    }", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "static ssize_t tx_maxrate_store(struct netdev_queue *queue,\n\t\t\t\tconst char *buf, size_t len)\n{\n\tstruct net_device *dev = queue->dev;\n\tint err, index = get_netdev_queue_index(queue);\n\tu32 rate = 0;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\terr = kstrtou32(buf, 10, &rate);\n\tif (err < 0)\n\t\treturn err;\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\terr = -EOPNOTSUPP;\n\tif (dev->netdev_ops->ndo_set_tx_maxrate)\n\t\terr = dev->netdev_ops->ndo_set_tx_maxrate(dev, index, rate);\n\trtnl_unlock();\n\tif (!err) {\n\t\tqueue->tx_maxrate = rate;\n\t\treturn len;\n\t}\n\treturn err;", "target": 0}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int tcp_parse_aligned_timestamp(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tconst __be32 *ptr = (const __be32 *)(th + 1);\n\tif (*ptr == htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\n\t\t\t  | (TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP)) {\n\t\ttp->rx_opt.saw_tstamp = 1;\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsval = ntohl(*ptr);\n\t\t++ptr;\n\t\ttp->rx_opt.rcv_tsecr = ntohl(*ptr);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"Cannot lstat '\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"'\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}", "target": 1}
{"code": "yang_read_deviate_units(struct ly_ctx *ctx, struct lys_deviate *deviate, struct lys_node *dev_target)\n{\n    const char **stritem;\n    int j;\n    if (dev_target->nodetype == LYS_LEAFLIST) {\n        stritem = &((struct lys_node_leaflist *)dev_target)->units;\n    } else if (dev_target->nodetype == LYS_LEAF) {\n        stritem = &((struct lys_node_leaf *)dev_target)->units;\n    } else {\n        LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Target node does not allow \\\"units\\\" property.\");\n        goto error;\n    }\n    if (deviate->mod == LY_DEVIATE_DEL) {\n        if (!ly_strequal(*stritem, deviate->units, 1)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, deviate->units, \"units\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n            goto error;\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = NULL;\n        j = -1;\n        while ((j = lys_ext_iter(dev_target->ext, dev_target->ext_size, j + 1, LYEXT_SUBSTMT_UNITS)) != -1) {\n            lyp_ext_instance_rm(ctx, &dev_target->ext, &dev_target->ext_size, j);\n            --j;\n        }\n    } else {\n        if (deviate->mod == LY_DEVIATE_ADD) {\n            if (*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Adding property that already exists.\");\n                goto error;\n            }\n        } else { \n            if (!*stritem) {\n                LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"units\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Replacing a property that does not exist.\");\n                goto error;\n            }\n        }\n        lydict_remove(ctx, *stritem);\n        *stritem = lydict_insert(ctx, deviate->units, 0);\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\tmutex_lock(&econet_mutex);\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\tmutex_unlock(&econet_mutex);\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}", "target": 1}
{"code": " void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "static void llcp_sock_destruct(struct sock *sk)\n{\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tpr_debug(\"%p\\n\", sk);\n\tif (sk->sk_state == LLCP_CONNECTED)\n\t\tnfc_put_device(llcp_sock->dev);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tnfc_llcp_sock_free(llcp_sock);\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Freeing alive NFC LLCP socket %p\\n\", sk);\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx)\n\t\teventfd_ctx_put(v->config_ctx);\n}", "target": 1}
{"code": "unsigned get_next_char(ASS_Renderer *render_priv, char **str)\n{\n    char *p = *str;\n    unsigned chr;\n    if (*p == '\\t') {\n        ++p;\n        *str = p;\n        return ' ';\n    }\n    if (*p == '\\\\') {\n        if ((p[1] == 'N') || ((p[1] == 'n') &&\n                              (render_priv->state.wrap_style == 2))) {\n            p += 2;\n            *str = p;\n            return '\\n';\n        } else if (p[1] == 'n') {\n            p += 2;\n            *str = p;\n            return ' ';\n        } else if (p[1] == 'h') {\n            p += 2;\n            *str = p;\n            return NBSP;\n        } else if (p[1] == '{') {\n            p += 2;\n            *str = p;\n            return '{';\n        } else if (p[1] == '}') {\n            p += 2;\n            *str = p;\n            return '}';\n        }\n    }\n    chr = ass_utf8_get_char((char **) &p);\n    *str = p;\n    return chr;\n}", "target": 0}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tu--;\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "PassRefPtr<HTMLButtonElement> HTMLButtonElement::create(Document& document, HTMLFormElement* form)\n{\n    return adoptRef(new HTMLButtonElement(document, form));\n}", "target": 0}
{"code": "static int vhost_vdpa_map(struct vhost_vdpa *v, u64 iova,\n\t\t\t  u64 size, u64 pa, u32 perm, void *opaque)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tint r = 0;\n\tr = vhost_iotlb_add_range_ctx(dev->iotlb, iova, iova + size - 1,\n\t\t\t\t      pa, perm, opaque);\n\tif (r)\n\t\treturn r;\n\tif (ops->dma_map) {\n\t\tr = ops->dma_map(vdpa, iova, size, pa, perm, opaque);\n\t} else if (ops->set_map) {\n\t\tif (!v->in_batch)\n\t\t\tr = ops->set_map(vdpa, dev->iotlb);\n\t} else {\n\t\tr = iommu_map(v->domain, iova, pa, size,\n\t\t\t      perm_to_iommu_flags(perm));\n\t}\n\tif (r) {\n\t\tvhost_iotlb_del_range(dev->iotlb, iova, iova + size - 1);\n\t\treturn r;\n\t}\n\tif (!vdpa->use_va)\n\t\tatomic64_add(PFN_DOWN(size), &dev->mm->pinned_vm);\n\treturn 0;\n}", "target": 0}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "void key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}", "target": 0}
{"code": "cdf_read_user_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    const cdf_dir_t *dir, const char *name, cdf_stream_t *scn)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\tsize_t name_len = strlen(name) + 1;\n\tfor (i = dir->dir_len; i > 0; i--)\n\t\tif (dir->dir_tab[i - 1].d_type == CDF_DIR_TYPE_USER_STREAM &&\n\t\t    cdf_namecmp(name, dir->dir_tab[i - 1].d_name, name_len)\n\t\t    == 0)\n\t\t\tbreak;\n\tif (i == 0) {\n\t\tDPRINTF((\"Cannot find user stream `%s'\\n\", name));\n\t\terrno = ESRCH;\n\t\treturn -1;\n\t}\n\td = &dir->dir_tab[i - 1];\n\treturn cdf_read_sector_chain(info, h, sat, ssat, sst,\n\t    d->d_stream_first_sector, d->d_size, scn);\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "void gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}", "target": 0}
{"code": "static unsigned long get_trampoline_vaddr(void)\n{\n\tstruct xol_area *area;\n\tunsigned long trampoline_vaddr = -1;\n\tarea = current->mm->uprobes_state.xol_area;\n\tsmp_read_barrier_depends();\n\tif (area)\n\t\ttrampoline_vaddr = area->vaddr;\n\treturn trampoline_vaddr;\n}", "target": 0}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "void SyncManager::SyncInternal::ShutdownOnSyncThread() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  weak_ptr_factory_.InvalidateWeakPtrs();\n  js_mutation_event_observer_.InvalidateWeakPtrs();\n  scheduler_.reset();\n  SetJsEventHandler(WeakHandle<JsEventHandler>());\n  RemoveObserver(&js_sync_manager_observer_);\n  RemoveObserver(&debug_info_event_listener_);\n  if (sync_notifier_.get()) {\n    sync_notifier_->RemoveObserver(this);\n  }\n  sync_notifier_.reset();\n  if (connection_manager_.get()) {\n    connection_manager_->RemoveListener(this);\n  }\n  connection_manager_.reset();\n  net::NetworkChangeNotifier::RemoveIPAddressObserver(this);\n  observing_ip_address_changes_ = false;\n  if (initialized_ && dir_manager()) {\n    {\n      ReadTransaction trans(FROM_HERE, GetUserShare());\n      trans.GetCryptographer()->RemoveObserver(this);\n    }\n    dir_manager()->FinalSaveChangesForAll();\n    dir_manager()->Close(username_for_share());\n  }\n  share_.dir_manager.reset();\n  setup_for_test_mode_ = false;\n  change_delegate_ = NULL;\n  registrar_ = NULL;\n  initialized_ = false;\n  change_observer_.Reset();\n  weak_handle_this_.Reset();\n}", "target": 0}
{"code": "static int verify_ee(const gnutls_datum_t *raw_crt, gnutls_certificate_type_t crt_type,\n\t\t dane_cert_type_t ctype, dane_match_type_t match, gnutls_datum_t * data,\n\t\t unsigned int *verify)\n{\ngnutls_datum_t pubkey = {NULL, 0};\nint ret;\n\tif (ctype == DANE_CERT_X509 && crt_type == GNUTLS_CRT_X509) {\n\t\tif (!matches(raw_crt, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else if (ctype == DANE_CERT_PK && crt_type == GNUTLS_CRT_X509) {\n\t\tret = crt_to_pubkey(raw_crt, &pubkey);\n\t\tif (ret < 0) {\n        \t        gnutls_assert();\n\t\t\tgoto cleanup;\n                }\n\t\tif (!matches(&pubkey, data, match)) {\n\t\t        gnutls_assert();\n\t\t\t*verify |= DANE_VERIFY_CERT_DIFFERS;\n                }\n\t} else {\n\t\tret = gnutls_assert_val(DANE_E_UNKNOWN_DANE_DATA);\n\t\tgoto cleanup;\n\t}\n\tret = 0;\ncleanup:\n\tfree(pubkey.data);\n\treturn ret;\n}", "target": 0}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n    currentBuffer.length = len;\n    wcb_->setSocket(socket_);\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }", "target": 1}
{"code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n    return has_optional || !has_any_optional;\n}", "target": 1}
{"code": "static int may_delete(struct inode *dir,struct dentry *victim,int isdir)\n{\n\tint error;\n\tif (!victim->d_inode)\n\t\treturn -ENOENT;\n\tBUG_ON(victim->d_parent->d_inode != dir);\n\taudit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);\n\terror = inode_permission(dir, MAY_WRITE | MAY_EXEC);\n\tif (error)\n\t\treturn error;\n\tif (IS_APPEND(dir))\n\t\treturn -EPERM;\n\tif (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||\n\t    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))\n\t\treturn -EPERM;\n\tif (isdir) {\n\t\tif (!S_ISDIR(victim->d_inode->i_mode))\n\t\t\treturn -ENOTDIR;\n\t\tif (IS_ROOT(victim))\n\t\t\treturn -EBUSY;\n\t} else if (S_ISDIR(victim->d_inode->i_mode))\n\t\treturn -EISDIR;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\tif (victim->d_flags & DCACHE_NFSFS_RENAMED)\n\t\treturn -EBUSY;\n\treturn 0;\n}", "target": 0}
{"code": "static int vhost_worker(void *data)\n{\n\tstruct vhost_dev *dev = data;\n\tstruct vhost_work *work = NULL;\n\tunsigned uninitialized_var(seq);\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(USER_DS);\n\tuse_mm(dev->mm);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\twork->done_seq = seq;\n\t\t\tif (work->flushing)\n\t\t\t\twake_up_all(&work->done);\n\t\t}\n\t\tif (kthread_should_stop()) {\n\t\t\tspin_unlock_irq(&dev->work_lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tif (!list_empty(&dev->work_list)) {\n\t\t\twork = list_first_entry(&dev->work_list,\n\t\t\t\t\t\tstruct vhost_work, node);\n\t\t\tlist_del_init(&work->node);\n\t\t\tseq = work->queue_seq;\n\t\t} else\n\t\t\twork = NULL;\n\t\tspin_unlock_irq(&dev->work_lock);\n\t\tif (work) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\twork->fn(work);\n\t\t\tif (need_resched())\n\t\t\t\tschedule();\n\t\t} else\n\t\t\tschedule();\n\t}\n\tunuse_mm(dev->mm);\n\tset_fs(oldfs);\n\treturn 0;\n}", "target": 0}
{"code": "unsigned int get_random_int(void)\n{\n\treturn secure_ip_id((__force __be32)(current->pid + jiffies));\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "DocumentLoader* FrameLoader::activeDocumentLoader() const\n{\n    if (m_state == FrameStateProvisional)\n        return m_provisionalDocumentLoader.get();\n    return m_documentLoader.get();\n}", "target": 0}
{"code": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\nout:\n\tkfree(ctx);\n}", "target": 1}
{"code": "pipe_setup (Pipe *pipe, FILE *logf, gpointer user_data)\n{\n\tGIOFlags flags = 0;\n\tpipe->logf = logf;\n\tpipe->buf = g_string_sized_new (512);\n\tpipe->channel = g_io_channel_unix_new (pipe->fd);\n\tg_io_channel_set_encoding (pipe->channel, NULL, NULL);\n\tflags = g_io_channel_get_flags (pipe->channel);\n\tg_io_channel_set_flags (pipe->channel, flags | G_IO_FLAG_NONBLOCK, NULL);\n\tg_io_channel_set_buffered (pipe->channel, FALSE);\n\tpipe->watch = g_io_add_watch (pipe->channel,\n\t                              G_IO_IN | G_IO_ERR | G_IO_PRI,\n\t                              data_available,\n\t                              user_data);\n}", "target": 0}
{"code": "generate_spc_link(cms_context *cms, SpcLink *slp, SpcLinkType link_type,\n\t\tvoid *link_data, size_t link_data_size)\n{\n\tSpcLink sl;\n\tmemset(&sl, '\\0', sizeof (sl));\n\tsl.type = link_type;\n\tswitch (sl.type) {\n\tcase SpcLinkTypeFile: {\n\t\tint rc = generate_spc_string(cms, &sl.file, link_data,\n\t\t\t\t\tlink_data_size);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tbreak;\n\t}\n\tcase SpcLinkTypeUrl:\n\t\tsl.url.type = siBuffer;\n\t\tsl.url.data = link_data;\n\t\tsl.url.len = link_data_size;\n\t\tbreak;\n\tdefault:\n\t\tcms->log(cms, LOG_ERR, \"Invalid SpcLinkType\");\n\t\treturn -1;\n\t};\n\tmemcpy(slp, &sl, sizeof (sl));\n\treturn 0;\n}", "target": 0}
{"code": "void rdma_unlock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_unlock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "fz_rendering_intent_name(int ri)\n{\n\tif (ri >= 0 && ri < nelem(fz_intent_names))\n\t\treturn (char*)fz_intent_names[ri];\n\treturn \"RelativeColorimetric\";\n}", "target": 0}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "manuf_name_lookup(const guint8 *addr)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n    return manuf_hash_new_entry(addr, NULL, NULL);\n} ", "target": 1}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "void RGWListMultipart_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\", CHUNKED_TRANSFER_ENCODING);\n  if (op_ret == 0) {\n    dump_start(s);\n    s->formatter->open_object_section_in_ns(\"ListPartsResult\", XMLNS_AWS_S3);\n    map<uint32_t, RGWUploadPartInfo>::iterator iter;\n    map<uint32_t, RGWUploadPartInfo>::reverse_iterator test_iter;\n    int cur_max = 0;\n    iter = parts.begin();\n    test_iter = parts.rbegin();\n    if (test_iter != parts.rend()) {\n      cur_max = test_iter->first;\n    }\n    if (!s->bucket_tenant.empty())\n      s->formatter->dump_string(\"Tenant\", s->bucket_tenant);\n    s->formatter->dump_string(\"Bucket\", s->bucket_name);\n    s->formatter->dump_string(\"Key\", s->object.name);\n    s->formatter->dump_string(\"UploadId\", upload_id);\n    s->formatter->dump_string(\"StorageClass\", \"STANDARD\");\n    s->formatter->dump_int(\"PartNumberMarker\", marker);\n    s->formatter->dump_int(\"NextPartNumberMarker\", cur_max);\n    s->formatter->dump_int(\"MaxParts\", max_parts);\n    s->formatter->dump_string(\"IsTruncated\", (truncated ? \"true\" : \"false\"));\n    ACLOwner& owner = policy.get_owner();\n    dump_owner(s, owner.get_id(), owner.get_display_name());\n    for (; iter != parts.end(); ++iter) {\n      RGWUploadPartInfo& info = iter->second;\n      s->formatter->open_object_section(\"Part\");\n      dump_time(s, \"LastModified\", &info.modified);\n      s->formatter->dump_unsigned(\"PartNumber\", info.num);\n      s->formatter->dump_format(\"ETag\", \"\\\"%s\\\"\", info.etag.c_str());\n      s->formatter->dump_unsigned(\"Size\", info.accounted_size);\n      s->formatter->close_section();\n    }\n    s->formatter->close_section();\n    rgw_flush_formatter_and_reset(s, s->formatter);\n  }\n}", "target": 0}
{"code": "unsigned long ossl_lh_strcasehash(const char *c)\n{\n    unsigned long ret = 0;\n    long n;\n    unsigned long v;\n    int r;\n    if (c == NULL || *c == '\\0')\n        return ret;\n    for (n = 0x100; *c != '\\0'; n += 0x100) {\n        v = n | ossl_tolower(*c);\n        r = (int)((v >> 2) ^ v) & 0x0f;\n        ret = (ret << r) | (unsigned long)((uint64_t)ret >> (32 - r));\n        ret &= 0xFFFFFFFFL;\n        ret ^= v * v;\n        c++;\n    }\n    return (ret >> 16) ^ ret;\n}", "target": 0}
{"code": "cql_server::unadvertise_connection(shared_ptr<generic_server::connection> raw_conn) {\n    --_stats.connections;\n    if (auto conn = dynamic_pointer_cast<connection>(raw_conn)) {\n        const auto ip = conn->get_client_state().get_client_address().addr();\n        const auto port = conn->get_client_state().get_client_port();\n        clogger.trace(\"Advertising disconnection of CQL client {}:{}\", ip, port);\n    }\n    return make_ready_future<>();\n}", "target": 0}
{"code": "seamless_line_handler(const char *line, void *data)\n{\n\tif (!seamless_process_line(line, data))\n\t{\n\t\twarning(\"SeamlessRDP: Invalid request:%s\\n\", line);\n\t}\n\treturn True;\n}", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "MATCHER_P(RepeatedProtoEq, expected, \"\") {\n  const bool equal = TestUtility::repeatedPtrFieldEqual(arg, expected);\n  if (!equal) {\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected repeated:\") << \"\\n\"\n                     << RepeatedPtrUtil::debugString(expected) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"is not equal to actual repeated:\")\n                     << \"\\n\"\n                     << RepeatedPtrUtil::debugString(arg) << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return NULL;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 0}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "  int libraw_adjust_sizes_info_only(libraw_data_t *lr)\n  {\n    if (!lr)\n      return EINVAL;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    return ip->adjust_sizes_info_only();\n  }", "target": 0}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "void HeaderToMetadataFilter::setDecoderFilterCallbacks(\n    Http::StreamDecoderFilterCallbacks& callbacks) {\n  decoder_callbacks_ = &callbacks;\n}", "target": 0}
{"code": "trad_enc_update_keys(struct trad_enc_ctx *ctx, uint8_t c)\n{\n\tuint8_t t;\n#define CRC32(c, b) (crc32(c ^ 0xffffffffUL, &b, 1) ^ 0xffffffffUL)\n\tctx->keys[0] = CRC32(ctx->keys[0], c);\n\tctx->keys[1] = (ctx->keys[1] + (ctx->keys[0] & 0xff)) * 134775813L + 1;\n\tt = (ctx->keys[1] >> 24) & 0xff;\n\tctx->keys[2] = CRC32(ctx->keys[2], t);\n#undef CRC32\n}", "target": 0}
{"code": "date_s_rfc2822(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"Mon, 1 Jan -4712 00:00:00 +0000\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__rfc2822(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,\n  const QuantumAny range)\n{\n  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));\n}", "target": 1}
{"code": "gb18030_code_to_mbclen(OnigCodePoint code)\n{\n       if ((code & 0xff000000) != 0) return 4;\n  else if ((code &   0xff0000) != 0) return ONIGERR_INVALID_CODE_POINT_VALUE;\n  else if ((code &     0xff00) != 0) return 2;\n  else {\n    if (GB18030_MAP[(int )(code & 0xff)] == CM)\n      return ONIGERR_INVALID_CODE_POINT_VALUE;\n    return 1;\n  }\n}", "target": 0}
{"code": "static int ext4_commit_super(struct super_block *sb, int sync)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\tif (!sbh || block_device_ejected(sb))\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\text4_free_blocks_count_set(es,\n\t\t\tEXT4_C2B(EXT4_SB(sb), percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeclusters_counter)));\n\tes->s_free_inodes_count =\n\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tsb->s_dirt = 0;\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\text4_superblock_csum_set(sb, es);\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "_polkit_subject_get_cmdline (PolkitSubject *subject, gint *pid, gint *uid)\n{\n  PolkitSubject *process;\n  gchar *ret;\n  gchar *filename;\n  gchar *contents;\n  gsize contents_len;\n  GError *error;\n  guint n;\n  g_return_val_if_fail (subject != NULL, NULL);\n  error = NULL;\n  ret = NULL;\n  process = NULL;\n  filename = NULL;\n  contents = NULL;\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n   {\n      process = g_object_ref (subject);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject),\n                                                         NULL,\n                                                         &error);\n      if (process == NULL)\n        {\n          g_warning (\"Error getting process for system bus name `%s': %s\",\n                     polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (subject)),\n                     error->message);\n          g_error_free (error);\n          goto out;\n        }\n    }\n  else\n    {\n      g_warning (\"Unknown subject type passed to guess_program_name()\");\n      goto out;\n    }\n  *pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (process));\n  *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  filename = g_strdup_printf (\"/proc/%d/cmdline\", *pid);\n  if (!g_file_get_contents (filename,\n                            &contents,\n                            &contents_len,\n                            &error))\n    {\n      g_warning (\"Error openeing `%s': %s\",\n                 filename,\n                 error->message);\n      g_error_free (error);\n      goto out;\n    }\n  for (n = 0; n < contents_len - 1; n++)\n    {\n      if (contents[n] == '\\0')\n        contents[n] = ' ';\n    }\n  ret = g_strdup (contents);\n  g_strstrip (ret);\n out:\n  g_free (filename);\n  g_free (contents);\n  if (process != NULL)\n    g_object_unref (process);\n  return ret;\n}", "target": 0}
{"code": "static struct dst_entry *ip6_route_input_lookup(struct net *net,\n\t\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\t\tstruct flowi6 *fl6, int flags)\n{\n\tif (rt6_need_strict(&fl6->daddr) && dev->type != ARPHRD_PIMREG)\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\treturn fib6_rule_lookup(net, fl6, flags, ip6_pol_route_input);\n}", "target": 0}
{"code": "grub_username_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  grub_printf (\"\\b\");\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\t{\n\t  buf[cur_len++] = key;\n\t  grub_printf (\"%c\", key);\n\t}\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tint len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\tif (name[len] != '\\\\')\n\t\t\t\treturn 0;\n\t\t\tname += len + 1;\n\t\t\tlen = -1;\n\t\t}\n}", "target": 1}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "static int wait_phy_eeprom_ready(struct usbnet *dev, int phy)\n{\n\tint i;\n\tfor (i = 0; i < SR_SHARE_TIMEOUT; i++) {\n\t\tu8 tmp = 0;\n\t\tint ret;\n\t\tudelay(1);\n\t\tret = sr_read_reg(dev, SR_EPCR, &tmp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(tmp & EPCR_ERRE))\n\t\t\treturn 0;\n\t}\n\tnetdev_err(dev->net, \"%s write timed out!\\n\", phy ? \"phy\" : \"eeprom\");\n\treturn -EIO;\n}", "target": 0}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_mknod(void *opaque)\n{\n    int mode;\n    gid_t gid;\n    int32_t fid;\n    V9fsQID qid;\n    int err = 0;\n    int major, minor;\n    size_t offset = 7;\n    V9fsString name;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdddd\", &fid, &name, &mode,\n                        &major, &minor, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mknod(pdu->tag, pdu->id, fid, mode, major, minor);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mknod(pdu, fidp, &name, fidp->uid, gid,\n                        makedev(major, minor), mode, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mknod_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 0}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 1}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "static int adpt_close(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void _ewk_view_smart_changed(Ewk_View_Smart_Data* smartData)\n{\n    if (smartData->changed.any)\n        return;\n    smartData->changed.any = true;\n    evas_object_smart_changed(smartData->self);\n}", "target": 0}
{"code": "put16(unsigned char *cp, unsigned short x)\n{\n\t*cp++ = x >> 8;\n\t*cp++ = x;\n\treturn cp;\n}", "target": 0}
{"code": "static void r_coresym_cache_element_line_info_fini(RCoreSymCacheElementLineInfo *line) {\n\tif (line) {\n\t\tr_coresym_cache_element_flc_fini (&line->flc);\n\t}\n}", "target": 0}
{"code": "static int bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n    uint8_t status, uint8_t ep, void *free_on_destroy)\n{\n    struct buf_packet *bufp;\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n        dev->endpoint[EP2I(ep)].bufpq_size >\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n    }\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n            free(data);\n            return -1;\n        }\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n    bufp = g_new(struct buf_packet, 1);\n    bufp->data   = data;\n    bufp->len    = len;\n    bufp->offset = 0;\n    bufp->status = status;\n    bufp->free_on_destroy = free_on_destroy;\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n    return 0;\n}", "target": 1}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "compile_lock_unlock(\n    lval_T  *lvp,\n    char_u  *name_end,\n    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\t    if (*end != '.' && *end != '[')\n\t    {\n\t\temsg(_(e_cannot_lock_unlock_local_variable));\n\t\treturn FAIL;\n\t    }\n\t    if (compile_load(&s, end, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    isn = ISN_LOCKUNLOCK;\n\t}\n    }\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;\n}", "target": 1}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static krb5_error_code hdb_samba4_lock(krb5_context context, HDB *db, int operation)\n{\n\treturn 0;\n}", "target": 0}
{"code": "Goffset JPXStream::getPos() {\n  return priv->counter * priv->ncomps + priv->ccounter;\n}", "target": 0}
{"code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}", "target": 1}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "read_line (FILE         *fp,\n           guchar       *row,\n           guchar       *buf,\n           tga_info     *info,\n           gint          bpp,\n           const guchar *convert_cmap)\n{\n  if (info->imageCompression == TGA_COMP_RLE)\n    {\n      rle_read (fp, buf, info);\n    }\n  else\n    {\n      fread (buf, info->bytes, info->width, fp);\n    }\n  if (info->flipHoriz)\n    {\n      flip_line (buf, info);\n    }\n  if (info->imageType == TGA_TYPE_COLOR)\n    {\n      if (info->bpp == 16 || info->bpp == 15)\n        {\n          upsample (row, buf, info->width, info->bytes, info->alphaBits);\n        }\n      else\n        {\n          bgr2rgb (row, buf, info->width, info->bytes, info->alphaBits);\n        }\n    }\n  else if (convert_cmap)\n    {\n      gboolean has_alpha = (info->alphaBits > 0);\n      apply_colormap (row, buf, info->width, convert_cmap, has_alpha,\n                      info->colorMapIndex);\n    }\n  else if (info->imageType == TGA_TYPE_MAPPED)\n    {\n      g_assert(bpp == 1);\n      apply_index (row, buf, info->width, info->colorMapIndex);\n    }\n  else\n    {\n      memcpy (row, buf, info->width * bpp);\n    }\n}", "target": 0}
{"code": "smb3_receive_transform(struct TCP_Server_Info *server,\n\t\t       struct mid_q_entry **mids, char **bufs, int *num_mids)\n{\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = server->pdu_size;\n\tstruct smb2_transform_hdr *tr_hdr = (struct smb2_transform_hdr *)buf;\n\tunsigned int orig_len = le32_to_cpu(tr_hdr->OriginalMessageSize);\n\tif (pdu_length < sizeof(struct smb2_transform_hdr) +\n\t\t\t\t\t\tsizeof(struct smb2_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is too small (%u)\\n\",\n\t\t\t pdu_length);\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length < orig_len + sizeof(struct smb2_transform_hdr)) {\n\t\tcifs_server_dbg(VFS, \"Transform message is broken\\n\");\n\t\tcifs_reconnect(server, true);\n\t\treturn -ECONNABORTED;\n\t}\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server)) {\n\t\treturn receive_encrypted_read(server, &mids[0], num_mids);\n\t}\n\treturn receive_encrypted_standard(server, mids, bufs, num_mids);\n}", "target": 0}
{"code": "static int connection_handle_write(request_st * const r, connection * const con) {\n\tif (con->is_writable <= 0) return CON_STATE_WRITE;\n\tint rc = connection_write_chunkqueue(con, con->write_queue, MAX_WRITE_LIMIT);\n\tswitch (rc) {\n\tcase 0:\n\t\tif (r->resp_body_finished) {\n\t\t\tconnection_set_state(r, CON_STATE_RESPONSE_END);\n\t\t\treturn CON_STATE_RESPONSE_END;\n\t\t}\n\t\tbreak;\n\tcase -1: \n\t\tlog_error(r->conf.errh, __FILE__, __LINE__,\n\t\t  \"connection closed: write failed on fd %d\", con->fd);\n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase -2: \n\t\tconnection_set_state_error(r, CON_STATE_ERROR);\n\t\treturn CON_STATE_ERROR;\n\tcase 1:\n\t\tif (con->write_queue->bytes_out)\n\t\t\tcon->is_writable = 0;\n\t\tbreak;\n\t}\n\treturn CON_STATE_WRITE; \n}", "target": 0}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "gimp_channel_get_memsize (GimpObject *object,\n                          gint64     *gui_size)\n{\n  GimpChannel *channel = GIMP_CHANNEL (object);\n  *gui_size += channel->num_segs_in  * sizeof (GimpBoundSeg);\n  *gui_size += channel->num_segs_out * sizeof (GimpBoundSeg);\n  return GIMP_OBJECT_CLASS (parent_class)->get_memsize (object, gui_size);\n}", "target": 0}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static int ogm_chapter(AVFormatContext *as, uint8_t *key, uint8_t *val)\n{\n    int i, cnum, h, m, s, ms, keylen = strlen(key);\n    AVChapter *chapter = NULL;\n    if (keylen < 9 || sscanf(key, \"CHAPTER%03d\", &cnum) != 1)\n        return 0;\n    if (keylen <= 10) {\n        if (sscanf(val, \"%02d:%02d:%02d.%03d\", &h, &m, &s, &ms) < 4)\n            return 0;\n        avpriv_new_chapter(as, cnum, (AVRational) { 1, 1000 },\n                           ms + 1000 * (s + 60 * (m + 60 * h)),\n                           AV_NOPTS_VALUE, NULL);\n        av_free(val);\n    } else if (!strcmp(key + keylen - 4, \"NAME\")) {\n        for (i = 0; i < as->nb_chapters; i++)\n            if (as->chapters[i]->id == cnum) {\n                chapter = as->chapters[i];\n                break;\n            }\n        if (!chapter)\n            return 0;\n        av_dict_set(&chapter->metadata, \"title\", val, AV_DICT_DONT_STRDUP_VAL);\n    } else\n        return 0;\n    av_free(key);\n    return 1;\n}", "target": 0}
{"code": "void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)\n{\n    int i;\n    int top = lua_gettop(L);\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) \"Lua Stack Dump: [%s]\", msg);\n    for (i = 1; i <= top; i++) {\n        int t = lua_type(L, i);\n        switch (t) {\n        case LUA_TSTRING:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  '%s'\", i, lua_tostring(L, i));\n                break;\n            }\n        case LUA_TUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  userdata\",\n                              i);\n                break;\n            }\n        case LUA_TLIGHTUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  lightuserdata\", i);\n                break;\n            }\n        case LUA_TNIL:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  NIL\", i);\n                break;\n            }\n        case LUA_TNONE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  None\", i);\n                break;\n            }\n        case LUA_TBOOLEAN:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %s\", i, lua_toboolean(L,\n                                                          i) ? \"true\" :\n                              \"false\");\n                break;\n            }\n        case LUA_TNUMBER:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %g\", i, lua_tonumber(L, i));\n                break;\n            }\n        case LUA_TTABLE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <table>\", i);\n                break;\n            }\n        case LUA_TFUNCTION:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <function>\", i);\n                break;\n            }\n        default:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  unknown: -[%s]-\", i, lua_typename(L, i));\n                break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "_gnutls_ecc_ansi_x963_export (gnutls_ecc_curve_t curve, bigint_t x, bigint_t y,\n                              gnutls_datum_t * out)\n{\n  int numlen = gnutls_ecc_curve_get_size (curve);\n  int byte_size, ret;\n  size_t size;\n  if (numlen == 0)\n    return gnutls_assert_val (GNUTLS_E_INVALID_REQUEST);\n  out->size = 1 + 2 * numlen;\n  out->data = gnutls_malloc (out->size);\n  if (out->data == NULL)\n    return gnutls_assert_val (GNUTLS_E_MEMORY_ERROR);\n  memset (out->data, 0, out->size);\n  out->data[0] = 0x04;\n  byte_size = (_gnutls_mpi_get_nbits (x) + 7) / 8;\n  size = out->size - (1 + (numlen - byte_size));\n  ret = _gnutls_mpi_print (x, &out->data[1 + (numlen - byte_size)], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  byte_size = (_gnutls_mpi_get_nbits (y) + 7) / 8;\n  size = out->size - (1 + (numlen + numlen - byte_size));\n  ret =\n    _gnutls_mpi_print (y, &out->data[1 + numlen + numlen - byte_size], &size);\n  if (ret < 0)\n    return gnutls_assert_val (ret);\n  return 0;\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 0}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": " */\nstatic inline zval *add_next_index_object(zval *arg, zval *tmp)\n{\n\tHashTable *symtable;\n\tif (Z_TYPE_P(arg) == IS_OBJECT) {\n\t\tsymtable = Z_OBJPROP_P(arg);\n\t} else {\n\t\tsymtable = Z_ARRVAL_P(arg);\n\t}\n\treturn zend_hash_next_index_insert(symtable, tmp);", "target": 0}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n      current_entry_.reset(provisional_entry_.release());\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}", "target": 1}
{"code": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}", "target": 1}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\terror = (*nproc)(priv, cookie, call_nests);\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\treturn error;\n}", "target": 0}
{"code": "njs_string_prototype_char_at(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    size_t             length;\n    int64_t            start;\n    njs_int_t          ret;\n    njs_slice_prop_t   slice;\n    njs_string_prop_t  string;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    slice.string_length = njs_string_prop(&string, njs_argument(args, 0));\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    length = 1;\n    if (start < 0 || start >= (int64_t) slice.string_length) {\n        start = 0;\n        length = 0;\n    }\n    slice.start = start;\n    slice.length = length;\n    return njs_string_slice(vm, &vm->retval, &string, &slice);\n}", "target": 0}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static int selinux_netlink_send(struct sock *sk, struct sk_buff *skb)\n{\n\tint err = 0;\n\tu32 perm;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tif (skb->len < NLMSG_HDRLEN) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tnlh = nlmsg_hdr(skb);\n\terr = selinux_nlmsg_lookup(sksec->sclass, nlh->nlmsg_type, &perm);\n\tif (err) {\n\t\tif (err == -EINVAL) {\n\t\t\tpr_warn_ratelimited(\"SELinux: unrecognized netlink\"\n\t\t\t       \" message: protocol=%hu nlmsg_type=%hu sclass=%s\"\n\t\t\t       \" pid=%d comm=%s\\n\",\n\t\t\t       sk->sk_protocol, nlh->nlmsg_type,\n\t\t\t       secclass_map[sksec->sclass - 1].name,\n\t\t\t       task_pid_nr(current), current->comm);\n\t\t\tif (!enforcing_enabled(&selinux_state) ||\n\t\t\t    security_get_allow_unknown(&selinux_state))\n\t\t\t\terr = 0;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\terr = sock_has_perm(sk, perm);\nout:\n\treturn err;\n}", "target": 1}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                     const struct arg *args, struct sample *smp)\n{\n\tCHECK_HTTP_MESSAGE_FIRST_PERM();\n\tsmp->type = SMP_T_BOOL;\n\tsmp->data.uint = 1;\n\treturn 1;\n}", "target": 0}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "TEST(SegmentSumOpModelTest, TestFailIfSegmentsAreNotSorted) {\n  SegmentSumOpModel<int32_t> model({TensorType_INT32, {3, 2}},\n                                   {TensorType_INT32, {3}});\n  model.PopulateTensor<int32_t>(model.data(), {1, 2, 3, 4, 5, 6});\n  model.PopulateTensor<int32_t>(model.segment_ids(), {0, 3, 1});\n  ASSERT_EQ(model.InvokeUnchecked(), kTfLiteError);\n}", "target": 0}
{"code": "static struct tipc_node *tipc_node_find_by_name(struct net *net,\n\t\t\t\t\t\tconst char *link_name,\n\t\t\t\t\t\tunsigned int *bearer_id)\n{\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tstruct tipc_link *l;\n\tstruct tipc_node *n;\n\tstruct tipc_node *found_node = NULL;\n\tint i;\n\t*bearer_id = 0;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_read_lock(n);\n\t\tfor (i = 0; i < MAX_BEARERS; i++) {\n\t\t\tl = n->links[i].link;\n\t\t\tif (l && !strcmp(tipc_link_name(l), link_name)) {\n\t\t\t\t*bearer_id = i;\n\t\t\t\tfound_node = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttipc_node_read_unlock(n);\n\t\tif (found_node)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn found_node;\n}", "target": 0}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "static int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}", "target": 0}
{"code": "void Item_string::print(String *str, enum_query_type query_type)\n{\n  const bool print_introducer=\n    !(query_type & QT_WITHOUT_INTRODUCERS) && is_cs_specified();\n  if (print_introducer)\n  {\n    str->append('_');\n    str->append(collation.collation->csname);\n  }\n  str->append('\\'');\n  if (query_type & QT_TO_SYSTEM_CHARSET)\n  {\n    if (print_introducer)\n    {\n      ErrConvString tmp(str_value.ptr(), str_value.length(), &my_charset_bin);\n      str->append(tmp.ptr());\n    }\n    else\n    {\n      if (my_charset_same(str_value.charset(), system_charset_info))\n        str_value.print(str); \n      else \n      {\n        THD *thd= current_thd;\n        LEX_STRING utf8_lex_str;\n        thd->convert_string(&utf8_lex_str,\n                            system_charset_info,\n                            str_value.c_ptr_safe(),\n                            str_value.length(),\n                            str_value.charset());\n        String utf8_str(utf8_lex_str.str,\n                        utf8_lex_str.length,\n                        system_charset_info);\n        utf8_str.print(str);\n      }\n    }\n  }\n  else\n  {\n    str_value.print(str);\n  }\n  str->append('\\'');\n}", "target": 0}
{"code": "  bool IsBelowFrame(JavaScriptFrame* frame) {\n    return (c_entry_fp_ == 0) || (c_entry_fp_ > frame->sp());\n  }", "target": 0}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "AirPDcapRsnaPwd2PskStep(\n    const guint8 *ppBytes,\n    const guint ppLength,\n    const CHAR *ssid,\n    const size_t ssidLength,\n    const INT iterations,\n    const INT count,\n    UCHAR *output)\n{\n    UCHAR digest[MAX_SSID_LENGTH+4];  \n    UCHAR digest1[SHA1_DIGEST_LEN];\n    INT i, j;\n    if (ssidLength > MAX_SSID_LENGTH) {\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    memset(digest, 0, sizeof digest);\n    memset(digest1, 0, sizeof digest1);\n    memcpy(digest, ssid, ssidLength);\n    digest[ssidLength] = (UCHAR)((count>>24) & 0xff);\n    digest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\n    digest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\n    digest[ssidLength+3] = (UCHAR)(count & 0xff);\n    sha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\n    memcpy(output, digest1, SHA1_DIGEST_LEN);\n    for (i = 1; i < iterations; i++) {\n        sha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\n        memcpy(digest1, digest, SHA1_DIGEST_LEN);\n        for (j = 0; j < SHA1_DIGEST_LEN; j++) {\n            output[j] ^= digest[j];\n        }\n    }\n    return AIRPDCAP_RET_SUCCESS;\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "static int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    FFStream *const sti = ffstream(st);\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n    if (!sti->nb_index_entries)\n        return -1;\n    avio_seek(sc->pb, sti->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "static void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\tif (dev != loopback_dev) {\n\t\tif (idev && idev->dev == dev) {\n\t\t\tstruct inet6_dev *loopback_idev =\n\t\t\t\tin6_dev_get(loopback_dev);\n\t\t\tif (loopback_idev) {\n\t\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t}\n\t\tif (rt->n && rt->n->dev == dev) {\n\t\t\trt->n->dev = loopback_dev;\n\t\t\tdev_hold(loopback_dev);\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "    TestOpaqueResourceDecoderImpl(absl::string_view name_field)\n        : Config::OpaqueResourceDecoderImpl<Current>(ProtobufMessage::getStrictValidationVisitor(),\n                                                     name_field) {}", "target": 0}
{"code": "jpeg_getc (j_decompress_ptr cinfo)\n{\n  struct jpeg_source_mgr *datasrc = cinfo->src;\n  if (datasrc->bytes_in_buffer == 0) {\n    if (! (*datasrc->fill_input_buffer) (cinfo))\n      ERREXIT(cinfo, JERR_CANT_SUSPEND);\n  }\n  datasrc->bytes_in_buffer--;\n  return GETJOCTET(*datasrc->next_input_byte++);\n}", "target": 0}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "void DHT::restore_hots()\n{\n  int iwidth = libraw.imgdata.sizes.iwidth;\n#if defined(LIBRAW_USE_OPENMP)\n#ifdef _MSC_VER\n#pragma omp parallel for firstprivate(iwidth)\n#else\n#pragma omp parallel for schedule(guided) firstprivate(iwidth) collapse(2)\n#endif\n#endif\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    for (int j = 0; j < iwidth; ++j)\n    {\n      int x = j + nr_leftmargin;\n      int y = i + nr_topmargin;\n      if (ndir[nr_offset(y, x)] & HOT)\n      {\n        int l = libraw.COLOR(i, j);\n        nraw[nr_offset(i + nr_topmargin, j + nr_leftmargin)][l] =\n            libraw.imgdata.image[i * iwidth + j][l];\n      }\n    }\n  }\n}", "target": 0}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "bool GLSurfaceOzoneSurfacelessSurfaceImpl::OnMakeCurrent(GLContext* context) {\n  DCHECK(!context_ || context == context_);\n  context_ = context;\n  if (!fbo_) {\n    glGenFramebuffersEXT(1, &fbo_);\n    if (!fbo_)\n      return false;\n    glGenTextures(arraysize(textures_), textures_);\n    if (!CreatePixmaps())\n      return false;\n  }\n  BindFramebuffer();\n  glBindFramebufferEXT(GL_FRAMEBUFFER, fbo_);\n  return SurfacelessEGL::OnMakeCurrent(context);\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "static inline int qdisc_restart(struct net_device *dev)\n{\n\tstruct Qdisc *q = dev->qdisc;\n\tstruct sk_buff *skb;\n\tint ret = NETDEV_TX_BUSY;\n\tif (unlikely((skb = dev_dequeue_skb(dev, q)) == NULL))\n\t\treturn 0;\n\tspin_unlock(&dev->queue_lock);\n\tHARD_TX_LOCK(dev, smp_processor_id());\n\tif (!netif_subqueue_stopped(dev, skb))\n\t\tret = dev_hard_start_xmit(skb, dev);\n\tHARD_TX_UNLOCK(dev);\n\tspin_lock(&dev->queue_lock);\n\tq = dev->qdisc;\n\tswitch (ret) {\n\tcase NETDEV_TX_OK:\n\t\tret = qdisc_qlen(q);\n\t\tbreak;\n\tcase NETDEV_TX_LOCKED:\n\t\tret = handle_dev_cpu_collision(skb, dev, q);\n\t\tbreak;\n\tdefault:\n\t\tif (unlikely (ret != NETDEV_TX_BUSY && net_ratelimit()))\n\t\t\tprintk(KERN_WARNING \"BUG %s code %d qlen %d\\n\",\n\t\t\t       dev->name, ret, q->q.qlen);\n\t\tret = dev_requeue_skb(skb, dev, q);\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}", "target": 1}
{"code": "void CE_WideToChar(unsigned short *w_str, char *str)\n{\n\tWideCharToMultiByte(CP_ACP, 0, w_str, -1, str, GF_MAX_PATH, NULL, NULL);\n}", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "irc_nick_nicklist_remove (struct t_irc_server *server,\n                          struct t_irc_channel *channel,\n                          struct t_irc_nick *nick)\n{\n    struct t_gui_nick_group *ptr_group;\n    ptr_group = irc_nick_get_nicklist_group (server, channel->buffer, nick);\n    weechat_nicklist_remove_nick (channel->buffer,\n                                  weechat_nicklist_search_nick (channel->buffer,\n                                                                ptr_group,\n                                                                nick->name));\n}", "target": 0}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "unsigned int _gnutls_x509_verify_certificate(\n    const gnutls_x509_crt_t *certificate_list, int clist_size,\n    const gnutls_x509_crt_t *trusted_cas, int tcas_size,\n    const gnutls_x509_crl_t *CRLs, int crls_size,\n    unsigned int flags)\n{\n    int i = 0, ret;\n    unsigned int status = 0, output;\n    ret =\n\t_gnutls_verify_certificate2(certificate_list[clist_size-1], \n\t    trusted_cas, tcas_size, flags, &output);\n    if (ret == 0) {\n\tgnutls_assert();\n\tstatus |= output;\n\tstatus |= GNUTLS_CERT_INVALID;\n\treturn status;\n    }\n#ifdef ENABLE_PKI\n    for (i = 0; i < clist_size; i++) {\n\tret = gnutls_x509_crt_check_revocation(certificate_list[i],\n\t\t\t\t\t       CRLs, crls_size);\n\tif (ret == 1) {\t\t\n\t    status |= GNUTLS_CERT_REVOKED;\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n#endif\n    for (i = clist_size-1; i > 0; i--) {\n\tif (i - 1 < 0)\n\t    break;\n        flags ^= GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT;\n\tif ((ret =\n\t     _gnutls_verify_certificate2(certificate_list[i-1],\n                  &certificate_list[i], 1, flags, NULL)) == 0) {\n\t    status |= GNUTLS_CERT_INVALID;\n\t    return status;\n\t}\n    }\n    return 0;\n}", "target": 0}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "static int parse_public_key(const u8 *key, size_t keysize, RSA *rsa)\n{\n\tconst u8 *p = key;\n\tBIGNUM *n, *e;\n\tint base;\n\tbase = (keysize - 7) / 5;\n\tif (base != 32 && base != 48 && base != 64 && base != 128) {\n\t\tfprintf(stderr, \"Invalid public key.\\n\");\n\t\treturn -1;\n\t}\n\tp += 3;\n\tn = BN_new();\n\tif (n == NULL)\n\t\treturn -1;\n\tcf2bn(p, 2 * base, n);\n\tp += 2 * base;\n\tp += base;\n\tp += 2 * base;\n\te = BN_new();\n\tif (e == NULL)\n\t\treturn -1;\n\tcf2bn(p, 4, e);\n\tif (RSA_set0_key(rsa, n, e, NULL) != 1)\n\t    return -1;\n\treturn 0;\n}", "target": 0}
{"code": "static int packet_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tif (po->tx_ring.pg_vec)\n\t\treturn tpacket_snd(po, msg);\n\telse\n\t\treturn packet_snd(sock, msg, len);\n}", "target": 0}
{"code": "    long XmpArrayValue::toLong(long n) const\n    {\n        return parseLong(value_[n], ok_);\n    }", "target": 0}
{"code": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void crst_table_init(unsigned long *crst, unsigned long entry)\n{\n\tclear_table(crst, entry, sizeof(unsigned long)*2048);\n}", "target": 0}
{"code": "GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, tmpName, to_read);\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "int GamutSampler(register const cmsUInt16Number In[], register cmsUInt16Number Out[], register void* Cargo)\n{\n    GAMUTCHAIN*  t = (GAMUTCHAIN* ) Cargo;\n    cmsCIELab LabIn1, LabOut1;\n    cmsCIELab LabIn2, LabOut2;\n    cmsUInt16Number Proof[cmsMAXCHANNELS], Proof2[cmsMAXCHANNELS];\n    cmsFloat64Number dE1, dE2, ErrorRatio;\n    ErrorRatio = 1.0;\n    cmsDoTransform(t -> hInput, In, &LabIn1, 1);\n    cmsDoTransform(t -> hForward, &LabIn1, Proof, 1);\n    cmsDoTransform(t -> hReverse, Proof, &LabOut1, 1);\n    memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));\n    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);\n    cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);\n    dE1 = cmsDeltaE(&LabIn1, &LabOut1);\n    dE2 = cmsDeltaE(&LabIn2, &LabOut2);\n    if (dE1 < t->Thereshold && dE2 < t->Thereshold)\n        Out[0] = 0;\n    else {\n        if (dE1 < t->Thereshold && dE2 > t->Thereshold)\n            Out[0] = 0;\n        else\n            if (dE1 > t->Thereshold && dE2 < t->Thereshold)\n                Out[0] = (cmsUInt16Number) _cmsQuickFloor((dE1 - t->Thereshold) + .5);\n            else  {\n                if (dE2 == 0.0)\n                    ErrorRatio = dE1;\n                else\n                    ErrorRatio = dE1 / dE2;\n                if (ErrorRatio > t->Thereshold)\n                    Out[0] = (cmsUInt16Number)  _cmsQuickFloor((ErrorRatio - t->Thereshold) + .5);\n                else\n                    Out[0] = 0;\n            }\n    }\n    return TRUE;\n}", "target": 0}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n{\n\tint ret;\n\tsigset_t sigsaved;\n\tif (unlikely(vcpu->arch.target < 0))\n\t\treturn -ENOEXEC;\n\tret = kvm_vcpu_first_run_init(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tif (run->exit_reason == KVM_EXIT_MMIO) {\n\t\tret = kvm_handle_mmio_return(vcpu, vcpu->run);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\tret = 1;\n\trun->exit_reason = KVM_EXIT_UNKNOWN;\n\twhile (ret > 0) {\n\t\tcond_resched();\n\t\tupdate_vttbr(vcpu->kvm);\n\t\tif (vcpu->arch.pause)\n\t\t\tvcpu_pause(vcpu);\n\t\tkvm_vgic_flush_hwstate(vcpu);\n\t\tkvm_timer_flush_hwstate(vcpu);\n\t\tlocal_irq_disable();\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\trun->exit_reason = KVM_EXIT_INTR;\n\t\t}\n\t\tif (ret <= 0 || need_new_vmid_gen(vcpu->kvm)) {\n\t\t\tlocal_irq_enable();\n\t\t\tkvm_timer_sync_hwstate(vcpu);\n\t\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_kvm_entry(*vcpu_pc(vcpu));\n\t\tkvm_guest_enter();\n\t\tvcpu->mode = IN_GUEST_MODE;\n\t\tret = kvm_call_hyp(__kvm_vcpu_run, vcpu);\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tvcpu->arch.last_pcpu = smp_processor_id();\n\t\tkvm_guest_exit();\n\t\ttrace_kvm_exit(*vcpu_pc(vcpu));\n\t\tlocal_irq_enable();\n\t\tkvm_timer_sync_hwstate(vcpu);\n\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\tret = handle_exit(vcpu, run, ret);\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "PHP_MINIT_FUNCTION(exif)\n{\n\tREGISTER_INI_ENTRIES();\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 1, CONST_CS | CONST_PERSISTENT);\n\t} else {\n\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 0, CONST_CS | CONST_PERSISTENT);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "void HeaderUtility::stripPortFromHost(RequestHeaderMap& headers, uint32_t listener_port) {\n  if (headers.getMethodValue() == Http::Headers::get().MethodValues.Connect) {\n    return;\n  }\n  const absl::string_view original_host = headers.getHostValue();\n  const absl::string_view::size_type port_start = original_host.rfind(':');\n  if (port_start == absl::string_view::npos) {\n    return;\n  }\n  const auto v6_end_index = original_host.rfind(\"]\");\n  if (v6_end_index == absl::string_view::npos || v6_end_index < port_start) {\n    if ((port_start + 1) > original_host.size()) {\n      return;\n    }\n    const absl::string_view port_str = original_host.substr(port_start + 1);\n    uint32_t port = 0;\n    if (!absl::SimpleAtoi(port_str, &port)) {\n      return;\n    }\n    if (port != listener_port) {\n      return;\n    }\n    const absl::string_view host = original_host.substr(0, port_start);\n    headers.setHost(host);\n  }\n}", "target": 0}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "AWSEngine::authenticate(const req_state* const s) const\n{\n  const auto auth_data = ver_abstractor.get_auth_data(s);\n  if (auth_data.access_key_id.empty() || auth_data.client_signature.empty()) {\n    return result_t::deny(-EINVAL);\n  } else {\n    return authenticate(auth_data.access_key_id,\n\t\t        auth_data.client_signature,\n\t\t\tauth_data.string_to_sign,\n                        auth_data.signature_factory,\n\t\t\tauth_data.completer_factory,\n\t\t\ts);\n  }\n}", "target": 0}
{"code": "int GetDPI(const PrintMsg_Print_Params* print_params) {\n#if defined(OS_MACOSX)\n  return kPointsPerInch;\n#else\n  return static_cast<int>(print_params->dpi);\n#endif  \n}", "target": 0}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; \n\tint size, in, string;\n\tunsigned port;\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string || in)\n\t\treturn emulate_instruction(vcpu, 0) == EMULATE_DONE;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\tskip_emulated_instruction(&svm->vcpu);\n\treturn kvm_fast_pio_out(vcpu, size, port);\n}", "target": 0}
{"code": "void dtls1_reset_seq_numbers(SSL *s, int rw)\n{\n    unsigned char *seq;\n    unsigned int seq_bytes = sizeof(s->s3->read_sequence);\n    if (rw & SSL3_CC_READ) {\n        seq = s->s3->read_sequence;\n        s->d1->r_epoch++;\n        memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));\n        memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\n    } else {\n        seq = s->s3->write_sequence;\n        memcpy(s->d1->last_write_sequence, seq,\n               sizeof(s->s3->write_sequence));\n        s->d1->w_epoch++;\n    }\n    memset(seq, 0x00, seq_bytes);\n}", "target": 1}
{"code": "static int orinoco_ioctl_getessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_point *erq,\n\t\t\t\t  char *essidbuf)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint active;\n\tint err = 0;\n\tunsigned long flags;\n\tif (netif_running(dev)) {\n\t\terr = orinoco_hw_get_essid(priv, &active, essidbuf);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terq->length = err;\n\t} else {\n\t\tif (orinoco_lock(priv, &flags) != 0)\n\t\t\treturn -EBUSY;\n\t\tmemcpy(essidbuf, priv->desired_essid, IW_ESSID_MAX_SIZE);\n\t\terq->length = strlen(priv->desired_essid);\n\t\torinoco_unlock(priv, &flags);\n\t}\n\terq->flags = 1;\n\treturn 0;\n}", "target": 0}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "bool pch_copy (void)\n{\n  return p_copy[OLD] && p_copy[NEW]\n\t && p_name[OLD] && p_name[NEW];\n}", "target": 0}
{"code": "process_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}", "target": 0}
{"code": "int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n    const RunFromHostProxyCallback& callback) {\n  if (state_->run_called()) {\n    if (!callback.is_null())\n      callback.Run(PP_ERROR_FAILED);\n    return PP_ERROR_FAILED;\n  }\n  state_->set_run_called();\n  state_->set_run_callback(callback);\n  scoped_refptr<State> state_protector(state_);\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n     base::MessageLoop::current()->Run();\n   }\n  return state_protector->result();\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 1}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "    bool chunked() const { return has(Http::HdrType::TRANSFER_ENCODING); }", "target": 0}
{"code": "read_response_line(smtp_inblock *inblock, uschar *buffer, int size, int timeout)\n{\nuschar *p = buffer;\nuschar *ptr = inblock->ptr;\nuschar *ptrend = inblock->ptrend;\nclient_conn_ctx * cctx = inblock->cctx;\nfor (;;)\n  {\n  int rc;\n  while (ptr < ptrend)\n    {\n    int c = *ptr++;\n    if (c == '\\n')\n      {\n      while (p > buffer && isspace(p[-1])) p--;\n      *p = 0;\n      inblock->ptr = ptr;\n      return p - buffer;\n      }\n    *p++ = c;\n    if (--size < 4)\n      {\n      *p = 0;                     \n      errno = ERRNO_SMTPFORMAT;\n      return -1;\n      }\n    }\n  if((rc = ip_recv(cctx, inblock->buffer, inblock->buffersize, timeout)) <= 0)\n    {\n    DEBUG(D_deliver|D_transport|D_acl)\n      debug_printf_indent(errno ? \"  SMTP(%s)<<\\n\" : \"  SMTP(closed)<<\\n\",\n\tstrerror(errno));\n    break;\n    }\n  ptrend = inblock->ptrend = inblock->buffer + rc;\n  ptr = inblock->buffer;\n  DEBUG(D_transport|D_acl) debug_printf_indent(\"read response data: size=%d\\n\", rc);\n  }\n*buffer = 0;\nreturn -1;\n}", "target": 0}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static int get_vmx_mem_address(struct kvm_vcpu *vcpu,\n\t\t\t\t unsigned long exit_qualification,\n\t\t\t\t u32 vmx_instruction_info, gva_t *ret)\n{\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\t*ret = vmx_get_segment_base(vcpu, seg_reg);\n\tif (base_is_valid)\n\t\t*ret += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\t*ret += kvm_register_read(vcpu, index_reg)<<scaling;\n\t*ret += exit_qualification; \n\tif (addr_size == 1) \n\t\t*ret &= 0xffffffff;\n\treturn 0;\n}", "target": 0}
{"code": "void _af_print_tracks (AFfilehandle filehandle)\n{\n\tint\ti;\n\tfor (i=0; i<filehandle->trackCount; i++)\n\t{\n\t\t_Track\t*track = &filehandle->tracks[i];\n\t\tprintf(\"track %d\\n\", i);\n\t\tprintf(\" id %d\\n\", track->id);\n\t\tprintf(\" sample format\\n\");\n\t\t_af_print_audioformat(&track->f);\n\t\tprintf(\" virtual format\\n\");\n\t\t_af_print_audioformat(&track->v);\n\t\tprintf(\" total file frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalfframes);\n\t\tprintf(\" total virtual frames: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->totalvframes);\n\t\tprintf(\" next file frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextfframe);\n\t\tprintf(\" next virtual frame: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->nextvframe);\n\t\tprintf(\" frames to ignore: %\" AF_FRAMECOUNT_PRINT_FMT \"\\n\",\n\t\t\ttrack->frames2ignore);\n\t\tprintf(\" data_size: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->data_size);\n\t\tprintf(\" fpos_first_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_first_frame);\n\t\tprintf(\" fpos_next_frame: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_next_frame);\n\t\tprintf(\" fpos_after_data: %\" AF_FILEOFFSET_PRINT_FMT \"\\n\",\n\t\t\ttrack->fpos_after_data);\n\t\tprintf(\" channel matrix:\");\n\t\t_af_print_channel_matrix(track->channelMatrix,\n\t\t\ttrack->f.channelCount, track->v.channelCount);\n\t\tprintf(\"\\n\");\n\t\tprintf(\" marker count: %d\\n\", track->markerCount);\n\t}\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, RouteOverride) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) {\n        envoy::extensions::filters::http::rbac::v3::RBACPerRoute per_route_config;\n        TestUtility::loadFromJson(\"{}\", per_route_config);\n        auto* config = cfg.mutable_route_config()\n                           ->mutable_virtual_hosts()\n                           ->Mutable(0)\n                           ->mutable_typed_per_filter_config();\n        (*config)[Extensions::HttpFilters::HttpFilterNames::get().Rbac].PackFrom(per_route_config);\n      });\n  config_helper_.addFilter(RBAC_CONFIG);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "static void flush_dpb(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n    for (i = 0; i <= MAX_DELAYED_PIC_COUNT; i++) {\n        if (h->delayed_pic[i])\n            h->delayed_pic[i]->reference = 0;\n        h->delayed_pic[i] = NULL;\n    }\n    flush_change(h);\n    if (h->DPB)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n    h->cur_pic_ptr = NULL;\n    unref_picture(h, &h->cur_pic);\n    h->mb_x = h->mb_y = 0;\n    h->parse_context.state             = -1;\n    h->parse_context.frame_start_found = 0;\n    h->parse_context.overread          = 0;\n    h->parse_context.overread_index    = 0;\n    h->parse_context.index             = 0;\n    h->parse_context.last_index        = 0;\n    free_tables(h, 1);\n    h->context_initialized = 0;\n}", "target": 0}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\tfree_pages -= (1 << order) - 1;\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n#ifdef CONFIG_CMA\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\tif (!order)\n\t\treturn true;\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "static void increment_offset(int64_t delta)\n{\n    if (unlikely(delta == 0))\n        return;\n    location.offset += delta;\n    set_curr_offs(location.offset);\n}", "target": 0}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[256];\n        sprintf(buf, \"conversion from %s to %s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "STATIC const char *\nS_cntrl_to_mnemonic(const U8 c)\n{\n    switch (c) {\n        case '\\a':       return \"\\\\a\";\n        case '\\b':       return \"\\\\b\";\n        case ESC_NATIVE: return \"\\\\e\";\n        case '\\f':       return \"\\\\f\";\n        case '\\n':       return \"\\\\n\";\n        case '\\r':       return \"\\\\r\";\n        case '\\t':       return \"\\\\t\";\n    }\n    return NULL;", "target": 0}
{"code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}", "target": 1}
{"code": "static int orinoco_ioctl_setpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  struct iw_param *prq,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (prq->disabled) {\n\t\tpriv->pm_on = 0;\n\t} else {\n\t\tswitch (prq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tpriv->pm_mcast = 0;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tpriv->pm_mcast = 1;\n\t\t\tpriv->pm_on = 1;\n\t\t\tbreak;\n\t\tcase IW_POWER_ON:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (prq->flags & IW_POWER_TIMEOUT) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_timeout = prq->value / 1000;\n\t\t}\n\t\tif (prq->flags & IW_POWER_PERIOD) {\n\t\t\tpriv->pm_on = 1;\n\t\t\tpriv->pm_period = prq->value / 1000;\n\t\t}\n\t\tif (!priv->pm_on) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "static void __mark_reg_const_zero(struct bpf_reg_state *reg)\n{\n\t__mark_reg_known(reg, 0);\n\treg->type = SCALAR_VALUE;\n}", "target": 0}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name)\n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path =\n\t\t\t\tg_build_filename (path_name,\n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "Status FunctionCallFrame::ConsumeRetvals(std::vector<Tensor>* rets,\n                                         bool allow_dead_tensors) {\n  rets->clear();\n  rets->reserve(rets_.size());\n  for (size_t i = 0; i < rets_.size(); ++i) {\n    if (rets_[i].has_val) {\n      rets->emplace_back(std::move(rets_[i].val));\n    } else if (allow_dead_tensors) {\n      rets->emplace_back();\n    } else {\n      return errors::Internal(\"Retval[\", i, \"] does not have value\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, DeniedWithPrefixRule) {\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             cfg) { cfg.mutable_normalize_path()->set_value(false); });\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PREFIX_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"POST\"},\n          {\":path\", \"/foo/../bar\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  waitForNextUpstreamRequest();\n  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "httpd_addheader(isc_httpd_t *httpd, const char *name, const char *val) {\n\tisc_result_t result;\n\tunsigned int needlen;\n\tREQUIRE(VALID_HTTPD(httpd));\n\tneedlen = strlen(name); \n\tif (val != NULL) {\n\t\tneedlen += 2 + strlen(val); \n\t}\n\tneedlen += 2; \n\twhile (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {\n\t\tresult = grow_headerspace(httpd);\n\t\tif (result != ISC_R_SUCCESS) {\n\t\t\treturn (result);\n\t\t}\n\t}\n\tif (val != NULL) {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s: %s\\r\\n\",\n\t\t\t\t\t  name, val));\n\t} else {\n\t\treturn (isc_buffer_printf(&httpd->headerbuffer, \"%s\\r\\n\",\n\t\t\t\t\t  name));\n\t}\n}", "target": 0}
{"code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    AnsiContext *s = avctx->priv_data;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    s->frame = av_frame_alloc();\n    if (!s->frame)\n        return AVERROR(ENOMEM);\n    s->font        = avpriv_vga16_font;\n    s->font_height = 16;\n    s->fg          = DEFAULT_FG_COLOR;\n    s->bg          = DEFAULT_BG_COLOR;\n    if (!avctx->width || !avctx->height)\n        ff_set_dimensions(avctx, 80 << 3, 25 << 4);\n    return 0;\n}", "target": 0}
{"code": "static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,\n\t\t\t unsigned long fh, u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm__pad1 = 0;\n\ttcm->tcm_ifindex = qdisc_dev(tp->q)->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tNLA_PUT_STRING(skb, TCA_KIND, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::GetSnapshotFromBrowser(\n    const GetSnapshotFromBrowserCallback& callback,\n    bool from_surface) {\n  int id = next_browser_snapshot_id_++;\n  if (from_surface) {\n    pending_surface_browser_snapshots_.insert(std::make_pair(id, callback));\n    ui::LatencyInfo latency_info;\n    latency_info.AddLatencyNumber(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT,\n                                  0, id);\n    Send(new ViewMsg_ForceRedraw(GetRoutingID(), latency_info));\n    return;\n  }\n#if defined(OS_MACOSX)\n  if (pending_browser_snapshots_.empty())\n    GetWakeLock()->RequestWakeLock();\n#endif\n  pending_browser_snapshots_.insert(std::make_pair(id, callback));\n  ui::LatencyInfo latency_info;\n  latency_info.AddLatencyNumber(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT, 0,\n                                id);\n  Send(new ViewMsg_ForceRedraw(GetRoutingID(), latency_info));\n}", "target": 0}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  \n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static uint8 TIFFClampDoubleToUInt8( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 255 || val != val )\n        return 255;\n    return (uint8)val;\n}", "target": 0}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "static void check_preempt_wakeup(struct rq *rq, struct task_struct *p)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tunsigned long gran;\n\tif (unlikely(rt_prio(p->prio))) {\n\t\tupdate_rq_clock(rq);\n\t\tupdate_curr(cfs_rq);\n\t\tresched_task(curr);\n\t\treturn;\n\t}\n\tcfs_rq_of(pse)->next = pse;\n\tif (unlikely(p->policy == SCHED_BATCH))\n\t\treturn;\n\tif (!sched_feat(WAKEUP_PREEMPT))\n\t\treturn;\n\twhile (!is_same_group(se, pse)) {\n\t\tse = parent_entity(se);\n\t\tpse = parent_entity(pse);\n\t}\n\tgran = sysctl_sched_wakeup_granularity;\n\tif (unlikely(se->load.weight > NICE_0_LOAD))\n\t\tgran = calc_delta_fair(gran, &se->load);\n\tif (pse->vruntime + gran < se->vruntime)\n\t\tresched_task(curr);\n}", "target": 0}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "    long TimeValue::toLong(long ) const\n    {\n        long result = (time_.hour - time_.tzHour) * 60 * 60;\n        result += (time_.minute - time_.tzMinute) * 60;\n        result += time_.second;\n        if (result < 0) {\n            result += 86400;\n        }\n        ok_ = true;\n        return result;\n    }", "target": 0}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n  PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeLateUserSections() {\n  for (auto& section : wasm->userSections) {\n    if (section.name != BinaryConsts::UserSections::Dylink) {\n      writeUserSection(section);\n    }\n  }\n}", "target": 0}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": "flatpak_run_add_journal_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char *journal_socket_socket = g_strdup (\"/run/systemd/journal/socket\");\n  g_autofree char *journal_stdout_socket = g_strdup (\"/run/systemd/journal/stdout\");\n  if (g_file_test (journal_socket_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_socket_socket, journal_socket_socket,\n                              NULL);\n    }\n  if (g_file_test (journal_stdout_socket, G_FILE_TEST_EXISTS))\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--ro-bind\", journal_stdout_socket, journal_stdout_socket,\n                              NULL);\n    }\n}", "target": 0}
{"code": "static int __init setup_fail_page_alloc(char *str)\n{\n\treturn setup_fault_attr(&fail_page_alloc.attr, str);\n}", "target": 0}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n  gcry_mpi_powm( t1, a, skey->x, skey->p );\n  mpi_invm( t1, t1, skey->p );\n  mpi_mulm( output, b, t1, skey->p );\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free(t1);\n}", "target": 1}
{"code": "static int ecryptfs_threadfn(void *ignored)\n{\n\tset_freezable();\n\twhile (1)  {\n\t\tstruct ecryptfs_open_req *req;\n\t\twait_event_freezable(\n\t\t\tecryptfs_kthread_ctl.wait,\n\t\t\t(!list_empty(&ecryptfs_kthread_ctl.req_list)\n\t\t\t || kthread_should_stop()));\n\t\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\t\tgoto out;\n\t\t}\n\t\twhile (!list_empty(&ecryptfs_kthread_ctl.req_list)) {\n\t\t\treq = list_first_entry(&ecryptfs_kthread_ctl.req_list,\n\t\t\t\t\t       struct ecryptfs_open_req,\n\t\t\t\t\t       kthread_ctl_list);\n\t\t\tlist_del(&req->kthread_ctl_list);\n\t\t\t*req->lower_file = dentry_open(&req->path,\n\t\t\t\t(O_RDWR | O_LARGEFILE), current_cred());\n\t\t\tcomplete(&req->done);\n\t\t}\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t}\nout:\n\treturn 0;\n}", "target": 0}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)\n{\n\tif (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||\n\t    synth->ser == SYNTH_DEFAULT_SER)\n\t\treturn tty_dev_name_to_number(synth->dev_name, dev_no);\n\treturn ser_to_dev(synth->ser, dev_no);\n}", "target": 0}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "gboolean reds_config_get_agent_mouse(const RedsState *reds)\n{\n    return reds->config->agent_mouse;\n}", "target": 0}
{"code": "static void set_seg_override(struct x86_emulate_ctxt *ctxt, int seg)\n{\n\tctxt->has_seg_override = true;\n\tctxt->seg_override = seg;\n}", "target": 0}
{"code": " static blink::WebScreenOrientations stringToOrientations(const AtomicString& orientationString)\n {\n     DEFINE_STATIC_LOCAL(const AtomicString, portrait, (\"portrait\", AtomicString::ConstructFromLiteral));\n     DEFINE_STATIC_LOCAL(const AtomicString, landscape, (\"landscape\", AtomicString::ConstructFromLiteral));\n     if (orientationString == portrait)\n         return blink::WebScreenOrientationPortraitPrimary | blink::WebScreenOrientationPortraitSecondary;\n     if (orientationString == landscape)\n        return blink::WebScreenOrientationLandscapePrimary | blink::WebScreenOrientationLandscapeSecondary;\n    unsigned length = 0;\n    ScreenOrientationInfo* orientationMap = orientationsMap(length);\n    for (unsigned i = 0; i < length; ++i) {\n        if (orientationMap[i].name == orientationString)\n            return orientationMap[i].orientation;\n    }\n    return 0;\n}", "target": 1}
{"code": "void RenderView::assignIdentifierToRequest(\n    WebFrame* frame, unsigned identifier, const WebURLRequest& request) {\n}", "target": 0}
{"code": "Array HHVM_FUNCTION(mcrypt_list_modes,\n                    const String& lib_dir ) {\n  String dir = lib_dir.empty() ? String(MCG(modes_dir)) : lib_dir;\n  int count = 0;\n  char **modules = mcrypt_list_modes((char*)dir.data(), &count);\n  if (count == 0) {\n    raise_warning(\"No modes found in module dir\");\n  }\n  Array ret = Array::Create();\n  for (int i = 0; i < count; i++) {\n    ret.append(String(modules[i], CopyString));\n  }\n  mcrypt_free_p(modules, count);\n  return ret;\n}", "target": 0}
{"code": " static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,\n                               int nb_sectors)\n {\n     return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,\n                                    nb_sectors * BDRV_SECTOR_SIZE);\n }", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}", "target": 1}
{"code": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n    free_server_handle(handle);\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    return(&ret);\n}", "target": 1}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "static void ml_ff_destroy(struct ff_device *ff)\n{\n\tstruct ml_device *ml = ff->private;\n\tkfree(ml->private);\n}", "target": 1}
{"code": "  Declaration_Obj Parser::parse_declaration() {\n    String_Obj prop;\n    bool is_custom_property = false;\n    if (lex< sequence< optional< exactly<'*'> >, identifier_schema > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = parse_identifier_schema();\n    }\n    else if (lex< sequence< optional< exactly<'*'> >, identifier, zero_plus< block_comment > > >()) {\n      const std::string property(lexed);\n      is_custom_property = property.compare(0, 2, \"--\") == 0;\n      prop = SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    else {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"}\\\", was \");\n    }\n    bool is_indented = true;\n    const std::string property(lexed);\n    if (!lex_css< one_plus< exactly<':'> > >()) error(\"property \\\"\" + escape_string(property)  + \"\\\" must be followed by a ':'\");\n    if (!is_custom_property && match< sequence< optional_css_comments, exactly<';'> > >()) error(\"style declaration must contain a value\");\n    if (match< sequence< optional_css_comments, exactly<'{'> > >()) is_indented = false; \n    if (is_custom_property) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_css_variable_value(), false, true);\n    }\n    lex < css_comments >(false);\n    if (peek_css< static_value >()) {\n      return SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, parse_static_value());\n    }\n    else {\n      Expression_Obj value;\n      Lookahead lookahead = lookahead_for_value(position);\n      if (lookahead.found) {\n        if (lookahead.has_interpolants) {\n          value = parse_value_schema(lookahead.found);\n        } else {\n          value = parse_list(DELAYED);\n        }\n      }\n      else {\n        value = parse_list(DELAYED);\n        if (List* list = Cast<List>(value)) {\n          if (!list->is_bracketed() && list->length() == 0 && !peek< exactly <'{'> >()) {\n            css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n          }\n        }\n      }\n      lex < css_comments >(false);\n      Declaration_Obj decl = SASS_MEMORY_NEW(Declaration, prop->pstate(), prop, value);\n      decl->is_indented(is_indented);\n      decl->update_pstate(pstate);\n      return decl;\n    }\n  }", "target": 0}
{"code": "static int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int test_signed_mod_replace_ba(int n)\n{\n    BIGNUM *a = NULL, *b = NULL, *c = NULL, *d = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = set_signed_bn(signed_mod_tests[n].n))\n            || !TEST_ptr(b = set_signed_bn(signed_mod_tests[n].divisor))\n            || !TEST_ptr(c = set_signed_bn(signed_mod_tests[n].result))\n            || !TEST_ptr(d = set_signed_bn(signed_mod_tests[n].remainder)))\n        goto err;\n    if (TEST_true(BN_div(b, a, a, b, ctx))\n            && TEST_BN_eq(b, c)\n            && TEST_BN_eq(a, d))\n        st = 1;\n err:\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    BN_free(d);\n    return st;\n}", "target": 0}
{"code": "static bool is_ctx_reg(struct bpf_verifier_env *env, int regno)\n{\n\tconst struct bpf_reg_state *reg = reg_state(env, regno);\n\treturn reg->type == PTR_TO_CTX;\n}", "target": 0}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }", "target": 0}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "uint32_t read32(uint8_t* arr, int pos,  int swapBytes)\n{\n    if(!swapBytes) {\n        return (arr[pos]   << 24) |\n               (arr[pos+1] << 16) |\n               (arr[pos+2] << 8) |\n                arr[pos+3];\n    }\n    return arr[pos] |\n           (arr[pos+1] << 8) |\n           (arr[pos+2] << 16) |\n           (arr[pos+3] << 24);\n}", "target": 0}
{"code": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}", "target": 0}
{"code": "asmlinkage long compat_sys_epoll_pwait(int epfd,\n\t\t\tstruct compat_epoll_event __user *events,\n\t\t\tint maxevents, int timeout,\n\t\t\tconst compat_sigset_t __user *sigmask,\n\t\t\tcompat_size_t sigsetsize)\n{\n\tlong err;\n\tcompat_sigset_t csigmask;\n\tsigset_t ksigmask, sigsaved;\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&csigmask, sigmask, sizeof(csigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &csigmask);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n#ifdef CONFIG_HAS_COMPAT_EPOLL_EVENT\n\terr = compat_sys_epoll_wait(epfd, events, maxevents, timeout);\n#else\n\terr = sys_epoll_wait(epfd, events, maxevents, timeout);\n#endif\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t} else\n\t\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "method_invocation_get_uid (GDBusMethodInvocation *context)\n{\n  const gchar *sender;\n  PolkitSubject *busname;\n  PolkitSubject *process;\n  uid_t uid;\n  sender = g_dbus_method_invocation_get_sender (context);\n  busname = polkit_system_bus_name_new (sender);\n  process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (busname), NULL, NULL);\n  uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n  g_object_unref (busname);\n  g_object_unref (process);\n  return uid;\n}", "target": 1}
{"code": "void DelegatedFrameHost::ResetCompositorFrameSinkSupport() {\n  if (!support_)\n    return;\n  if (compositor_)\n    compositor_->RemoveFrameSink(frame_sink_id_);\n  support_.reset();\n}", "target": 0}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_ctl_elem_write_user(struct snd_ctl_file *file,\n\t\t\t\t   struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tstruct snd_card *card;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tcard = file->card;\n\tsnd_power_lock(card);\n\tresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\n\tif (result >= 0)\n\t\tresult = snd_ctl_elem_write(card, file, control);\n\tsnd_power_unlock(card);\n\tif (result >= 0)\n\t\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\t\tresult = -EFAULT;\n\tkfree(control);\n\treturn result;\n}", "target": 0}
{"code": "static int __rt_schedulable(struct task_group *tg, u64 period, u64 runtime)\n{\n\tint ret;\n\tstruct rt_schedulable_data data = {\n\t\t.tg = tg,\n\t\t.rt_period = period,\n\t\t.rt_runtime = runtime,\n\t};\n\trcu_read_lock();\n\tret = walk_tg_tree(tg_rt_schedulable, tg_nop, &data);\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "static bool ok_inflater_init_fixed_huffman(ok_inflater *inflater) {\n    if (!inflater->fixed_literal_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t code_length[288];\n            int i;\n            for (i = 0; i < 144; i++) {\n                code_length[i] = 8;\n            }\n            for (i = 144; i < 256; i++) {\n                code_length[i] = 9;\n            }\n            for (i = 256; i < 280; i++) {\n                code_length[i] = 7;\n            }\n            for (i = 280; i < 288; i++) {\n                code_length[i] = 8;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, code_length,\n                                                     sizeof(code_length) / sizeof(code_length[0]));\n            inflater->fixed_literal_huffman = tree;\n        }\n    }\n    if (!inflater->fixed_distance_huffman) {\n        ok_inflater_huffman_tree *tree = ok_alloc(inflater, sizeof(ok_inflater_huffman_tree));\n        if (tree) {\n            uint8_t distance_code_length[32];\n            for (int i = 0; i < 32; i++) {\n                distance_code_length[i] = 5;\n            }\n            ok_inflater_make_huffman_tree_from_array(tree, distance_code_length, 32);\n            inflater->fixed_distance_huffman = tree;\n        }\n    }\n    return inflater->fixed_literal_huffman && inflater->fixed_distance_huffman;\n}", "target": 0}
{"code": "static inline void kvm_memslot_delete(struct kvm_memslots *slots,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tstruct kvm_memory_slot *mslots = slots->memslots;\n\tint i;\n\tif (WARN_ON(slots->id_to_index[memslot->id] == -1))\n\t\treturn;\n\tslots->used_slots--;\n\tfor (i = slots->id_to_index[memslot->id]; i < slots->used_slots; i++) {\n\t\tmslots[i] = mslots[i + 1];\n\t\tslots->id_to_index[mslots[i].id] = i;\n\t}\n\tmslots[i] = *memslot;\n\tslots->id_to_index[memslot->id] = -1;\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 0}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "g_opendir(Char *str, glob_t *pglob)\n{\n    char buf[PATH_MAX];\n    if (!*str) {\n        buf[0] = '.';\n        buf[1] = 0;\n    } else {\n        if (g_Ctoc(str, buf, sizeof(buf))) {\n            return NULL;\n        }\n    }\n    if (pglob->gl_flags & GLOB_ALTDIRFUNC) {\n        return (*pglob->gl_opendir)(buf);\n    }\n    return opendir(buf);\n}", "target": 0}
{"code": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    NetClientState *nc = qemu_get_queue(n->nic);\n    int queue_pairs = n->multiqueue ? n->max_queue_pairs : 1;\n    int cvq = n->max_ncs - n->max_queue_pairs;\n    if (!get_vhost_net(nc->peer)) {\n        return;\n    }\n    if ((virtio_net_started(n, status) && !nc->peer->link_down) ==\n        !!n->vhost_started) {\n        return;\n    }\n    if (!n->vhost_started) {\n        int r, i;\n        if (n->needs_vnet_hdr_swap) {\n            error_report(\"backend does not support %s vnet headers; \"\n                         \"falling back on userspace virtio\",\n                         virtio_is_big_endian(vdev) ? \"BE\" : \"LE\");\n            return;\n        }\n        for (i = 0;  i < queue_pairs; i++) {\n            NetClientState *qnc = qemu_get_subqueue(n->nic, i);\n            qemu_net_queue_purge(qnc->peer->incoming_queue, qnc);\n            qemu_net_queue_purge(qnc->incoming_queue, qnc->peer);\n        }\n        if (virtio_has_feature(vdev->guest_features, VIRTIO_NET_F_MTU)) {\n            r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);\n            if (r < 0) {\n                error_report(\"%uBytes MTU not supported by the backend\",\n                             n->net_conf.mtu);\n                return;\n            }\n        }\n        n->vhost_started = 1;\n        r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);\n        if (r < 0) {\n            error_report(\"unable to start vhost net: %d: \"\n                         \"falling back on userspace virtio\", -r);\n            n->vhost_started = 0;\n        }\n    } else {\n        vhost_net_stop(vdev, n->nic->ncs, queue_pairs, cvq);\n        n->vhost_started = 0;\n    }\n}", "target": 0}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "translate_input(int forward_translation, char *table_name) {\n\tchar charbuf[BUFSIZE];\n\tuint8_t *outputbuf;\n\tsize_t outlen;\n\twidechar inbuf[BUFSIZE];\n\twidechar transbuf[BUFSIZE];\n\tint inlen;\n\tint translen;\n\tint k;\n\tint ch = 0;\n\tint result;\n\twhile (1) {\n\t\ttranslen = BUFSIZE;\n\t\tk = 0;\n\t\twhile ((ch = fgetc(input)) != '\\n' && ch != EOF && k < BUFSIZE - 1)\n\t\t\tcharbuf[k++] = ch;\n\t\tif (ch == EOF && k == 0) break;\n\t\tcharbuf[k] = 0;\n\t\tinlen = _lou_extParseChars(charbuf, inbuf);\n\t\tif (forward_translation)\n\t\t\tresult = lou_translateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\telse\n\t\t\tresult = lou_backTranslateString(\n\t\t\t\t\ttable_name, inbuf, &inlen, transbuf, &translen, NULL, NULL, 0);\n\t\tif (!result) break;\n#ifdef WIDECHARS_ARE_UCS4\n\t\toutputbuf = u32_to_u8(transbuf, translen, NULL, &outlen);\n#else\n\t\toutputbuf = u16_to_u8(transbuf, translen, NULL, &outlen);\n#endif\n\t\tprintf(ch == EOF ? \"%.*s\" : \"%.*s\\n\", (int)outlen, outputbuf);\n\t\tfree(outputbuf);\n\t}\n\tlou_free();\n}", "target": 1}
{"code": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n  to->len = i;\n  if (p >= end)\n    to->reach_end = 1;\n}", "target": 1}
{"code": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tstart += strlen(key) + strlen(value) + 2;\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter *iter,\n\t\tloff_t *ppos, iter_fn_t fn)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tret = fn(&kiocb, iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}", "target": 0}
{"code": "pcl_status_read(byte * data, uint max_data, pcl_state_t * pcs)\n{\n    uint count = min(max_data,\n                     pcs->status.write_pos - pcs->status.read_pos);\n    if (count)\n        memcpy(data, pcs->status.buffer + pcs->status.read_pos, count);\n    pcs->status.read_pos += count;\n    if (pcs->status.read_pos == pcs->status.write_pos) {\n        gs_free_object(pcs->memory, pcs->status.buffer, \"status buffer\");\n        pcs->status.write_pos = pcs->status.read_pos = 0;\n    }\n    return count;\n}", "target": 1}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)\n {\n     return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);\n }", "target": 1}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void setup_DMA(void)\n{\n\tunsigned long f;\n\tif (raw_cmd->length == 0) {\n\t\tint i;\n\t\tpr_info(\"zero dma transfer size:\");\n\t\tfor (i = 0; i < raw_cmd->cmd_count; i++)\n\t\t\tpr_cont(\"%x,\", raw_cmd->cmd[i]);\n\t\tpr_cont(\"\\n\");\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tif (((unsigned long)raw_cmd->kernel_data) % 512) {\n\t\tpr_info(\"non aligned address: %p\\n\", raw_cmd->kernel_data);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\tf = claim_dma_lock();\n\tfd_disable_dma();\n#ifdef fd_dma_setup\n\tif (fd_dma_setup(raw_cmd->kernel_data, raw_cmd->length,\n\t\t\t (raw_cmd->flags & FD_RAW_READ) ?\n\t\t\t DMA_MODE_READ : DMA_MODE_WRITE, FDCS->address) < 0) {\n\t\trelease_dma_lock(f);\n\t\tcont->done(0);\n\t\tFDCS->reset = 1;\n\t\treturn;\n\t}\n\trelease_dma_lock(f);\n#else\n\tfd_clear_dma_ff();\n\tfd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);\n\tfd_set_dma_mode((raw_cmd->flags & FD_RAW_READ) ?\n\t\t\tDMA_MODE_READ : DMA_MODE_WRITE);\n\tfd_set_dma_addr(raw_cmd->kernel_data);\n\tfd_set_dma_count(raw_cmd->length);\n\tvirtual_dma_port = FDCS->address;\n\tfd_enable_dma();\n\trelease_dma_lock(f);\n#endif\n}", "target": 0}
{"code": "HIDDEN void *zstd_init()\n{\n    ZSTD_CCtx *cctx = ZSTD_createCCtx();\n    if (cctx) {\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_compressionLevel,\n                               ZSTD_CLEVEL_DEFAULT);\n        ZSTD_CCtx_setParameter(cctx, ZSTD_c_checksumFlag, 1);\n    }\n    return cctx;\n}", "target": 0}
{"code": "int ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i, j, count;\n\tkgid_t low, high;\n\tint ret = 0;\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\tgroup_info = get_current_groups();\n\tcount = group_info->ngroups;\n\tfor (i = 0; i < group_info->nblocks; i++) {\n\t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n\t\tfor (j = 0; j < cp_count; j++) {\n\t\t\tkgid_t gid = group_info->blocks[i][j];\n\t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\t\tgoto out_release_group;\n\t\t}\n\t\tcount -= cp_count;\n\t}\n\tret = -EACCES;\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}", "target": 0}
{"code": "static INLINE INT32 planar_skip_plane_rle(const BYTE* pSrcData, UINT32 SrcSize, UINT32 nWidth,\n                                          UINT32 nHeight)\n{\n\tUINT32 x, y;\n\tBYTE controlByte;\n\tconst BYTE* pRLE = pSrcData;\n\tconst BYTE* pEnd = &pSrcData[SrcSize];\n\tfor (y = 0; y < nHeight; y++)\n\t{\n\t\tfor (x = 0; x < nWidth;)\n\t\t{\n\t\t\tint cRawBytes;\n\t\t\tint nRunLength;\n\t\t\tif (pRLE >= pEnd)\n\t\t\t\treturn -1;\n\t\t\tcontrolByte = *pRLE++;\n\t\t\tnRunLength = PLANAR_CONTROL_BYTE_RUN_LENGTH(controlByte);\n\t\t\tcRawBytes = PLANAR_CONTROL_BYTE_RAW_BYTES(controlByte);\n\t\t\tif (nRunLength == 1)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 16;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\telse if (nRunLength == 2)\n\t\t\t{\n\t\t\t\tnRunLength = cRawBytes + 32;\n\t\t\t\tcRawBytes = 0;\n\t\t\t}\n\t\t\tpRLE += cRawBytes;\n\t\t\tx += cRawBytes;\n\t\t\tx += nRunLength;\n\t\t\tif (x > nWidth)\n\t\t\t\treturn -1;\n\t\t\tif (pRLE > pEnd)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\treturn (INT32)(pRLE - pSrcData);\n}", "target": 1}
{"code": "static int vm_stat_get_per_vm(void *data, u64 *val)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\t*val = *(ulong *)((void *)stat_data->kvm + stat_data->offset);\n\treturn 0;\n}", "target": 0}
{"code": "  int get_request_payment_payer(bool *requester_pays) {\n    XMLObj *config = find_first(\"RequestPaymentConfiguration\");\n    if (!config)\n      return -EINVAL;\n    *requester_pays = false;\n    XMLObj *field = config->find_first(\"Payer\");\n    if (!field)\n      return 0;\n    string& s = field->get_data();\n    if (stringcasecmp(s, \"Requester\") == 0) {\n      *requester_pays = true;\n    } else if (stringcasecmp(s, \"BucketOwner\") != 0) {\n      return -EINVAL;\n    }\n    return 0;\n  }", "target": 0}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == 0xdf && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_ISO_8859_2_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1; \n}", "target": 0}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)\n{\n\tunsigned long hashval;\n\tif (unlikely(!have_filled_random_ptr_key)) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\treturn string(buf, end, \"(ptrval)\", spec);\n\t}\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}", "target": 1}
{"code": "rb_reserve_next_event(struct ring_buffer *buffer,\n\t\t      struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      unsigned long length)\n{\n\tstruct ring_buffer_event *event;\n\tstruct rb_event_info info;\n\tint nr_loops = 0;\n\tu64 diff;\n\trb_start_commit(cpu_buffer);\n#ifdef CONFIG_RING_BUFFER_ALLOW_SWAP\n\tbarrier();\n\tif (unlikely(ACCESS_ONCE(cpu_buffer->buffer) != buffer)) {\n\t\tlocal_dec(&cpu_buffer->committing);\n\t\tlocal_dec(&cpu_buffer->commits);\n\t\treturn NULL;\n\t}\n#endif\n\tinfo.length = rb_calculate_event_length(length);\n again:\n\tinfo.add_timestamp = 0;\n\tinfo.delta = 0;\n\tif (RB_WARN_ON(cpu_buffer, ++nr_loops > 1000))\n\t\tgoto out_fail;\n\tinfo.ts = rb_time_stamp(cpu_buffer->buffer);\n\tdiff = info.ts - cpu_buffer->write_stamp;\n\tbarrier();\n\tif (likely(info.ts >= cpu_buffer->write_stamp)) {\n\t\tinfo.delta = diff;\n\t\tif (unlikely(test_time_stamp(info.delta)))\n\t\t\trb_handle_timestamp(cpu_buffer, &info);\n\t}\n\tevent = __rb_reserve_next(cpu_buffer, &info);\n\tif (unlikely(PTR_ERR(event) == -EAGAIN)) {\n\t\tif (info.add_timestamp)\n\t\t\tinfo.length -= RB_LEN_TIME_EXTEND;\n\t\tgoto again;\n\t}\n\tif (!event)\n\t\tgoto out_fail;\n\treturn event;\n out_fail:\n\trb_end_commit(cpu_buffer);\n\treturn NULL;\n}", "target": 0}
{"code": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}", "target": 1}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "static int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}", "target": 0}
{"code": "static int load_file(struct augeas *aug, struct lens *lens,\n                     const char *lens_name, char *filename) {\n    char *text = NULL;\n    const char *err_status = NULL;\n    struct tree *tree = NULL;\n    char *path = NULL;\n    struct lns_error *err = NULL;\n    struct span *span = NULL;\n    int result = -1, r, text_len = 0;\n    path = file_name_path(aug, filename);\n    ERR_NOMEM(path == NULL, aug);\n    r = add_file_info(aug, path, lens, lens_name, filename, false);\n    if (r < 0)\n        goto done;\n    text = xread_file(filename);\n    if (text == NULL) {\n        err_status = \"read_failed\";\n        goto done;\n    }\n    text_len = strlen(text);\n    text = append_newline(text, text_len);\n    struct info *info;\n    make_ref(info);\n    make_ref(info->filename);\n    info->filename->str = strdup(filename);\n    info->error = aug->error;\n    info->flags = aug->flags;\n    info->first_line = 1;\n    if (aug->flags & AUG_ENABLE_SPAN) {\n        span = make_span(info);\n        ERR_NOMEM(span == NULL, info);\n    }\n    tree = lns_get(info, lens, text, &err);\n    unref(info, info);\n    if (err != NULL) {\n        err_status = \"parse_failed\";\n        goto done;\n    }\n    tree_replace(aug, path, tree);\n    if (span != NULL && tree != NULL) {\n        tree->parent->span = span;\n        tree->parent->span->span_start = 0;\n        tree->parent->span->span_end = text_len;\n    }\n    tree = NULL;\n    result = 0;\n done:\n    store_error(aug, filename + strlen(aug->root) - 1, path, err_status,\n                errno, err, text);\n error:\n    free_lns_error(err);\n    free(path);\n    free_tree(tree);\n    free(text);\n    return result;\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "void LibRaw::adjust_bl()\n{\n  int clear_repeat=0;\n   if (O.user_black >= 0) \n     {\n       C.black = O.user_black;\n       clear_repeat = 1;\n     }\n   for(int i=0; i<4; i++)\n     if(O.user_cblack[i]>-1000000)\n       {\n         C.cblack[i] = O.user_cblack[i];\n         clear_repeat  = 1;\n       }\n   if(clear_repeat)\n     C.cblack[4]=C.cblack[5]=0;\n   if (imgdata.idata.filters > 1000 && (C.cblack[4]+1)/2 == 1 && (C.cblack[5]+1)/2 == 1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6 + c/2 % C.cblack[4] * C.cblack[5] + c%2 % C.cblack[5]];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n   else if(imgdata.idata.filters <= 1000 && C.cblack[4]==1 && C.cblack[5]==1) \n   {\n\t   for(int c=0; c<4; c++)\n\t\t   C.cblack[c] += C.cblack[6];\n\t   C.cblack[4]=C.cblack[5]=0;\n   }\n  int i = C.cblack[3];\n  int c;\n  for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c];\n  for(c=0;c<4;c++) C.cblack[c] -= i; \n  C.black += i;\n  if(C.cblack[4] && C.cblack[5])\n    {\n      i = C.cblack[6];\n      for(c=1; c<C.cblack[4]*C.cblack[5]; c++)\n        if(i>C.cblack[6+c]) i = C.cblack[6+c];\n      int nonz=0;\n      for(c=0; c<C.cblack[4]*C.cblack[5]; c++)\n        {\n          C.cblack[6+c]-=i;\n          if(C.cblack[6+c])nonz++;\n        }\n      C.black +=i;\n      if(!nonz)\n        C.cblack[4] = C.cblack[5] = 0;\n    }\n  for(c=0;c<4;c++) C.cblack[c] += C.black; \n}", "target": 0}
{"code": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS (s);\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n      if ((s = msg_parse_flags (h, s)) == NULL)\n        return -1;\n    }\n    else if (ascii_strncasecmp (\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS (s);\n      if (mutt_atoui (s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word (s);\n    }\n    else if (ascii_strncasecmp (\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error (\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "int expand_upwards(struct vm_area_struct *vma, unsigned long address)\n{\n\tint error;\n\tif (!(vma->vm_flags & VM_GROWSUP))\n\t\treturn -EFAULT;\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock(vma);\n\tif (address < PAGE_ALIGN(address+4))\n\t\taddress = PAGE_ALIGN(address+4);\n\telse {\n\t\tanon_vma_unlock(vma);\n\t\treturn -ENOMEM;\n\t}\n\terror = 0;\n\tif (address > vma->vm_end) {\n\t\tunsigned long size, grow;\n\t\tsize = address - vma->vm_start;\n\t\tgrow = (address - vma->vm_end) >> PAGE_SHIFT;\n\t\terror = acct_stack_growth(vma, size, grow);\n\t\tif (!error)\n\t\t\tvma->vm_end = address;\n\t}\n\tanon_vma_unlock(vma);\n\treturn error;\n}", "target": 0}
{"code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\tif (!fepriv)\n\t\treturn;\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}", "target": 1}
{"code": "nodeVPush(xmlValidCtxtPtr ctxt, xmlNodePtr value)\n{\n    if (ctxt->nodeMax <= 0) {\n        ctxt->nodeMax = 4;\n        ctxt->nodeTab =\n            (xmlNodePtr *) xmlMalloc(ctxt->nodeMax *\n                                     sizeof(ctxt->nodeTab[0]));\n        if (ctxt->nodeTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n            ctxt->nodeMax = 0;\n            return (0);\n        }\n    }\n    if (ctxt->nodeNr >= ctxt->nodeMax) {\n        xmlNodePtr *tmp;\n        tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n\t\t\t      ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"realloc failed\");\n            return (0);\n        }\n        ctxt->nodeMax *= 2;\n\tctxt->nodeTab = tmp;\n    }\n    ctxt->nodeTab[ctxt->nodeNr] = value;\n    ctxt->node = value;\n    return (ctxt->nodeNr++);\n}", "target": 0}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "void VideoRendererBase::Flush(const base::Closure& callback) {\n  base::AutoLock auto_lock(lock_);\n  DCHECK_EQ(state_, kPaused);\n  flush_cb_ = callback;\n  state_ = kFlushingDecoder;\n  base::AutoUnlock auto_unlock(lock_);\n  decoder_->Reset(base::Bind(&VideoRendererBase::OnDecoderFlushDone, this));\n}", "target": 0}
{"code": "STATIC int\nS_edit_distance(const UV* src,\n                const UV* tgt,\n                const STRLEN x,             \n                const STRLEN y,             \n                const SSize_t maxDistance\n)\n{\n    item *head = NULL;\n    UV swapCount, swapScore, targetCharCount, i, j;\n    UV *scores;\n    UV score_ceil = x + y;\n    PERL_ARGS_ASSERT_EDIT_DISTANCE;\n    Newx(scores, ( (x + 2) * (y + 2)), UV);\n    scores[0] = score_ceil;\n    scores[1 * (y + 2) + 0] = score_ceil;\n    scores[0 * (y + 2) + 1] = score_ceil;\n    scores[1 * (y + 2) + 1] = 0;\n    head = uniquePush(uniquePush(head, src[0]), tgt[0]);\n    for (i=1;i<=x;i++) {\n        if (i < x)\n            head = uniquePush(head, src[i]);\n        scores[(i+1) * (y + 2) + 1] = i;\n        scores[(i+1) * (y + 2) + 0] = score_ceil;\n        swapCount = 0;\n        for (j=1;j<=y;j++) {\n            if (i == 1) {\n                if(j < y)\n                head = uniquePush(head, tgt[j]);\n                scores[1 * (y + 2) + (j + 1)] = j;\n                scores[0 * (y + 2) + (j + 1)] = score_ceil;\n            }\n            targetCharCount = find(head, tgt[j-1])->value;\n            swapScore = scores[targetCharCount * (y + 2) + swapCount] + i - targetCharCount - 1 + j - swapCount;\n            if (src[i-1] != tgt[j-1]){\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(swapScore,(MIN(scores[i * (y + 2) + j], MIN(scores[(i+1) * (y + 2) + j], scores[i * (y + 2) + (j + 1)])) + 1));\n            }\n            else {\n                swapCount = j;\n                scores[(i+1) * (y + 2) + (j + 1)] = MIN(scores[i * (y + 2) + j], swapScore);\n            }\n        }\n        find(head, src[i-1])->value = i;\n    }\n    {\n        IV score = scores[(x+1) * (y + 2) + (y + 1)];\n        dict_free(head);\n        Safefree(scores);\n        return (maxDistance != 0 && maxDistance < score)?(-1):score;\n    }", "target": 0}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "static inline void mpeg4_encode_dc(PutBitContext *s, int level, int n)\n{\n#if 1\n    level += 256;\n    if (n < 4) {\n        put_bits(s, uni_DCtab_lum_len[level], uni_DCtab_lum_bits[level]);\n    } else {\n        put_bits(s, uni_DCtab_chrom_len[level], uni_DCtab_chrom_bits[level]);\n    }\n#else\n    int size, v;\n    size = 0;\n    v    = abs(level);\n    while (v) {\n        v >>= 1;\n        size++;\n    }\n    if (n < 4) {\n        put_bits(s, ff_mpeg4_DCtab_lum[size][1], ff_mpeg4_DCtab_lum[size][0]);\n    } else {\n        put_bits(s, ff_mpeg4_DCtab_chrom[size][1], ff_mpeg4_DCtab_chrom[size][0]);\n    }\n    if (size > 0) {\n        if (level < 0)\n            level = (-level) ^ ((1 << size) - 1);\n        put_bits(s, size, level);\n        if (size > 8)\n            put_bits(s, 1, 1);\n    }\n#endif\n}", "target": 0}
{"code": "static int chdir_to_parent(char *copy, const char **lastp)\n{\n\tchar *tmp;\n\tconst char *parent;\n\tchar buf[65536];\n\tint res;\n\ttmp = strrchr(copy, '/');\n\tif (tmp == NULL || tmp[1] == '\\0') {\n\t\tfprintf(stderr, \"%s: internal error: invalid abs path: <%s>\\n\",\n\t\t\tprogname, copy);\n\t\treturn -1;\n\t}\n\tif (tmp != copy) {\n\t\t*tmp = '\\0';\n\t\tparent = copy;\n\t\t*lastp = tmp + 1;\n\t} else if (tmp[1] != '\\0') {\n\t\t*lastp = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\t*lastp = \".\";\n\t\tparent = \"/\";\n\t}\n\tres = chdir(parent);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to %s: %s\\n\",\n\t\t\tprogname, parent, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (getcwd(buf, sizeof(buf)) == NULL) {\n\t\tfprintf(stderr, \"%s: failed to obtain current directory: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, parent) != 0) {\n\t\tfprintf(stderr, \"%s: mountpoint moved (%s -> %s)\\n\", progname,\n\t\t\tparent, buf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "zzip_dir_fdopen_ext_io(int fd, zzip_error_t * errcode_p,\n                       zzip_strings_t * ext, const zzip_plugin_io_t io)\n{\n    zzip_error_t rv;\n    ZZIP_DIR *dir;\n    if ((dir = zzip_dir_alloc_ext_io(ext, io)) == NULL)\n        { rv = ZZIP_OUTOFMEM; goto error; }\n    dir->fd = fd;\n    if ((rv = __zzip_dir_parse(dir)))\n        goto error;\n    dir->hdr = dir->hdr0;\n    dir->refcount |= 0x10000000;\n    if (errcode_p)\n        *errcode_p = rv;\n    return dir;\n  error:\n    if (dir)\n        zzip_dir_free(dir);\n    if (errcode_p)\n        *errcode_p = rv;\n    return NULL;\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);\n\t\t\tpk->keyid[0] = _cdk_buftou32(buf + 12);\n\t\t\tpk->keyid[1] = _cdk_buftou32(buf + 16);\n\t\t}\n\t}\n\tlowbits = pk ? pk->keyid[1] : 0;\n\tif (keyid && pk) {\n\t\tkeyid[0] = pk->keyid[0];\n\t\tkeyid[1] = pk->keyid[1];\n\t}\n\treturn lowbits;\n}", "target": 1}
{"code": "ldns_tsig_keydata(const ldns_tsig_credentials *tc)\n{\n\treturn tc->keydata;\n}", "target": 0}
{"code": "int zmq::stream_engine_t::pull_and_encode (msg_t *msg_)\n{\n    zmq_assert (mechanism != NULL);\n    if (session->pull_msg (msg_) == -1)\n        return -1;\n    if (mechanism->encode (msg_) == -1)\n        return -1;\n    return 0;\n}", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "void GfxPath::append(GfxPath *path)\n{\n    int i;\n    if (n + path->n > size) {\n        size = n + path->n;\n        subpaths = (GfxSubpath **)greallocn(subpaths, size, sizeof(GfxSubpath *));\n    }\n    for (i = 0; i < path->n; ++i) {\n        subpaths[n++] = path->subpaths[i]->copy();\n    }\n    justMoved = false;\n}", "target": 0}
{"code": "static void decode_ltp(LongTermPrediction *ltp,\n                       GetBitContext *gb, uint8_t max_sfb)\n{\n    int sfb;\n    ltp->lag  = get_bits(gb, 11);\n    ltp->coef = ltp_coef[get_bits(gb, 3)];\n    for (sfb = 0; sfb < FFMIN(max_sfb, MAX_LTP_LONG_SFB); sfb++)\n        ltp->used[sfb] = get_bits1(gb);\n}", "target": 0}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint space;\n\tif (tp->rcvq_space.time == 0)\n\t\tgoto new_measure;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tspace = 2 * (tp->copied_seq - tp->rcvq_space.seq);\n\tspace = max(tp->rcvq_space.space, space);\n\tif (tp->rcvq_space.space != space) {\n\t\tint rcvmem;\n\t\ttp->rcvq_space.space = space;\n\t\tif (sysctl_tcp_moderate_rcvbuf &&\n\t\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\t\tint new_clamp = space;\n\t\t\tspace /= tp->advmss;\n\t\t\tif (!space)\n\t\t\t\tspace = 1;\n\t\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\t\trcvmem += 128;\n\t\t\tspace *= rcvmem;\n\t\t\tspace = min(space, sysctl_tcp_rmem[2]);\n\t\t\tif (space > sk->sk_rcvbuf) {\n\t\t\t\tsk->sk_rcvbuf = space;\n\t\t\t\ttp->window_clamp = new_clamp;\n\t\t\t}\n\t\t}\n\t}\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "mono_dllmap_lookup (MonoImage *assembly, const char *dll, const char* func, const char **rdll, const char **rfunc)\n{\n\tint res;\n\tif (assembly && assembly->dll_map) {\n\t\tres = mono_dllmap_lookup_list (assembly->dll_map, dll, func, rdll, rfunc);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn mono_dllmap_lookup_list (global_dll_map, dll, func, rdll, rfunc);\n}", "target": 0}
{"code": "get_parent_resource(const dav_resource *resource,\n                    dav_resource **parent_resource)\n{\n  dav_resource *parent;\n  dav_resource_private *parentinfo;\n  svn_stringbuf_t *path = resource->info->uri_path;\n  *parent_resource = NULL;\n  if (path->len == 1 && *path->data == '/')\n    return NULL;\n  switch (resource->type)\n    {\n    case DAV_RESOURCE_TYPE_REGULAR:\n      parent = apr_pcalloc(resource->pool, sizeof(*parent));\n      parentinfo  = apr_pcalloc(resource->pool, sizeof(*parentinfo));\n      parent->type = DAV_RESOURCE_TYPE_REGULAR;\n      parent->exists = 1;\n      parent->collection = 1;\n      parent->versioned = 1;\n      parent->hooks = resource->hooks;\n      parent->pool = resource->pool;\n      parent->uri = get_parent_path(svn_urlpath__canonicalize(resource->uri,\n                                                              resource->pool),\n                                    TRUE, resource->pool);\n      parent->info = parentinfo;\n      parentinfo->uri_path =\n        svn_stringbuf_create(get_parent_path(resource->info->uri_path->data,\n                                             TRUE, resource->pool),\n                             resource->pool);\n      parentinfo->repos = resource->info->repos;\n      parentinfo->root = resource->info->root;\n      parentinfo->r = resource->info->r;\n      parentinfo->svn_client_options = resource->info->svn_client_options;\n      parentinfo->repos_path = get_parent_path(resource->info->repos_path,\n                                               FALSE, resource->pool);\n      *parent_resource = parent;\n      break;\n    case DAV_RESOURCE_TYPE_WORKING:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_WRK_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_ACTIVITY:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_ACT_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_PRIVATE:\n      if ((resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)\n          || (resource->info->restype == DAV_SVN_RESTYPE_REV_COLLECTION))\n        *parent_resource =\n          create_private_resource(resource, resource->info->restype);\n      break;\n    default:\n      break;\n    }\n  if (! *parent_resource)\n    return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              apr_psprintf(resource->pool,\n                                           \"get_parent_resource was called for \"\n                                           \"%s (type %d)\",\n                                           resource->uri, resource->type));\n  return NULL;\n}", "target": 1}
{"code": "static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *RESTRICT mspace, size_t size, size_t alignment, unsigned flags) THROWSPEC\n{\n\tvoid *RESTRICT ret=0;\n#if USE_MAGIC_HEADERS\n\tsize_t _alignment=alignment;\n\tsize_t *_ret=0;\n\tsize+=alignment+3*sizeof(size_t);\n\t_alignment=0;\n#endif\n#if USE_ALLOCATOR==0\n\tret=(flags & M2_ZERO_MEMORY) ? syscalloc(1, size) : sysmalloc(size);\t\n#elif USE_ALLOCATOR==1\n\tret=mspace_malloc2((mstate) mspace, size, alignment, flags);\n#ifndef ENABLE_FAST_HEAP_DETECTION\n\tif(ret)\n\t{\n\t\tmchunkptr p=mem2chunk(ret);\n\t\tsize_t truesize=chunksize(p) - overhead_for(p);\n\t\tif(!leastusedaddress || (void *)((mstate) mspace)->least_addr<leastusedaddress) leastusedaddress=(void *)((mstate) mspace)->least_addr;\n\t\tif(!largestusedblock || truesize>largestusedblock) largestusedblock=(truesize+mparams.page_size) & ~(mparams.page_size-1);\n\t}\n#endif\n#endif\n\tif(!ret) return 0;\n#if DEBUG\n\tif(flags & M2_ZERO_MEMORY)\n\t{\n\t\tconst char *RESTRICT n;\n\t\tfor(n=(const char *)ret; n<(const char *)ret+size; n++)\n\t\t{\n\t\t\tassert(!*n);\n\t\t}\n\t}\n#endif\n#if USE_MAGIC_HEADERS\n\t_ret=(size_t *) ret;\n\tret=(void *)(_ret+3);\n\tif(alignment) ret=(void *)(((size_t) ret+alignment-1)&~(alignment-1));\n\tfor(; _ret<(size_t *)ret-2; _ret++) *_ret=*(size_t *)\"NEDMALOC\";\n\t_ret[0]=(size_t) mspace;\n\t_ret[1]=size-3*sizeof(size_t);\n#endif\n\treturn ret;\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 1}
{"code": "ZEND_API zend_bool zend_make_callable(zval *callable, char **callable_name TSRMLS_DC) \n{\n\tzend_fcall_info_cache fcc;\n\tif (zend_is_callable_ex(callable, NULL, IS_CALLABLE_STRICT, callable_name, NULL, &fcc, NULL TSRMLS_CC)) {\n\t\tif (Z_TYPE_P(callable) == IS_STRING && fcc.calling_scope) {\n\t\t\tzval_dtor(callable);\n\t\t\tarray_init(callable);\n\t\t\tadd_next_index_string(callable, fcc.calling_scope->name, 1);\n\t\t\tadd_next_index_string(callable, fcc.function_handler->common.function_name, 1);\n\t\t}\n\t\tif (fcc.function_handler &&\n\t\t\t((fcc.function_handler->type == ZEND_INTERNAL_FUNCTION &&\n\t\t      (fcc.function_handler->common.fn_flags & ZEND_ACC_CALL_VIA_HANDLER)) ||\n\t\t     fcc.function_handler->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY ||\n\t\t     fcc.function_handler->type == ZEND_OVERLOADED_FUNCTION)) {\n\t\t\tif (fcc.function_handler->type != ZEND_OVERLOADED_FUNCTION) {\n\t\t\t\tefree((char*)fcc.function_handler->common.function_name);\n\t\t\t}\n\t\t\tefree(fcc.function_handler);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "mysql_set_local_infile_handler(MYSQL *mysql,\n                               int (*local_infile_init)(void **, const char *,\n                               void *),\n                               int (*local_infile_read)(void *, char *, uint),\n                               void (*local_infile_end)(void *),\n                               int (*local_infile_error)(void *, char *, uint),\n                               void *userdata)\n{\n  mysql->options.local_infile_init=  local_infile_init;\n  mysql->options.local_infile_read=  local_infile_read;\n  mysql->options.local_infile_end=   local_infile_end;\n  mysql->options.local_infile_error= local_infile_error;\n  mysql->options.local_infile_userdata = userdata;\n}", "target": 0}
{"code": "static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tmutex_lock(&cfg80211_mutex);\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif_idx = 0;\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev) < 0) {\n\t\t\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\twp_idx++;\n\t}\n out:\n\tmutex_unlock(&cfg80211_mutex);\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "void PCM::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tif (m_track->totalfframes != -1 &&\n\t\tm_track->nextfframe + framesToRead > m_track->totalfframes)\n\t{\n\t\tframesToRead = m_track->totalfframes - m_track->nextfframe;\n\t}\n\tssize_t bytesRead = read(m_outChunk->buffer, m_bytesPerFrame * framesToRead);\n\tAFframecount framesRead = bytesRead >= 0 ? bytesRead / m_bytesPerFrame : 0;\n\tCHNK(printf(\"reading %\" AF_FRAMECOUNT_PRINT_FMT \" frames from pcm file \"\n\t\t\"(got %\" AF_FRAMECOUNT_PRINT_FMT \")\\n\",\n\t\tframesToRead, framesRead));\n\tm_track->nextfframe += framesRead;\n\tm_track->fpos_next_frame += (framesRead>0) ? framesRead * m_bytesPerFrame : 0;\n\tassert(!canSeek() || (tell() == m_track->fpos_next_frame));\n\tif (framesRead != framesToRead && m_track->totalfframes != -1)\n\t{\n\t\tif (m_track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"file missing data -- read %d frames, \"\n\t\t\t\t\"should be %d\",\n\t\t\t\tm_track->nextfframe,\n\t\t\t\tm_track->totalfframes);\n\t\t\tm_track->filemodhappy = false;\n\t\t}\n\t}\n\tm_outChunk->frameCount = framesRead;\n}", "target": 0}
{"code": "static unsigned char ttyio_in(int timeout)\n{\n\tstruct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;\n\tchar rv;\n\tif (wait_for_completion_timeout(&ldisc_data->completion,\n\t\t\t\t\tusecs_to_jiffies(timeout)) == 0) {\n\t\tif (timeout)\n\t\t\tpr_warn(\"spk_ttyio: timeout (%d)  while waiting for input\\n\",\n\t\t\t\ttimeout);\n\t\treturn 0xff;\n\t}\n\trv = ldisc_data->buf;\n\tmb();\n\tldisc_data->buf_free = true;\n\ttty_schedule_flip(speakup_tty->port);\n\treturn rv;\n}", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "vte_sequence_handler_ho (VteTerminal *terminal, GValueArray *params)\n{\n\t_vte_terminal_home_cursor (terminal);\n}", "target": 0}
{"code": "static uint64_t pit_ioport_read(void *opaque, hwaddr addr,\n                                unsigned size)\n{\n    PITCommonState *pit = opaque;\n    int ret, count;\n    PITChannelState *s;\n    addr &= 3;\n    s = &pit->channels[addr];\n    if (s->status_latched) {\n        s->status_latched = 0;\n        ret = s->status;\n    } else if (s->count_latched) {\n        switch(s->count_latched) {\n        default:\n        case RW_STATE_LSB:\n            ret = s->latched_count & 0xff;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_MSB:\n            ret = s->latched_count >> 8;\n            s->count_latched = 0;\n            break;\n        case RW_STATE_WORD0:\n            ret = s->latched_count & 0xff;\n            s->count_latched = RW_STATE_MSB;\n            break;\n        }\n    } else {\n        switch(s->read_state) {\n        default:\n        case RW_STATE_LSB:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            break;\n        case RW_STATE_MSB:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            break;\n        case RW_STATE_WORD0:\n            count = pit_get_count(s);\n            ret = count & 0xff;\n            s->read_state = RW_STATE_WORD1;\n            break;\n        case RW_STATE_WORD1:\n            count = pit_get_count(s);\n            ret = (count >> 8) & 0xff;\n            s->read_state = RW_STATE_WORD0;\n            break;\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "static bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\treturn false;\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}", "target": 0}
{"code": "int fuse_fs_write(struct fuse_fs *fs, const char *path, const char *buf,\n                  size_t size, off_t off, struct fuse_file_info *fi)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.write)\n        return fs->op.write(path, buf, size, off, fi);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "void WebContentsImpl::IncrementCapturerCount() {\n  DCHECK(!is_being_destroyed_);\n  ++capturer_count_;\n  DVLOG(1) << \"There are now \" << capturer_count_\n           << \" capturing(s) of WebContentsImpl@\" << this;\n}", "target": 0}
{"code": "comics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = comics_document_finalize;\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}", "target": 0}
{"code": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n  register const double\n    *p;\n  register double\n    *q;\n  register ssize_t\n    i;\n  size_t\n    n;\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}", "target": 1}
{"code": "static inline void CheckEventLogging()\n{\n  if (IsLinkedListEmpty(log_cache) != MagickFalse)\n    event_logging=MagickFalse;\n  else\n    {\n      LogInfo\n        *p;\n      ResetLinkedListIterator(log_cache);\n      p=(LogInfo *) GetNextValueInLinkedList(log_cache);\n      event_logging=p->event_mask != NoEvents ? MagickTrue: MagickFalse;\n    }\n}", "target": 1}
{"code": "void InstanceKlass::initialize_super_interfaces(TRAPS) {\n  assert (has_nonstatic_concrete_methods(), \"caller should have checked this\");\n  for (int i = 0; i < local_interfaces()->length(); ++i) {\n    InstanceKlass* ik = local_interfaces()->at(i);\n    if (ik->has_nonstatic_concrete_methods()) {\n      ik->initialize_super_interfaces(CHECK);\n    }\n    if (ik->should_be_initialized() && ik->declares_nonstatic_concrete_methods()) {\n      ik->initialize(CHECK);\n    }\n  }\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\tif (!bio_flagged(bio, BIO_NULL_MAPPED)) {\n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "gboolean tcmulib_callback(GIOChannel *source,\n\t\t\t  GIOCondition condition,\n\t\t\t  gpointer data)\n{\n\tstruct tcmulib_context *ctx = data;\n\ttcmulib_master_fd_ready(ctx);\n\treturn TRUE;\n}", "target": 0}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static long vhost_net_reset_owner(struct vhost_net *n)\n{\n\tstruct socket *tx_sock = NULL;\n\tstruct socket *rx_sock = NULL;\n\tlong err;\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tvhost_net_stop(n, &tx_sock, &rx_sock);\n\tvhost_net_flush(n);\n\terr = vhost_dev_reset_owner(&n->dev);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\tif (tx_sock)\n\t\tfput(tx_sock->file);\n\tif (rx_sock)\n\t\tfput(rx_sock->file);\n\treturn err;\n}", "target": 0}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "void __init psi_init(void)\n{\n\tif (!psi_enable) {\n\t\tstatic_branch_enable(&psi_disabled);\n\t\treturn;\n\t}\n\tpsi_period = jiffies_to_nsecs(PSI_FREQ);\n\tgroup_init(&psi_system);\n}", "target": 0}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "_dbus_lookup_launchd_socket (DBusString *socket_path,\n                             const char *launchd_env_var,\n                             DBusError  *error)\n{\n#ifdef DBUS_ENABLE_LAUNCHD\n  char *argv[4];\n  int i;\n  _DBUS_ASSERT_ERROR_IS_CLEAR (error);\n  if (_dbus_check_setuid ())\n    {\n      dbus_set_error_const (error, DBUS_ERROR_NOT_SUPPORTED,\n                            \"Unable to find launchd socket when setuid\");\n      return FALSE;\n    }\n  i = 0;\n  argv[i] = \"launchctl\";\n  ++i;\n  argv[i] = \"getenv\";\n  ++i;\n  argv[i] = (char*)launchd_env_var;\n  ++i;\n  argv[i] = NULL;\n  ++i;\n  _dbus_assert (i == _DBUS_N_ELEMENTS (argv));\n  if (!_read_subprocess_line_argv(argv[0], TRUE, argv, socket_path, error))\n    {\n      return FALSE;\n    }\n  if (_dbus_string_get_length(socket_path) == 0)\n    {\n      return FALSE;\n    }\n  _dbus_string_shorten(socket_path, 1);\n  return TRUE;\n#else \n  dbus_set_error(error, DBUS_ERROR_NOT_SUPPORTED,\n                \"can't lookup socket from launchd; launchd support not compiled in\");\n  return FALSE;\n#endif\n}", "target": 0}
{"code": "static inline void perf_get_data_addr(struct pt_regs *regs, u64 *addrp) { }", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(time, time_t __user *, tloc)\n{\n\ttime_t i = get_seconds();\n\tif (tloc) {\n\t\tif (put_user(i,tloc))\n\t\t\treturn -EFAULT;\n\t}\n\tforce_successful_syscall_return();\n\treturn i;\n}", "target": 0}
{"code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\treturn prop;\n}", "target": 1}
{"code": "__mem_cgroup_commit_charge_swapin(struct page *page, struct mem_cgroup *memcg,\n\t\t\t\t\tenum charge_type ctype)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\tcgroup_exclude_rmdir(&memcg->css);\n\t__mem_cgroup_commit_charge_lrucare(page, memcg, ctype);\n\tif (do_swap_account && PageSwapCache(page)) {\n\t\tswp_entry_t ent = {.val = page_private(page)};\n\t\tstruct mem_cgroup *swap_memcg;\n\t\tunsigned short id;\n\t\tid = swap_cgroup_record(ent, 0);\n\t\trcu_read_lock();\n\t\tswap_memcg = mem_cgroup_lookup(id);\n\t\tif (swap_memcg) {\n\t\t\tif (!mem_cgroup_is_root(swap_memcg))\n\t\t\t\tres_counter_uncharge(&swap_memcg->memsw,\n\t\t\t\t\t\t     PAGE_SIZE);\n\t\t\tmem_cgroup_swap_statistics(swap_memcg, false);\n\t\t\tmem_cgroup_put(swap_memcg);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tcgroup_release_and_wakeup_rmdir(&memcg->css);\n}", "target": 0}
{"code": "void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunion cpu_time_count now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tint clear_dead;\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\tif (timer->it.cpu.expires.sched == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\tif (unlikely(p == NULL)) {\n\tdead:\n\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t   &itp->it_value);\n\t\treturn;\n\t}\n\tif (CPUCLOCK_PERTHREAD(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tclear_dead = p->exit_state;\n\t} else {\n\t\tread_lock(&tasklist_lock);\n\t\tif (unlikely(p->signal == NULL)) {\n\t\t\tput_task_struct(p);\n\t\t\ttimer->it.cpu.task = NULL;\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\tread_unlock(&tasklist_lock);\n\t\t\tgoto dead;\n\t\t} else {\n\t\t\tcpu_clock_sample_group(timer->it_clock, p, &now);\n\t\t\tclear_dead = (unlikely(p->exit_state) &&\n\t\t\t\t      thread_group_empty(p));\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tif ((timer->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE) {\n\t\tif (timer->it.cpu.incr.sched == 0 &&\n\t\t    cpu_time_before(timer->it_clock,\n\t\t\t\t    timer->it.cpu.expires, now)) {\n\t\t\ttimer->it.cpu.expires.sched = 0;\n\t\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\t\treturn;\n\t\t}\n\t\tbump_cpu_timer(timer, now);\n\t}\n\tif (unlikely(clear_dead)) {\n\t\tclear_dead_task(timer, now);\n\t\tgoto dead;\n\t}\n\tif (cpu_time_before(timer->it_clock, now, timer->it.cpu.expires)) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   cpu_time_sub(timer->it_clock,\n\t\t\t\t\t\ttimer->it.cpu.expires, now),\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}", "target": 0}
{"code": "static int sctp_setsockopt_partial_delivery_point(struct sock *sk,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int optlen)\n{\n\tu32 val;\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tsctp_sk(sk)->pd_point = val;\n\treturn 0; \n}", "target": 0}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *end; \n#ifdef DEBUG\n    nbParseNCNameComplex++;\n#endif\n    GROW;\n    end = ctxt->input->cur;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || \n\t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n\treturn(NULL);\n    }\n    while ((c != ' ') && (c != '>') && (c != '/') && \n\t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n            if ((len > XML_MAX_NAME_LENGTH) &&\n                ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n                return(NULL);\n            }\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tend = ctxt->input->cur;\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    ctxt->input->cur -= l;\n\t    GROW;\n\t    ctxt->input->cur += l;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t    end = ctxt->input->cur;\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((len > XML_MAX_NAME_LENGTH) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n        return(NULL);\n    }\n    return(xmlDictLookup(ctxt->dict, end - len, len));\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "try_flatedecode(unsigned char *buf, off_t real_len, off_t calculated_len, int fout, cli_ctx *ctx)\n{\n\tint ret = cli_checklimits(\"cli_pdf\", ctx, real_len, 0, 0);\n\tif (ret==CL_CLEAN && flatedecode(buf, real_len, fout, ctx) == CL_SUCCESS)\n\t\treturn CL_CLEAN;\n\tif(real_len == calculated_len) {\n\t\tcli_dbgmsg(\"cli_pdf: Bad compression in flate stream\\n\");\n\t\treturn CL_CLEAN;\n\t}\n\tif(cli_checklimits(\"cli_pdf\", ctx, calculated_len, 0, 0)!=CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tret = flatedecode(buf, calculated_len, fout, ctx);\n\tif(ret == CL_CLEAN)\n\t\treturn CL_CLEAN;\n\tcli_dbgmsg(\"cli_pdf: Bad compressed block length in flate stream\\n\");\n\treturn ret;\n}", "target": 0}
{"code": "static int create_srq_ring(PCIDevice *pci_dev, PvrdmaRing **ring,\n                           uint64_t pdir_dma, uint32_t max_wr,\n                           uint32_t max_sge, uint32_t nchunks)\n{\n    uint64_t *dir = NULL, *tbl = NULL;\n    PvrdmaRing *r;\n    int rc = -EINVAL;\n    char ring_name[MAX_RING_NAME_SZ];\n    uint32_t wqe_sz;\n    if (!nchunks || nchunks > PVRDMA_MAX_FAST_REG_PAGES) {\n        rdma_error_report(\"Got invalid page count for SRQ ring: %d\",\n                          nchunks);\n        return rc;\n    }\n    dir = rdma_pci_dma_map(pci_dev, pdir_dma, TARGET_PAGE_SIZE);\n    if (!dir) {\n        rdma_error_report(\"Failed to map to SRQ page directory\");\n        goto out;\n    }\n    tbl = rdma_pci_dma_map(pci_dev, dir[0], TARGET_PAGE_SIZE);\n    if (!tbl) {\n        rdma_error_report(\"Failed to map to SRQ page table\");\n        goto out;\n    }\n    r = g_malloc(sizeof(*r));\n    *ring = r;\n    r->ring_state = (PvrdmaRingState *)\n            rdma_pci_dma_map(pci_dev, tbl[0], TARGET_PAGE_SIZE);\n    if (!r->ring_state) {\n        rdma_error_report(\"Failed to map tp SRQ ring state\");\n        goto out_free_ring_mem;\n    }\n    wqe_sz = pow2ceil(sizeof(struct pvrdma_rq_wqe_hdr) +\n                      sizeof(struct pvrdma_sge) * max_sge - 1);\n    sprintf(ring_name, \"srq_ring_%\" PRIx64, pdir_dma);\n    rc = pvrdma_ring_init(r, ring_name, pci_dev, &r->ring_state[1], max_wr,\n                          wqe_sz, (dma_addr_t *)&tbl[1], nchunks - 1);\n    if (rc) {\n        goto out_unmap_ring_state;\n    }\n    goto out;\nout_unmap_ring_state:\n    rdma_pci_dma_unmap(pci_dev, r->ring_state, TARGET_PAGE_SIZE);\nout_free_ring_mem:\n    g_free(r);\nout:\n    rdma_pci_dma_unmap(pci_dev, tbl, TARGET_PAGE_SIZE);\n    rdma_pci_dma_unmap(pci_dev, dir, TARGET_PAGE_SIZE);\n    return rc;\n}", "target": 0}
{"code": "bool RenderView::IsNonLocalTopLevelNavigation(\n    const GURL& url, WebKit::WebFrame* frame, WebKit::WebNavigationType type) {\n  if (frame->parent() != NULL)\n    return false;\n  if (!url.SchemeIs(\"http\") && !url.SchemeIs(\"https\"))\n    return false;\n  GURL frame_url(frame->url());\n  if (!frame_url.SchemeIs(\"http\") && !frame_url.SchemeIs(\"https\"))\n    return false;\n  GURL frame_origin = frame_url.GetOrigin();\n  if (url.GetOrigin() != frame_origin || url.ref().empty()) {\n    if (type == WebKit::WebNavigationTypeLinkClicked)\n      return true;\n    if (last_top_level_navigation_page_id_ != page_id_ &&\n        type != WebKit::WebNavigationTypeReload &&\n        type != WebKit::WebNavigationTypeFormSubmitted &&\n        type != WebKit::WebNavigationTypeBackForward) {\n      return true;\n    }\n  }\n  if (type != WebKit::WebNavigationTypeReload &&\n      type != WebKit::WebNavigationTypeFormSubmitted &&\n      type != WebKit::WebNavigationTypeBackForward) {\n    WebKit::WebFrame* opener = frame->opener();\n    if (opener) {\n      if (url.GetOrigin() != GURL(opener->url()).GetOrigin())\n        return true;\n    }\n  }\n  return false;\n}", "target": 0}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "tiff_document_get_page_size (EvDocument *document,\n\t\t\t     EvPage     *page,\n\t\t\t     double     *width,\n\t\t\t     double     *height)\n{\n\tguint32 w, h;\n\tgfloat x_res, y_res;\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tg_return_if_fail (TIFF_IS_DOCUMENT (document));\n\tg_return_if_fail (tiff_document->tiff != NULL);\n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, page->index) != 1) {\n\t\tpop_handlers ();\n\t\treturn;\n\t}\n\tTIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &h);\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\th = h * (x_res / y_res);\n\t*width = w;\n\t*height = h;\n\tpop_handlers ();\n}", "target": 0}
{"code": "static int count_fuse_fs(void)\n{\n\tstruct mntent *entp;\n\tint count = 0;\n\tconst char *mtab = _PATH_MOUNTED;\n\tFILE *fp = setmntent(mtab, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname, mtab,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (strcmp(entp->mnt_type, \"fuse\") == 0 ||\n\t\t    strncmp(entp->mnt_type, \"fuse.\", 5) == 0)\n\t\t\tcount ++;\n\t}\n\tendmntent(fp);\n\treturn count;\n}", "target": 0}
{"code": "gimp_channel_get_node (GimpFilter *filter)\n{\n  GimpDrawable *drawable = GIMP_DRAWABLE (filter);\n  GimpChannel  *channel  = GIMP_CHANNEL (filter);\n  GeglNode     *node;\n  GeglNode     *source;\n  GeglNode     *mode_node;\n  const Babl   *color_format;\n  node = GIMP_FILTER_CLASS (parent_class)->get_node (filter);\n  source = gimp_drawable_get_source_node (drawable);\n  gegl_node_add_child (node, source);\n  g_warn_if_fail (channel->color_node == NULL);\n  if (gimp_drawable_get_linear (drawable))\n    color_format = babl_format (\"RGBA float\");\n  else\n    color_format = babl_format (\"R'G'B'A float\");\n  channel->color_node = gegl_node_new_child (node,\n                                             \"operation\", \"gegl:color\",\n                                             \"format\",    color_format,\n                                             NULL);\n  gimp_gegl_node_set_color (channel->color_node,\n                            &channel->color);\n  g_warn_if_fail (channel->mask_node == NULL);\n  channel->mask_node = gegl_node_new_child (node,\n                                            \"operation\", \"gegl:opacity\",\n                                            NULL);\n  gegl_node_connect_to (channel->color_node, \"output\",\n                        channel->mask_node,  \"input\");\n  g_warn_if_fail (channel->invert_node == NULL);\n  channel->invert_node = gegl_node_new_child (node,\n                                              \"operation\", \"gegl:invert-linear\",\n                                              NULL);\n  if (channel->show_masked)\n    {\n      gegl_node_connect_to (source,               \"output\",\n                            channel->invert_node, \"input\");\n      gegl_node_connect_to (channel->invert_node, \"output\",\n                            channel->mask_node,   \"aux\");\n    }\n  else\n    {\n      gegl_node_connect_to (source,             \"output\",\n                            channel->mask_node, \"aux\");\n    }\n  mode_node = gimp_drawable_get_mode_node (drawable);\n  gegl_node_connect_to (channel->mask_node, \"output\",\n                        mode_node,          \"aux\");\n  return node;\n}", "target": 0}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n  if (*re_ast == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n   (*re_ast)->flags = 0;\n   (*re_ast)->root_node = NULL;\n   return ERROR_SUCCESS;\n}", "target": 1}
{"code": "void hid_reset(HIDState *hs)\n{\n    switch (hs->kind) {\n    case HID_KEYBOARD:\n        memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes));\n        memset(hs->kbd.key, 0, sizeof(hs->kbd.key));\n        hs->kbd.keys = 0;\n        break;\n    case HID_MOUSE:\n    case HID_TABLET:\n        memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue));\n        break;\n    }\n    hs->head = 0;\n    hs->n = 0;\n    hs->protocol = 1;\n    hs->idle = 0;\n    hs->idle_pending = false;\n    hid_del_idle_timer(hs);\n}", "target": 1}
{"code": "de265_error decoder_context::decode(int* more)\n{\n  decoder_context* ctx = this;\n  if (ctx->nal_parser.get_NAL_queue_length() == 0 &&\n      (ctx->nal_parser.is_end_of_stream() || ctx->nal_parser.is_end_of_frame()) &&\n      ctx->image_units.empty()) {\n    ctx->dpb.flush_reorder_buffer();\n    if (more) { *more = ctx->dpb.num_pictures_in_output_queue(); }\n    return DE265_OK;\n  }\n  if (ctx->nal_parser.is_end_of_stream() == false &&\n      ctx->nal_parser.is_end_of_frame() == false &&\n      ctx->nal_parser.get_NAL_queue_length() == 0) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  if (!ctx->dpb.has_free_dpb_picture(false)) {\n    if (more) *more = 1;\n    return DE265_ERROR_IMAGE_BUFFER_FULL;\n  }\n  de265_error err = DE265_OK;\n  bool did_work = false;\n  if (ctx->nal_parser.get_NAL_queue_length()) { \n    NAL_unit* nal = ctx->nal_parser.pop_from_NAL_queue();\n    assert(nal);\n    err = ctx->decode_NAL(nal);\n    did_work=true;\n  }\n  else if (ctx->nal_parser.is_end_of_frame() == true &&\n      ctx->image_units.empty()) {\n    if (more) { *more=1; }\n    return DE265_ERROR_WAITING_FOR_INPUT_DATA;\n  }\n  else {\n    err = decode_some(&did_work);\n  }\n  if (more) {\n    *more = (err==DE265_OK && did_work);\n  }\n  return err;\n}", "target": 0}
{"code": "aspath_show_all_iterator (struct hash_backet *backet, struct vty *vty)\n{\n  struct aspath *as;\n  as = (struct aspath *) backet->data;\n  vty_out (vty, \"[%p:%u] (%ld) \", (void *)backet, backet->key, as->refcnt);\n  vty_out (vty, \"%s%s\", as->str, VTY_NEWLINE);\n}", "target": 0}
{"code": "cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n}", "target": 0}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "Opal::Call::send_dtmf (const char dtmf)\n{\n  PSafePtr<OpalConnection> connection = get_remote_connection ();\n  if (connection != NULL) {\n    connection->SendUserInputTone (dtmf, 180);\n  }\n}", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tkfree(clt);\n}", "target": 1}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "GF_Err fiin_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tgf_bs_read_u16(bs);\n\treturn gf_isom_box_array_read(s, bs, fiin_on_child_box);", "target": 0}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}", "target": 1}
{"code": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}", "target": 1}
{"code": "cmsToneCurve* CMSEXPORT cmsBuildGamma(cmsContext ContextID, cmsFloat64Number Gamma)\n{\n    return cmsBuildParametricToneCurve(ContextID, 1, &Gamma);\n}", "target": 0}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static __sum16 __tcp_checksum_complete_user(struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\t__sum16 result;\n\tif (sock_owned_by_user(sk)) {\n\t\tlocal_bh_enable();\n\t\tresult = __tcp_checksum_complete(skb);\n\t\tlocal_bh_disable();\n\t} else {\n\t\tresult = __tcp_checksum_complete(skb);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint err;\n\tstruct iattr newattrs;\n\tif (length < 0)\n\t\treturn -EINVAL;\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\terr = notify_change(dentry, &newattrs);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\treturn err;\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return ksize_;\n    }\n    const TensorShape ksize_shape = ctx->InputShape(1);\n    if (!TensorShapeUtils::IsVector(ksize_shape)) {\n      return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                     ksize_shape.DebugString());\n    }\n    if (ksize_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> ksize;\n    auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n    if (!status.ok()) {\n      return status;\n    }\n    return ksize;\n  }", "target": 1}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "blkid_partlist blkid_probe_get_partlist(blkid_probe pr)\n{\n\treturn (blkid_partlist) pr->chains[BLKID_CHAIN_PARTS].data;\n}", "target": 0}
{"code": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}", "target": 1}
{"code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n{\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n    double rounded;\n    if (code == gs_error_undefinedresult) {\n        pdist->x = pdist->y = 0;\n    } else if (code < 0)\n        return code;\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "const char *ApplyChannelMatrix::name() const { return \"channelMatrix\"; }", "target": 0}
{"code": "aspath_hash_alloc (void *arg)\n{\n  const struct aspath *aspath = arg;\n  struct aspath *new;\n  assert (aspath->str);\n  if (! aspath->str)\n    return NULL;\n  new = XMALLOC (MTYPE_AS_PATH, sizeof (struct aspath));\n  new->refcnt = 0;\n  new->segments = aspath->segments;\n  new->str = aspath->str;\n  new->str_len = aspath->str_len;\n  return new;\n}", "target": 0}
{"code": "static void prepare_attr_stack(const char *path, int dirlen)\n{\n\tstruct attr_stack *elem, *info;\n\tint len;\n\tstruct strbuf pathbuf;\n\tstrbuf_init(&pathbuf, dirlen+2+strlen(GITATTRIBUTES_FILE));\n\tif (!attr_stack)\n\t\tbootstrap_attr_stack();\n\tinfo = attr_stack;\n\tattr_stack = info->prev;\n\twhile (attr_stack && attr_stack->origin) {\n\t\tint namelen = strlen(attr_stack->origin);\n\t\telem = attr_stack;\n\t\tif (namelen <= dirlen &&\n\t\t    !strncmp(elem->origin, path, namelen))\n\t\t\tbreak;\n\t\tdebug_pop(elem);\n\t\tattr_stack = elem->prev;\n\t\tfree_attr_elem(elem);\n\t}\n\tif (!is_bare_repository()) {\n\t\twhile (1) {\n\t\t\tchar *cp;\n\t\t\tlen = strlen(attr_stack->origin);\n\t\t\tif (dirlen <= len)\n\t\t\t\tbreak;\n\t\t\tstrbuf_reset(&pathbuf);\n\t\t\tstrbuf_add(&pathbuf, path, dirlen);\n\t\t\tstrbuf_addch(&pathbuf, '/');\n\t\t\tcp = strchr(pathbuf.buf + len + 1, '/');\n\t\t\tstrcpy(cp + 1, GITATTRIBUTES_FILE);\n\t\t\telem = read_attr(pathbuf.buf, 0);\n\t\t\t*cp = '\\0';\n\t\t\telem->origin = strdup(pathbuf.buf);\n\t\t\telem->prev = attr_stack;\n\t\t\tattr_stack = elem;\n\t\t\tdebug_push(elem);\n\t\t}\n\t}\n\tinfo->prev = attr_stack;\n\tattr_stack = info;\n}", "target": 0}
{"code": "    bool wc2mb(UINT cp, std::string& str)\n    {\n        if (str.empty())\n            return true;\n        if (str.size() & 1) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Size \" << str.size() << \" of input string is not even.\\n\";\n#endif\n            return false;\n        }\n        int len = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, 0, 0, 0, 0);\n        if (len == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to determine required size of output buffer.\\n\";\n#endif\n            return false;\n        }\n        std::vector<std::string::value_type> out;\n        out.reserve(len);\n        int ret = WideCharToMultiByte(cp, 0, (LPCWSTR)str.data(), (int)str.size() / 2, (LPSTR)out.data(), len, 0, 0);\n        if (ret == 0) {\n#ifdef DEBUG\n            EXV_DEBUG << \"wc2mb: Failed to convert the input string to a multi byte string.\\n\";\n#endif\n            return false;\n        }\n        str.assign(out.data(), static_cast<size_t>(len));\n        return true;\n    }", "target": 0}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,\n                                const unsigned char* in, size_t i, const LodePNGColorMode* mode)\n{\n  if(mode->colortype == LCT_GREY)\n  {\n    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];\n    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_RGB)\n  {\n    *r = 256 * in[i * 6 + 0] + in[i * 6 + 1];\n    *g = 256 * in[i * 6 + 2] + in[i * 6 + 3];\n    *b = 256 * in[i * 6 + 4] + in[i * 6 + 5];\n    if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r\n       && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g\n       && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;\n    else *a = 65535;\n  }\n  else if(mode->colortype == LCT_GREY_ALPHA)\n  {\n    *r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];\n    *a = 256 * in[i * 4 + 2] + in[i * 4 + 3];\n  }\n  else if(mode->colortype == LCT_RGBA)\n  {\n    *r = 256 * in[i * 8 + 0] + in[i * 8 + 1];\n    *g = 256 * in[i * 8 + 2] + in[i * 8 + 3];\n    *b = 256 * in[i * 8 + 4] + in[i * 8 + 5];\n    *a = 256 * in[i * 8 + 6] + in[i * 8 + 7];\n  }\n}", "target": 0}
{"code": "static void bnx2x_after_function_update(struct bnx2x *bp)\n{\n\tint q, rc;\n\tstruct bnx2x_fastpath *fp;\n\tstruct bnx2x_queue_state_params queue_params = {NULL};\n\tstruct bnx2x_queue_update_params *q_update_params =\n\t\t&queue_params.params.update;\n\tqueue_params.cmd = BNX2X_Q_CMD_UPDATE;\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM_CHNG,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(BNX2X_Q_UPDATE_SILENT_VLAN_REM,\n\t\t  &q_update_params->update_flags);\n\t__set_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\tif (bp->afex_vlan_mode == FUNC_MF_CFG_AFEX_VLAN_ACCESS_MODE) {\n\t\tq_update_params->silent_removal_value = 0;\n\t\tq_update_params->silent_removal_mask = 0;\n\t} else {\n\t\tq_update_params->silent_removal_value =\n\t\t\t(bp->afex_def_vlan_tag & VLAN_VID_MASK);\n\t\tq_update_params->silent_removal_mask = VLAN_VID_MASK;\n\t}\n\tfor_each_eth_queue(bp, q) {\n\t\tfp = &bp->fp[q];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t}\n\tif (!NO_FCOE(bp) && CNIC_ENABLED(bp)) {\n\t\tfp = &bp->fp[FCOE_IDX(bp)];\n\t\tqueue_params.q_obj = &bnx2x_sp_obj(bp, fp).q_obj;\n\t\t__clear_bit(RAMROD_COMP_WAIT, &queue_params.ramrod_flags);\n\t\tsmp_mb__before_atomic();\n\t\tset_bit(BNX2X_AFEX_FCOE_Q_UPDATE_PENDING, &bp->sp_state);\n\t\tsmp_mb__after_atomic();\n\t\trc = bnx2x_queue_state_change(bp, &queue_params);\n\t\tif (rc < 0)\n\t\t\tBNX2X_ERR(\"Failed to config silent vlan rem for Q %d\\n\",\n\t\t\t\t  q);\n\t} else {\n\t\tbnx2x_link_report(bp);\n\t\tbnx2x_fw_command(bp, DRV_MSG_CODE_AFEX_VIFSET_ACK, 0);\n\t}\n}", "target": 0}
{"code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n    if (!s || !s->orig_buf)\n        goto read_end;\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n        if (!acb)\n            continue;\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\nread_end:\n    return realsize;\n}", "target": 1}
{"code": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\t}\t\t\t\n\treturn status;\n}\t\t\t\t", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "readpw(PK11SlotInfo *slot UNUSED,\n       PRBool retry UNUSED,\n       void *arg UNUSED)\n{\n\tstruct termios sio, tio;\n\tchar line[LINE_MAX], *p;\n\tchar *ret;\n\tingress();\n\tmemset(line, '\\0', sizeof (line));\n\tif (tcgetattr(fileno(stdin), &sio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\ttio = sio;\n\ttio.c_lflag &= ~ECHO;\n\tif (tcsetattr(fileno(stdin), 0, &tio) < 0) {\n\t\twarnx(\"Could not read password from standard input.\");\n\t\treturn NULL;\n\t}\n\tfprintf(stdout, \"Enter passphrase for private key: \");\n\tfflush(stdout);\n\tret = fgets(line, sizeof(line), stdin);\n\tset_errno_guard();\n\ttcsetattr(fileno(stdin), 0, &sio);\n\tfprintf(stdout, \"\\n\");\n\tfflush(stdout);\n\tif (ret == NULL)\n\t\treturn NULL;\n\tp = line + strcspn(line, \"\\r\\n\");\n\tif (p == NULL)\n\t\tp = line + strcspn(line, \"\\n\");\n\tif (p != NULL)\n\t\t*p = '\\0';\n\tret = strdup(line);\n\tmemset(line, '\\0', sizeof (line));\n\tif (!ret) {\n\t\twarnx(\"Could not read passphrase.\");\n\t\treturn NULL;\n\t}\n\tegress();\n\treturn ret;\n}", "target": 0}
{"code": "static int ext4_iomap_end(struct inode *inode, loff_t offset, loff_t length,\n\t\t\t  ssize_t written, unsigned flags, struct iomap *iomap)\n{\n\tint ret = 0;\n\thandle_t *handle;\n\tint blkbits = inode->i_blkbits;\n\tbool truncate = false;\n\tif (!(flags & IOMAP_WRITE) || (flags & IOMAP_FAULT))\n\t\treturn 0;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto orphan_del;\n\t}\n\tif (ext4_update_inode_size(inode, offset + written))\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (iomap->offset + iomap->length > \n\t    ALIGN(inode->i_size, 1 << blkbits)) {\n\t\text4_lblk_t written_blk, end_blk;\n\t\twritten_blk = (offset + written) >> blkbits;\n\t\tend_blk = (offset + length) >> blkbits;\n\t\tif (written_blk < end_blk && ext4_can_truncate(inode))\n\t\t\ttruncate = true;\n\t}\n\tif (!truncate && inode->i_nlink &&\n\t    !list_empty(&EXT4_I(inode)->i_orphan))\n\t\text4_orphan_del(handle, inode);\n\text4_journal_stop(handle);\n\tif (truncate) {\n\t\text4_truncate_failed_write(inode);\norphan_del:\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void read_user_name(char *name)\n{\n  char *str=getenv(\"USER\");\t\t\n  strmake(name,str ? str : \"ODBC\", USERNAME_LENGTH);\n}", "target": 0}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}", "target": 1}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "   Copy specified message to a mailbox */\nPHP_FUNCTION(imap_mail_copy)\n{\n\tzval *streamind;\n\tzend_long options = 0;\n\tzend_string *seq, *folder;\n\tint argc = ZEND_NUM_ARGS();\n\tpils *imap_le_struct;\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &seq, &folder, &options) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? options : NIL)) == T) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_fetch_all_columns)\n{\n\tzval *result;\n\tPGresult *pgsql_result;\n\tpgsql_result_handle *pg_result;\n\tunsigned long colno=0;\n\tint pg_numrows, pg_row;\n\tsize_t num_fields;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &result, &colno) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, \"PostgreSQL result\", le_result);\n\tpgsql_result = pg_result->result;\n\tnum_fields = PQnfields(pgsql_result);\n\tif (colno >= num_fields || colno < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid column number '%ld'\", colno);\n\t\tRETURN_FALSE;\n\t}\n\tarray_init(return_value);\n\tif ((pg_numrows = PQntuples(pgsql_result)) <= 0) {\n\t\treturn;\n\t}\n\tfor (pg_row = 0; pg_row < pg_numrows; pg_row++) {\n\t\tif (PQgetisnull(pgsql_result, pg_row, colno)) {\n\t\t\tadd_next_index_null(return_value);\n\t\t} else {\n\t\t\tadd_next_index_string(return_value, PQgetvalue(pgsql_result, pg_row, colno), 1); \n\t\t}\n\t}\n}", "target": 0}
{"code": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock;\n\ts64 delta;\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\told_clock = scd->clock;\n\tclock = scd->tick_gtod + delta;\n\tmin_clock = wrap_max(scd->tick_gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, scd->tick_gtod + TICK_NSEC);\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\treturn clock;\n}", "target": 0}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "const SSL_CIPHER *dtls1_get_cipher(unsigned int u)\n{\n    const SSL_CIPHER *ciph = ssl3_get_cipher(u);\n    if (ciph != NULL) {\n        if (ciph->algorithm_enc == SSL_RC4)\n            return NULL;\n    }\n    return ciph;\n}", "target": 0}
{"code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  insertByKey(std::move(key), std::move(value));\n}", "target": 0}
{"code": "static int llc_ui_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t     char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = -EINVAL, opt;\n\tlock_sock(sk);\n\tif (unlikely(level != SOL_LLC || optlen != sizeof(int)))\n\t\tgoto out;\n\trc = get_user(opt, (int __user *)optval);\n\tif (rc)\n\t\tgoto out;\n\trc = -EINVAL;\n\tswitch (optname) {\n\tcase LLC_OPT_RETRY:\n\t\tif (opt > LLC_OPT_MAX_RETRY)\n\t\t\tgoto out;\n\t\tllc->n2 = opt;\n\t\tbreak;\n\tcase LLC_OPT_SIZE:\n\t\tif (opt > LLC_OPT_MAX_SIZE)\n\t\t\tgoto out;\n\t\tllc->n1 = opt;\n\t\tbreak;\n\tcase LLC_OPT_ACK_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_ACK_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->ack_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_P_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_P_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->pf_cycle_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_REJ_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_REJ_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->rej_sent_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_BUSY_TMR_EXP:\n\t\tif (opt > LLC_OPT_MAX_BUSY_TMR_EXP)\n\t\t\tgoto out;\n\t\tllc->busy_state_timer.expire = opt * HZ;\n\t\tbreak;\n\tcase LLC_OPT_TX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->k = opt;\n\t\tbreak;\n\tcase LLC_OPT_RX_WIN:\n\t\tif (opt > LLC_OPT_MAX_WIN)\n\t\t\tgoto out;\n\t\tllc->rw = opt;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 0}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    const char *portstr, *part;\n    char *scheme;\n    int port;\n    if (err != NULL) {\n        return err;\n    }\n    if (apr_fnmatch_test(arg))\n        return apr_pstrcat(cmd->temp_pool, \"Invalid ServerName \\\"\", arg,\n                \"\\\" use ServerAlias to set multiple server names.\", NULL);\n    part = ap_strstr_c(arg, \":\n    if (part) {\n      scheme = apr_pstrndup(cmd->pool, arg, part - arg);\n      ap_str_tolower(scheme);\n      cmd->server->server_scheme = (const char *)scheme;\n      part += 3;\n    } else {\n      part = arg;\n    }\n    portstr = ap_strchr_c(part, ':');\n    if (portstr) {\n        cmd->server->server_hostname = apr_pstrndup(cmd->pool, part,\n                                                    portstr - part);\n        portstr++;\n        port = atoi(portstr);\n        if (port <= 0 || port >= 65536) { \n            return apr_pstrcat(cmd->temp_pool, \"The port number \\\"\", arg,\n                          \"\\\" is outside the appropriate range \"\n                          \"(i.e., 1..65535).\", NULL);\n        }\n    }\n    else {\n        cmd->server->server_hostname = apr_pstrdup(cmd->pool, part);\n        port = 0;\n    }\n    cmd->server->port = port;\n    return NULL;\n}", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "xfs_attrmulti_attr_set(\n\tstruct inode\t\t*inode,\n\tunsigned char\t\t*name,\n\tconst unsigned char\t__user *ubuf,\n\tuint32_t\t\tlen,\n\tuint32_t\t\tflags)\n{\n\tstruct xfs_da_args\targs = {\n\t\t.dp\t\t= XFS_I(inode),\n\t\t.attr_filter\t= xfs_attr_filter(flags),\n\t\t.attr_flags\t= xfs_attr_flags(flags),\n\t\t.name\t\t= name,\n\t\t.namelen\t= strlen(name),\n\t};\n\tint\t\t\terror;\n\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\treturn -EPERM;\n\tif (ubuf) {\n\t\tif (len > XFS_XATTR_SIZE_MAX)\n\t\t\treturn -EINVAL;\n\t\targs.value = memdup_user(ubuf, len);\n\t\tif (IS_ERR(args.value))\n\t\t\treturn PTR_ERR(args.value);\n\t\targs.valuelen = len;\n\t}\n\terror = xfs_attr_set(&args);\n\tif (!error && (flags & XFS_IOC_ATTR_ROOT))\n\t\txfs_forget_acl(inode, name);\n\tkfree(args.value);\n\treturn error;\n}", "target": 0}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\tmsg = spnego_key->payload.data[0];\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}", "target": 0}
{"code": "void RemoteFrame::ScheduleNavigation(Document& origin_document,\n                                      const KURL& url,\n                                      WebFrameLoadType frame_load_type,\n                                      UserGestureStatus user_gesture_status) {\n   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));\n   frame_request.GetResourceRequest().SetHasUserGesture(\n       user_gesture_status == UserGestureStatus::kActive);\n  frame_request.GetResourceRequest().SetFrameType(\n      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel\n                    : network::mojom::RequestContextFrameType::kNested);\n  Navigate(frame_request, frame_load_type);\n}", "target": 1}
{"code": "newVar_N2(char *var,char *var2, char *var3,char *var4,int pop_counter,char *final)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tint psize=PARAM_STRSIZE;\n\tint i;\n\tint slen=strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(final);\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->p.String = malloc(psize + slen);\n\tv->Type = PUSH_VARIABLE; \n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tfor(i=0;i<pop_counter;i++) \n\t{\n\t\tchar *pops1=getString(pop());\n\t\tchar *pops2=getName  (pop());\n\t\twhile ( strlen(v->p.String)+ 3 + strlen(pops1)+ strlen(pops2) +slen >= psize)\n\t\t{\n\t\t\tpsize += PARAM_STRSIZE;\n\t\t\tv->p.String = realloc( v->p.String, psize);\n\t\t}\n\t\tstrcat(v->p.String,pops2);\n\t\tstrcat(v->p.String,\":\");\n\t\tstrcat(v->p.String,pops1);\n\t\tif( i < pop_counter-1 ) \n\t\t\tstrcat(v->p.String,\",\");\n\t}\n\tstrcat(v->p.String,final);\n\treturn v;\n}", "target": 0}
{"code": "void STDCALL mysql_close(MYSQL *mysql)\n{\n  DBUG_ENTER(\"mysql_close\");\n  if (mysql)\t\t\t\t\t\n  {\n    if (mysql->net.vio != 0)\n    {\n      free_old_query(mysql);\n      mysql->status=MYSQL_STATUS_READY; \n      mysql->reconnect=0;\n      simple_command(mysql,COM_QUIT,(uchar*) 0,0,1);\n      end_server(mysql);\t\t\t\n    }\n    mysql_close_free_options(mysql);\n    mysql_close_free(mysql);\n    mysql_detach_stmt_list(&mysql->stmts, \"mysql_close\");\n#ifndef MYSQL_SERVER\n    if (mysql->thd)\n      (*mysql->methods->free_embedded_thd)(mysql);\n#endif\n    if (mysql->free_me)\n      my_free(mysql);\n  }\n  DBUG_VOID_RETURN;", "target": 0}
{"code": "static inline unsigned long node_nr_slabs(struct kmem_cache_node *n)\n\t\t\t\t\t\t\t{ return 0; }", "target": 0}
{"code": "check_secret_key( ELG_secret_key *sk )\n{\n    int rc;\n    MPI y = mpi_alloc( mpi_get_nlimbs(sk->y) );\n    mpi_powm( y, sk->g, sk->x, sk->p );\n    rc = !mpi_cmp( y, sk->y );\n    mpi_free( y );\n    return rc;\n}", "target": 0}
{"code": "static void rfc2231_decode_one (char *dest, char *src)\n{\n  char *d;\n  for (d = dest; *src; src++)\n  {\n    if (*src == '%' &&\n        isxdigit ((unsigned char) *(src + 1)) &&\n        isxdigit ((unsigned char) *(src + 2)))\n    {\n      *d++ = (hexval (*(src + 1)) << 4) | (hexval (*(src + 2)));\n      src += 2;\n    }\n    else\n      *d++ = *src;\n  }\n  *d = '\\0';\n}", "target": 0}
{"code": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}", "target": 1}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ppoll(struct pollfd __user *ufds,\n\tunsigned int nfds, struct compat_timespec __user *tsp,\n\tconst compat_sigset_t __user *sigmask, compat_size_t sigsetsize)\n{\n\tcompat_sigset_t ss32;\n\tsigset_t ksigmask, sigsaved;\n\tstruct compat_timespec ts;\n\ts64 timeout = -1;\n\tint ret;\n\tif (tsp) {\n\t\tif (copy_from_user(&ts, tsp, sizeof(ts)))\n\t\t\treturn -EFAULT;\n\t\ttimeout = ROUND_UP(ts.tv_nsec, 1000000000/HZ);\n\t\ttimeout += ts.tv_sec * HZ;\n\t}\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ss32, sigmask, sizeof(ss32)))\n\t\t\treturn -EFAULT;\n\t\tsigset_from_compat(&ksigmask, &ss32);\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\tret = do_sys_poll(ufds, nfds, &timeout);\n\tif (ret == -EINTR) {\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_thread_flag(TIF_RESTORE_SIGMASK);\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\tif (tsp && timeout >= 0) {\n\t\tstruct compat_timespec rts;\n\t\tif (current->personality & STICKY_TIMEOUTS)\n\t\t\tgoto sticky;\n\t\trts.tv_nsec = jiffies_to_usecs(do_div((*(u64*)&timeout), HZ)) *\n\t\t\t\t\t1000;\n\t\trts.tv_sec = timeout;\n\t\tif (compat_timespec_compare(&rts, &ts) >= 0)\n\t\t\trts = ts;\n\t\tif (copy_to_user(tsp, &rts, sizeof(rts))) {\nsticky:\n\t\t\tif (ret == -ERESTARTNOHAND && timeout >= 0)\n\t\t\t\tret = -EINTR;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int ssh_scp_close(ssh_scp scp)\n{\n    char buffer[128] = {0};\n    int rc;\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->channel != NULL) {\n        if (ssh_channel_send_eof(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        while (!ssh_channel_is_eof(scp->channel)) {\n            rc = ssh_channel_read(scp->channel, buffer, sizeof(buffer), 0);\n            if (rc == SSH_ERROR || rc == 0) {\n                break;\n            }\n        }\n        if (ssh_channel_close(scp->channel) == SSH_ERROR) {\n            scp->state = SSH_SCP_ERROR;\n            return SSH_ERROR;\n        }\n        ssh_channel_free(scp->channel);\n        scp->channel = NULL;\n    }\n    scp->state = SSH_SCP_NEW;\n    return SSH_OK;\n}", "target": 0}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "rfbMpiToBytes(const gcry_mpi_t value, uint8_t *result, size_t size)\n{\n  gcry_error_t error;\n  size_t len;\n  int i;\n  error = gcry_mpi_print(GCRYMPI_FMT_USG, result, size, &len, value);\n  if (gcry_err_code(error) != GPG_ERR_NO_ERROR)\n  {\n    rfbClientLog(\"gcry_mpi_print error: %s\\n\", gcry_strerror(error));\n    return FALSE;\n  }\n  for (i=size-1;i>(int)size-1-(int)len;--i)\n    result[i] = result[i-size+len];\n  for (;i>=0;--i)\n    result[i] = 0;\n  return TRUE;\n}", "target": 0}
{"code": "file_magwarn(struct magic_set *ms, const char *f, ...)\n{\n\tva_list va;\n\tchar *expanded_format;\n\tTSRMLS_FETCH();\n\tva_start(va, f);\n\tvasprintf(&expanded_format, f, va);\n\tva_end(va);\n\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Warning: %s\", expanded_format);\n\tfree(expanded_format);\n}", "target": 0}
{"code": "static int restore_case_semantics(struct case_semantics_state *state)\n{\n\tstate->conn->case_sensitive = state->case_sensitive;\n\tstate->conn->case_preserve = state->case_preserve;\n\tstate->conn->short_case_preserve = state->short_case_preserve;\n\treturn 0;\n}", "target": 0}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "static void radix_count(const RCCMPEntry *data, int size, int buckets[RADIX_PASSES][NBUCKETS])\n{\n    int i, j;\n    memset(buckets, 0, sizeof(buckets[0][0]) * RADIX_PASSES * NBUCKETS);\n    for (i = 0; i < size; i++) {\n        int v = data[i].value;\n        for (j = 0; j < RADIX_PASSES; j++) {\n            buckets[j][get_bucket(v, 0)]++;\n            v >>= BUCKET_BITS;\n        }\n        av_assert1(!v);\n    }\n    for (j = 0; j < RADIX_PASSES; j++) {\n        int offset = size;\n        for (i = NBUCKETS - 1; i >= 0; i--)\n            buckets[j][i] = offset -= buckets[j][i];\n        av_assert1(!buckets[j][0]);\n    }\n}", "target": 0}
{"code": "void FrameLoader::applyUserAgent(ResourceRequest& request)\n{\n    String userAgent = this->userAgent(request.url());\n    ASSERT(!userAgent.isNull());\n    request.setHTTPUserAgent(userAgent);\n}", "target": 0}
{"code": "GF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\tmutex_lock(&dir->i_mutex);\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "_dbus_close_all (void)\n{\n  int maxfds, i;\n#ifdef __linux__\n  DIR *d;\n  d = opendir (\"/proc/self/fd\");\n  if (d)\n    {\n      for (;;)\n        {\n          struct dirent buf, *de;\n          int k, fd;\n          long l;\n          char *e = NULL;\n          k = readdir_r (d, &buf, &de);\n          if (k != 0 || !de)\n            break;\n          if (de->d_name[0] == '.')\n            continue;\n          errno = 0;\n          l = strtol (de->d_name, &e, 10);\n          if (errno != 0 || e == NULL || *e != '\\0')\n            continue;\n          fd = (int) l;\n          if (fd < 3)\n            continue;\n          if (fd == dirfd (d))\n            continue;\n          close (fd);\n        }\n      closedir (d);\n      return;\n    }\n#endif\n  maxfds = sysconf (_SC_OPEN_MAX);\n  if (maxfds < 0)\n    maxfds = 1024;\n  for (i = 3; i < maxfds; i++)\n    close (i);\n}", "target": 0}
{"code": "isdn_net_unreachable(struct net_device *dev, struct sk_buff *skb, char *reason)\n{\n\tif (skb) {\n\t\tu_short proto = ntohs(skb->protocol);\n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s, signalling dst_link_failure %s\\n\",\n\t\t       dev->name,\n\t\t       (reason != NULL) ? reason : \"unknown\",\n\t\t       (proto != ETH_P_IP) ? \"Protocol != ETH_P_IP\" : \"\");\n\t\tdst_link_failure(skb);\n\t}\n\telse {  \n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s\\n\",\n\t\t       dev->name,\n\t\t       (reason != NULL) ? reason : \"reason unknown\");\n\t}\n}", "target": 0}
{"code": "void Document::FinishedParsing() {\n  DCHECK(!GetScriptableDocumentParser() || !parser_->IsParsing());\n  DCHECK(!GetScriptableDocumentParser() || ready_state_ != kLoading);\n  SetParsingState(kInDOMContentLoaded);\n  DocumentParserTiming::From(*this).MarkParserStop();\n  if (!document_timing_.DomContentLoadedEventStart())\n    document_timing_.MarkDomContentLoadedEventStart();\n  DispatchEvent(Event::CreateBubble(EventTypeNames::DOMContentLoaded));\n  if (!document_timing_.DomContentLoadedEventEnd())\n    document_timing_.MarkDomContentLoadedEventEnd();\n  SetParsingState(kFinishedParsing);\n  Microtask::PerformCheckpoint(V8PerIsolateData::MainThreadIsolate());\n  ScriptableDocumentParser* parser = GetScriptableDocumentParser();\n  well_formed_ = parser && parser->WellFormed();\n  if (LocalFrame* frame = GetFrame()) {\n    if (title_.IsEmpty())\n      DispatchDidReceiveTitle();\n    const bool main_resource_was_already_requested =\n        frame->Loader().StateMachine()->CommittedFirstRealDocumentLoad();\n    if (main_resource_was_already_requested)\n      UpdateStyleAndLayoutTree();\n    BeginLifecycleUpdatesIfRenderingReady();\n    frame->Loader().FinishedParsing();\n    TRACE_EVENT_INSTANT1(\"devtools.timeline\", \"MarkDOMContent\",\n                         TRACE_EVENT_SCOPE_THREAD, \"data\",\n                         InspectorMarkLoadEvent::Data(frame));\n    probe::domContentLoadedEventFired(frame);\n    frame->GetIdlenessDetector()->DomContentLoadedEventFired();\n  }\n  element_data_cache_clear_timer_.StartOneShot(10, BLINK_FROM_HERE);\n  fetcher_->ClearPreloads(ResourceFetcher::kClearSpeculativeMarkupPreloads);\n  if (!frame_ || frame_->GetSettings()->GetSavePreviousDocumentResources() ==\n                     SavePreviousDocumentResources::kUntilOnDOMContentLoaded) {\n    fetcher_->ClearResourcesFromPreviousFetcher();\n  }\n  if (IsPrefetchOnly())\n    WebPrerenderingSupport::Current()->PrefetchFinished();\n}", "target": 0}
{"code": "void SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "ProtoValidationTypeString(const ServiceValidationResultsType t)\n{\n   switch (t) {\n   case VALIDATION_RESULTS_TYPE_NAMEPASSWORD:\n      return VGAUTH_USERHANDLE_TYPE_NAMEPASSWORD;\n   case VALIDATION_RESULTS_TYPE_SSPI:\n      return VGAUTH_USERHANDLE_TYPE_SSPI;\n   case VALIDATION_RESULTS_TYPE_SAML:\n      return VGAUTH_USERHANDLE_TYPE_SAML;\n   case VALIDATION_RESULTS_TYPE_SAML_INFO_ONLY:\n      return VGAUTH_USERHANDLE_TYPE_SAML_INFO_ONLY;\n   case VALIDATION_RESULTS_TYPE_UNKNOWN:\n   default:\n      ASSERT(0);\n      Warning(\"%s: Tried to convert a validationType of %d to a string\\n\",\n              __FUNCTION__, t);\n      return \"<UNKNOWN>\";\n   }\n}", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "static int fts3EvalPhraseStart(Fts3Cursor *pCsr, int bOptOk, Fts3Phrase *p){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc = SQLITE_OK;             \n  int i;\n  int bHaveIncr = 0;\n  int bIncrOk = (bOptOk \n   && pCsr->bDesc==pTab->bDescIdx \n   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0\n   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0\n#ifdef SQLITE_TEST\n   && pTab->bNoIncrDoclist==0\n#endif\n  );\n  for(i=0; bIncrOk==1 && i<p->nToken; i++){\n    Fts3PhraseToken *pToken = &p->aToken[i];\n    if( pToken->bFirst || (pToken->pSegcsr!=0 && !pToken->pSegcsr->bLookup) ){\n      bIncrOk = 0;\n    }\n    if( pToken->pSegcsr ) bHaveIncr = 1;\n  }\n  if( bIncrOk && bHaveIncr ){\n    int iCol = (p->iColumn >= pTab->nColumn ? -1 : p->iColumn);\n    for(i=0; rc==SQLITE_OK && i<p->nToken; i++){\n      Fts3PhraseToken *pToken = &p->aToken[i];\n      Fts3MultiSegReader *pSegcsr = pToken->pSegcsr;\n      if( pSegcsr ){\n        rc = sqlite3Fts3MsrIncrStart(pTab, pSegcsr, iCol, pToken->z, pToken->n);\n      }\n    }\n    p->bIncr = 1;\n  }else{\n    rc = fts3EvalPhraseLoad(pCsr, p);\n    p->bIncr = 0;\n  }\n  assert( rc!=SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr==0 || p->bIncr );\n  return rc;\n}", "target": 0}
{"code": "static __init int efivar_ssdt_load(void)\n{\n\tLIST_HEAD(entries);\n\tstruct efivar_entry *entry, *aux;\n\tunsigned long size;\n\tvoid *data;\n\tint ret;\n\tret = efivar_init(efivar_ssdt_iter, &entries, true, &entries);\n\tlist_for_each_entry_safe(entry, aux, &entries, list) {\n\t\tpr_info(\"loading SSDT from variable %s-%pUl\\n\", efivar_ssdt,\n\t\t\t&entry->var.VendorGuid);\n\t\tlist_del(&entry->list);\n\t\tret = efivar_entry_size(entry, &size);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var size\\n\");\n\t\t\tgoto free_entry;\n\t\t}\n\t\tdata = kmalloc(size, GFP_KERNEL);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_entry;\n\t\t}\n\t\tret = efivar_entry_get(entry, NULL, &size, data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to get var data\\n\");\n\t\t\tgoto free_data;\n\t\t}\n\t\tret = acpi_load_table(data);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to load table: %d\\n\", ret);\n\t\t\tgoto free_data;\n\t\t}\n\t\tgoto free_entry;\nfree_data:\n\t\tkfree(data);\nfree_entry:\n\t\tkfree(entry);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 1}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n  const char\n    *geometry,\n    *path,\n    *type;\n  DrawInfo\n    *clone_info;\n  ImageInfo\n    *image_info;\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#00000000\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->stroke_pattern=DestroyImage(clone_info->stroke_pattern);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}", "target": 0}
{"code": "copy_text_attr(\n    int\t\toff,\n    char_u\t*buf,\n    int\t\tlen,\n    int\t\tattr)\n{\n    int\t\ti;\n    mch_memmove(ScreenLines + off, buf, (size_t)len);\n    if (enc_utf8)\n\tvim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);\n    for (i = 0; i < len; ++i)\n\tScreenAttrs[off + i] = attr;\n}", "target": 0}
{"code": "static void patch_fn(struct cgit_context *ctx)\n{\n\tcgit_print_patch(ctx->qry.sha1);\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}", "target": 1}
{"code": "static int snd_timer_start1(struct snd_timer_instance *timeri,\n\t\t\t    bool start, unsigned long ticks)\n{\n\tstruct snd_timer *timer;\n\tint result;\n\tunsigned long flags;\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (timer->card && timer->card->shutdown) {\n\t\tresult = -ENODEV;\n\t\tgoto unlock;\n\t}\n\tif (timeri->flags & (SNDRV_TIMER_IFLG_RUNNING |\n\t\t\t     SNDRV_TIMER_IFLG_START)) {\n\t\tresult = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tif (start)\n\t\ttimeri->ticks = timeri->cticks = ticks;\n\telse if (!timeri->cticks)\n\t\ttimeri->cticks = 1;\n\ttimeri->pticks = 0;\n\tlist_move_tail(&timeri->active_list, &timer->active_list_head);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tgoto __start_now;\n\t\ttimer->flags |= SNDRV_TIMER_FLG_RESCHED;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_START;\n\t\tresult = 1; \n\t} else {\n\t\tif (start)\n\t\t\ttimer->sticks = ticks;\n\t\ttimer->hw.start(timer);\n\t      __start_now:\n\t\ttimer->running++;\n\t\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\t\tresult = 0;\n\t}\n\tsnd_timer_notify1(timeri, start ? SNDRV_TIMER_EVENT_START :\n\t\t\t  SNDRV_TIMER_EVENT_CONTINUE);\n unlock:\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\treturn result;\n}", "target": 0}
{"code": "int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = addr_family;\n\tif (sock_initaddress(address, \"22222\" , &hints, &addrinfo, errbuf, errbuflen) == -1)\n\t\treturn 0;\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}", "target": 1}
{"code": "bool RenderView::allowImages(WebFrame* frame, bool enabled_per_settings) {\n  if (enabled_per_settings &&\n      AllowContentType(CONTENT_SETTINGS_TYPE_IMAGES))\n    return true;\n  if (IsWhitelistedForContentSettings(frame))\n    return true;\n  DidBlockContentType(CONTENT_SETTINGS_TYPE_IMAGES);\n  return false;  \n}", "target": 0}
{"code": "get_voting_schedule(const or_options_t *options, time_t now, int severity)\n{\n  int interval, vote_delay, dist_delay;\n  time_t start;\n  time_t end;\n  networkstatus_t *consensus;\n  voting_schedule_t *new_voting_schedule;\n  new_voting_schedule = tor_malloc_zero(sizeof(voting_schedule_t));\n  consensus = networkstatus_get_live_consensus(now);\n  if (consensus) {\n    interval = (int)( consensus->fresh_until - consensus->valid_after );\n    vote_delay = consensus->vote_seconds;\n    dist_delay = consensus->dist_seconds;\n  } else {\n    interval = options->TestingV3AuthInitialVotingInterval;\n    vote_delay = options->TestingV3AuthInitialVoteDelay;\n    dist_delay = options->TestingV3AuthInitialDistDelay;\n  }\n  tor_assert(interval > 0);\n  if (vote_delay + dist_delay > interval/2)\n    vote_delay = dist_delay = interval / 4;\n  start = new_voting_schedule->interval_starts =\n    dirvote_get_start_of_next_interval(now,interval,\n                                      options->TestingV3AuthVotingStartOffset);\n  end = dirvote_get_start_of_next_interval(start+1, interval,\n                                      options->TestingV3AuthVotingStartOffset);\n  tor_assert(end > start);\n  new_voting_schedule->fetch_missing_signatures = start - (dist_delay/2);\n  new_voting_schedule->voting_ends = start - dist_delay;\n  new_voting_schedule->fetch_missing_votes =\n    start - dist_delay - (vote_delay/2);\n  new_voting_schedule->voting_starts = start - dist_delay - vote_delay;\n  {\n    char tbuf[ISO_TIME_LEN+1];\n    format_iso_time(tbuf, new_voting_schedule->interval_starts);\n    tor_log(severity, LD_DIR,\"Choosing expected valid-after time as %s: \"\n            \"consensus_set=%d, interval=%d\",\n            tbuf, consensus?1:0, interval);\n  }\n  return new_voting_schedule;\n}", "target": 0}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static spl_ptr_heap_element spl_ptr_heap_delete_top(spl_ptr_heap *heap, void *cmp_userdata TSRMLS_DC) { \n\tint i, j;\n\tconst int limit = (heap->count-1)/2;\n\tspl_ptr_heap_element top;\n\tspl_ptr_heap_element bottom;\n\tif (heap->count == 0) {\n\t\treturn NULL;\n\t}\n\ttop    = heap->elements[0];\n\tbottom = heap->elements[--heap->count];\n\tfor( i = 0; i < limit; i = j)\n\t{\n\t\tj = i*2+1;\n\t\tif(j != heap->count && heap->cmp(heap->elements[j+1], heap->elements[j], cmp_userdata TSRMLS_CC) > 0) {\n\t\t\tj++; \n\t\t}\n\t\tif(heap->cmp(bottom, heap->elements[j], cmp_userdata TSRMLS_CC) < 0) {\n\t\t\theap->elements[i] = heap->elements[j];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (EG(exception)) {\n\t\theap->flags |= SPL_HEAP_CORRUPTED;\n\t}\n\theap->elements[i] = bottom;\n\theap->dtor(top TSRMLS_CC);\n\treturn top;\n}", "target": 0}
{"code": "void zend_accel_shared_protect(int mode)\n{\n#ifdef HAVE_MPROTECT\n\tint i;\n\tif (mode) {\n\t\tmode = PROT_READ;\n\t} else {\n\t\tmode = PROT_READ|PROT_WRITE;\n\t}\n\tfor (i = 0; i < ZSMMG(shared_segments_count); i++) {\n\t\tmprotect(ZSMMG(shared_segments)[i]->p, ZSMMG(shared_segments)[i]->size, mode);\n\t}\n#endif\n}", "target": 0}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "yang_deviate_delete_unique(struct lys_module *module, struct lys_deviate *deviate,\n                           struct lys_node_list *list, int index, char * value)\n{\n    struct ly_ctx *ctx = module->ctx;\n    int i, j, k;\n    for (i = 0; i < list->unique_size; i++) {\n        if (list->unique[i].expr_size != deviate->unique[index].expr_size) {\n            continue;\n        }\n        for (j = 0; j < deviate->unique[index].expr_size; j++) {\n            if (!ly_strequal(list->unique[i].expr[j], deviate->unique[index].expr[j], 1)) {\n                break;\n            }\n        }\n        if (j == deviate->unique[index].expr_size) {\n            for (j = 0; j < list->unique[i].expr_size; j++) {\n                lydict_remove(ctx, list->unique[i].expr[j]);\n            }\n            free(list->unique[i].expr);\n            list->unique_size--;\n            if (i != list->unique_size) {\n                list->unique[i].expr_size = list->unique[list->unique_size].expr_size;\n                list->unique[i].expr = list->unique[list->unique_size].expr;\n            }\n            if (!list->unique_size) {\n                free(list->unique);\n                list->unique = NULL;\n            } else {\n                list->unique[list->unique_size].expr_size = 0;\n                list->unique[list->unique_size].expr = NULL;\n            }\n            k = i; \n            i = -1; \n            break;\n        }\n    }\n    if (i != -1) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Value differs from the target being deleted.\");\n        return EXIT_FAILURE;\n    }\n    j = -1;\n    while ((j = lys_ext_iter(list->ext, list->ext_size, j + 1, LYEXT_SUBSTMT_UNIQUE)) != -1) {\n        if (list->ext[j]->insubstmt_index == k) {\n            lyp_ext_instance_rm(ctx, &list->ext, &list->ext_size, j);\n            --j;\n        } else if (list->ext[j]->insubstmt_index > k) {\n            list->ext[j]->insubstmt_index--;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "get_req_flags(unsigned char **buff_in, OM_uint32 bodysize,\n\t      OM_uint32 *req_flags)\n{\n\tunsigned int len;\n\tif (**buff_in != (CONTEXT | 0x01))\n\t\treturn (0);\n\tif (g_get_tag_and_length(buff_in, (CONTEXT | 0x01),\n\t\t\t\tbodysize, &len) < 0)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_LENGTH)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*(*buff_in)++ != BIT_STRING_PADDING)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t*req_flags = (OM_uint32) (*(*buff_in)++ >> 1);\n\treturn (0);\n}", "target": 0}
{"code": "cmsUInt32Number CMSEXPORT cmsGetPostScriptColorResource(cmsContext ContextID,\n                                                               cmsPSResourceType Type,\n                                                               cmsHPROFILE hProfile,\n                                                               cmsUInt32Number Intent,\n                                                               cmsUInt32Number dwFlags,\n                                                               cmsIOHANDLER* io)\n{\n    cmsUInt32Number  rc;\n    switch (Type) {\n        case cmsPS_RESOURCE_CSA:\n            rc = GenerateCSA(ContextID, hProfile, Intent, dwFlags, io);\n            break;\n        default:\n        case cmsPS_RESOURCE_CRD:\n            rc = GenerateCRD(ContextID, hProfile, Intent, dwFlags, io);\n            break;\n    }\n    return rc;\n}", "target": 0}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "u32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}", "target": 0}
{"code": "ppp_input(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct channel *pch = chan->ppp;\n\tint proto;\n\tif (!pch || skb->len == 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = PPP_PROTO(skb);\n\tread_lock_bh(&pch->upl);\n\tif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\n\t\tskb_queue_tail(&pch->file.rq, skb);\n\t\twhile (pch->file.rq.qlen > PPP_MAX_RQLEN\n\t\t       && (skb = skb_dequeue(&pch->file.rq)))\n\t\t\tkfree_skb(skb);\n\t\twake_up_interruptible(&pch->file.rwait);\n\t} else {\n\t\tppp_do_recv(pch->ppp, skb, pch);\n\t}\n\tread_unlock_bh(&pch->upl);\n}", "target": 0}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 0}
{"code": "nwfilterConnectNumOfNWFilters(virConnectPtr conn)\n{\n    if (virConnectNumOfNWFiltersEnsureACL(conn) < 0)\n        return -1;\n    return virNWFilterObjListNumOfNWFilters(driver->nwfilters, conn,\n                                        virConnectNumOfNWFiltersCheckACL);\n}", "target": 1}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "oneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    \n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n    if (ptr[l] == NUL && (ve_flags & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}", "target": 0}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "int js_isstring(js_State *J, int idx) { enum js_Type t = stackidx(J, idx)->type; return t == JS_TSHRSTR || t == JS_TLITSTR || t == JS_TMEMSTR; }", "target": 0}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "convert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}", "target": 1}
{"code": "static int inet6_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t     struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct netconfmsg *ncm;\n\tstruct sk_buff *skb;\n\tstruct ipv6_devconf *devconf;\n\tstruct inet6_dev *in6_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\terr = nlmsg_parse(nlh, sizeof(*ncm), tb, NETCONFA_MAX,\n\t\t\t  devconf_ipv6_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv6.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv6.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (dev == NULL)\n\t\t\tgoto errout;\n\t\tin6_dev = __in6_dev_get(dev);\n\t\tif (in6_dev == NULL)\n\t\t\tgoto errout;\n\t\tdevconf = &in6_dev->cnf;\n\t\tbreak;\n\t}\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet6_netconf_msgsize_devconf(-1), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = inet6_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\t NETLINK_CB(in_skb).portid,\n\t\t\t\t\t nlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\t -1);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}", "target": 0}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "vg_get_config(VuDev *dev, uint8_t *config, uint32_t len)\n{\n    VuGpu *g = container_of(dev, VuGpu, dev.parent);\n    if (len > sizeof(struct virtio_gpu_config)) {\n        return -1;\n    }\n    if (opt_virgl) {\n        g->virtio_config.num_capsets = vg_virgl_get_num_capsets();\n    }\n    memcpy(config, &g->virtio_config, len);\n    return 0;\n}", "target": 0}
{"code": "void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n    MemSlot *slot;\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"group_id too big\");\n        return NULL;\n    }\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"slot_id %d too big, addr=%\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n    slot = &info->mem_slots[group_id][slot_id];\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"address generation is not valid, group_id %d, slot_id %d, \"\n                       \"gen %d, slot_gen %d\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n    return (void*)(uintptr_t)h_virt;\n}", "target": 1}
{"code": "static int __execlists_context_alloc(struct intel_context *ce,\n\t\t\t\t     struct intel_engine_cs *engine)\n{\n\tstruct drm_i915_gem_object *ctx_obj;\n\tstruct intel_ring *ring;\n\tstruct i915_vma *vma;\n\tu32 context_size;\n\tint ret;\n\tGEM_BUG_ON(ce->state);\n\tcontext_size = round_up(engine->context_size, I915_GTT_PAGE_SIZE);\n\tif (IS_ENABLED(CONFIG_DRM_I915_DEBUG_GEM))\n\t\tcontext_size += I915_GTT_PAGE_SIZE; \n\tctx_obj = i915_gem_object_create_shmem(engine->i915, context_size);\n\tif (IS_ERR(ctx_obj))\n\t\treturn PTR_ERR(ctx_obj);\n\tvma = i915_vma_instance(ctx_obj, &engine->gt->ggtt->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto error_deref_obj;\n\t}\n\tif (!ce->timeline) {\n\t\tstruct intel_timeline *tl;\n\t\ttl = intel_timeline_create(engine->gt, NULL);\n\t\tif (IS_ERR(tl)) {\n\t\t\tret = PTR_ERR(tl);\n\t\t\tgoto error_deref_obj;\n\t\t}\n\t\tce->timeline = tl;\n\t}\n\tring = intel_engine_create_ring(engine, (unsigned long)ce->ring);\n\tif (IS_ERR(ring)) {\n\t\tret = PTR_ERR(ring);\n\t\tgoto error_deref_obj;\n\t}\n\tret = populate_lr_context(ce, ctx_obj, engine, ring);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to populate LRC: %d\\n\", ret);\n\t\tgoto error_ring_free;\n\t}\n\tce->ring = ring;\n\tce->state = vma;\n\treturn 0;\nerror_ring_free:\n\tintel_ring_put(ring);\nerror_deref_obj:\n\ti915_gem_object_put(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "    static void _distance_scan(const unsigned int len,\n                               const longT *const g,\n                               longT (*const sep)(const longT, const longT, const longT *const),\n                               longT (*const f)(const longT, const longT, const longT *const),\n                               longT *const s,\n                               longT *const t,\n                               longT *const dt) {\n      longT q = s[0] = t[0] = 0;\n      for (int u = 1; u<(int)len; ++u) { \n        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }\n        if (q<0) { q = 0; s[0] = u; }\n        else { const longT w = 1 + sep(s[q], u, g); if (w<(longT)len) { ++q; s[q] = u; t[q] = w; }}\n      }\n      for (int u = (int)len - 1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; } ", "target": 0}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}", "target": 1}
{"code": "onig_get_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n  }\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "KCleanup::KCleanup( QString\t\tid,\n\t\t    QString\t\tcommand,\n\t\t    QString\t\ttitle,\n\t\t    KActionCollection *\tparent\t)\n    : KAction( title,\n\t       parent)\n    , _id\t( id\t  )\n    , _command\t( command )\n    , _title\t( title\t  )\n{\n    _selection\t\t= 0;\n    _enabled\t\t= true;\n    _worksForDir\t= true;\n    _worksForFile\t= false;\n    _worksForDotEntry\t= false;\n    _worksLocalOnly\t= true;\n    _recurse\t\t= false;\n    _askForConfirmation\t= false;\n    _refreshPolicy\t= noRefresh;\n    KAction::setEnabled( false );\n    parent->addAction(id,this);\n    connect(this, SIGNAL(triggered()),\n            this, SLOT(executeWithSelection()));\n}", "target": 0}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "print_optimize_info(FILE* f, regex_t* reg)\n{\n  static const char* on[] = { \"NONE\", \"EXACT\", \"EXACT_BM\", \"EXACT_BM_NOT_REV\",\n                              \"EXACT_IC\", \"MAP\" };\n  fprintf(f, \"optimize: %s\\n\", on[reg->optimize]);\n  fprintf(f, \"  anchor: \"); print_anchor(f, reg->anchor);\n  if ((reg->anchor & ANCHOR_END_BUF_MASK) != 0)\n    print_distance_range(f, reg->anchor_dmin, reg->anchor_dmax);\n  fprintf(f, \"\\n\");\n  if (reg->optimize) {\n    fprintf(f, \"  sub anchor: \"); print_anchor(f, reg->sub_anchor);\n    fprintf(f, \"\\n\");\n  }\n  fprintf(f, \"\\n\");\n  if (reg->exact) {\n    UChar *p;\n    fprintf(f, \"exact: [\");\n    for (p = reg->exact; p < reg->exact_end; p++) {\n      fputc(*p, f);\n    }\n    fprintf(f, \"]: length: %ld\\n\", (reg->exact_end - reg->exact));\n  }\n  else if (reg->optimize & ONIG_OPTIMIZE_MAP) {\n    int c, i, n = 0;\n    for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n      if (reg->map[i]) n++;\n    fprintf(f, \"map: n=%d\\n\", n);\n    if (n > 0) {\n      c = 0;\n      fputc('[', f);\n      for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n\tif (reg->map[i] != 0) {\n          if (c > 0)  fputs(\", \", f);\n          c++;\n          if (ONIGENC_MBC_MAXLEN(reg->enc) == 1 &&\n              ONIGENC_IS_CODE_PRINT(reg->enc, (OnigCodePoint )i))\n            fputc(i, f);\n          else\n            fprintf(f, \"%d\", i);\n        }\n      }\n      fprintf(f, \"]\\n\");\n    }\n  }\n}", "target": 0}
{"code": "void HeaderString::setReference(absl::string_view ref_value) {\n  buffer_ = ref_value;\n  ASSERT(valid());\n}", "target": 0}
{"code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}", "target": 1}
{"code": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "static ssize_t psi_write(struct file *file, const char __user *user_buf,\n\t\t\t size_t nbytes, enum psi_res res)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\tstruct seq_file *seq;\n\tstruct psi_trigger *new;\n\tif (static_branch_likely(&psi_disabled))\n\t\treturn -EOPNOTSUPP;\n\tbuf_size = min(nbytes, sizeof(buf));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\tbuf[buf_size - 1] = '\\0';\n\tnew = psi_trigger_create(&psi_system, buf, nbytes, res);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tseq = file->private_data;\n\tmutex_lock(&seq->lock);\n\tpsi_trigger_replace(&seq->private, new);\n\tmutex_unlock(&seq->lock);\n\treturn nbytes;\n}", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n    return qftf_list;\n}", "target": 1}
{"code": "static int io_wqe_worker(void *data)\n{\n\tstruct io_worker *worker = data;\n\tstruct io_wqe_acct *acct = io_wqe_get_acct(worker);\n\tstruct io_wqe *wqe = worker->wqe;\n\tstruct io_wq *wq = wqe->wq;\n\tbool last_timeout = false;\n\tchar buf[TASK_COMM_LEN];\n\tworker->flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);\n\tsnprintf(buf, sizeof(buf), \"iou-wrk-%d\", wq->task->pid);\n\tset_task_comm(current, buf);\n\twhile (!test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\tlong ret;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\nloop:\n\t\traw_spin_lock(&wqe->lock);\n\t\tif (io_acct_run_queue(acct)) {\n\t\t\tio_worker_handle_work(worker);\n\t\t\tgoto loop;\n\t\t}\n\t\tif (last_timeout && acct->nr_workers > 1) {\n\t\t\traw_spin_unlock(&wqe->lock);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t\tlast_timeout = false;\n\t\t__io_worker_idle(wqe, worker);\n\t\traw_spin_unlock(&wqe->lock);\n\t\tif (io_flush_signals())\n\t\t\tcontinue;\n\t\tret = schedule_timeout(WORKER_IDLE_TIMEOUT);\n\t\tif (signal_pending(current)) {\n\t\t\tstruct ksignal ksig;\n\t\t\tif (!get_signal(&ksig))\n\t\t\t\tcontinue;\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\tlast_timeout = !ret;\n\t}\n\tif (test_bit(IO_WQ_BIT_EXIT, &wq->state)) {\n\t\traw_spin_lock(&wqe->lock);\n\t\tio_worker_handle_work(worker);\n\t}\n\tio_worker_exit(worker);\n\treturn 0;\n}", "target": 0}
{"code": "const char* menu_cache_item_get_file_basename( MenuCacheItem* item )\n{\n    return item->file_name;\n}", "target": 0}
{"code": "const std::string& GetExtensionIdForMutedTab(content::WebContents* contents) {\n  DCHECK_EQ(GetTabAudioMutedReason(contents) != TabMutedReason::EXTENSION,\n            LastMuteMetadata::FromWebContents(contents)->extension_id.empty());\n  return LastMuteMetadata::FromWebContents(contents)->extension_id;\n}", "target": 0}
{"code": "TEST(EqOp, MatchesReferencedArrayValue) {\n    BSONObj operand = BSON(\"a.0\" << 5);\n    EqualityMatchExpression eq(\"a.0\", operand[\"a.0\"]);\n    ASSERT(eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(5)), NULL));\n    ASSERT(!eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON_ARRAY(5))), NULL));\n}", "target": 0}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 1}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,\n                                      uint32_t arch,\n                                      int nr,\n                                      unsigned int arg_cnt,\n                                      const struct scmp_arg_cmp arg) {\n        int r;\n        r = seccomp_rule_add_exact(seccomp, SCMP_ACT_ERRNO(EPERM), nr, arg_cnt, arg);\n        if (r < 0) {\n                _cleanup_free_ char *n = NULL;\n                n = seccomp_syscall_resolve_num_arch(arch, nr);\n                log_debug_errno(r, \"Failed to add %s() rule for architecture %s, skipping: %m\",\n                                strna(n),\n                                seccomp_arch_to_string(arch));\n        }\n        return r;\n}", "target": 0}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\t*prev = NULL;\t\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1}
{"code": "static bool imap_client_input_next_cmd(struct client *_client)\n{\n\tstruct imap_client *client = (struct imap_client *)_client;\n\tconst struct imap_arg *args;\n\tbool parsed;\n\tint ret;\n\tif (strcasecmp(client->cmd_name, \"AUTHENTICATE\") == 0) {\n\t\tret = cmd_authenticate(client, &parsed);\n\t\tif (ret == 0 && !parsed)\n\t\t\treturn FALSE;\n\t} else if (strcasecmp(client->cmd_name, \"ID\") == 0) {\n\t\tret = cmd_id(client);\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tif (ret < 0)\n\t\t\tret = 1; \n\t} else {\n\t\tret = client_parse_command(client, &args);\n\t\tif (ret < 0)\n\t\t\treturn TRUE;\n\t\tif (ret == 0)\n\t\t\treturn FALSE;\n\t\tret = *client->cmd_tag == '\\0' ? -1 :\n\t\t\tclient_command_execute(client, client->cmd_name, args);\n\t}\n\tclient->cmd_finished = TRUE;\n\tif (ret == -2 && strcasecmp(client->cmd_tag, \"LOGIN\") == 0) {\n\t\tclient_send_reply(&client->common, IMAP_CMD_REPLY_BAD,\n\t\t\t\"First parameter in line is IMAP's command tag, \"\n\t\t\t\"not the command name. Add that before the command, \"\n\t\t\t\"like: a login user pass\");\n\t} else if (ret < 0) {\n\t\tif (!client_invalid_command(client))\n\t\t\treturn FALSE;\n\t}\n\treturn ret != 0 && !client->common.destroyed;\n}", "target": 0}
{"code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}", "target": 1}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n{\n    int r, b;\n    b = cdt[p2];\n    r = cdt[p1]<<16;\n    return (b+r) << 1;\n}", "target": 0}
{"code": "debug_print_string(uschar *debug_string)\n{\nif (!debug_string) return;\nHDEBUG(D_any|D_v)\n  {\n  uschar *s = expand_string(debug_string);\n  if (!s)\n    debug_printf(\"failed to expand debug_output \\\"%s\\\": %s\\n\", debug_string,\n      expand_string_message);\n  else if (s[0] != 0)\n    debug_printf(\"%s%s\", s, (s[Ustrlen(s)-1] == '\\n')? \"\" : \"\\n\");\n  }\n}", "target": 0}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "Value ExpressionDateFromParts::evaluate(const Document& root, Variables* variables) const {\n    long long hour, minute, second, millisecond;\n    if (!evaluateNumberWithDefaultAndBounds(root, _hour.get(), \"hour\"_sd, 0, &hour, variables) ||\n        !evaluateNumberWithDefaultAndBounds(\n            root, _minute.get(), \"minute\"_sd, 0, &minute, variables) ||\n        !evaluateNumberWithDefault(root, _second.get(), \"second\"_sd, 0, &second, variables) ||\n        !evaluateNumberWithDefault(\n            root, _millisecond.get(), \"millisecond\"_sd, 0, &millisecond, variables)) {\n        return Value(BSONNULL);\n    }\n    auto timeZone =\n        makeTimeZone(getExpressionContext()->timeZoneDatabase, root, _timeZone.get(), variables);\n    if (!timeZone) {\n        return Value(BSONNULL);\n    }\n    if (_year) {\n        long long year, month, day;\n        if (!evaluateNumberWithDefault(root, _year.get(), \"year\"_sd, 1970, &year, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _month.get(), \"month\"_sd, 1, &month, variables) ||\n            !evaluateNumberWithDefaultAndBounds(root, _day.get(), \"day\"_sd, 1, &day, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(40523,\n                str::stream() << \"'year' must evaluate to an integer in the range \" << 1 << \" to \"\n                              << 9999 << \", found \" << year,\n                year >= 1 && year <= 9999);\n        return Value(\n            timeZone->createFromDateParts(year, month, day, hour, minute, second, millisecond));\n    }\n    if (_isoWeekYear) {\n        long long isoWeekYear, isoWeek, isoDayOfWeek;\n        if (!evaluateNumberWithDefault(\n                root, _isoWeekYear.get(), \"isoWeekYear\"_sd, 1970, &isoWeekYear, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoWeek.get(), \"isoWeek\"_sd, 1, &isoWeek, variables) ||\n            !evaluateNumberWithDefaultAndBounds(\n                root, _isoDayOfWeek.get(), \"isoDayOfWeek\"_sd, 1, &isoDayOfWeek, variables)) {\n            return Value(BSONNULL);\n        }\n        uassert(31095,\n                str::stream() << \"'isoWeekYear' must evaluate to an integer in the range \" << 1\n                              << \" to \" << 9999 << \", found \" << isoWeekYear,\n                isoWeekYear >= 1 && isoWeekYear <= 9999);\n        return Value(timeZone->createFromIso8601DateParts(\n            isoWeekYear, isoWeek, isoDayOfWeek, hour, minute, second, millisecond));\n    }\n    MONGO_UNREACHABLE;\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "const char *who_am_i(void)\n{\n\tif (am_starting_up)\n\t\treturn am_server ? \"server\" : \"client\";\n\treturn am_sender ? \"sender\"\n\t     : am_generator ? \"generator\"\n\t     : am_receiver ? \"receiver\"\n\t     : \"Receiver\"; \n}", "target": 0}
{"code": "rdp_protocol_error(const char *message, STREAM s)\n{\n\terror(\"%s(), %s\", __func__, message);\n\tif (s)\n\t\thexdump(s->p, s_length(s));\n\texit(0);\n}", "target": 0}
{"code": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for(list<string>::iterator it = exposable_hdrs.begin();\n      it != exposable_hdrs.end(); ++it) {\n      if (s.length() > 0)\n        s.append(\",\");\n      s.append((*it));\n  }\n}", "target": 1}
{"code": "static void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twait_event(fs_info->dev_replace.replace_wait, !percpu_counter_sum(\n\t\t   &fs_info->dev_replace.bio_counter));\n}", "target": 0}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\n{\n\tint lookup_flags = 0;\n\tint acc_mode;\n\tif (flags & O_CREAT)\n\t\top->mode = (mode & S_IALLUGO) | S_IFREG;\n\telse\n\t\top->mode = 0;\n\tflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\n\tif (flags & __O_SYNC)\n\t\tflags |= O_DSYNC;\n\tif (flags & __O_TMPFILE) {\n\t\tif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\n\t\t\treturn -EINVAL;\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t} else if (flags & O_PATH) {\n\t\tflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\n\t\tacc_mode = 0;\n\t} else {\n\t\tacc_mode = MAY_OPEN | ACC_MODE(flags);\n\t}\n\top->open_flag = flags;\n\tif (flags & O_TRUNC)\n\t\tacc_mode |= MAY_WRITE;\n\tif (flags & O_APPEND)\n\t\tacc_mode |= MAY_APPEND;\n\top->acc_mode = acc_mode;\n\top->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\n\tif (flags & O_CREAT) {\n\t\top->intent |= LOOKUP_CREATE;\n\t\tif (flags & O_EXCL)\n\t\t\top->intent |= LOOKUP_EXCL;\n\t}\n\tif (flags & O_DIRECTORY)\n\t\tlookup_flags |= LOOKUP_DIRECTORY;\n\tif (!(flags & O_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\top->lookup_flags = lookup_flags;\n\treturn 0;\n}", "target": 0}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}", "target": 1}
{"code": "regional_alloc(struct regional *r, size_t size)\n{\n\tsize_t a = ALIGN_UP(size, ALIGNMENT);\n\tvoid *s;\n\tif(a > REGIONAL_LARGE_OBJECT_SIZE) {\n\t\ts = malloc(ALIGNMENT + size);\n\t\tif(!s) return NULL;\n\t\tr->total_large += ALIGNMENT+size;\n\t\t*(char**)s = r->large_list;\n\t\tr->large_list = (char*)s;\n\t\treturn (char*)s+ALIGNMENT;\n\t}\n\tif(a > r->available) {\n\t\ts = malloc(REGIONAL_CHUNK_SIZE);\n\t\tif(!s) return NULL;\n\t\t*(char**)s = r->next;\n\t\tr->next = (char*)s;\n\t\tr->data = (char*)s + ALIGNMENT;\n\t\tr->available = REGIONAL_CHUNK_SIZE - ALIGNMENT;\n\t}\n\tr->available -= a;\n\ts = r->data;\n\tr->data += a;\n\treturn s;\n}", "target": 1}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\tread_lock(&tasklist_lock);\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"SAK: killed process %d (%s): by session\\n\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by controlling tty\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"SAK: killed process %d (%s): by fd#%d\\n\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}", "target": 1}
{"code": "void rfc_send_rls(tRFC_MCB* p_mcb, uint8_t dlci, bool is_command,\n uint8_t status) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_RLS;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_RLS_LEN << 1);\n *p_data++ = RFCOMM_EA | RFCOMM_CR_MASK | (dlci << RFCOMM_SHIFT_DLCI);\n *p_data++ = RFCOMM_RLS_ERROR | status;\n  p_buf->len = RFCOMM_MX_RLS_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "xsltFreeKeyTableList(xsltKeyTablePtr keyt) {\n    xsltKeyTablePtr cur;\n    while (keyt != NULL) {\n\tcur = keyt;\n\tkeyt = keyt->next;\n\txsltFreeKeyTable(cur);\n    }\n}", "target": 0}
{"code": "make_valid_utf8 (string & str)\n{\n  const char *pos;\n  if (!g_utf8_validate (str.c_str(), -1, &pos)) {\n    PTRACE (4, \"Ekiga\\tTrimming invalid UTF-8 string: \" << str.c_str());\n    str = str.substr (0, pos - str.c_str()).append (\"...\");\n  }\n}", "target": 0}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static inline void sctp_ulpq_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 tsn, ctsn;\n\ttsn = event->tsn;\n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tcevent = sctp_skb2event(pos);\n\tctsn = cevent->tsn;\n\tif (TSN_lt(ctsn, tsn)) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\t\tif (TSN_lt(tsn, ctsn))\n\t\t\tbreak;\n\t}\n\t__skb_insert(sctp_event2skb(event), pos->prev, pos, &ulpq->reasm);\n}", "target": 0}
{"code": "static void *intel_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  unsigned long attrs)\n{\n\tstruct page *page = NULL;\n\tint order;\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\tif (!iommu_no_mapping(dev))\n\t\tflags &= ~(GFP_DMA | GFP_DMA32);\n\telse if (dev->coherent_dma_mask < dma_get_required_mask(dev)) {\n\t\tif (dev->coherent_dma_mask < DMA_BIT_MASK(32))\n\t\t\tflags |= GFP_DMA;\n\t\telse\n\t\t\tflags |= GFP_DMA32;\n\t}\n\tif (gfpflags_allow_blocking(flags)) {\n\t\tunsigned int count = size >> PAGE_SHIFT;\n\t\tpage = dma_alloc_from_contiguous(dev, count, order,\n\t\t\t\t\t\t flags & __GFP_NOWARN);\n\t\tif (page && iommu_no_mapping(dev) &&\n\t\t    page_to_phys(page) + size > dev->coherent_dma_mask) {\n\t\t\tdma_release_from_contiguous(dev, page, count);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (!page)\n\t\tpage = alloc_pages(flags, order);\n\tif (!page)\n\t\treturn NULL;\n\tmemset(page_address(page), 0, size);\n\t*dma_handle = __intel_map_single(dev, page_to_phys(page), size,\n\t\t\t\t\t DMA_BIDIRECTIONAL,\n\t\t\t\t\t dev->coherent_dma_mask);\n\tif (*dma_handle)\n\t\treturn page_address(page);\n\tif (!dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT))\n\t\t__free_pages(page, order);\n\treturn NULL;\n}", "target": 0}
{"code": "\tTEST_METHOD(7) {\n\t\tServerInstanceDir dir(parentDir + \"/passenger-test.1234\");\n\t\tServerInstanceDir::GenerationPtr generation = dir.newGeneration(true,\n\t\t\t\"nobody\", nobodyGroup, 0, 0);\n\t\tstring path = generation->getPath();\n\t\tgeneration.reset();\n\t\tensure_equals(getFileType(path), FT_NONEXISTANT);\n\t}", "target": 0}
{"code": "__visible void kvm_lock_spinning(struct arch_spinlock *lock, __ticket_t want)\n{\n\tstruct kvm_lock_waiting *w;\n\tint cpu;\n\tu64 start;\n\tunsigned long flags;\n\tif (in_nmi())\n\t\treturn;\n\tw = this_cpu_ptr(&klock_waiting);\n\tcpu = smp_processor_id();\n\tstart = spin_time_start();\n\tlocal_irq_save(flags);\n\tw->lock = NULL;\n\tsmp_wmb();\n\tw->want = want;\n\tsmp_wmb();\n\tw->lock = lock;\n\tadd_stats(TAKEN_SLOW, 1);\n\tcpumask_set_cpu(cpu, &waiting_cpus);\n\tbarrier();\n\t__ticket_enter_slowpath(lock);\n\tif (ACCESS_ONCE(lock->tickets.head) == want) {\n\t\tadd_stats(TAKEN_SLOW_PICKUP, 1);\n\t\tgoto out;\n\t}\n\tif (arch_irqs_disabled_flags(flags))\n\t\thalt();\n\telse\n\t\tsafe_halt();\nout:\n\tcpumask_clear_cpu(cpu, &waiting_cpus);\n\tw->lock = NULL;\n\tlocal_irq_restore(flags);\n\tspin_time_accum_blocked(start);\n}", "target": 0}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\tif (!sanity(i))\n\t\treturn 0;\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "rdp_enum_bmpcache2(void)\n{\n\tSTREAM s;\n\tHASH_KEY keylist[BMPCACHE2_NUM_PSTCELLS];\n\tuint32 num_keys, offset, count, flags;\n\toffset = 0;\n\tnum_keys = pstcache_enumerate(2, keylist);\n\twhile (offset < num_keys)\n\t{\n\t\tcount = MIN(num_keys - offset, 169);\n\t\ts = rdp_init_data(24 + count * sizeof(HASH_KEY));\n\t\tflags = 0;\n\t\tif (offset == 0)\n\t\t\tflags |= PDU_FLAG_FIRST;\n\t\tif (num_keys - offset <= 169)\n\t\t\tflags |= PDU_FLAG_LAST;\n\t\tout_uint32_le(s, 0);\n\t\tout_uint16_le(s, count);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, 0);\n\t\tout_uint16_le(s, num_keys);\n\t\tout_uint32_le(s, 0);\n\t\tout_uint32_le(s, flags);\n\t\tout_uint8a(s, keylist[offset], count * sizeof(HASH_KEY));\n\t\ts_mark_end(s);\n\t\trdp_send_data(s, 0x2b);\n\t\toffset += 169;\n\t}\n}", "target": 0}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static void OneLineTransp(struct ico_progressive_state *context)\n{\n\tgint X;\n\tguchar *Pixels;\n\tif (context->Header.depth == 32)\n\t\treturn;\n\tX = 0;\n\tif (context->Header.Negative == 0)\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (2*context->Header.height - context->Lines - 1));\n\telse\n\t\tPixels = (context->pixbuf->pixels +\n\t\t\t  (gsize) context->pixbuf->rowstride *\n\t\t\t  (context->Lines-context->Header.height));\n\twhile (X < context->Header.width) {\n\t\tint Bit;\n\t\tBit = (context->LineBuf[X / 8]) >> (7 - (X & 7));\n\t\tBit = Bit & 1;\n\t\tPixels[X * 4 + 3] = 255-Bit*255;\n#if 0\n\t\tif (Bit){\n\t\t  Pixels[X*4+0] = 255;\n\t\t  Pixels[X*4+1] = 255;\n\t\t} else {\n\t\t  Pixels[X*4+0] = 0;\n\t\t  Pixels[X*4+1] = 0;\n\t\t}\n#endif\t\t\n\t\tX++;\n\t}\n}", "target": 0}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "static void domain_exit(struct dmar_domain *domain)\n{\n\tstruct page *freelist = NULL;\n\tif (!domain)\n\t\treturn;\n\trcu_read_lock();\n\tdomain_remove_dev_info(domain);\n\trcu_read_unlock();\n\tput_iova_domain(&domain->iovad);\n\tfreelist = domain_unmap(domain, 0, DOMAIN_MAX_PFN(domain->gaw));\n\tdma_free_pagelist(freelist);\n\tfree_domain_mem(domain);\n}", "target": 0}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "key_ref_t search_process_keyrings(struct key_type *type,\n\t\t\t\t  const void *description,\n\t\t\t\t  key_match_func_t match,\n\t\t\t\t  const struct cred *cred)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\tmight_sleep();\n\tkey_ref = search_my_process_keyrings(type, description, match,\n\t\t\t\t\t     false, cred);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\tif (cred->request_key_auth &&\n\t    cred == current_cred() &&\n\t    type != &key_type_request_key_auth\n\t    ) {\n\t\tdown_read(&cred->request_key_auth->sem);\n\t\tif (key_validate(cred->request_key_auth) == 0) {\n\t\t\trka = cred->request_key_auth->payload.data;\n\t\t\tkey_ref = search_process_keyrings(type, description,\n\t\t\t\t\t\t\t  match, rka->cred);\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\nfound:\n\treturn key_ref;\n}", "target": 0}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err)\n\t\treturn err;\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\tkcrtc->wb_conn = kwb_conn;\n\treturn 0;\n}", "target": 1}
{"code": "    ImageType ImageFactory::getType(const std::wstring& wpath)\n    {\n        FileIo fileIo(wpath);\n        return getType(fileIo);\n    }", "target": 0}
{"code": "void QuotaManager::RegisterClient(QuotaClient* client) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  DCHECK(!database_.get());\n  clients_.push_back(client);\n}", "target": 0}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "int gnutls_x509_aki_set_cert_issuer(gnutls_x509_aki_t aki,\n\t\t\t\t    unsigned int san_type,\n\t\t\t\t    const gnutls_datum_t * san,\n\t\t\t\t    const char *othername_oid,\n\t\t\t\t    const gnutls_datum_t * serial)\n{\n\tint ret;\n\tgnutls_datum_t t_san, t_othername_oid = { NULL, 0 };\n\tret = _gnutls_set_datum(&aki->serial, serial->data, serial->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\taki->cert_issuer.names[aki->cert_issuer.size].type = san_type;\n\tret = _gnutls_set_datum(&t_san, san->data, san->size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (othername_oid) {\n\t\tt_othername_oid.data = (uint8_t *) gnutls_strdup(othername_oid);\n\t\tif (t_othername_oid.data == NULL) {\n\t\t\tgnutls_free(t_san.data);\n\t\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\t\t}\n\t\tt_othername_oid.size = strlen(othername_oid);\n\t}\n\tret =\n\t    subject_alt_names_set(&aki->cert_issuer.names,\n\t\t\t\t  &aki->cert_issuer.size, san_type, &t_san,\n\t\t\t\t  (char *)t_othername_oid.data);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "cmsHPROFILE CreatePCS2ITU_ICC(void)\n{\n    cmsHPROFILE hProfile;\n    cmsPipeline* BToA0;\n    cmsStage* ColorMap;\n    BToA0 = cmsPipelineAlloc(0, 3, 3);\n    if (BToA0 == NULL) return NULL;\n    ColorMap = cmsStageAllocCLut16bit(0, GRID_POINTS, 3, 3, NULL);\n    if (ColorMap == NULL) return NULL;\n    cmsPipelineInsertStage(BToA0, cmsAT_BEGIN, ColorMap);\n    cmsStageSampleCLut16bit(ColorMap, PCS2ITU, NULL, 0);\n    hProfile = cmsCreateProfilePlaceholder(0);\n    if (hProfile == NULL) {\n        cmsPipelineFree(BToA0);\n        return NULL;\n    }\n    cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA0);\n    cmsSetColorSpace(hProfile, cmsSigLabData);\n    cmsSetPCS(hProfile, cmsSigLabData);\n    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n    cmsPipelineFree(BToA0);\n    return hProfile;\n}", "target": 0}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "static void iommu_enable_dev_iotlb(struct device_domain_info *info)\n{\n\tstruct pci_dev *pdev;\n\tassert_spin_locked(&device_domain_lock);\n\tif (!info || !dev_is_pci(info->dev))\n\t\treturn;\n\tpdev = to_pci_dev(info->dev);\n\tif (!ecap_dit(info->iommu->ecap))\n\t\tinfo->pfsid = 0;\n\telse {\n\t\tstruct pci_dev *pf_pdev;\n\t\tpf_pdev = pci_physfn(pdev);\n\t\tinfo->pfsid = PCI_DEVID(pf_pdev->bus->number, pf_pdev->devfn);\n\t}\n#ifdef CONFIG_INTEL_IOMMU_SVM\n\tif (info->pasid_supported && !pci_enable_pasid(pdev, info->pasid_supported & ~1))\n\t\tinfo->pasid_enabled = 1;\n\tif (info->pri_supported && !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))\n\t\tinfo->pri_enabled = 1;\n#endif\n\tif (!pdev->untrusted && info->ats_supported &&\n\t    !pci_enable_ats(pdev, VTD_PAGE_SHIFT)) {\n\t\tinfo->ats_enabled = 1;\n\t\tdomain_update_iotlb(info->domain);\n\t\tinfo->ats_qdep = pci_ats_queue_depth(pdev);\n\t}\n}", "target": 0}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "dirserv_should_launch_reachability_test(const routerinfo_t *ri,\n                                        const routerinfo_t *ri_old)\n{\n  if (!authdir_mode_handles_descs(get_options(), ri->purpose))\n    return 0;\n  if (!ri_old) {\n    return 1;\n  }\n  if (ri_old->is_hibernating && !ri->is_hibernating) {\n    return 1;\n  }\n  if (! routers_have_same_or_addrs(ri, ri_old)) {\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static int ax_close(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\tif (ax->tty)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\tnetif_stop_queue(dev);\n\treturn 0;\n}", "target": 0}
{"code": "void smp_send_init(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  smp_send_cmd(SMP_OPCODE_INIT, p_cb);\n}", "target": 0}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "bool Item_cache_row::null_inside()\n{\n  for (uint i= 0; i < item_count; i++)\n  {\n    if (values[i]->cols() > 1)\n    {\n      if (values[i]->null_inside())\n\treturn 1;\n    }\n    else\n    {\n      values[i]->update_null_value();\n      if (values[i]->null_value)\n\treturn 1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "struct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key))\n\t\treturn key;\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn key;\n}", "target": 0}
{"code": "int64 SavePackage::CurrentSpeed() const {\n  base::TimeDelta diff = base::TimeTicks::Now() - start_tick_;\n  int64 diff_ms = diff.InMilliseconds();\n  return diff_ms == 0 ? 0 : completed_count() * 1000 / diff_ms;\n}", "target": 0}
{"code": "static void unzzip_cat_file(ZZIP_DIR* disk, char* name, FILE* out)\n{\n    ZZIP_FILE* file = zzip_file_open (disk, name, 0);\n    if (file) \n    {\n\tchar buffer[1024]; int len;\n\twhile ((len = zzip_file_read (file, buffer, 1024))) \n\t{\n\t    fwrite (buffer, 1, len, out);\n\t}\n\tzzip_file_close (file);\n    }\n}", "target": 1}
{"code": "static int wrap_nettle_hash_fast(gnutls_digest_algorithm_t algo,\n\t\t\t\t const void *text, size_t text_size,\n\t\t\t\t void *digest)\n{\n\tstruct nettle_hash_ctx ctx;\n\tint ret;\n\tret = _ctx_init(algo, &ctx);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tctx.update(&ctx, text_size, text);\n\tctx.digest(&ctx, ctx.length, digest);\n\treturn 0;\n}", "target": 1}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "    TiffCopier::TiffCopier(      TiffComponent*  pRoot,\n                                 uint32_t        root,\n                           const TiffHeaderBase* pHeader,\n                           const PrimaryGroups*  pPrimaryGroups)\n        : pRoot_(pRoot),\n          root_(root),\n          pHeader_(pHeader),\n          pPrimaryGroups_(pPrimaryGroups)\n    {\n        assert(pRoot_ != 0);\n        assert(pHeader_ != 0);\n        assert(pPrimaryGroups_ != 0);\n    }", "target": 0}
{"code": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, size;\n\tint npinned;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\tint ret;\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn ERR_PTR(-EINVAL);\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (WARN_ON_ONCE(npages > INT_MAX))\n\t\treturn ERR_PTR(-EINVAL);\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnpinned = pin_user_pages_fast(uaddr, npages, write ? FOLL_WRITE : 0, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\t*n = npages;\n\tsev->pages_locked = locked;\n\treturn pages;\nerr:\n\tif (npinned > 0)\n\t\tunpin_user_pages(pages, npinned);\n\tkvfree(pages);\n\treturn ERR_PTR(ret);\n}", "target": 0}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "static handler_t mod_wstunnel_check_extension(request_st * const r, void *p_d) {\n    plugin_data *p = p_d;\n    handler_t rc;\n    if (NULL != r->handler_module)\n        return HANDLER_GO_ON;\n  if (r->http_version > HTTP_VERSION_1_1) {\n    if (!r->h2_connect_ext)\n        return HANDLER_GO_ON;\n  }\n  else {\n    if (r->http_method != HTTP_METHOD_GET)\n        return HANDLER_GO_ON;\n    if (r->http_version != HTTP_VERSION_1_1)\n        return HANDLER_GO_ON;\n    const buffer *vb;\n    vb = http_header_request_get(r, HTTP_HEADER_UPGRADE, CONST_STR_LEN(\"Upgrade\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"websocket\")))\n        return HANDLER_GO_ON;\n    vb = http_header_request_get(r, HTTP_HEADER_CONNECTION, CONST_STR_LEN(\"Connection\"));\n    if (NULL == vb\n        || !http_header_str_contains_token(BUF_PTR_LEN(vb), CONST_STR_LEN(\"upgrade\")))\n        return HANDLER_GO_ON;\n  }\n    mod_wstunnel_patch_config(r, p);\n    if (NULL == p->conf.gw.exts) return HANDLER_GO_ON;\n    rc = gw_check_extension(r, (gw_plugin_data *)p, 1, sizeof(handler_ctx));\n    return (HANDLER_GO_ON == rc && r->handler_module == p->self)\n      ? wstunnel_handler_setup(r, p)\n      : rc;\n}", "target": 0}
{"code": "void fuse_fs_destroy(struct fuse_fs *fs)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.destroy)\n        fs->op.destroy(fs->user_data);\n#ifdef __SOLARIS__\n    if (fs->m)\n        fuse_put_module(fs->m);\n#endif \n    free(fs);\n}", "target": 0}
{"code": "int fuse_fs_listxattr(struct fuse_fs *fs, const char *path, char *list,\n                      size_t size)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.listxattr)\n        return fs->op.listxattr(path, list, size);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "static zend_object_value zend_error_exception_new(zend_class_entry *class_type TSRMLS_DC) \n{\n\treturn zend_default_exception_new_ex(class_type, 2 TSRMLS_CC);\n}", "target": 0}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "int remove_file(struct augeas *aug, struct tree *tree) {\n    char *path = NULL;\n    const char *filename = NULL;\n    const char *err_status = NULL;\n    char *dyn_err_status = NULL;\n    char *augsave = NULL, *augorig = NULL, *augorig_canon = NULL;\n    int r;\n    path = path_of_tree(tree);\n    if (path == NULL) {\n        err_status = \"path_of_tree\";\n        goto error;\n    }\n    filename = path + strlen(AUGEAS_META_FILES);\n    if ((augorig = strappend(aug->root, filename + 1)) == NULL) {\n        err_status = \"root_file\";\n        goto error;\n    }\n    augorig_canon = canonicalize_file_name(augorig);\n    if (augorig_canon == NULL) {\n        if (errno == ENOENT) {\n            goto done;\n        } else {\n            err_status = \"canon_augorig\";\n            goto error;\n        }\n    }\n    r = file_saved_event(aug, path + strlen(AUGEAS_META_TREE));\n    if (r < 0) {\n        err_status = \"saved_event\";\n        goto error;\n    }\n    if (aug->flags & AUG_SAVE_NOOP)\n        goto done;\n    if (aug->flags & AUG_SAVE_BACKUP) {\n        r = asprintf(&augsave, \"%s\" EXT_AUGSAVE, augorig_canon);\n        if (r == -1) {\n            augsave = NULL;\n                goto error;\n        }\n        r = clone_file(augorig_canon, augsave, &err_status, 1, 1);\n        if (r != 0) {\n            dyn_err_status = strappend(err_status, \"_augsave\");\n            goto error;\n        }\n    } else {\n        r = unlink(augorig_canon);\n        if (r < 0) {\n            err_status = \"unlink_orig\";\n            goto error;\n        }\n    }\n    tree_unlink(tree);\n done:\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    return 0;\n error:\n    {\n        const char *emsg =\n            dyn_err_status == NULL ? err_status : dyn_err_status;\n        store_error(aug, filename, path, emsg, errno, NULL, NULL);\n    }\n    free(path);\n    free(augorig);\n    free(augorig_canon);\n    free(augsave);\n    free(dyn_err_status);\n    return -1;\n}", "target": 0}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ns_client_isself(dns_view_t *myview, dns_tsigkey_t *mykey,\n\t\t isc_sockaddr_t *srcaddr, isc_sockaddr_t *dstaddr,\n\t\t dns_rdataclass_t rdclass, void *arg)\n{\n\tdns_view_t *view;\n\tdns_tsigkey_t *key = NULL;\n\tdns_name_t *tsig = NULL;\n\tisc_netaddr_t netsrc;\n\tisc_netaddr_t netdst;\n\tUNUSED(arg);\n\tif (ns_g_server->interfacemgr == NULL)\n\t\treturn (true);\n\tif (!ns_interfacemgr_listeningon(ns_g_server->interfacemgr, dstaddr))\n\t\treturn (false);\n\tisc_netaddr_fromsockaddr(&netsrc, srcaddr);\n\tisc_netaddr_fromsockaddr(&netdst, dstaddr);\n\tfor (view = ISC_LIST_HEAD(ns_g_server->viewlist);\n\t     view != NULL;\n\t     view = ISC_LIST_NEXT(view, link)) {\n\t\tif (view->matchrecursiveonly)\n\t\t\tcontinue;\n\t\tif (rdclass != view->rdclass)\n\t\t\tcontinue;\n\t\tif (mykey != NULL) {\n\t\t\tbool match;\n\t\t\tisc_result_t result;\n\t\t\tresult = dns_view_gettsig(view, &mykey->name, &key);\n\t\t\tif (result != ISC_R_SUCCESS)\n\t\t\t\tcontinue;\n\t\t\tmatch = dst_key_compare(mykey->key, key->key);\n\t\t\tdns_tsigkey_detach(&key);\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\t\t\ttsig = dns_tsigkey_identity(mykey);\n\t\t}\n\t\tif (allowed(&netsrc, tsig, NULL, 0, NULL,\n\t\t\t    view->matchclients) &&\n\t\t    allowed(&netdst, tsig, NULL, 0, NULL,\n\t\t\t    view->matchdestinations))\n\t\t\tbreak;\n\t}\n\treturn (view == myview);\n}", "target": 0}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "int main(int ac, char *av[])\n{\n  int i, max_threads = 2;\n  pthread_t *threads;\n  if (ac < 2)\n    usage(av[0]);\n  queue = calloc(ac - 1, sizeof(queue[0]));\n  for (i = 1; i < ac; i++)\n  {\n    if (av[i][0] == '-')\n    {\n      if (av[i][1] == 'w')\n        use_camera_wb = 1;\n      if (av[i][1] == 'a')\n        use_auto_wb = 1;\n      if (av[i][1] == 'v')\n        verbose = 1;\n      if (av[i][1] == 'T')\n        tiff_mode = 1;\n      if (av[i][1] == 'J')\n      {\n        max_threads = atoi(av[++i]);\n        if (max_threads < 1)\n        {\n          fprintf(stderr, \"Job count should be at least 1\\n\");\n          exit(1);\n        }\n      }\n    }\n    else\n      queue[qsize++] = av[i];\n  }\n  pthread_mutex_init(&qm, NULL);\n  threads = calloc(max_threads, sizeof(threads[0]));\n  for (i = 0; i < max_threads; i++)\n    pthread_create(&threads[i], NULL, process_files, NULL);\n  for (i = 0; i < max_threads; i++)\n  {\n    int *iptr;\n    if (threads[i])\n    {\n      pthread_join(threads[i], (void *)&iptr);\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "char* Elf_(r_bin_elf_get_file_type)(ELFOBJ *bin) {\n\tut32 e_type;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\te_type = (ut32)bin->ehdr.e_type; \n\tswitch (e_type) {\n\tcase ET_NONE: return strdup (\"NONE (None)\");\n\tcase ET_REL:  return strdup (\"REL (Relocatable file)\");\n\tcase ET_EXEC: return strdup (\"EXEC (Executable file)\");\n\tcase ET_DYN:  return strdup (\"DYN (Shared object file)\");\n\tcase ET_CORE: return strdup (\"CORE (Core file)\");\n\t}\n\tif ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC)) {\n\t\treturn r_str_newf (\"Processor Specific: %x\", e_type);\n\t}\n\tif ((e_type >= ET_LOOS) && (e_type <= ET_HIOS)) {\n\t\treturn r_str_newf (\"OS Specific: %x\", e_type);\n\t}\n\treturn r_str_newf (\"<unknown>: %x\", e_type);\n}", "target": 0}
{"code": "void HTMLMediaElement::StartDeferredLoad() {\n  if (deferred_load_state_ == kWaitingForTrigger) {\n    ExecuteDeferredLoad();\n    return;\n  }\n  if (deferred_load_state_ == kExecuteOnStopDelayingLoadEventTask)\n    return;\n  DCHECK_EQ(deferred_load_state_, kWaitingForStopDelayingLoadEventTask);\n  deferred_load_state_ = kExecuteOnStopDelayingLoadEventTask;\n}", "target": 0}
{"code": "mm_answer_sign(int socket, Buffer *m)\n{\n\tKey *key;\n\tu_char *p;\n\tu_char *signature;\n\tu_int siglen, datlen;\n\tint keyid;\n\tdebug3(\"%s\", __func__);\n\tkeyid = buffer_get_int(m);\n\tp = buffer_get_string(m, &datlen);\n\tif (datlen != 20)\n\t\tfatal(\"%s: data length incorrect: %u\", __func__, datlen);\n\tif (session_id2_len == 0) {\n\t\tsession_id2_len = datlen;\n\t\tsession_id2 = xmalloc(session_id2_len);\n\t\tmemcpy(session_id2, p, session_id2_len);\n\t}\n\tif ((key = get_hostkey_by_index(keyid)) == NULL)\n\t\tfatal(\"%s: no hostkey from index %d\", __func__, keyid);\n\tif (key_sign(key, &signature, &siglen, p, datlen) < 0)\n\t\tfatal(\"%s: key_sign failed\", __func__);\n\tdebug3(\"%s: signature %p(%u)\", __func__, signature, siglen);\n\tbuffer_clear(m);\n\tbuffer_put_string(m, signature, siglen);\n\txfree(p);\n\txfree(signature);\n\tmm_request_send(socket, MONITOR_ANS_SIGN, m);\n\tmonitor_permit(mon_dispatch, MONITOR_REQ_PWNAM, 1);\n\treturn (0);\n}", "target": 0}
{"code": "    Image::UniquePtr ImageFactory::open(const std::wstring& wpath, bool useCurl)\n    {\n        Image::UniquePtr image = open(ImageFactory::createIo(wpath, useCurl)); \n        if (image.get() == 0) throw WError(kerFileContainsUnknownImageType, wpath);\n        return image;\n    }", "target": 0}
{"code": "static ssize_t read_kmem(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\tssize_t low_count, read, sz;\n\tchar *kbuf; \n\tint err = 0;\n\tread = 0;\n\tif (p < (unsigned long) high_memory) {\n\t\tlow_count = count;\n\t\tif (count > (unsigned long)high_memory - p)\n\t\t\tlow_count = (unsigned long)high_memory - p;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t\tif (p < PAGE_SIZE && low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n#endif\n\t\twhile (low_count > 0) {\n\t\t\tsz = size_inside_page(p, low_count);\n\t\t\tkbuf = xlate_dev_kmem_ptr((void *)p);\n\t\t\tif (!virt_addr_valid(kbuf))\n\t\t\t\treturn -ENXIO;\n\t\t\tif (copy_to_user(buf, kbuf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tread += sz;\n\t\t\tlow_count -= sz;\n\t\t\tcount -= sz;\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tkbuf = (char *)__get_free_page(GFP_KERNEL);\n\t\tif (!kbuf)\n\t\t\treturn -ENOMEM;\n\t\twhile (count > 0) {\n\t\t\tsz = size_inside_page(p, count);\n\t\t\tif (!is_vmalloc_or_module_addr((void *)p)) {\n\t\t\t\terr = -ENXIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsz = vread(kbuf, (char *)p, sz);\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t\tif (copy_to_user(buf, kbuf, sz)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount -= sz;\n\t\t\tbuf += sz;\n\t\t\tread += sz;\n\t\t\tp += sz;\n\t\t}\n\t\tfree_page((unsigned long)kbuf);\n\t}\n\t*ppos = p;\n\treturn read ? read : err;\n}", "target": 0}
{"code": "void RegisterInternalHandlers() {\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloDonateThread,\n                                               EntryHandler{DonateThread})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: DonateThread.\");\n  }\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloFini,\n                                               EntryHandler{FinalizeEnclave})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: FinalizeEnclave\");\n  }\n}", "target": 0}
{"code": "int seccomp_lock_personality(unsigned long personality) {\n        uint32_t arch;\n        int r;\n        if (personality >= PERSONALITY_INVALID)\n                return -EINVAL;\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(personality),\n                                1,\n                                SCMP_A0(SCMP_CMP_NE, personality));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to enable personality lock for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "read_yin_subnode(struct ly_ctx *ctx, struct lyxml_elem *node, const char *name)\n{\n    int len;\n    if (!node->child || !node->child->name || strcmp(node->child->name, name)) {\n        LOGERR(ctx, LY_EVALID, \"Expected \\\"%s\\\" element in \\\"%s\\\" element.\", name, node->name);\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, node->name);\n        return NULL;\n    } else if (node->child->content) {\n        len = strlen(node->child->content);\n        return lydict_insert(ctx, node->child->content, len);\n    } else {\n        return lydict_insert(ctx, \"\", 0);\n    }\n}", "target": 0}
{"code": "int emulate_int_real(struct x86_emulate_ctxt *ctxt, int irq)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tint rc;\n\tstruct desc_ptr dt;\n\tgva_t cs_addr;\n\tgva_t eip_addr;\n\tu16 cs, eip;\n\tctxt->src.val = ctxt->eflags;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->eflags &= ~(EFLG_IF | EFLG_TF | EFLG_AC);\n\tctxt->src.val = get_segment_selector(ctxt, VCPU_SREG_CS);\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = ctxt->_eip;\n\trc = em_push(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tops->get_idt(ctxt, &dt);\n\teip_addr = dt.address + (irq << 2);\n\tcs_addr = dt.address + (irq << 2) + 2;\n\trc = ops->read_std(ctxt, cs_addr, &cs, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = ops->read_std(ctxt, eip_addr, &eip, 2, &ctxt->exception);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = load_segment_descriptor(ctxt, cs, VCPU_SREG_CS);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->_eip = eip;\n\treturn rc;\n}", "target": 0}
{"code": "ncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}", "target": 1}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "test_validate_path_args (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_args); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GError) local_error = NULL;\n      const char *path = invalid_path_args[idx];\n      context_parse_args (context, &local_error, path, NULL);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "cache_user_id (KBNODE keyblock)\n{\n  user_id_db_t r;\n  const char *uid;\n  size_t uidlen;\n  keyid_list_t keyids = NULL;\n  KBNODE k;\n  for (k = keyblock; k; k = k->next)\n    {\n      if (k->pkt->pkttype == PKT_PUBLIC_KEY\n\t  || k->pkt->pkttype == PKT_PUBLIC_SUBKEY)\n\t{\n\t  keyid_list_t a = xmalloc_clear (sizeof *a);\n\t  keyid_from_pk (k->pkt->pkt.public_key, a->keyid);\n\t  for (r = user_id_db; r; r = r->next)\n\t    {\n\t      keyid_list_t b = r->keyids;\n\t      for (b = r->keyids; b; b = b->next)\n\t\t{\n\t\t  if (b->keyid[0] == a->keyid[0]\n\t\t      && b->keyid[1] == a->keyid[1])\n\t\t    {\n\t\t      if (DBG_CACHE)\n\t\t\tlog_debug (\"cache_user_id: already in cache\\n\");\n\t\t      release_keyid_list (keyids);\n\t\t      xfree (a);\n\t\t      return;\n\t\t    }\n\t\t}\n\t    }\n\t  a->next = keyids;\n\t  keyids = a;\n\t}\n    }\n  if (!keyids)\n    BUG (); \n  uid = get_primary_uid (keyblock, &uidlen);\n  if (uid_cache_entries >= MAX_UID_CACHE_ENTRIES)\n    {\n      r = user_id_db;\n      user_id_db = r->next;\n      release_keyid_list (r->keyids);\n      xfree (r);\n      uid_cache_entries--;\n    }\n  r = xmalloc (sizeof *r + uidlen - 1);\n  r->keyids = keyids;\n  r->len = uidlen;\n  memcpy (r->name, uid, r->len);\n  r->next = user_id_db;\n  user_id_db = r;\n  uid_cache_entries++;\n}", "target": 0}
{"code": "st_init_numtable_with_size(st_index_t size)\n{\n    return st_init_table_with_size(&type_numhash, size);\n}", "target": 0}
{"code": "static int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port, void *val,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data)) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\treturn 0;\n}", "target": 0}
{"code": "std::tuple<net::inet_address, int, client_type> cql_server::connection::make_client_key(const service::client_state& cli_state) {\n    return std::make_tuple(cli_state.get_client_address().addr(),\n            cli_state.get_client_port(),\n            cli_state.is_thrift() ? client_type::thrift : client_type::cql);\n}", "target": 0}
{"code": "std::string TestURLLoader::TestUntendedLoad() {\n  pp::URLRequestInfo request(instance_);\n  request.SetURL(\"test_url_loader_data/hello.txt\");\n  request.SetRecordDownloadProgress(true);\n  TestCompletionCallback callback(instance_->pp_instance(), callback_type());\n  pp::URLLoader loader(instance_);\n  callback.WaitForResult(loader.Open(request, callback.GetCallback()));\n  CHECK_CALLBACK_BEHAVIOR(callback);\n  ASSERT_EQ(PP_OK, callback.result());\n  int64_t bytes_received = 0;\n  int64_t total_bytes_to_be_received = 0;\n  while (true) {\n     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);\n     if (total_bytes_to_be_received <= 0)\n       return ReportError(\"URLLoader::GetDownloadProgress total size\",\n          total_bytes_to_be_received);\n     if (bytes_received == total_bytes_to_be_received)\n       break;\n    if (pp::Module::Get()->core()->IsMainThread()) {\n      NestedEvent event(instance_->pp_instance());\n      event.PostSignal(10);\n      event.Wait();\n    }\n  }\n  std::string body;\n  std::string error = ReadEntireResponseBody(&loader, &body);\n  if (!error.empty())\n    return error;\n  if (body != \"hello\\n\")\n    return ReportError(\"Couldn't read data\", callback.result());\n  PASS();\n}", "target": 1}
{"code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "fmtint(int64 value, char type, int forcesign, int leftjust,\n\t   int minlen, int zpad, int precision, int pointflag,\n\t   PrintfTarget *target)\n{\n\tuint64\t\tbase;\n\tint\t\t\tdosign;\n\tconst char *cvt = \"0123456789abcdef\";\n\tint\t\t\tsignvalue = 0;\n\tchar\t\tconvert[64];\n\tint\t\t\tvallen = 0;\n\tint\t\t\tpadlen = 0;\t\t\n\tint\t\t\tzeropad;\t\t\n\tswitch (type)\n\t{\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tbase = 10;\n\t\t\tdosign = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tbase = 10;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcvt = \"0123456789ABCDEF\";\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t\t\t\n\t}\n\tif (dosign && adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tif (value == 0 && pointflag && precision == 0)\n\t\tvallen = 0;\n\telse\n\t{\n\t\tuint64\t\tuvalue = (uint64) value;\n\t\tdo\n\t\t{\n\t\t\tconvert[vallen++] = cvt[uvalue % base];\n\t\t\tuvalue = uvalue / base;\n\t\t} while (uvalue);\n\t}\n\tzeropad = Max(0, precision - vallen);\n\tadjust_padlen(minlen, vallen + zeropad, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\twhile (zeropad-- > 0)\n\t\tdopr_outch('0', target);\n\twhile (vallen > 0)\n\t\tdopr_outch(convert[--vallen], target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "TEST(LteOp, MatchesMaxKey) {\n    BSONObj operand = BSON(\"a\" << MaxKey);\n    LTEMatchExpression lte(\"a\", operand[\"a\"]);\n    BSONObj minKeyObj = BSON(\"a\" << MinKey);\n    BSONObj maxKeyObj = BSON(\"a\" << MaxKey);\n    BSONObj numObj = BSON(\"a\" << 4);\n    ASSERT(lte.matchesBSON(minKeyObj, NULL));\n    ASSERT(lte.matchesBSON(maxKeyObj, NULL));\n    ASSERT(lte.matchesBSON(numObj, NULL));\n    ASSERT(lte.matchesSingleElement(minKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(maxKeyObj.firstElement()));\n    ASSERT(lte.matchesSingleElement(numObj.firstElement()));\n}", "target": 0}
{"code": "remove_waiting_conn(conn c)\n{\n    tube t;\n    size_t i;\n    if (!conn_waiting(c)) return NULL;\n    c->type &= ~CONN_TYPE_WAITING;\n    global_stat.waiting_ct--;\n    for (i = 0; i < c->watch.used; i++) {\n        t = c->watch.items[i];\n        t->stat.waiting_ct--;\n        ms_remove(&t->waiting, c);\n    }\n    return c;\n}", "target": 0}
{"code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}", "target": 1}
{"code": "static void header(RBinFile *bf) {\n\tr_return_if_fail (bf && bf->o);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tif (!element) {\n\t\treturn;\n\t}\n\tRBin *bin = bf->rbin;\n\tPrintfCallback p = bin->cb_printf;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_kn (pj, \"cs_version\", element->hdr->version);\n\tpj_kn (pj, \"size\", element->hdr->size);\n\tif (element->file_name) {\n\t\tpj_ks (pj, \"name\", element->file_name);\n\t}\n\tif (element->binary_version) {\n\t\tpj_ks (pj, \"version\", element->binary_version);\n\t}\n\tchar uuidstr[R_UUID_LENGTH];\n\tr_hex_bin2str (element->hdr->uuid, 16, uuidstr);\n\tpj_ks (pj, \"uuid\", uuidstr);\n\tpj_kn (pj, \"segments\", element->hdr->n_segments);\n\tpj_kn (pj, \"sections\", element->hdr->n_sections);\n\tpj_kn (pj, \"symbols\", element->hdr->n_symbols);\n\tpj_kn (pj, \"lined_symbols\", element->hdr->n_lined_symbols);\n\tpj_kn (pj, \"line_info\", element->hdr->n_line_info);\n\tpj_end (pj);\n\tp (\"%s\\n\", pj_string (pj));\n\tpj_free (pj);\n}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "void LibRaw::ahd_interpolate_green_h_and_v(\n    int top, int left, ushort (*out_rgb)[LIBRAW_AHD_TILE][LIBRAW_AHD_TILE][3])\n{\n  int row, col;\n  int c, val;\n  ushort(*pix)[4];\n  const int rowlimit = MIN(top + LIBRAW_AHD_TILE, height - 2);\n  const int collimit = MIN(left + LIBRAW_AHD_TILE, width - 2);\n  for (row = top; row < rowlimit; row++)\n  {\n    col = left + (FC(row, left) & 1);\n    for (c = FC(row, col); col < collimit; col += 2)\n    {\n      pix = image + row * width + col;\n      val =\n          ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2 - pix[-2][c] - pix[2][c]) >>\n          2;\n      out_rgb[0][row - top][col - left][1] = ULIM(val, pix[-1][1], pix[1][1]);\n      val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2 -\n             pix[-2 * width][c] - pix[2 * width][c]) >>\n            2;\n      out_rgb[1][row - top][col - left][1] =\n          ULIM(val, pix[-width][1], pix[width][1]);\n    }\n  }\n}", "target": 0}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "void QuotaManager::SetPersistentHostQuota(const std::string& host,\n                                          int64 new_quota,\n                                          HostQuotaCallback* callback_ptr) {\n  scoped_ptr<HostQuotaCallback> callback(callback_ptr);\n  LazyInitialize();\n  if (host.empty()) {\n    callback->Run(kQuotaErrorNotSupported, host, kStorageTypePersistent, 0);\n    return;\n  }\n  if (new_quota < 0) {\n    callback->Run(kQuotaErrorInvalidModification,\n                  host, kStorageTypePersistent, -1);\n    return;\n  }\n  if (!db_disabled_) {\n    scoped_refptr<UpdatePersistentHostQuotaTask> task(\n        new UpdatePersistentHostQuotaTask(\n            this, host, new_quota, callback.release()));\n    task->Start();\n  } else {\n    callback->Run(kQuotaErrorInvalidAccess,\n                  host, kStorageTypePersistent, -1);\n  }\n}", "target": 0}
{"code": "get_stdinput(char *(*fn_readline)(const char *), void(*fn_addhist)(const char *))\n{\nint i;\ngstring * g = NULL;\nif (!fn_readline) { printf(\"> \"); fflush(stdout); }\nfor (i = 0;; i++)\n  {\n  uschar buffer[1024];\n  uschar *p, *ss;\n  #ifdef USE_READLINE\n  char *readline_line = NULL;\n  if (fn_readline != NULL)\n    {\n    if ((readline_line = fn_readline((i > 0)? \"\":\"> \")) == NULL) break;\n    if (*readline_line != 0 && fn_addhist != NULL) fn_addhist(readline_line);\n    p = US readline_line;\n    }\n  else\n  #endif\n    {\n    if (Ufgets(buffer, sizeof(buffer), stdin) == NULL) break;\n    p = buffer;\n    }\n  ss = p + (int)Ustrlen(p);\n  while (ss > p && isspace(ss[-1])) ss--;\n  if (i > 0)\n    {\n    while (p < ss && isspace(*p)) p++;   \n    }\n  g = string_catn(g, p, ss - p);\n  #ifdef USE_READLINE\n  if (fn_readline) free(readline_line);\n  #endif\n  if (ss == p || g->s[g->ptr-1] != '\\\\')\n    break;\n  --g->ptr;\n  (void) string_from_gstring(g);\n  }\nif (!g) printf(\"\\n\");\nreturn string_from_gstring(g);\n}", "target": 0}
{"code": "void ok_inflater_free(ok_inflater *inflater) {\n    if (inflater) {\n        ok_png_allocator allocator = inflater->allocator;\n        void *allocator_user_data = inflater->allocator_user_data;\n        allocator.free(allocator_user_data, inflater->buffer);\n        allocator.free(allocator_user_data, inflater->code_length_huffman);\n        allocator.free(allocator_user_data, inflater->literal_huffman);\n        allocator.free(allocator_user_data, inflater->distance_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_literal_huffman);\n        allocator.free(allocator_user_data, inflater->fixed_distance_huffman);\n        allocator.free(allocator_user_data, inflater);\n    }\n}", "target": 0}
{"code": "static int r_jws_verify_sig_hmac(jws_t * jws, jwk_t * jwk) {\n  unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n  int ret;\n  if (sig != NULL && 0 == o_strcmp((const char *)jws->signature_b64url, (const char *)sig)) {\n    ret = RHN_OK;\n  } else {\n    ret = RHN_ERROR_INVALID;\n  }\n  o_free(sig);\n  return ret;\n}", "target": 1}
{"code": "    TiffVisitor::~TiffVisitor()\n    {\n    }", "target": 0}
{"code": "void RGWGetObjTags_ObjStore_S3::send_response_data(bufferlist& bl)\n{\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  s->formatter->open_object_section_in_ns(\"Tagging\", XMLNS_AWS_S3);\n  s->formatter->open_object_section(\"TagSet\");\n  if (has_tags){\n    RGWObjTagSet_S3 tagset;\n    auto iter = bl.cbegin();\n    try {\n      tagset.decode(iter);\n    } catch (buffer::error& err) {\n      ldout(s->cct,0) << \"ERROR: caught buffer::error, couldn't decode TagSet\" << dendl;\n      op_ret= -EIO;\n      return;\n    }\n    tagset.dump_xml(s->formatter);\n  }\n  s->formatter->close_section();\n  s->formatter->close_section();\n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "gen_muldiv(codegen_scope *s, uint8_t op, uint16_t dst)\n{\n  if (no_peephole(s)) {\n  normal:\n    genop_1(s, op, dst);\n    return;\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n    mrb_int n, n0;\n    if (addr_pc(s, data.addr) == s->lastlabel || !get_int_operand(s, &data, &n)) {\n      goto normal;\n    }\n    struct mrb_insn_data data0 = mrb_decode_insn(mrb_prev_pc(s, data.addr));\n    if (!get_int_operand(s, &data0, &n0) || n == 0) {\n      goto normal;\n    }\n    if (op == OP_MUL) {\n      if (mrb_int_mul_overflow(n0, n, &n)) goto normal;\n    }\n    else { \n      if (n0 == MRB_INT_MIN && n == -1) goto normal;\n      n = n0 / n;\n    }\n    s->pc = addr_pc(s, data0.addr);\n    gen_int(s, dst, n);\n  }\n}", "target": 0}
{"code": "int ipmi_validate_addr(struct ipmi_addr *addr, int len)\n{\n\tif (len < sizeof(struct ipmi_system_interface_addr))\n\t\treturn -EINVAL;\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tif (addr->channel != IPMI_BMC_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif ((addr->channel == IPMI_BMC_CHANNEL)\n\t    || (addr->channel >= IPMI_MAX_CHANNELS)\n\t    || (addr->channel < 0))\n\t\treturn -EINVAL;\n\tif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_ipmb_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (is_lan_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_lan_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static void print_liveness(struct bpf_verifier_env *env,\n\t\t\t   enum bpf_reg_liveness live)\n{\n\tif (live & (REG_LIVE_READ | REG_LIVE_WRITTEN | REG_LIVE_DONE))\n\t    verbose(env, \"_\");\n\tif (live & REG_LIVE_READ)\n\t\tverbose(env, \"r\");\n\tif (live & REG_LIVE_WRITTEN)\n\t\tverbose(env, \"w\");\n\tif (live & REG_LIVE_DONE)\n\t\tverbose(env, \"D\");\n}", "target": 0}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "  virtual std::string GetHtmlInfo(int refresh) {\n    std::string output;\n    output.append(\"<html><head><title>About Network</title>\");\n    if (refresh > 0)\n      output.append(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" +\n          base::IntToString(refresh) + \"\\\"/>\");\n    output.append(\"</head><body>\");\n    if (refresh > 0) {\n      output.append(\"(Auto-refreshing page every \" +\n                    base::IntToString(refresh) + \"s)\");\n    } else {\n      output.append(\"(To auto-refresh this page: about:network/&lt;secs&gt;)\");\n    }\n    output.append(\"<h3>Ethernet:</h3><table border=1>\");\n    if (ethernet_ && ethernet_enabled()) {\n      output.append(\"<tr>\" + ToHtmlTableHeader(ethernet_) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(ethernet_) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(wifi_networks_[i]) + \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(wifi_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Cellular:</h3><table border=1>\");\n    for (size_t i = 0; i < cellular_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\"<tr>\" + ToHtmlTableHeader(cellular_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(cellular_networks_[i]) + \"</tr>\");\n    }\n    output.append(\"</table><h3>Remembered Wifi:</h3><table border=1>\");\n    for (size_t i = 0; i < remembered_wifi_networks_.size(); ++i) {\n      if (i == 0)\n        output.append(\n            \"<tr>\" + ToHtmlTableHeader(remembered_wifi_networks_[i]) +\n            \"</tr>\");\n      output.append(\"<tr>\" + ToHtmlTableRow(remembered_wifi_networks_[i]) +\n          \"</tr>\");\n    }\n    output.append(\"</table></body></html>\");\n    return output;\n  }", "target": 0}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "static int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}", "target": 0}
{"code": "PHP_MINFO_FUNCTION(mcrypt) \n{\n\tchar **modules;\n\tchar mcrypt_api_no[16];\n\tint i, count;\n\tsmart_str tmp1 = {0};\n\tsmart_str tmp2 = {0};\n\tmodules = mcrypt_list_algorithms(MCG(algorithms_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp1, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp1, modules[i]);\n\t\tsmart_str_appendc(&tmp1, ' ');\n\t}\n\tsmart_str_0(&tmp1);\n\tmcrypt_free_p(modules, count);\n\tmodules = mcrypt_list_modes(MCG(modes_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp2, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp2, modules[i]);\n\t\tsmart_str_appendc(&tmp2, ' ');\n\t}\n\tsmart_str_0 (&tmp2);\n\tmcrypt_free_p (modules, count);\n\tsnprintf (mcrypt_api_no, 16, \"%d\", MCRYPT_API_VERSION);\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"mcrypt support\", \"enabled\");\n\tphp_info_print_table_header(2, \"mcrypt_filter support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Version\", LIBMCRYPT_VERSION);\n\tphp_info_print_table_row(2, \"Api No\", mcrypt_api_no);\n\tphp_info_print_table_row(2, \"Supported ciphers\", tmp1.c);\n\tphp_info_print_table_row(2, \"Supported modes\", tmp2.c);\n\tsmart_str_free(&tmp1);\n\tsmart_str_free(&tmp2);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();", "target": 1}
{"code": "mm_destroy(struct mm_master *mm)\n{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %zu): %s\", mm->address, mm->size,\n\t\t    strerror(errno));\n\tif (mm->mmalloc == NULL)\n\t\tfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "target": 1}
{"code": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }", "target": 1}
{"code": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}", "target": 1}
{"code": "  void GrantBindings(int bindings) {\n    enabled_bindings_ |= bindings;\n  }", "target": 0}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\tNFS_PROTO(data->inode)->commit_setup(data, &msg);\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}", "target": 0}
{"code": "  void *realloc(void *ptr, size_t newsz)\n  {\n    void *ret = ::realloc(ptr, newsz + extra_bytes);\n    forget_ptr(ptr);\n    mem_ptr(ret);\n    return ret;\n  }", "target": 0}
{"code": "isdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}", "target": 0}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "SSLNetVConnection::select_next_protocol(SSL *ssl, const unsigned char **out, unsigned char *outlen,\n                                        const unsigned char *in ATS_UNUSED, unsigned inlen ATS_UNUSED, void *)\n{\n  SSLNetVConnection *netvc = SSLNetVCAccess(ssl);\n  const unsigned char *npn = nullptr;\n  unsigned npnsz           = 0;\n  ink_release_assert(netvc != nullptr);\n  if (netvc->npnSet && netvc->npnSet->advertiseProtocols(&npn, &npnsz)) {\n#if HAVE_SSL_SELECT_NEXT_PROTO\n    if (SSL_select_next_proto((unsigned char **)out, outlen, npn, npnsz, in, inlen) == OPENSSL_NPN_NEGOTIATED) {\n      Debug(\"ssl\", \"selected ALPN protocol %.*s\", (int)(*outlen), *out);\n      return SSL_TLSEXT_ERR_OK;\n    }\n#endif \n  }\n  *out    = nullptr;\n  *outlen = 0;\n  return SSL_TLSEXT_ERR_NOACK;\n}", "target": 0}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "static void _WM_CheckEventMemoryPool(struct _mdi *mdi) {\n    if ((mdi->event_count + 1) >= mdi->events_size) {\n        mdi->events_size += MEM_CHUNK;\n        mdi->events = realloc(mdi->events,\n                              (mdi->events_size * sizeof(struct _event)));\n    }\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "TIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\tm = _TIFFgetMode(mode, module);\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\ttif = TIFFFdOpen((int)fd,    \n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\t_TIFFfree(mbname);\n\treturn tif;\n}", "target": 0}
{"code": "int con_clear_unimap(struct vc_data *vc)\n{\n\tint ret;\n\tconsole_lock();\n\tret = con_do_clear_unimap(vc);\n\tconsole_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "ldap_start_tls_s ( LDAP *ld,\n\tLDAPControl **serverctrls,\n\tLDAPControl **clientctrls )\n{\n#ifndef HAVE_TLS\n\treturn LDAP_NOT_SUPPORTED;\n#else\n\tint rc;\n\tchar *rspoid = NULL;\n\tstruct berval *rspdata = NULL;\n\tif ( ldap_tls_inplace( ld ) ) {\n\t\treturn LDAP_LOCAL_ERROR;\n\t}\n\trc = ldap_extended_operation_s( ld, LDAP_EXOP_START_TLS,\n\t\tNULL, serverctrls, clientctrls, &rspoid, &rspdata );\n\tif ( rspoid != NULL ) {\n\t\tLDAP_FREE(rspoid);\n\t}\n\tif ( rspdata != NULL ) {\n\t\tber_bvfree( rspdata );\n\t}\n\tif ( rc == LDAP_SUCCESS ) {\n\t\trc = ldap_int_tls_start( ld, ld->ld_defconn, NULL );\n\t}\n\treturn rc;\n#endif\n}", "target": 0}
{"code": "  void set_external_caught_exception(bool value) {\n    thread_local_top_.external_caught_exception_ = value;\n  }", "target": 0}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "guestfs___check_hurd_root (guestfs_h *g, struct inspect_fs *fs)\n{\n  fs->type = OS_TYPE_HURD;\n  if (guestfs_exists (g, \"/etc/debian_version\") > 0) {\n    fs->distro = OS_DISTRO_DEBIAN;\n    if (parse_release_file (g, fs, \"/etc/debian_version\") == -1)\n      return -1;\n    if (guestfs___parse_major_minor (g, fs) == -1)\n      return -1;\n  }\n  check_architecture (g, fs);\n  if (check_hostname_unix (g, fs) == -1)\n    return -1;\n  return 0;\n}", "target": 0}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tsize_t oldoff = buf->off;\n\tif (buf->totallen < need) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\treturn (0);\n}", "target": 1}
{"code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\tbuf->tr = tr;\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\treturn 0;\n}", "target": 1}
{"code": "push_n_(codegen_scope *s, int n)\n{\n  if (s->sp+n >= 0xffff) {\n    codegen_error(s, \"too complex expression\");\n  }\n  s->sp+=n;\n  nregs_update;\n}", "target": 0}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "yang_check_rpc_action(struct lys_module *module, struct lys_node_rpc_action *rpc, struct lys_node **child,\n                      int options, struct unres_schema *unres)\n{\n    struct lys_node *node;\n    if (rpc->nodetype == LYS_ACTION) {\n        for (node = rpc->parent; node; node = lys_parent(node)) {\n            if ((node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF))\n                    || ((node->nodetype == LYS_LIST) && !((struct lys_node_list *)node)->keys)) {\n                LOGVAL(module->ctx, LYE_INPAR, LY_VLOG_LYS, rpc->parent, strnodetype(node->nodetype), \"action\");\n                goto error;\n            }\n        }\n    }\n    if (yang_check_typedef(module, (struct lys_node *)rpc, unres)) {\n        goto error;\n    }\n    if (yang_check_iffeatures(module, NULL, rpc, RPC_KEYWORD, unres)) {\n        goto error;\n    }\n    if (yang_check_nodes(module, (struct lys_node *)rpc, *child, options | LYS_PARSE_OPT_CFG_IGNORE, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "void AudioContext::initialize()\n{\n    if (isInitialized())\n        return;\n    FFTFrame::initialize();\n    m_listener = AudioListener::create();\n    if (m_destinationNode.get()) {\n        m_destinationNode->initialize();\n        if (!isOfflineContext()) {\n            startRendering();\n            ++s_hardwareContextCount;\n        }\n        m_isInitialized = true;\n    }\n}", "target": 0}
{"code": "int WebGraphicsContext3DDefaultImpl::sizeInBytes(int type)\n{\n    switch (type) {\n    case GL_BYTE:\n        return sizeof(GLbyte);\n    case GL_UNSIGNED_BYTE:\n        return sizeof(GLubyte);\n    case GL_SHORT:\n        return sizeof(GLshort);\n    case GL_UNSIGNED_SHORT:\n        return sizeof(GLushort);\n    case GL_INT:\n        return sizeof(GLint);\n    case GL_UNSIGNED_INT:\n        return sizeof(GLuint);\n    case GL_FLOAT:\n        return sizeof(GLfloat);\n    }\n    return 0;\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "void print_2fun(FILE* outfile, LibRaw& MyCoolRawProcessor, std::string& fn)\n{\n\tfprintf(outfile, \"\n\tif (C.cam_mul[0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'As shot' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %.3f\", C.cam_mul[c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Auto][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Auto' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Auto][c]);\n\t}\n\tif (C.WB_Coeffs[LIBRAW_WBI_Measured][0] > 0)\n\t{\n\t\tfprintf(outfile, \"\\n'Camera Measured' WB:\");\n\t\tfor (int c = 0; c < 4; c++)\n\t\t\tfprintf(outfile, \" %d\", C.WB_Coeffs[LIBRAW_WBI_Measured][c]);\n\t}\n\tfprintf(outfile, \"\\n\\n\");\n}", "target": 0}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 1}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n    if (equalIgnoringCase(m_scheme, \"http\"))\n        return equalIgnoringCase(url.protocol(), \"http\") || equalIgnoringCase(url.protocol(), \"https\");\n    if (equalIgnoringCase(m_scheme, \"ws\"))\n        return equalIgnoringCase(url.protocol(), \"ws\") || equalIgnoringCase(url.protocol(), \"wss\");\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 0}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    qemuMonitorUnregister(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 1}
{"code": "fbFetch_a2b2g2r2 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + x;\n    const CARD8 *end = pixel + width;\n    while (pixel < end) {\n        CARD32  p = READ(pixel++);\n        CARD32   a,r,g,b;\n        a = ((p & 0xc0) * 0x55) << 18;\n        b = ((p & 0x30) * 0x55) >> 6;\n        g = ((p & 0x0c) * 0x55) << 6;\n        r = ((p & 0x03) * 0x55) << 16;\n        WRITE(buffer++, a|r|g|b);\n    }\n}", "target": 0}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_ablkcipher *skcipher;\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tskcipher = crypto_alloc_ablkcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\ttfm->skcipher = skcipher;\n\treturn tfm;\n}", "target": 0}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "SWFInput_file_getChar(SWFInput input)\n{\n\tint c = fgetc((FILE *)input->data);\n\tif ( c == EOF )\n\t\tinput->length = input->offset;\n\telse\n\t\t++input->offset;\n\treturn c;\n}", "target": 0}
{"code": "static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,\n                            unsigned size)\n{\n    NvmeCtrl *n = (NvmeCtrl *)opaque;\n    trace_pci_nvme_mmio_write(addr, data, size);\n    if (addr < sizeof(n->bar)) {\n        nvme_write_bar(n, addr, data, size);\n    } else {\n        nvme_process_db(n, addr, data);\n    }\n}", "target": 0}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "static av_always_inline float flt16_even(float pf)\n{\n    union av_intfloat32 tmp;\n    tmp.f = pf;\n    tmp.i = (tmp.i + 0x00007FFFU + (tmp.i & 0x00010000U >> 16)) & 0xFFFF0000U;\n    return tmp.f;\n}", "target": 0}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "bool Matrix::invertTo(Matrix *other) const\n{\n    const double det_denominator = determinant();\n    if (unlikely(det_denominator == 0)) {\n        *other = { 1, 0, 0, 1, 0, 0 };\n        return false;\n    }\n    const double det = 1 / det_denominator;\n    other->m[0] = m[3] * det;\n    other->m[1] = -m[1] * det;\n    other->m[2] = -m[2] * det;\n    other->m[3] = m[0] * det;\n    other->m[4] = (m[2] * m[5] - m[3] * m[4]) * det;\n    other->m[5] = (m[1] * m[4] - m[0] * m[5]) * det;\n    return true;\n}", "target": 0}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "ctnetlink_parse_tuple_filter(const struct nlattr * const cda[],\n\t\t\t      struct nf_conntrack_tuple *tuple, u32 type,\n\t\t\t      u_int8_t l3num, struct nf_conntrack_zone *zone,\n\t\t\t      u_int32_t flags)\n{\n\tstruct nlattr *tb[CTA_TUPLE_MAX+1];\n\tint err;\n\tmemset(tuple, 0, sizeof(*tuple));\n\terr = nla_parse_nested_deprecated(tb, CTA_TUPLE_MAX, cda[type],\n\t\t\t\t\t  tuple_nla_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\ttuple->src.l3num = l3num;\n\tif (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||\n\t    flags & CTA_FILTER_FLAG(CTA_IP_SRC)) {\n\t\tif (!tb[CTA_TUPLE_IP])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_ip(tb[CTA_TUPLE_IP], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (flags & CTA_FILTER_FLAG(CTA_PROTO_NUM)) {\n\t\tif (!tb[CTA_TUPLE_PROTO])\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_proto(tb[CTA_TUPLE_PROTO], tuple, flags);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (flags & CTA_FILTER_FLAG(ALL_CTA_PROTO)) {\n\t\treturn -EINVAL;\n\t}\n\tif ((flags & CTA_FILTER_FLAG(CTA_TUPLE_ZONE)) && tb[CTA_TUPLE_ZONE]) {\n\t\tif (!zone)\n\t\t\treturn -EINVAL;\n\t\terr = ctnetlink_parse_tuple_zone(tb[CTA_TUPLE_ZONE],\n\t\t\t\t\t\t type, zone);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (type == CTA_TUPLE_REPLY)\n\t\ttuple->dst.dir = IP_CT_DIR_REPLY;\n\telse\n\t\ttuple->dst.dir = IP_CT_DIR_ORIGINAL;\n\treturn 0;\n}", "target": 1}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "leaving_window(win_T *win)\n{\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t\n    restart_edit = NUL;\n    if (State & INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}", "target": 0}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "static int nf_tables_set_alloc_name(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t\t    const char *name)\n{\n\tconst struct nft_set *i;\n\tconst char *p;\n\tunsigned long *inuse;\n\tunsigned int n = 0, min = 0;\n\tp = strnchr(name, IFNAMSIZ, '%');\n\tif (p != NULL) {\n\t\tif (p[1] != 'd' || strchr(p + 2, '%'))\n\t\t\treturn -EINVAL;\n\t\tinuse = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (inuse == NULL)\n\t\t\treturn -ENOMEM;\ncont:\n\t\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\t\tint tmp;\n\t\t\tif (!sscanf(i->name, name, &tmp))\n\t\t\t\tcontinue;\n\t\t\tif (tmp < min || tmp >= min + BITS_PER_BYTE * PAGE_SIZE)\n\t\t\t\tcontinue;\n\t\t\tset_bit(tmp - min, inuse);\n\t\t}\n\t\tn = find_first_zero_bit(inuse, BITS_PER_BYTE * PAGE_SIZE);\n\t\tif (n >= BITS_PER_BYTE * PAGE_SIZE) {\n\t\t\tmin += BITS_PER_BYTE * PAGE_SIZE;\n\t\t\tmemset(inuse, 0, PAGE_SIZE);\n\t\t\tgoto cont;\n\t\t}\n\t\tfree_page((unsigned long)inuse);\n\t}\n\tsnprintf(set->name, sizeof(set->name), name, min + n);\n\tlist_for_each_entry(i, &ctx->table->sets, list) {\n\t\tif (!strcmp(set->name, i->name))\n\t\t\treturn -ENFILE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "yang_read_length(struct ly_ctx *ctx, struct yang_type *stype, char *value, int is_ext_instance)\n{\n    struct lys_restr *length;\n    if (is_ext_instance) {\n        length = (struct lys_restr *)stype;\n    } else {\n        if (stype->base == 0 || stype->base == LY_TYPE_STRING) {\n            stype->base = LY_TYPE_STRING;\n        } else {\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected length statement.\");\n            goto error;\n        }\n        if (stype->type->info.str.length) {\n            LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"length\", \"type\");\n            goto error;\n        }\n        length = calloc(1, sizeof *length);\n        LY_CHECK_ERR_GOTO(!length, LOGMEM(ctx), error);\n        stype->type->info.str.length = length;\n    }\n    length->expr = lydict_insert_zc(ctx, value);\n    return length;\nerror:\n    free(value);\n    return NULL;\n}", "target": 0}
{"code": "static int netsnmp_session_gen_sec_key(struct snmp_session *s, char *pass)\n{\n\tint snmp_errno;\n\ts->securityPrivKeyLen = USM_PRIV_KU_LEN;\n\tif ((snmp_errno = generate_Ku(s->securityAuthProto, s->securityAuthProtoLen,\n\t\t\t(u_char *)pass, strlen(pass),\n\t\t\ts->securityPrivKey, &(s->securityPrivKeyLen)))) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Error generating a key for privacy pass phrase '%s': %s\", pass, snmp_api_errstring(snmp_errno));\n\t\treturn (-2);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tstruct inode *inode;\n\tstruct dentry *error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\terror = ERR_PTR(-ENOENT);\n\tinode = NULL;\n\tif (!task)\n\t\tgoto out_no_task;\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn error;\n}", "target": 0}
{"code": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}", "target": 1}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "get_blk_size(int fd)\n{\n\tstruct stat stat;\n\tint ret;\n\tret = fstat(fd, &stat);\n\treturn ret == -1 ? (uint64_t)-1 : (uint64_t)stat.st_blksize;\n}", "target": 0}
{"code": "  Mixin_Call_Obj Parser::parse_include_directive()\n  {\n    lex_identifier(); \n    std::string name(Util::normalize_underscores(lexed));\n    Mixin_Call_Obj call = SASS_MEMORY_NEW(Mixin_Call, pstate, name, {}, {}, {});\n    call->arguments(parse_arguments());\n    bool has_parameters = lex< kwd_using >() != nullptr;\n    if (has_parameters) {\n      if (!peek< exactly<'('> >()) css_error(\"Invalid CSS\", \" after \", \": expected \\\"(\\\", was \");\n    } else {\n      if (peek< exactly<'('> >()) css_error(\"Invalid CSS\", \" after \", \": expected \\\";\\\", was \");\n    }\n    if (has_parameters) call->block_parameters(parse_parameters());\n    if (peek < exactly <'{'> >()) {\n      call->block(parse_block());\n    }\n    else if (has_parameters)  {\n      css_error(\"Invalid CSS\", \" after \", \": expected \\\"{\\\", was \");\n    }\n    return call.detach();\n  }", "target": 0}
{"code": "gfp_to_alloc_flags(gfp_t gfp_mask)\n{\n\tunsigned int alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;\n\tBUILD_BUG_ON(__GFP_HIGH != (__force gfp_t) ALLOC_HIGH);\n\talloc_flags |= (__force int) (gfp_mask & __GFP_HIGH);\n\tif (gfp_mask & __GFP_ATOMIC) {\n\t\tif (!(gfp_mask & __GFP_NOMEMALLOC))\n\t\t\talloc_flags |= ALLOC_HARDER;\n\t\talloc_flags &= ~ALLOC_CPUSET;\n\t} else if (unlikely(rt_task(current)) && !in_interrupt())\n\t\talloc_flags |= ALLOC_HARDER;\n#ifdef CONFIG_CMA\n\tif (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)\n\t\talloc_flags |= ALLOC_CMA;\n#endif\n\treturn alloc_flags;\n}", "target": 0}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isSelected() const\n{\n    return checkElementState(m_element, ATK_STATE_SELECTED);\n}", "target": 0}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "Extension::State ExtensionPrefs::GetExtensionState(\n    const std::string& extension_id) const {\n  const DictionaryValue* extension = GetExtensionPref(extension_id);\n  if (!extension)\n    return Extension::ENABLED;\n  int state = -1;\n  if (!extension->GetInteger(kPrefState, &state) ||\n      state < 0 || state >= Extension::NUM_STATES) {\n    LOG(ERROR) << \"Bad or missing pref 'state' for extension '\"\n               << extension_id << \"'\";\n    return Extension::ENABLED;\n  }\n  return static_cast<Extension::State>(state);\n}", "target": 0}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 0}
{"code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n    if (!server || !prefix)\n        return;\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "Item_func_null_predicate::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                                         uint *and_level,\n                                         table_map usable_tables,\n                                         SARGABLE_PARAM **sargables)\n{\n  if (is_local_field(args[0]) && !(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    Item *tmp= new (join->thd->mem_root) Item_null(join->thd);\n    if (unlikely(!tmp))                       \n      return;\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(),\n                         functype() == Item_func::ISNULL_FUNC,\n                         &tmp, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\t*uinfo = ue->info;\n\treturn 0;\n}", "target": 0}
{"code": "static int em_wrmsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 msr_data;\n\tmsr_data = (u32)ctxt->regs[VCPU_REGS_RAX]\n\t\t| ((u64)ctxt->regs[VCPU_REGS_RDX] << 32);\n\tif (ctxt->ops->set_msr(ctxt, ctxt->regs[VCPU_REGS_RCX], msr_data))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static void emit(JF, int value)\n{\n\temitraw(J, F, value);\n}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "static void init_skiplist(struct fsck_options *options, const char *path)\n{\n\tstatic struct oid_array skiplist = OID_ARRAY_INIT;\n\tint sorted, fd;\n\tchar buffer[GIT_MAX_HEXSZ + 1];\n\tstruct object_id oid;\n\tif (options->skiplist)\n\t\tsorted = options->skiplist->sorted;\n\telse {\n\t\tsorted = 1;\n\t\toptions->skiplist = &skiplist;\n\t}\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tdie(\"Could not open skip list: %s\", path);\n\tfor (;;) {\n\t\tconst char *p;\n\t\tint result = read_in_full(fd, buffer, sizeof(buffer));\n\t\tif (result < 0)\n\t\t\tdie_errno(\"Could not read '%s'\", path);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tif (parse_oid_hex(buffer, &oid, &p) || *p != '\\n')\n\t\t\tdie(\"Invalid SHA-1: %s\", buffer);\n\t\toid_array_append(&skiplist, &oid);\n\t\tif (sorted && skiplist.nr > 1 &&\n\t\t\t\toidcmp(&skiplist.oid[skiplist.nr - 2],\n\t\t\t\t       &oid) > 0)\n\t\t\tsorted = 0;\n\t}\n\tclose(fd);\n\tif (sorted)\n\t\tskiplist.sorted = 1;\n}", "target": 0}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\tsvm->vmcb->control.lbr_ctl = 1;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "aspath_unintern (struct aspath **aspath)\n{\n  struct aspath *ret;\n  struct aspath *asp = *aspath;\n  if (asp->refcnt)\n    asp->refcnt--;\n  if (asp->refcnt == 0)\n    {\n      ret = hash_release (ashash, asp);\n      assert (ret != NULL);\n      aspath_free (asp);\n      *aspath = NULL;\n    }\n}", "target": 0}
{"code": "static inline unsigned int unix_hash_fold(__wsum n)\n{\n\tunsigned int hash = (__force unsigned int)csum_fold(n);\n\thash ^= hash>>8;\n\treturn hash&(UNIX_HASH_SIZE-1);\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "void html_link_open(char *url, char *title, char *class)\n{\n\thtml(\"<a href='\");\n\thtml_attr(url);\n\tif (title) {\n\t\thtml(\"' title='\");\n\t\thtml_attr(title);\n\t}\n\tif (class) {\n\t\thtml(\"' class='\");\n\t\thtml_attr(class);\n\t}\n\thtml(\"'>\");\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MaxMinBadHintSelectsReverseIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runInvalidQueryFull(BSONObj(),\n                        BSONObj(),\n                        BSONObj(),\n                        0,\n                        0,\n                        fromjson(\"{a: 1}\"),\n                        fromjson(\"{a: 8}\"),\n                        fromjson(\"{a: 2}\"));\n}", "target": 0}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "void PasswordAutofillAgent::PasswordValueGatekeeper::RegisterElement(\n    blink::WebInputElement* element) {\n  if (was_user_gesture_seen_)\n    ShowValue(element);\n  else\n    elements_.push_back(*element);\n}", "target": 0}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 1}
{"code": "append_wild(char *to, char *end, const char *wild)\n{\n  end-=5;\t\t\t\t\t\n  if (wild && wild[0])\n  {\n    to=strmov(to,\" like '\");\n    while (*wild && to < end)\n    {\n      if (*wild == '\\\\' || *wild == '\\'')\n\t*to++='\\\\';\n      *to++= *wild++;\n    }\n    if (*wild)\t\t\t\t\t\n      *to++='%';\t\t\t\t\n    to[0]='\\'';\n    to[1]=0;\n  }\n}", "target": 0}
{"code": " void HTMLFormControlElement::updateVisibleValidationMessage() {\n   Page* page = document().page();\n  if (!page)\n     return;\n   String message;\n   if (layoutObject() && willValidate())\n    message = validationMessage().stripWhiteSpace();\n  m_hasValidationMessage = true;\n  ValidationMessageClient* client = &page->validationMessageClient();\n  TextDirection messageDir = LTR;\n  TextDirection subMessageDir = LTR;\n  String subMessage = validationSubMessage().stripWhiteSpace();\n  if (message.isEmpty())\n    client->hideValidationMessage(*this);\n  else\n    findCustomValidationMessageTextDirection(message, messageDir, subMessage,\n                                             subMessageDir);\n  client->showValidationMessage(*this, message, messageDir, subMessage,\n                                subMessageDir);\n}", "target": 1}
{"code": "static struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}", "target": 0}
{"code": "int tcp_ctl(struct socket *so)\n{\n    Slirp *slirp = so->slirp;\n    struct sbuf *sb = &so->so_snd;\n    struct gfwd_list *ex_ptr;\n    DEBUG_CALL(\"tcp_ctl\");\n    DEBUG_ARG(\"so = %p\", so);\n    if (so->so_faddr.s_addr != slirp->vhost_addr.s_addr) {\n        for (ex_ptr = slirp->guestfwd_list; ex_ptr; ex_ptr = ex_ptr->ex_next) {\n            if (ex_ptr->ex_fport == so->so_fport &&\n                so->so_faddr.s_addr == ex_ptr->ex_addr.s_addr) {\n                if (ex_ptr->write_cb) {\n                    so->s = -1;\n                    so->guestfwd = ex_ptr;\n                    return 1;\n                }\n                DEBUG_MISC(\" executing %s\", ex_ptr->ex_exec);\n                if (ex_ptr->ex_unix)\n                    return open_unix(so, ex_ptr->ex_unix);\n                else\n                    return fork_exec(so, ex_ptr->ex_exec);\n            }\n        }\n    }\n    sb->sb_cc =\n        snprintf(sb->sb_wptr, sb->sb_datalen - (sb->sb_wptr - sb->sb_data),\n                 \"Error: No application configured.\\r\\n\");\n    sb->sb_wptr += sb->sb_cc;\n    return 0;\n}", "target": 0}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "    TiffComponent* newNikon2Mn2(uint16_t tag,\n                                IfdId    group,\n                                IfdId    mnGroup)\n    {\n        return new TiffIfdMakernote(tag, group, mnGroup, new Nikon2MnHeader);\n    }", "target": 0}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "user_local_save_to_keyfile (User     *user,\n                            GKeyFile *keyfile)\n{\n        if (user->email)\n                g_key_file_set_string (keyfile, \"User\", \"Email\", user->email);\n        if (user->language)\n                g_key_file_set_string (keyfile, \"User\", \"Language\", user->language);\n        if (user->x_session)\n                g_key_file_set_string (keyfile, \"User\", \"XSession\", user->x_session);\n        if (user->location)\n                g_key_file_set_string (keyfile, \"User\", \"Location\", user->location);\n        if (user->password_hint)\n                g_key_file_set_string (keyfile, \"User\", \"PasswordHint\", user->password_hint);\n        if (user->icon_file)\n                g_key_file_set_string (keyfile, \"User\", \"Icon\", user->icon_file);\n}", "target": 0}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "static ssize_t itlb_multihit_show_state(char *buf)\n{\n\tif (itlb_multihit_kvm_mitigation)\n\t\treturn sprintf(buf, \"KVM: Mitigation: Split huge pages\\n\");\n\telse\n\t\treturn sprintf(buf, \"KVM: Vulnerable\\n\");\n}", "target": 0}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n    if (strlen(addr_text) < 2) {\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "target": 1}
{"code": "int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,\n                        size_t buflen )\n{\n    int ret;\n    mbedtls_x509_crt *crt = chain, *prev = NULL;\n    if( crt == NULL || buf == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n    while( crt->version != 0 && crt->next != NULL )\n    {\n        prev = crt;\n        crt = crt->next;\n    }\n    if( crt->version != 0 && crt->next == NULL )\n    {\n        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );\n        if( crt->next == NULL )\n            return( MBEDTLS_ERR_X509_ALLOC_FAILED );\n        prev = crt;\n        mbedtls_x509_crt_init( crt->next );\n        crt = crt->next;\n    }\n    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )\n    {\n        if( prev )\n            prev->next = NULL;\n        if( crt != chain )\n            mbedtls_free( crt );\n        return( ret );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   \n        break;\n    }\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n    if (conf_state)\n        *conf_state = conf_req_flag;\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static void dup_xol_work(struct callback_head *work)\n{\n\tif (current->flags & PF_EXITING)\n\t\treturn;\n\tif (!__create_xol_area(current->utask->dup_xol_addr) &&\n\t\t\t!fatal_signal_pending(current))\n\t\tuprobe_warn(current, \"dup xol area\");\n}", "target": 0}
{"code": "status _af_set_sample_format (_AudioFormat *f, int sampleFormat, int sampleWidth)\n{\n\tswitch (sampleFormat)\n\t{\n\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\tif (sampleWidth < 1 || sampleWidth > 32)\n\t\t{\n\t\t\t_af_error(AF_BAD_SAMPFMT,\n\t\t\t\t\"illegal sample width %d for integer data\",\n\t\t\t\tsampleWidth);\n\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint bytes;\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = sampleWidth;\n\t\t\tbytes = _af_format_sample_size_uncompressed(f, false);\n\t\t\tif (sampleFormat == AF_SAMPFMT_TWOSCOMP)\n\t\t\t\tf->pcm = _af_default_signed_integer_pcm_mappings[bytes];\n\t\t\telse\n\t\t\t\tf->pcm = _af_default_unsigned_integer_pcm_mappings[bytes];\n\t\t}\n\t\tbreak;\n\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 32;\n\t\t\tf->pcm = _af_default_float_pcm_mapping;\n\t\t\tbreak;\n\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\tf->sampleFormat = sampleFormat;\n\t\t\tf->sampleWidth = 64;      \n\t\t\tf->pcm = _af_default_double_pcm_mapping;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_SAMPFMT, \"unknown sample format %d\",\n\t\t\t\tsampleFormat);\n\t\t\treturn AF_FAIL;\n\t}\n\treturn AF_SUCCEED;\n}", "target": 0}
{"code": "incomplete_transaction_log(uschar *what)\n{\nif (sender_address == NULL ||                 \n    !LOGGING(smtp_incomplete_transaction))\n  return;\nif (recipients_count > 0)\n  {\n  int i;\n  raw_recipients = store_get(recipients_count * sizeof(uschar *));\n  for (i = 0; i < recipients_count; i++)\n    raw_recipients[i] = recipients_list[i].address;\n  raw_recipients_count = recipients_count;\n  }\nlog_write(L_smtp_incomplete_transaction, LOG_MAIN|LOG_SENDER|LOG_RECIPIENTS,\n  \"%s incomplete transaction (%s)\", host_and_ident(TRUE), what);\n}", "target": 0}
{"code": "test_append_uri_pathel(void)\n{\n  unsigned i;\n  static const struct {\n    const char *original_url;\n    const char *input;\n    bool escaped;\n    const char *expected_result;\n  } test_array[] = {\n    { \"http:\n  };\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      struct growable dest;\n      const char *p = test_array[i].input;\n      memset (&dest, 0, sizeof (dest));\n      append_string (test_array[i].original_url, &dest);\n      append_uri_pathel (p, p + strlen(p), test_array[i].escaped, &dest);\n      mu_assert (\"test_append_uri_pathel: wrong result\",\n                 strcmp (dest.base, test_array[i].expected_result) == 0);\n      xfree (dest.base);\n    }\n  return NULL;\n}", "target": 0}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "static bool get_sequence_numbers(struct torture_context *torture,\n\t\t\t\t struct torture_domain_sequence **seqs)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tconst char *extra_data;\n\tchar line[256];\n\tuint32_t count = 0;\n\tstruct torture_domain_sequence *s = NULL;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SHOW_SEQUENCE, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL sequence list\");\n\twhile (next_token(&extra_data, line, \"\\n\", sizeof(line))) {\n\t\tchar *p, *lp;\n\t\tuint32_t seq;\n\t\ts = talloc_realloc(torture, s, struct torture_domain_sequence,\n\t\t\t\t   count + 2);\n\t\tZERO_STRUCT(s[count+1]);\n\t\tlp = line;\n\t\tp = strchr(lp, ' ');\n\t\ttorture_assert(torture, p, \"invalid line format\");\n\t\t*p = 0;\n\t\ts[count].netbios_name = talloc_strdup(s, lp);\n\t\tlp = p+1;\n\t\ttorture_assert(torture, strncmp(lp, \": \", 2) == 0,\n\t\t\t       \"invalid line format\");\n\t\tlp += 2;\n\t\tif (strcmp(lp, \"DISCONNECTED\") == 0) {\n\t\t\tseq = (uint32_t)-1;\n\t\t} else {\n\t\t\tseq = (uint32_t)strtol(lp, &p, 10);\n\t\t\ttorture_assert(torture, (*p == '\\0'),\n\t\t\t\t       \"invalid line format\");\n\t\t\ttorture_assert(torture, (seq != (uint32_t)-1),\n\t\t\t\t       \"sequence number -1 encountered\");\n\t\t}\n\t\ts[count].seq = seq;\n\t\tcount++;\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\ttorture_assert(torture, count >= 2, \"The list of domain sequence \"\n\t\t       \"numbers should contain 2 entries\");\n\t*seqs = s;\n\treturn true;\n}", "target": 0}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "static int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\n{\n\tint status;\n\tint start_address;\n\tstruct ti_i2c_desc *rom_desc;\n\tstruct edge_ti_manuf_descriptor *desc;\n\tstruct device *dev = &serial->serial->dev->dev;\n\trom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\n\tif (!rom_desc)\n\t\treturn -ENOMEM;\n\tstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\n\t\t\t\t\t\t\t\trom_desc);\n\tif (!start_address) {\n\t\tdev_dbg(dev, \"%s - Edge Descriptor not found in I2C\\n\", __func__);\n\t\tstatus = -ENODEV;\n\t\tgoto exit;\n\t}\n\tstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\n\t\t\t\t\tle16_to_cpu(rom_desc->Size), buffer);\n\tif (status)\n\t\tgoto exit;\n\tstatus = valid_csum(rom_desc, buffer);\n\tdesc = (struct edge_ti_manuf_descriptor *)buffer;\n\tdev_dbg(dev, \"%s - IonConfig      0x%x\\n\", __func__, desc->IonConfig);\n\tdev_dbg(dev, \"%s - Version          %d\\n\", __func__, desc->Version);\n\tdev_dbg(dev, \"%s - Cpu/Board      0x%x\\n\", __func__, desc->CpuRev_BoardRev);\n\tdev_dbg(dev, \"%s - NumPorts         %d\\n\", __func__, desc->NumPorts);\n\tdev_dbg(dev, \"%s - NumVirtualPorts  %d\\n\", __func__, desc->NumVirtualPorts);\n\tdev_dbg(dev, \"%s - TotalPorts       %d\\n\", __func__, desc->TotalPorts);\nexit:\n\tkfree(rom_desc);\n\treturn status;\n}", "target": 0}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  PixelChannels\n    **pixels;\n  register ssize_t\n    i;\n   size_t\n     columns,\n    number_threads;\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (PixelChannels **) NULL)\n     return((PixelChannels **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  columns=images->columns;\n   for (next=images; next != (Image *) NULL; next=next->next)\n     columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     register ssize_t\n       j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 1}
{"code": "digest_hex(unsigned char *p)\n{\n    char *h = \"0123456789abcdef\";\n    Str tmp = Strnew_size(MD5_DIGEST_LENGTH * 2 + 1);\n    int i;\n    for (i = 0; i < MD5_DIGEST_LENGTH; i++, p++) {\n\tStrcat_char(tmp, h[(*p >> 4) & 0x0f]);\n\tStrcat_char(tmp, h[*p & 0x0f]);\n    }\n    return tmp;\n}", "target": 0}
{"code": "static sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}", "target": 0}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "bool Item_default_value::fix_fields(THD *thd, Item **items)\n{\n  Item *real_arg;\n  Item_field *field_arg;\n  Field *def_field;\n  DBUG_ASSERT(fixed == 0);\n  if (!arg)\n  {\n    fixed= 1;\n    return FALSE;\n  }\n  if (!arg->fixed && arg->fix_fields(thd, &arg))\n    goto error;\n  real_arg= arg->real_item();\n  if (real_arg->type() != FIELD_ITEM)\n  {\n    my_error(ER_NO_DEFAULT_FOR_FIELD, MYF(0), arg->name);\n    goto error;\n  }\n  field_arg= (Item_field *)real_arg;\n  if (field_arg->field->flags & NO_DEFAULT_VALUE_FLAG)\n  {\n    my_error(ER_NO_DEFAULT_FOR_FIELD, MYF(0), field_arg->field->field_name);\n    goto error;\n  }\n  if (!(def_field= (Field*) sql_alloc(field_arg->field->size_of())))\n    goto error;\n  memcpy((void *)def_field, (void *)field_arg->field, field_arg->field->size_of());\n  def_field->move_field_offset((my_ptrdiff_t)\n                               (def_field->table->s->default_values -\n                                def_field->table->record[0]));\n  set_field(def_field);\n  return FALSE;\nerror:\n  context->process_error(thd);\n  return TRUE;\n}", "target": 0}
{"code": "PHP_FUNCTION(grapheme_strlen)\n{\n\tunsigned char* string;\n\tint string_len;\n\tUChar* ustring = NULL;\n\tint ustring_len = 0;\n\tint ret_len;\n\tUErrorCode status;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", (char **)&string, &string_len) == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strlen: unable to parse input param\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tret_len = grapheme_ascii_check(string, string_len);\n\tif ( ret_len >= 0 )\n\t\tRETURN_LONG(ret_len);\n\tstatus = U_ZERO_ERROR;\n\tintl_convert_utf8_to_utf16(&ustring, &ustring_len, (char*) string, string_len, &status );\n\tif ( U_FAILURE( status ) ) {\n\t\tintl_error_set_code( NULL, status TSRMLS_CC );\n\t\tintl_error_set_custom_msg( NULL, \"Error converting input string to UTF-16\", 0 TSRMLS_CC );\n\t\tif (ustring) {\n\t\t\tefree( ustring );\n\t\t}\n\t\tRETURN_NULL();\n\t}\n\tret_len = grapheme_split_string(ustring, ustring_len, NULL, 0 TSRMLS_CC );\n\tif (ustring) {\n\t\tefree( ustring );\n\t}\n\tif (ret_len >= 0) {\n\t\tRETVAL_LONG(ret_len);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n}", "target": 0}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "  explicit BoostedTreesAggregateStatsOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n  }", "target": 0}
{"code": "static void OneLine(struct bmp_progressive_state *context)\n{\n\tcontext->BufferDone = 0;\n\tif (context->Lines >= context->Header.height)\n\t\treturn;\n\tif (context->Type == 32)\n\t\tOneLine32(context);\n\telse if (context->Type == 24)\n\t\tOneLine24(context);\n\telse if (context->Type == 16)\n\t\tOneLine16(context);\n\telse if (context->Type == 8)\n\t\tOneLine8(context);\n\telse if (context->Type == 4)\n\t\tOneLine4(context);\n\telse if (context->Type == 1)\n\t\tOneLine1(context);\n\telse\n\t\tg_assert_not_reached ();\n\tcontext->Lines++;\n\tif (context->updated_func != NULL) {\n\t\t(*context->updated_func) (context->pixbuf,\n\t\t\t\t\t  0,\n\t\t\t\t\t  (context->Header.Negative ?\n\t\t\t\t\t   (context->Lines - 1) :\n\t\t\t\t\t   (context->Header.height - context->Lines)),\n\t\t\t\t\t  context->Header.width,\n\t\t\t\t\t  1,\n\t\t\t\t\t  context->user_data);\n\t}\n}", "target": 0}
{"code": "OFCondition DcmSCP::listen()\n{\n  dcmEnableAutomaticInputDataCorrection.set( OFFalse );\n  OFCondition cond = EC_Normal;\n  if( !dcmDataDict.isDictionaryLoaded() )\n    DCMNET_WARN(\"No data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( m_cfg->getPort() < 1024 && geteuid() != 0 )\n  {\n    DCMNET_ERROR(\"No privileges to open this network port (\" << m_cfg->getPort() << \")\");\n    return NET_EC_InsufficientPortPrivileges;\n  }\n#endif\n#endif\n  T_ASC_Network *network = NULL;\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, m_cfg->getPort()), m_cfg->getACSETimeout(), &network );\n  if( cond.bad() )\n    return cond;\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() && !stopAfterCurrentAssociation() )\n  {\n    cond = waitForAssociationRQ(network);\n  }\n  cond = ASC_dropNetwork( &network );\n  network = NULL;\n  return cond;\n}", "target": 1}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "void html_url_path(const char *txt)\n{\n\tconst char *t = txt;\n\twhile (t && *t) {\n\t\tunsigned char c = *t;\n\t\tconst char *e = url_escape_table[c];\n\t\tif (e && c != '+' && c != '&') {\n\t\t\thtml_raw(txt, t - txt);\n\t\t\thtml(e);\n\t\t\ttxt = t + 1;\n\t\t}\n\t\tt++;\n\t}\n\tif (t != txt)\n\t\thtml(txt);\n}", "target": 0}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "static int decode_secinfo_common(struct xdr_stream *xdr, struct nfs4_secinfo_res *res)\n{\n\tstruct nfs4_secinfo_flavor *sec_flavor;\n\tint status;\n\t__be32 *p;\n\tint i, num_flavors;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->flavors->num_flavors = 0;\n\tnum_flavors = be32_to_cpup(p);\n\tfor (i = 0; i < num_flavors; i++) {\n\t\tsec_flavor = &res->flavors->flavors[i];\n\t\tif ((char *)&sec_flavor[1] - (char *)res->flavors > PAGE_SIZE)\n\t\t\tbreak;\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\tsec_flavor->flavor = be32_to_cpup(p);\n\t\tif (sec_flavor->flavor == RPC_AUTH_GSS) {\n\t\t\tstatus = decode_secinfo_gss(xdr, sec_flavor);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t\tres->flavors->num_flavors++;\n\t}\n\tstatus = 0;\nout:\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "static int __init atalk_init(void)\n{\n\tint rc;\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl)\n\t\tprintk(atalk_err_snap);\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\taarp_proto_init();\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_sock:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}", "target": 1}
{"code": "static uint64_t lru_total_bumps_dropped(void) {\n    uint64_t total = 0;\n    lru_bump_buf *b;\n    pthread_mutex_lock(&bump_buf_lock);\n    for (b = bump_buf_head; b != NULL; b=b->next) {\n        pthread_mutex_lock(&b->mutex);\n        total += b->dropped;\n        pthread_mutex_unlock(&b->mutex);\n    }\n    pthread_mutex_unlock(&bump_buf_lock);\n    return total;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n    return extracted;\n}", "target": 1}
{"code": "input_parse(struct window_pane *wp)\n{\n\tstruct input_ctx\t\t*ictx = wp->ictx;\n\tconst struct input_transition\t*itr;\n\tstruct evbuffer\t\t\t*evb = wp->event->input;\n\tu_char\t\t\t\t*buf;\n\tsize_t\t\t\t\t len, off;\n\tif (EVBUFFER_LENGTH(evb) == 0)\n\t\treturn;\n\twp->window->flags |= WINDOW_ACTIVITY;\n\twp->window->flags &= ~WINDOW_SILENCE;\n\tif (gettimeofday(&wp->window->activity_time, NULL) != 0)\n\t\tfatal(\"gettimeofday failed\");\n\tif (wp->mode == NULL)\n\t\tscreen_write_start(&ictx->ctx, wp, &wp->base);\n\telse\n\t\tscreen_write_start(&ictx->ctx, NULL, &wp->base);\n\tictx->wp = wp;\n\tbuf = EVBUFFER_DATA(evb);\n\tlen = EVBUFFER_LENGTH(evb);\n\tnotify_input(wp, evb);\n\toff = 0;\n\twhile (off < len) {\n\t\tictx->ch = buf[off++];\n\t\tlog_debug(\"%s: '%c' %s\", __func__, ictx->ch, ictx->state->name);\n\t\titr = ictx->state->transitions;\n\t\twhile (itr->first != -1 && itr->last != -1) {\n\t\t\tif (ictx->ch >= itr->first && ictx->ch <= itr->last)\n\t\t\t\tbreak;\n\t\t\titr++;\n\t\t}\n\t\tif (itr->first == -1 || itr->last == -1) {\n\t\t\tfatalx(\"No transition from state!\");\n\t\t}\n\t\tif (itr->handler != NULL && itr->handler(ictx) != 0)\n\t\t\tcontinue;\n\t\tif (itr->state != NULL)\n\t\t\tinput_set_state(wp, itr);\n\t\tif (ictx->state != &input_state_ground)\n\t\t\tevbuffer_add(ictx->since_ground, &ictx->ch, 1);\n\t}\n\tscreen_write_stop(&ictx->ctx);\n\tevbuffer_drain(evb, len);\n}", "target": 0}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 1}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "    inline double log2(const double x) {\n      const double base = std::log(2.0);\n      return std::log(x)/base;", "target": 0}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\treclblp = \"\\\\N\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"false\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"false\")));\n    ul = pointfof(-sz.x / 2., sz.y / 2.);\t\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t\n    ND_shape_info(n) = (void *) info;\n}", "target": 1}
{"code": "apply_stored_configuration_at_startup (GsdXrandrManager *manager, guint32 timestamp)\n{\n        GError *my_error;\n        gboolean success;\n        char *backup_filename;\n        char *intended_filename;\n        backup_filename = gnome_rr_config_get_backup_filename ();\n        intended_filename = gnome_rr_config_get_intended_filename ();\n        my_error = NULL;\n        success = apply_configuration_from_filename (manager, backup_filename, FALSE, timestamp, &my_error);\n        if (success) {\n                restore_backup_configuration (manager, backup_filename, intended_filename, timestamp);\n                goto out;\n        }\n        if (!g_error_matches (my_error, G_FILE_ERROR, G_FILE_ERROR_NOENT)) {\n                unlink (backup_filename);\n                goto out;\n        }\n        apply_intended_configuration (manager, intended_filename, timestamp);\nout:\n        if (my_error)\n                g_error_free (my_error);\n        g_free (backup_filename);\n        g_free (intended_filename);\n}", "target": 0}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\t__u8 proto;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tstruct xfrm_state *x;\n\tif (!ext_hdrs[SADB_EXT_SA-1] ||\n\t    !present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC-1],\n\t\t\t\t     ext_hdrs[SADB_EXT_ADDRESS_DST-1]))\n\t\treturn -EINVAL;\n\tx = pfkey_xfrm_state_lookup(net, hdr, ext_hdrs);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\tout_skb = pfkey_xfrm_state2msg(x);\n\tproto = x->id.proto;\n\txfrm_state_put(x);\n\tif (IS_ERR(out_skb))\n\t\treturn  PTR_ERR(out_skb);\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = hdr->sadb_msg_version;\n\tout_hdr->sadb_msg_type = SADB_GET;\n\tout_hdr->sadb_msg_satype = pfkey_proto2satype(proto);\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_reserved = 0;\n\tout_hdr->sadb_msg_seq = hdr->sadb_msg_seq;\n\tout_hdr->sadb_msg_pid = hdr->sadb_msg_pid;\n\tpfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n    if ( !id )\n        id = rand();\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n    return mm;\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_destroy_session(struct rpc_rqst *req,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t struct nfs4_session *session)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = session->clp->cl_mvops->minor_version,\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_destroy_session(xdr, session, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": " void OmniboxEditModel::RestoreState(const State* state) {\n   controller_->GetToolbarModel()->set_url_replacement_enabled(\n      !state || state->url_replacement_enabled);\n   permanent_text_ = controller_->GetToolbarModel()->GetText();\n  view_->RevertWithoutResettingSearchTermReplacement();\n  input_ = state ? state->autocomplete_input : AutocompleteInput();\n  if (!state)\n    return;\n  SetFocusState(state->focus_state, OMNIBOX_FOCUS_CHANGE_TAB_SWITCH);\n  focus_source_ = state->focus_source;\n  if (state->user_input_in_progress) {\n    keyword_ = state->keyword;\n    is_keyword_hint_ = state->is_keyword_hint;\n    view_->SetUserText(state->user_text,\n        DisplayTextFromUserText(state->user_text), false);\n    view_->SetGrayTextAutocompletion(state->gray_text);\n  }\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "int PpapiPluginMain(const content::MainFunctionParams& parameters) {\n  const CommandLine& command_line = parameters.command_line;\n#if defined(OS_WIN)\n  g_target_services = parameters.sandbox_info->target_services;\n#endif\n  if (command_line.HasSwitch(switches::kPpapiStartupDialog)) {\n    if (g_target_services)\n      base::debug::WaitForDebugger(2*60, false);\n    else\n       ChildProcess::WaitForDebugger(\"Ppapi\");\n   }\n  if (command_line.HasSwitch(switches::kLang)) {\n    std::string locale = command_line.GetSwitchValueASCII(switches::kLang);\n    base::i18n::SetICUDefaultLocale(locale);\n  }\n   MessageLoop main_message_loop;\n   base::PlatformThread::SetName(\"CrPPAPIMain\");\n#if defined(OS_LINUX)\n  content::InitializeSandbox();\n#endif\n  ChildProcess ppapi_process;\n  ppapi_process.set_main_thread(\n      new PpapiThread(parameters.command_line, false));  \n  main_message_loop.Run();\n  return 0;\n}", "target": 0}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static int dsa_missing_parameters(const EVP_PKEY *pkey)\n{\n    DSA *dsa;\n    dsa = pkey->pkey.dsa;\n    if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "new_msg_lsa_change_notify (u_char msgtype,\n\t\t\t   u_int32_t seqnum,\n\t\t\t   struct in_addr ifaddr,\n\t\t\t   struct in_addr area_id,\n\t\t\t   u_char is_self_originated, struct lsa_header *data)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_lsa_change_notify *nmsg;\n  int len;\n  assert (data);\n  nmsg = (struct msg_lsa_change_notify *) buf;\n  len = ntohs (data->length) + sizeof (struct msg_lsa_change_notify)\n    - sizeof (struct lsa_header);\n  nmsg->ifaddr = ifaddr;\n  nmsg->area_id = area_id;\n  nmsg->is_self_originated = is_self_originated;\n  memset (&nmsg->pad, 0, sizeof (nmsg->pad));\n  memcpy (&nmsg->data, data, ntohs (data->length));\n  return msg_new (msgtype, nmsg, seqnum, len);\n}", "target": 1}
{"code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}", "target": 1}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::SetScreenOrientationForTesting(\n    uint16_t angle,\n    ScreenOrientationValues type) {\n  screen_orientation_angle_for_testing_ = angle;\n  screen_orientation_type_for_testing_ = type;\n  WasResized();\n}", "target": 0}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location){\n  ssh_scp scp=malloc(sizeof(struct ssh_scp_struct));\n  if(scp == NULL){\n    ssh_set_error(session,SSH_FATAL,\"Error allocating memory for ssh_scp\");\n    return NULL;\n  }\n  ZERO_STRUCTP(scp);\n  if((mode&~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE && (mode &~SSH_SCP_RECURSIVE) != SSH_SCP_READ){\n    ssh_set_error(session,SSH_FATAL,\"Invalid mode %d for ssh_scp_new()\",mode);\n    ssh_scp_free(scp);\n    return NULL;\n  }\n  scp->location=strdup(location);\n  if (scp->location == NULL) {\n    ssh_set_error(session,SSH_FATAL,\"Error allocating memory for ssh_scp\");\n    ssh_scp_free(scp);\n    return NULL;\n  }\n  scp->session=session;\n  scp->mode=mode & ~SSH_SCP_RECURSIVE;\n  scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n  scp->channel=NULL;\n  scp->state=SSH_SCP_NEW;\n  return scp;\n}", "target": 1}
{"code": "status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {\n     ALOGV(\"setNextPlayer\");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n     mNextClient = c;\n     if (c != NULL) {\n if (mAudioOutput != NULL) {\n            mAudioOutput->setNextOutput(c->mAudioOutput);\n } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {\n            ALOGE(\"no current audio output\");\n }\n if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {\n            mPlayer->setNextPlayer(mNextClient->getPlayer());\n }\n }\n return OK;\n}", "target": 1}
{"code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; \n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}", "target": 1}
{"code": "bool VBRISeeker::getOffsetForTime(int64_t *timeUs, off64_t *pos) {\n if (mDurationUs < 0 || mSegments.size() == 0) {\n return false;\n }\n int64_t segmentDurationUs = mDurationUs / mSegments.size();\n int64_t nowUs = 0;\n *pos = mBasePos;\n size_t segmentIndex = 0;\n while (segmentIndex < mSegments.size() && nowUs < *timeUs) {\n        nowUs += segmentDurationUs;\n *pos += mSegments.itemAt(segmentIndex++);\n }\n    ALOGV(\"getOffsetForTime %lld us => 0x%016llx\", (long long)*timeUs, (long long)*pos);\n *timeUs = nowUs;\n return true;\n}", "target": 0}
{"code": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, int aligned)\n{\n\tint buffers = 0, error = 0;\n\tdown_read(&current->mm->mmap_sem);\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\t\terror = -EFAULT;\n\t\tif (copy_from_user_mmap_sem(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (unlikely(!base))\n\t\t\tbreak;\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > PIPE_BUFFERS - buffers)\n\t\t\tnpages = PIPE_BUFFERS - buffers;\n\t\terror = get_user_pages(current, current->mm,\n\t\t\t\t       (unsigned long) base, npages, 0, 0,\n\t\t\t\t       &pages[buffers], NULL);\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\t\tif (len)\n\t\t\tbreak;\n\t\tif (error < npages || buffers == PIPE_BUFFERS)\n\t\t\tbreak;\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\tup_read(&current->mm->mmap_sem);\n\tif (buffers)\n\t\treturn buffers;\n\treturn error;\n}", "target": 1}
{"code": "int detach_capi_ctr(struct capi_ctr *ctr)\n{\n\tint err = 0;\n\tmutex_lock(&capi_controller_lock);\n\tctr_down(ctr, CAPI_CTR_DETACHED);\n\tif (capi_controller[ctr->cnr - 1] != ctr) {\n\t\terr = -EINVAL;\n\t\tgoto unlock_out;\n\t}\n\tcapi_controller[ctr->cnr - 1] = NULL;\n\tncontrollers--;\n\tif (ctr->procent)\n\t\tremove_proc_entry(ctr->procfn, NULL);\n\tprintk(KERN_NOTICE \"kcapi: controller [%03d]: %s unregistered\\n\",\n\t       ctr->cnr, ctr->name);\nunlock_out:\n\tmutex_unlock(&capi_controller_lock);\n\treturn err;\n}", "target": 1}
{"code": "void LinkInfo::print() {\n  ResourceMark rm;\n  tty->print_cr(\"Link resolved_klass=%s name=%s signature=%s current_klass=%s check_access=%s check_loader_constraints=%s\",\n                _resolved_klass->name()->as_C_string(),\n                _name->as_C_string(),\n                _signature->as_C_string(),\n                _current_klass == NULL ? \"(none)\" : _current_klass->name()->as_C_string(),\n                _check_access ? \"true\" : \"false\",\n                _check_loader_constraints ? \"true\" : \"false\");\n}", "target": 0}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 1}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "static double util_pointsize( wmfAPI* API, wmfFont* font, char* str, double font_height, ExceptionInfo *exception)\n{\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n  Image\n    *image = ddata->image;\n  TypeMetric\n    metrics;\n  DrawInfo\n    *draw_info;\n  double\n    pointsize = 0;\n  draw_info=ddata->draw_info;\n  if (draw_info == (const DrawInfo *) NULL)\n    return 0;\n  draw_info->font=WMF_FONT_PSNAME(font);\n  draw_info->pointsize=font_height;\n  draw_info->text=str;\n  if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n    {\n      if (strlen(str) == 1)\n        {\n          pointsize = (font_height *\n                       ( font_height / (metrics.ascent + fabs(metrics.descent))));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / ( metrics.ascent + fabs(metrics.descent)));\n        }\n      else\n        {\n          pointsize = (font_height * (font_height / (metrics.height)));\n          draw_info->pointsize = pointsize;\n          if (GetTypeMetrics(image, draw_info, &metrics, exception) != MagickFalse)\n            pointsize *= (font_height / metrics.height);\n        }\n#if 0\n      draw_info.pointsize = pointsize;\n      if (GetTypeMetrics(image, &draw_info, &metrics, exception) != MagickFalse)\n        pointsize *= (font_height / (metrics.ascent + fabs(metrics.descent)));\n      pointsize *= 1.114286; \n#endif\n    }\n  draw_info->font=NULL;\n  draw_info->text=NULL;\n#if 0\n  printf(\"String    = %s\\n\", str);\n  printf(\"Font      = %s\\n\", WMF_FONT_PSNAME(font));\n  printf(\"lfHeight  = %g\\n\", font_height);\n  printf(\"bounds    = %g,%g %g,%g\\n\", metrics.bounds.x1, metrics.bounds.y1,\n         metrics.bounds.x2,metrics.bounds.y2);\n  printf(\"ascent    = %g\\n\", metrics.ascent);\n  printf(\"descent   = %g\\n\", metrics.descent);\n  printf(\"height    = %g\\n\", metrics.height);\n  printf(\"Pointsize = %g\\n\", pointsize);\n#endif\n  return floor(pointsize);\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnForwardCompositorProto(\n    const std::vector<uint8_t>& proto) {\n  if (delegate_)\n    delegate_->ForwardCompositorProto(this, proto);\n}", "target": 0}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tcond_resched();\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(&tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "static int virtio_net_ufo_pre_save(void *opaque)\n{\n    struct VirtIONetMigTmp *tmp = opaque;\n    tmp->has_ufo = tmp->parent->has_ufo;\n    return 0;\n}", "target": 0}
{"code": "static int do_nonlinear_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tint write_access, pte_t orig_pte)\n{\n\tunsigned int flags = FAULT_FLAG_NONLINEAR |\n\t\t\t\t(write_access ? FAULT_FLAG_WRITE : 0);\n\tpgoff_t pgoff;\n\tif (!pte_unmap_same(mm, pmd, page_table, orig_pte))\n\t\treturn 0;\n\tif (unlikely(!(vma->vm_flags & VM_NONLINEAR) ||\n\t\t\t!(vma->vm_flags & VM_CAN_NONLINEAR))) {\n\t\tprint_bad_pte(vma, orig_pte, address);\n\t\treturn VM_FAULT_OOM;\n\t}\n\tpgoff = pte_to_pgoff(orig_pte);\n\treturn __do_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "static struct dentry *__d_obtain_alias(struct inode *inode, int disconnected)\n{\n\tstatic const struct qstr anonstring = QSTR_INIT(\"/\", 1);\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\tunsigned add_flags;\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\ttmp = __d_alloc(inode->i_sb, &anonstring);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(tmp);\n\t\tgoto out_iput;\n\t}\n\tadd_flags = d_flags_for_inode(inode);\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\tspin_lock(&tmp->d_lock);\n\t__d_set_inode_and_type(tmp, inode, add_flags);\n\thlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);\n\thlist_bl_lock(&tmp->d_sb->s_anon);\n\thlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);\n\thlist_bl_unlock(&tmp->d_sb->s_anon);\n\tspin_unlock(&tmp->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(tmp, inode);\n\treturn tmp;\n out_iput:\n\tif (res && !IS_ERR(res))\n\t\tsecurity_d_instantiate(res, inode);\n\tiput(inode);\n\treturn res;\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "static void mctp_serial_uninit(struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tcancel_work_sync(&dev->tx_work);\n}", "target": 0}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "check_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\n\t\t\tvoid *data)\n{\n\tint ret;\n\tlong offlined = *(long *)data;\n\tret = test_pages_isolated(start_pfn, start_pfn + nr_pages);\n\tofflined = nr_pages;\n\tif (!ret)\n\t\t*(long *)data += offlined;\n\treturn ret;\n}", "target": 0}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}", "target": 0}
{"code": "            bool isValid() const\n            {\n                return version_ != -1;\n            }", "target": 0}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n\tPG(allow_url_fopen) = old_allow_url_fopen;\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->keepBlanks = 0;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){\n  ZipfileCDS *pCds = &pEntry->cds;\n  u8 *a = aBuf;\n  pCds->nExtra = 9;\n  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);\n  zipfileWrite16(a, pCds->iVersionExtract);\n  zipfileWrite16(a, pCds->flags);\n  zipfileWrite16(a, pCds->iCompression);\n  zipfileWrite16(a, pCds->mTime);\n  zipfileWrite16(a, pCds->mDate);\n  zipfileWrite32(a, pCds->crc32);\n  zipfileWrite32(a, pCds->szCompressed);\n  zipfileWrite32(a, pCds->szUncompressed);\n  zipfileWrite16(a, (u16)pCds->nFile);\n  zipfileWrite16(a, pCds->nExtra);\n  assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );\n  memcpy(a, pCds->zFile, (int)pCds->nFile);\n  a += (int)pCds->nFile;\n  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);\n  zipfileWrite16(a, 5);\n  *a++ = 0x01;\n  zipfileWrite32(a, pEntry->mUnixTime);\n  return a-aBuf;\n}", "target": 0}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "void shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}", "target": 0}
{"code": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}", "target": 1}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "acl_fetch_hdr_val(struct proxy *px, struct session *l4, void *l7, char *sol,\n                  struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tstruct hdr_idx *idx = &txn->hdr_idx;\n\tstruct hdr_ctx *ctx = (struct hdr_ctx *)test->ctx.a;\n\tif (!txn)\n\t\treturn 0;\n\tif (!(test->flags & ACL_TEST_F_FETCH_MORE))\n\t\tctx->idx = 0;\n\tif (http_find_header2(expr->arg.str, expr->arg_len, sol, idx, ctx)) {\n\t\ttest->flags |= ACL_TEST_F_FETCH_MORE;\n\t\ttest->flags |= ACL_TEST_F_VOL_HDR;\n\t\ttest->i = strl2ic((char *)ctx->line + ctx->val, ctx->vlen);\n\t\treturn 1;\n\t}\n\ttest->flags &= ~ACL_TEST_F_FETCH_MORE;\n\ttest->flags |= ACL_TEST_F_VOL_HDR;\n\treturn 0;\n}", "target": 0}
{"code": "static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_msr_entry *msr;\n\tu64 host_tsc;\n\tint ret = 0;\n\tswitch (msr_index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_EFER:\n\t\tvmx_load_host_state(vmx);\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t\tbreak;\n\tcase MSR_FS_BASE:\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_TIME_STAMP_COUNTER:\n\t\trdtscll(host_tsc);\n\t\tguest_write_tsc(data, host_tsc);\n\t\tbreak;\n\tcase MSR_P6_PERFCTR0:\n\tcase MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0:\n\tcase MSR_P6_EVNTSEL1:\n\t\tpr_unimpl(vcpu, \"unimplemented perfctr wrmsr: 0x%x data 0x%llx\\n\", msr_index, data);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tvmx_load_host_state(vmx);\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr) {\n\t\t\tmsr->data = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool zone_watermark_ok_safe(struct zone *z, unsigned int order,\n\t\t\tunsigned long mark, int classzone_idx)\n{\n\tlong free_pages = zone_page_state(z, NR_FREE_PAGES);\n\tif (z->percpu_drift_mark && free_pages < z->percpu_drift_mark)\n\t\tfree_pages = zone_page_state_snapshot(z, NR_FREE_PAGES);\n\treturn __zone_watermark_ok(z, order, mark, classzone_idx, 0,\n\t\t\t\t\t\t\t\tfree_pages);\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(timezone_name_from_abbr)\n{\n\tchar    *abbr;\n\tchar    *tzid;\n\tint      abbr_len;\n\tlong     gmtoffset = -1;\n\tlong     isdst = -1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ll\", &abbr, &abbr_len, &gmtoffset, &isdst) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\ttzid = timelib_timezone_id_from_abbr(abbr, gmtoffset, isdst);\n\tif (tzid) {\n\t\tRETURN_STRING(tzid, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 0}
{"code": "void dname_pkt_copy(sldns_buffer* pkt, uint8_t* to, uint8_t* dname)\n{\n\tsize_t len = 0;\n\tuint8_t lablen;\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(lablen > LDNS_MAX_LABELLEN) {\n\t\t\t*to = 0; \n\t\t\treturn;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlen += (size_t)lablen+1;\n\t\tif(len >= LDNS_MAX_DOMAINLEN) {\n\t\t\t*to = 0; \n\t\t\tlog_err(\"bad dname in dname_pkt_copy\");\n\t\t\treturn;\n\t\t}\n\t\t*to++ = lablen;\n\t\tmemmove(to, dname, lablen);\n\t\tdname += lablen;\n\t\tto += lablen;\n\t\tlablen = *dname++;\n\t}\n\t*to = 0;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed(size_t n,\n                                                        size_t lb, GC_descr d)\n{\n    word *op;\n    size_t lg;\n    GC_descr simple_descr;\n    complex_descriptor *complex_descr;\n    int descr_type;\n    struct LeafDescriptor leaf;\n    GC_ASSERT(GC_explicit_typing_initialized);\n    descr_type = GC_make_array_descriptor((word)n, (word)lb, d, &simple_descr,\n                                          &complex_descr, &leaf);\n    switch(descr_type) {\n        case NO_MEM: return(0);\n        case SIMPLE: return(GC_malloc_explicitly_typed(n*lb, simple_descr));\n        case LEAF:\n            lb *= n;\n            lb += sizeof(struct LeafDescriptor) + TYPD_EXTRA_BYTES;\n            break;\n        case COMPLEX:\n            lb *= n;\n            lb += TYPD_EXTRA_BYTES;\n            break;\n    }\n    op = GC_malloc_kind(lb, GC_array_kind);\n    if (EXPECT(NULL == op, FALSE))\n        return NULL;\n    lg = SMALL_OBJ(lb) ? GC_size_map[lb] : BYTES_TO_GRANULES(GC_size(op));\n    if (descr_type == LEAF) {\n       volatile struct LeafDescriptor * lp =\n           (struct LeafDescriptor *)\n               (op + GRANULES_TO_WORDS(lg)\n                - (BYTES_TO_WORDS(sizeof(struct LeafDescriptor)) + 1));\n       lp -> ld_tag = LEAF_TAG;\n       lp -> ld_size = leaf.ld_size;\n       lp -> ld_nelements = leaf.ld_nelements;\n       lp -> ld_descriptor = leaf.ld_descriptor;\n       ((volatile word *)op)[GRANULES_TO_WORDS(lg) - 1] = (word)lp;\n   } else {\n#    ifndef GC_NO_FINALIZATION\n       size_t lw = GRANULES_TO_WORDS(lg);\n       op[lw - 1] = (word)complex_descr;\n       if (EXPECT(GC_general_register_disappearing_link(\n                                                (void **)(op + lw - 1), op)\n                  == GC_NO_MEMORY, FALSE))\n#    endif\n       {\n            return GC_malloc(lb);\n       }\n   }\n   return op;\n}", "target": 1}
{"code": "static char *exif_get_sectionlist(int sectionlist)\n{\n\tint i, len, ml = 0;\n\tchar *sections;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tml += strlen(exif_get_sectionname(i))+2;\n\t}\n\tsections = safe_emalloc(ml, 1, 1);\n\tsections[0] = '\\0';\n\tlen = 0;\n\tfor(i=0; i<SECTION_COUNT; i++) {\n\t\tif (sectionlist&(1<<i)) {\n\t\t\tsnprintf(sections+len, ml-len, \"%s, \", exif_get_sectionname(i));\n\t\t\tlen = strlen(sections);\n\t\t}\n\t}\n\tif (len>2)\n\t\tsections[len-2] = '\\0';\n\treturn sections;\n}", "target": 0}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\treturn 'E';\n}", "target": 0}
{"code": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}", "target": 1}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n \t\t\treturn range_within(rold, rcur) &&\n \t\t\t       tnum_in(rold->var_off, rcur->var_off);\n \t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n \t\t}\n \tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "zend_bool php_std_auto_global_callback(char *name, uint name_len TSRMLS_DC)\n{\n\tzend_printf(\"%s\\n\", name);\n\treturn 0; \n}", "target": 0}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "void ApplyChannelMatrix::run(const void *inputData, void *outputData, int frameCount)\n{\n\tconst T *input = reinterpret_cast<const T *>(inputData);\n\tT *output = reinterpret_cast<T *>(outputData);\n\tfor (int frame=0; frame<frameCount; frame++)\n\t{\n\t\tconst T *inputSave = input;\n\t\tconst double *m = m_matrix;\n\t\tfor (int outChannel=0; outChannel < m_outChannels; outChannel++)\n\t\t{\n\t\t\tinput = inputSave;\n\t\t\tdouble t = 0;\n\t\t\tfor (int inChannel=0; inChannel < m_inChannels; inChannel++)\n\t\t\t\tt += *input++ * *m++;\n\t\t\t*output++ = t;\n\t\t}\n\t}\n}", "target": 0}
{"code": "std::vector<std::vector<float>> DefaultColorTable(int depth) {\n  std::vector<std::vector<float>> color_table;\n  color_table.emplace_back(std::vector<float>({1, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 0, 1, 1}));      \n  color_table.emplace_back(std::vector<float>({1, 0, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0, 1, 0, 1}));      \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0.5, 0, 1}));  \n  color_table.emplace_back(std::vector<float>({0.5, 0, 0, 1}));    \n  color_table.emplace_back(std::vector<float>({0, 0, 0.5, 1}));  \n  color_table.emplace_back(std::vector<float>({0, 1, 1, 1}));    \n  color_table.emplace_back(std::vector<float>({1, 0, 1, 1}));    \n  if (depth == 1) {\n    for (int64 i = 0; i < color_table.size(); i++) {\n      color_table[i][0] = 1;\n    }\n  }\n  return color_table;\n}", "target": 0}
{"code": "static int parseValuesReturnFilter (\n\tOperation *op,\n\tSlapReply *rs,\n\tLDAPControl *ctrl )\n{\n\tBerElement\t*ber;\n\tstruct berval\tfstr = BER_BVNULL;\n\tif ( op->o_valuesreturnfilter != SLAP_CONTROL_NONE ) {\n\t\trs->sr_text = \"valuesReturnFilter control specified multiple times\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISNULL( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is absent\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tif ( BER_BVISEMPTY( &ctrl->ldctl_value )) {\n\t\trs->sr_text = \"valuesReturnFilter control value is empty\";\n\t\treturn LDAP_PROTOCOL_ERROR;\n\t}\n\tber = ber_init( &(ctrl->ldctl_value) );\n\tif (ber == NULL) {\n\t\trs->sr_text = \"internal error\";\n\t\treturn LDAP_OTHER;\n\t}\n\trs->sr_err = get_vrFilter( op, ber,\n\t\t(ValuesReturnFilter **)&(op->o_vrFilter), &rs->sr_text);\n\t(void) ber_free( ber, 1 );\n\tif( rs->sr_err != LDAP_SUCCESS ) {\n\t\tif( rs->sr_err == SLAPD_DISCONNECT ) {\n\t\t\trs->sr_err = LDAP_PROTOCOL_ERROR;\n\t\t\tsend_ldap_disconnect( op, rs );\n\t\t\trs->sr_err = SLAPD_DISCONNECT;\n\t\t} else {\n\t\t\tsend_ldap_result( op, rs );\n\t\t}\n\t\tif( op->o_vrFilter != NULL) vrFilter_free( op, op->o_vrFilter ); \n\t}\n#ifdef LDAP_DEBUG\n\telse {\n\t\tvrFilter2bv( op, op->o_vrFilter, &fstr );\n\t}\n\tDebug( LDAP_DEBUG_ARGS, \"\tvrFilter: %s\\n\",\n\t\tfstr.bv_len ? fstr.bv_val : \"empty\", 0, 0 );\n\top->o_tmpfree( fstr.bv_val, op->o_tmpmemctx );\n#endif\n\top->o_valuesreturnfilter = ctrl->ldctl_iscritical\n\t\t? SLAP_CONTROL_CRITICAL\n\t\t: SLAP_CONTROL_NONCRITICAL;\n\trs->sr_err = LDAP_SUCCESS;\n\treturn LDAP_SUCCESS;\n}", "target": 1}
{"code": "bool FrameLoader::isComplete() const\n{\n    return m_isComplete;\n}", "target": 0}
{"code": "static int proc_uptime_read(char *buf, size_t size, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tstruct file_info *d = (struct file_info *)fi->fh;\n\tlong int reaperage = getreaperage(fc->pid);;\n\tunsigned long int busytime = get_reaper_busy(fc->pid), idletime;\n\tchar *cache = d->buf;\n\tsize_t total_len = 0;\n\tif (offset){\n\t\tif (offset > d->size)\n\t\t\treturn -EINVAL;\n\t\tif (!d->cached)\n\t\t\treturn 0;\n\t\tint left = d->size - offset;\n\t\ttotal_len = left > size ? size: left;\n\t\tmemcpy(buf, cache + offset, total_len);\n\t\treturn total_len;\n\t}\n\tidletime = reaperage - busytime;\n\tif (idletime > reaperage)\n\t\tidletime = reaperage;\n\ttotal_len = snprintf(d->buf, d->size, \"%ld.0 %lu.0\\n\", reaperage, idletime);\n\tif (total_len < 0){\n\t\tperror(\"Error writing to cache\");\n\t\treturn 0;\n\t}\n\td->size = (int)total_len;\n\td->cached = 1;\n\tif (total_len > size) total_len = size;\n\tmemcpy(buf, d->buf, total_len);\n\treturn total_len;\n}", "target": 0}
{"code": "lt_dlinsertsearchdir (const char *before, const char *search_dir)\n{\n  int errors = 0;\n  if (before)\n    {\n      if ((before < user_search_path)\n\t  || (before >= user_search_path + LT_STRLEN (user_search_path)))\n\t{\n\t  LT__SETERROR (INVALID_POSITION);\n\t  return 1;\n\t}\n    }\n  if (search_dir && *search_dir)\n    {\n      if (lt_dlpath_insertdir (&user_search_path,\n\t\t\t       (char *) before, search_dir) != 0)\n\t{\n\t  ++errors;\n\t}\n    }\n  return errors;\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "archive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length;\n\tint i, r = 0, r2;\n\tif (_p == NULL || n == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\tif (sc == NULL) {\n\t\tlength = mbsnbytes(_p, n);\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tlength = utf16nbytes(_p, n);\n\telse\n\t\tlength = mbsnbytes(_p, n);\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}", "target": 1}
{"code": "static int orinoco_ioctl_setwap(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct sockaddr *ap_addr,\n\t\t\t\tchar *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint err = -EINPROGRESS;\t\t\n\tunsigned long flags;\n\tstatic const u8 off_addr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstatic const u8 any_addr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tif (memcmp(&ap_addr->sa_data, off_addr, ETH_ALEN) == 0 ||\n\t    memcmp(&ap_addr->sa_data, any_addr, ETH_ALEN) == 0) {\n\t\tpriv->bssid_fixed = 0;\n\t\tmemset(priv->desired_bssid, 0, ETH_ALEN);\n\t\tif (ap_addr->sa_data[0] == 0) {\n\t\t\t__orinoco_hw_set_wap(priv);\n\t\t\terr = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_AGERE) {\n\t\tprintk(KERN_WARNING \"%s: Lucent/Agere firmware doesn't \"\n\t\t       \"support manual roaming\\n\",\n\t\t       dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->iw_mode != NL80211_IFTYPE_STATION) {\n\t\tprintk(KERN_WARNING \"%s: Manual roaming supported only in \"\n\t\t       \"managed mode\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (priv->firmware_type == FIRMWARE_TYPE_INTERSIL &&\n\t    strlen(priv->desired_essid) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Desired ESSID must be set for \"\n\t\t       \"manual roaming\\n\", dev->name);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tpriv->bssid_fixed = 1;\n\tmemcpy(priv->desired_bssid, &ap_addr->sa_data, ETH_ALEN);\n out:\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "new_httpd(isc_httpdmgr_t *httpdmgr, isc_nmhandle_t *handle) {\n\tisc_httpd_t *httpd = NULL;\n\tchar *headerdata = NULL;\n\tREQUIRE(VALID_HTTPDMGR(httpdmgr));\n\thttpd = isc_nmhandle_getdata(handle);\n\tif (httpd == NULL) {\n\t\thttpd = isc_nmhandle_getextra(handle);\n\t\t*httpd = (isc_httpd_t){ .handle = NULL };\n\t\thttpdmgr_attach(httpdmgr, &httpd->mgr);\n\t}\n\tif (httpd->handle == NULL) {\n\t\tisc_nmhandle_setdata(handle, httpd, httpd_reset, httpd_put);\n\t\thttpd->handle = handle;\n\t} else {\n\t\tINSIST(httpd->handle == handle);\n\t}\n\theaderdata = isc_mem_get(httpdmgr->mctx, HTTP_SENDGROW);\n\tisc_buffer_init(&httpd->headerbuffer, headerdata, HTTP_SENDGROW);\n\tisc_buffer_clear(&httpd->headerbuffer);\n\tisc_buffer_initnull(&httpd->compbuffer);\n\tisc_buffer_clear(&httpd->compbuffer);\n\tisc_buffer_initnull(&httpd->bodybuffer);\n\tISC_LINK_INIT(httpd, link);\n\thttpd->magic = HTTPD_MAGIC;\n\thttpd->state = RECV;\n\tLOCK(&httpdmgr->lock);\n\tISC_LIST_APPEND(httpdmgr->running, httpd, link);\n\tUNLOCK(&httpdmgr->lock);\n\tisc_nmhandle_attach(httpd->handle, &httpd->readhandle);\n\tisc_nm_read(handle, httpd_request, httpdmgr);\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "  void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,\n                                      const int c, const int kx, const int ky,\n                                      const int sx, const int sy,\n                                      const string& data_format,\n                                      const string& padding) {\n    OpContext op_context;\n    int ho;\n    int wo;\n    if (data_format == \"NHWC\") {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, h, w, c}, {1, kx, ky, 1},\n                                     {1, sx, sy, 1}, \"NHWC\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(1).size();\n      wo = op_context.op_info.outputs(0).shape().dim(2).size();\n    } else {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, c, h, w}, {1, 1, kx, ky},\n                                     {1, 1, sx, sy}, \"NCHW\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(2).size();\n      wo = op_context.op_info.outputs(0).shape().dim(3).size();\n    }\n    bool found_unknown_shapes;\n    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n    Padding padding_enum;\n    if (padding == \"VALID\") {\n      padding_enum = Padding::VALID;\n    } else {\n      padding_enum = Padding::SAME;\n    }\n    EXPECT_EQ(n, dims.batch);\n    EXPECT_EQ(h, dims.ix);\n    EXPECT_EQ(w, dims.iy);\n    EXPECT_EQ(c, dims.iz);\n    EXPECT_EQ(kx, dims.kx);\n    EXPECT_EQ(ky, dims.ky);\n    EXPECT_EQ(sx, dims.sx);\n    EXPECT_EQ(sy, dims.sy);\n    EXPECT_EQ(ho, dims.ox);\n    EXPECT_EQ(wo, dims.oy);\n    EXPECT_EQ(c, dims.oz);\n    EXPECT_EQ(padding_enum, dims.padding);\n  }", "target": 1}
{"code": "static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)\n{\n  unsigned result = 0;\n  size_t i;\n  for(i = nbits - 1; i < nbits; i--)\n  {\n    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;\n  }\n  return result;\n}", "target": 0}
{"code": "static int zipfileComparePath(const char *zA, const char *zB, int nB){\n  int nA = (int)strlen(zA);\n  if( zA[nA-1]=='/' ) nA--;\n  if( zB[nB-1]=='/' ) nB--;\n  if( nA==nB && memcmp(zA, zB, nA)==0 ) return 0;\n  return 1;\n}", "target": 0}
{"code": "njs_string_prototype_match(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_str_t             string;\n    njs_int_t             ret;\n    njs_value_t           arguments[2];\n    njs_regexp_pattern_t  *pattern;\n    ret = njs_string_object_validate(vm, njs_argument(args, 0));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arguments[1] = args[0];\n    string.start = NULL;\n    string.length = 0;\n    if (nargs > 1) {\n        if (njs_is_regexp(&args[1])) {\n            pattern = njs_regexp_pattern(&args[1]);\n            if (pattern->global) {\n                return njs_string_match_multiple(vm, args, pattern);\n            }\n            arguments[0] = args[1];\n            goto match;\n        }\n        if (!njs_is_string(&args[1])) {\n            if (!njs_is_undefined(&args[1])) {\n                ret = njs_value_to_string(vm, &args[1], &args[1]);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n                njs_string_get(&args[1], &string);\n            }\n        } else {\n            njs_string_get(&args[1], &string);\n        }\n    }\n    ret = njs_regexp_create(vm, &arguments[0], string.start, string.length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\nmatch:\n    return njs_regexp_prototype_exec(vm, arguments, nargs, unused);\n}", "target": 0}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "clamp_indexed(const fz_colorspace *cs, const float *in, float *out)\n{\n\tstruct indexed *idx = cs->data;\n\t*out = fz_clamp(*in, 0, idx->high) / 255.0f; \n}", "target": 0}
{"code": "bool JOIN::save_explain_data(Explain_query *output, bool can_overwrite,\n                             bool need_tmp_table, bool need_order, \n                             bool distinct)\n{\n  DBUG_ENTER(\"JOIN::save_explain_data\");\n  DBUG_PRINT(\"enter\", (\"Save explain Select_lex: %u (%p)  parent lex: %p  stmt_lex: %p  present select: %u (%p)\",\n                        select_lex->select_number, select_lex,\n                        select_lex->parent_lex, thd->lex->stmt_lex,\n                        (output->get_select(select_lex->select_number) ?\n                         select_lex->select_number : 0),\n                        (output->get_select(select_lex->select_number) ?\n                         output->get_select(select_lex->select_number)\n                         ->select_lex : NULL)));\n  DBUG_SLOW_ASSERT(select_lex->select_number == UINT_MAX ||\n              select_lex->select_number == INT_MAX ||\n              !output ||\n              !output->get_select(select_lex->select_number) ||\n              output->get_select(select_lex->select_number)->select_lex ==\n                select_lex);\n  if (select_lex->select_number != UINT_MAX && \n      select_lex->select_number != INT_MAX  && \n      have_query_plan != JOIN::QEP_NOT_PRESENT_YET && \n      have_query_plan != JOIN::QEP_DELETED &&  \n      output && \n      (can_overwrite? true: !output->get_select(select_lex->select_number)))\n  {\n    const char *message= NULL;\n    if (!table_count || !tables_list || zero_result_cause)\n    {\n      message= zero_result_cause ? zero_result_cause : \"No tables used\";\n    }\n    bool rc= save_explain_data_intern(thd->lex->explain, need_tmp_table,\n                                      need_order, distinct, message);\n    DBUG_RETURN(rc);\n  }\n  if (select_lex == select_lex->master_unit()->fake_select_lex && join_tab)\n  {\n    uint nr= select_lex->master_unit()->first_select()->select_number;\n    Explain_union *eu= output->get_union(nr);\n    explain= &eu->fake_select_lex_explain;\n    join_tab[0].tracker= eu->get_fake_select_lex_tracker();\n    for (uint i=0 ; i < exec_join_tab_cnt() + aggr_tables; i++)\n    {\n      if (join_tab[i].filesort)\n      {\n        if (!(join_tab[i].filesort->tracker=\n              new Filesort_tracker(thd->lex->analyze_stmt)))\n          DBUG_RETURN(1);\n      }\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}", "target": 1}
{"code": "netsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  \n    }\n    closedir( dir );\n}", "target": 1}
{"code": "static void _ewk_frame_smart_del(Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET(ewkFrame, smartData);\n    if (smartData) {\n         if (smartData->frame) {\n             WebCore::FrameLoaderClientEfl* flc = _ewk_frame_loader_efl_get(smartData->frame);\n             flc->setWebFrame(0);\n            smartData->frame->loader()->detachFromParent();\n            smartData->frame->loader()->cancelAndClear();\n             smartData->frame = 0;\n         }\n        eina_stringshare_del(smartData->title);\n        eina_stringshare_del(smartData->uri);\n        eina_stringshare_del(smartData->name);\n    }\n    _parent_sc.del(ewkFrame);\n}", "target": 1}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "xmlParseCheckTransition(xmlParserCtxtPtr ctxt, const char *chunk, int size) {\n    if ((ctxt == NULL) || (chunk == NULL) || (size < 0))\n        return(-1);\n    if (ctxt->instate == XML_PARSER_START_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_COMMENT) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_CDATA_SECTION) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->progressive == XML_PARSER_PI) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if (ctxt->instate == XML_PARSER_END_TAG) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    if ((ctxt->progressive == XML_PARSER_DTD) ||\n        (ctxt->instate == XML_PARSER_DTD)) {\n        if (memchr(chunk, '>', size) != NULL)\n            return(1);\n        return(0);\n    }\n    return(1);\n}", "target": 0}
{"code": "bool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  const bool status = proto.ParseFromString(s);\n  if (status) FromProto(proto);\n  return status;\n}", "target": 1}
{"code": "is_mbc_ambiguous(OnigCaseFoldType flag,\n\t\t const UChar** pp, const UChar* end)\n{\n  int v;\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    (*pp)++;\n    return TRUE;\n  }\n  (*pp)++;\n  v = (EncISO_8859_1_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  if ((v | BIT_CTYPE_LOWER) != 0) {\n    if (*p >= 0xaa && *p <= 0xba)\n      return FALSE;\n    else\n      return TRUE;\n  }\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "static void free_kmem_cache_nodes(struct kmem_cache *s)\n{\n\tint node;\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n = s->node[node];\n\t\tif (n && n != &s->local_node)\n\t\t\tkmem_cache_free(kmalloc_caches, n);\n\t\ts->node[node] = NULL;\n\t}\n}", "target": 0}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "void gf_fs_print_non_connected(GF_FilterSession *fsess)\n{\n\tgf_fs_print_not_connected_filters(fsess, NULL, GF_FALSE);\n}", "target": 0}
{"code": "fill_yin_revision(struct lys_module *module, struct lyxml_elem *yin, struct lys_revision *rev,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *next, *child;\n    const char *value;\n    GETVAL(ctx, value, yin, \"date\");\n    if (lyp_check_date(ctx, value)) {\n        goto error;\n    }\n    memcpy(rev->date, value, LY_REV_SIZE - 1);\n    LY_TREE_FOR_SAFE(yin->child, next, child) {\n        if (!child->ns) {\n            continue;\n        } else if (strcmp(child->ns->value, LY_NSYIN)) {\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_SELF, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"description\")) {\n            if (rev->dsc) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_DESCRIPTION, 0, unres)) {\n                goto error;\n            }\n            rev->dsc = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->dsc) {\n                goto error;\n            }\n        } else if (!strcmp(child->name, \"reference\")) {\n            if (rev->ref) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, child->name, yin->name);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, rev, LYEXT_PAR_REVISION,\n                                          child, LYEXT_SUBSTMT_REFERENCE, 0, unres)) {\n                goto error;\n            }\n            rev->ref = read_yin_subnode(ctx, child, \"text\");\n            if (!rev->ref) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, child->name);\n            goto error;\n        }\n    }\n    return EXIT_SUCCESS;\nerror:\n    return EXIT_FAILURE;\n}", "target": 0}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "static void fuse_intr_sighandler(int sig)\n{\n    (void) sig;\n}", "target": 0}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "util_write_callback(int flags, char *ptr, size_t size, size_t nmemb, void *stream)\n{\n    CurlObject *self;\n    PyObject *arglist;\n    PyObject *result = NULL;\n    size_t ret = 0;     \n    PyObject *cb;\n    int total_size;\n    PYCURL_DECLARE_THREAD_STATE;\n    self = (CurlObject *)stream;\n    if (!PYCURL_ACQUIRE_THREAD())\n        return ret;\n    cb = flags ? self->h_cb : self->w_cb;\n    if (cb == NULL)\n        goto silent_error;\n    if (size <= 0 || nmemb <= 0)\n        goto done;\n    total_size = (int)(size * nmemb);\n    if (total_size < 0 || (size_t)total_size / size != nmemb) {\n        PyErr_SetString(ErrorObject, \"integer overflow in write callback\");\n        goto verbose_error;\n    }\n#if PY_MAJOR_VERSION >= 3\n    arglist = Py_BuildValue(\"(y#)\", ptr, total_size);\n#else\n    arglist = Py_BuildValue(\"(s#)\", ptr, total_size);\n#endif\n    if (arglist == NULL)\n        goto verbose_error;\n    result = PyEval_CallObject(cb, arglist);\n    Py_DECREF(arglist);\n    if (result == NULL)\n        goto verbose_error;\n    if (result == Py_None) {\n        ret = total_size;           \n    }\n    else if (PyInt_Check(result) || PyLong_Check(result)) {\n        ret = (size_t) PyLong_AsLong(result);\n    }\n    else {\n        PyErr_SetString(ErrorObject, \"write callback must return int or None\");\n        goto verbose_error;\n    }\ndone:\nsilent_error:\n    Py_XDECREF(result);\n    PYCURL_RELEASE_THREAD();\n    return ret;\nverbose_error:\n    PyErr_Print();\n    goto silent_error;\n}", "target": 0}
{"code": "int FoFiTrueType::setupGSUB(const char *scriptName)\n{\n  return setupGSUB(scriptName, NULL);\n}", "target": 0}
{"code": "static inline void nfsd4_increment_op_stats(u32 opnum)\n{\n\tif (opnum >= FIRST_NFS4_OP && opnum <= LAST_NFS4_OP)\n\t\tnfsdstats.nfs4_opcount[opnum]++;\n}", "target": 0}
{"code": "static gboolean get_name_index(const EnumNames names[], const char *name, uint32_t *index)\n{\n    if (name) {\n        int i;\n        for (i = 0; names[i].name; i++) {\n            if (strcmp(name, names[i].name) == 0) {\n                *index = i;\n                return TRUE;\n            }\n        }\n    }\n    return FALSE;\n}", "target": 0}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 1}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "_pam_parse (const pam_handle_t *pamh, int argc, const char **argv,\n\t    const char **conffile, const char **envfile, int *readenv,\n\t    const char **user_envfile, int *user_readenv)\n{\n    int ctrl=0;\n    *user_envfile = DEFAULT_USER_ENVFILE;\n    *envfile = DEFAULT_ETC_ENVFILE;\n    *readenv = DEFAULT_READ_ENVFILE;\n    *user_readenv = DEFAULT_USER_READ_ENVFILE;\n    *conffile = DEFAULT_CONF_FILE;\n    for (; argc-- > 0; ++argv) {\n\tif (!strcmp(*argv,\"debug\"))\n\t    ctrl |= PAM_DEBUG_ARG;\n\telse if (!strncmp(*argv,\"conffile=\",9)) {\n\t  if ((*argv)[9] == '\\0') {\n\t    pam_syslog(pamh, LOG_ERR,\n\t\t       \"conffile= specification missing argument - ignored\");\n\t  } else {\n\t    *conffile = 9+*argv;\n\t    D((\"new Configuration File: %s\", *conffile));\n\t  }\n\t} else if (!strncmp(*argv,\"envfile=\",8)) {\n\t  if ((*argv)[8] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *envfile = 8+*argv;\n\t    D((\"new Env File: %s\", *envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"user_envfile=\",13)) {\n\t  if ((*argv)[13] == '\\0') {\n\t    pam_syslog (pamh, LOG_ERR,\n\t\t\t\"user_envfile= specification missing argument - ignored\");\n\t  } else {\n\t    *user_envfile = 13+*argv;\n\t    D((\"new User Env File: %s\", *user_envfile));\n\t  }\n\t} else if (!strncmp(*argv,\"readenv=\",8))\n\t  *readenv = atoi(8+*argv);\n\telse if (!strncmp(*argv,\"user_readenv=\",13))\n\t  *user_readenv = atoi(13+*argv);\n\telse\n\t  pam_syslog(pamh, LOG_ERR, \"unknown option: %s\", *argv);\n    }\n    return ctrl;\n}", "target": 0}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    char *uuid;\n    Slapi_Attr *attr;\n    Slapi_Value *val;\n    if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = NULL;\n    slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n    slapi_attr_first_value(attr, &val);\n    uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n    if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n        if (cookie) {\n            char *cookiestr = sync_cookie2str(cookie);\n            rc = ber_printf(ber, \"s}\", cookiestr);\n            slapi_ch_free((void **)&cookiestr);\n        } else {\n            rc = ber_printf(ber, \"}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    slapi_ch_free((void **)&uuid);\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n    (*ctrlp)->ldctl_value = *bvp; \n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n    return (LDAP_SUCCESS);\n}", "target": 1}
{"code": "EXPORTED int meth_trace(struct transaction_t *txn, void *params)\n{\n    parse_path_t parse_path = (parse_path_t) params;\n    const char **hdr;\n    unsigned long max_fwd = -1;\n    struct buf *msg = &txn->resp_body.payload;\n    txn->flags.cc |= CC_NOCACHE;\n    if (!(txn->req_tgt.allow & ALLOW_TRACE)) return HTTP_NOT_ALLOWED;\n    if ((hdr = spool_getheader(txn->req_hdrs, \"Max-Forwards\"))) {\n        max_fwd = strtoul(hdr[0], NULL, 10);\n    }\n    if (max_fwd && parse_path) {\n        int r;\n        if ((r = parse_path(txn->req_uri->path,\n                            &txn->req_tgt, &txn->error.desc))) return r;\n        if (txn->req_tgt.mbentry && txn->req_tgt.mbentry->server) {\n            struct backend *be;\n            be = proxy_findserver(txn->req_tgt.mbentry->server,\n                                  &http_protocol, httpd_userid,\n                                  &backend_cached, NULL, NULL, httpd_in);\n            if (!be) return HTTP_UNAVAILABLE;\n            return http_pipe_req_resp(be, txn);\n        }\n    }\n    buf_reset(msg);\n    buf_printf(msg, \"TRACE %s %s\\r\\n\", txn->req_line.uri, txn->req_line.ver);\n    spool_enum_hdrcache(txn->req_hdrs, &trace_cachehdr, msg);\n    buf_appendcstr(msg, \"\\r\\n\");\n    txn->resp_body.type = \"message/http\";\n    txn->resp_body.len = buf_len(msg);\n    write_body(HTTP_OK, txn, buf_cstring(msg), buf_len(msg));\n    return 0;\n}", "target": 0}
{"code": "void AccessibilityUIElement::getChildrenWithRange(Vector<RefPtr<AccessibilityUIElement> >& children, unsigned location, unsigned length)\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return;\n    unsigned end = location + length;\n    for (unsigned i = location; i < end; i++) {\n        AtkObject* child = atk_object_ref_accessible_child(ATK_OBJECT(m_element), i);\n        children.append(AccessibilityUIElement::create(child));\n    }\n}", "target": 0}
{"code": "static void free_pcppages_bulk(struct zone *zone, int count,\n\t\t\t\t\tstruct per_cpu_pages *pcp)\n{\n\tint migratetype = 0;\n\tint batch_free = 0;\n\tbool isolated_pageblocks;\n\tspin_lock(&zone->lock);\n\tisolated_pageblocks = has_isolate_pageblock(zone);\n\twhile (count) {\n\t\tstruct page *page;\n\t\tstruct list_head *list;\n\t\tdo {\n\t\t\tbatch_free++;\n\t\t\tif (++migratetype == MIGRATE_PCPTYPES)\n\t\t\t\tmigratetype = 0;\n\t\t\tlist = &pcp->lists[migratetype];\n\t\t} while (list_empty(list));\n\t\tif (batch_free == MIGRATE_PCPTYPES)\n\t\t\tbatch_free = count;\n\t\tdo {\n\t\t\tint mt;\t\n\t\t\tpage = list_last_entry(list, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tmt = get_pcppage_migratetype(page);\n\t\t\tVM_BUG_ON_PAGE(is_migrate_isolate(mt), page);\n\t\t\tif (unlikely(isolated_pageblocks))\n\t\t\t\tmt = get_pageblock_migratetype(page);\n\t\t\tif (bulkfree_pcp_prepare(page))\n\t\t\t\tcontinue;\n\t\t\t__free_one_page(page, page_to_pfn(page), zone, 0, mt);\n\t\t\ttrace_mm_page_pcpu_drain(page, 0, mt);\n\t\t} while (--count && --batch_free && !list_empty(list));\n\t}\n\tspin_unlock(&zone->lock);\n}", "target": 0}
{"code": "static int x509_info_subject_alt_name( char **buf, size_t *size,\n                                       const mbedtls_x509_sequence *subject_alt_name )\n{\n    size_t i;\n    size_t n = *size;\n    char *p = *buf;\n    const mbedtls_x509_sequence *cur = subject_alt_name;\n    const char *sep = \"\";\n    size_t sep_len = 0;\n    while( cur != NULL )\n    {\n        if( cur->buf.len + sep_len >= n )\n        {\n            *p = '\\0';\n            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );\n        }\n        n -= cur->buf.len + sep_len;\n        for( i = 0; i < sep_len; i++ )\n            *p++ = sep[i];\n        for( i = 0; i < cur->buf.len; i++ )\n            *p++ = cur->buf.p[i];\n        sep = \", \";\n        sep_len = 2;\n        cur = cur->next;\n    }\n    *p = '\\0';\n    *size = n;\n    *buf = p;\n    return( 0 );\n}", "target": 0}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "void BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tdecodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);\n\t\tframesRead += m_framesPerPacket;\n\t}\n\tm_track->nextfframe += framesRead;\n\tassert(tell() == m_track->fpos_next_frame);\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\tm_outChunk->frameCount = framesRead;\n}", "target": 1}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, OrCollapsesToSingleScan) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{$or: [{a:{$gt:2}}, {a:{$gt:0}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[0,Infinity,false,true]]}}}}}\");\n}", "target": 0}
{"code": "elg_get_nbits (gcry_sexp_t parms)\n{\n  gcry_sexp_t l1;\n  gcry_mpi_t p;\n  unsigned int nbits;\n  l1 = sexp_find_token (parms, \"p\", 1);\n  if (!l1)\n    return 0; \n  p= sexp_nth_mpi (l1, 1, GCRYMPI_FMT_USG);\n  sexp_release (l1);\n  nbits = p? mpi_get_nbits (p) : 0;\n  _gcry_mpi_release (p);\n  return nbits;\n}", "target": 0}
{"code": "void mark_progress(struct st_command* command __attribute__((unused)),\n                   int line)\n{\n  static ulonglong progress_start= 0; \n  DYNAMIC_STRING ds_progress;\n  char buf[32], *end;\n  ulonglong timer= timer_now();\n  if (!progress_start)\n    progress_start= timer;\n  timer-= progress_start;\n  if (init_dynamic_string(&ds_progress, \"\", 256, 256))\n    die(\"Out of memory\");\n  end= longlong10_to_str(timer, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  end= int10_to_str(line, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\t\", 1);\n  dynstr_append(&ds_progress, cur_file->file_name);\n  dynstr_append_mem(&ds_progress, \":\", 1);\n  end= int10_to_str(cur_file->lineno, buf, 10);\n  dynstr_append_mem(&ds_progress, buf, (int)(end-buf));\n  dynstr_append_mem(&ds_progress, \"\\n\", 1);\n  progress_file.write(&ds_progress);\n  dynstr_free(&ds_progress);\n}", "target": 0}
{"code": "static inline float *VMUL2S(float *dst, const float *v, unsigned idx,\n                            unsigned sign, const float *scale)\n{\n    union av_intfloat32 s0, s1;\n    s0.f = s1.f = *scale;\n    s0.i ^= sign >> 1 << 31;\n    s1.i ^= sign      << 31;\n    *dst++ = v[idx    & 15] * s0.f;\n    *dst++ = v[idx>>4 & 15] * s1.f;\n    return dst;\n}", "target": 0}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "loop_pop(codegen_scope *s, int val)\n{\n  if (val) {\n    genop_1(s, OP_LOADNIL, cursp());\n  }\n  dispatch_linked(s, s->loop->pc2);\n  s->loop = s->loop->prev;\n  if (val) push();\n}", "target": 0}
{"code": "int main(int argc, char **argv)\n{\n    int fd;\n    int ret;\n    fd = mkstemp(test_image);\n    g_assert(fd >= 0);\n    ret = ftruncate(fd, TEST_IMAGE_SIZE);\n    g_assert(ret == 0);\n    close(fd);\n    g_test_init(&argc, &argv, NULL);\n    qtest_start(\"-machine pc -device floppy,id=floppy0\");\n    qtest_irq_intercept_in(global_qtest, \"ioapic\");\n    qtest_add_func(\"/fdc/cmos\", test_cmos);\n    qtest_add_func(\"/fdc/no_media_on_start\", test_no_media_on_start);\n    qtest_add_func(\"/fdc/read_without_media\", test_read_without_media);\n    qtest_add_func(\"/fdc/media_change\", test_media_change);\n    qtest_add_func(\"/fdc/sense_interrupt\", test_sense_interrupt);\n    qtest_add_func(\"/fdc/relative_seek\", test_relative_seek);\n    qtest_add_func(\"/fdc/read_id\", test_read_id);\n    qtest_add_func(\"/fdc/verify\", test_verify);\n    qtest_add_func(\"/fdc/media_insert\", test_media_insert);\n    qtest_add_func(\"/fdc/read_no_dma_1\", test_read_no_dma_1);\n    qtest_add_func(\"/fdc/read_no_dma_18\", test_read_no_dma_18);\n    qtest_add_func(\"/fdc/read_no_dma_19\", test_read_no_dma_19);\n    qtest_add_func(\"/fdc/fuzz-registers\", fuzz_registers);\n    qtest_add_func(\"/fdc/fuzz/cve_2021_20196\", test_cve_2021_20196);\n    ret = g_test_run();\n    qtest_end();\n    unlink(test_image);\n    return ret;\n}", "target": 1}
{"code": "GF_Err udta_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, udta_on_child_box);\n\tif (e) return e;\n\tif (s->size==4) {\n\t\tu32 val = gf_bs_read_u32(bs);\n\t\ts->size = 0;\n\t\tif (val) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] udta has 4 remaining bytes set to %08X but they should be 0\\n\", val));\n\t\t}\n\t}\n\treturn GF_OK;", "target": 0}
{"code": "static void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid, u8 err)\n{\n\tstruct cnic_ctl_info ctl = {0};\n\tctl.cmd = CNIC_CTL_COMPLETION_CMD;\n\tctl.data.comp.cid = cid;\n\tctl.data.comp.error = err;\n\tbnx2x_cnic_ctl_send_bh(bp, &ctl);\n\tbnx2x_cnic_sp_post(bp, 0);\n}", "target": 0}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "sock_set_v6only(int s)\n{\n#if defined(IPV6_V6ONLY) && !defined(__OpenBSD__)\n\tint on = 1;\n\tdebug3(\"%s: set socket %d IPV6_V6ONLY\", __func__, s);\n\tif (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof(on)) == -1)\n\t\terror(\"setsockopt IPV6_V6ONLY: %s\", strerror(errno));\n#endif\n}", "target": 0}
{"code": "Bool gf_sys_get_battery_state(Bool *onBattery, u32 *onCharge, u32*level, u32 *batteryLifeTime, u32 *batteryFullLifeTime)\n{\n#if defined(_WIN32_WCE)\n\tSYSTEM_POWER_STATUS_EX sps;\n\tGetSystemPowerStatusEx(&sps, 0);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? 0 : 1;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#elif defined(WIN32)\n\tSYSTEM_POWER_STATUS sps;\n\tGetSystemPowerStatus(&sps);\n\tif (onBattery) *onBattery = sps.ACLineStatus ? GF_FALSE : GF_TRUE;\n\tif (onCharge) *onCharge = (sps.BatteryFlag & BATTERY_FLAG_CHARGING) ? 1 : 0;\n\tif (level) *level = sps.BatteryLifePercent;\n\tif (batteryLifeTime) *batteryLifeTime = sps.BatteryLifeTime;\n\tif (batteryFullLifeTime) *batteryFullLifeTime = sps.BatteryFullLifeTime;\n#endif\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n\t\t\t\t   union md_node_info *node_info)\n{\n\tconst u64 *parent_cfg_hdlp;\n\tconst char *name;\n\tconst u64 *idp;\n\tidp = mdesc_get_property(md, node, \"id\", NULL);\n\tname = mdesc_get_property(md, node, \"name\", NULL);\n\tparent_cfg_hdlp = parent_cfg_handle(md, node);\n\tif (!idp || !name || !parent_cfg_hdlp)\n\t\treturn -1;\n\tnode_info->vdev_port.id = *idp;\n\tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n\tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "static int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  InstanceFeatureDimKey(const int32_t instance, const int32_t feature_dim)\n      : instance(instance), feature_dim(feature_dim) {}", "target": 0}
{"code": "static void test_bug17309863()\n{\n  MYSQL *lmysql;\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  myheader(\"test_bug17309863\");\n  if (!opt_silent)\n    fprintf(stdout, \"\\n Establishing a test connection ...\");\n  if (!(lmysql= mysql_client_init(NULL)))\n  {\n    myerror(\"mysql_client_init() failed\");\n    exit(1);\n  }\n  lmysql->reconnect= 1;\n  if (!(mysql_real_connect(lmysql, opt_host, opt_user,\n                           opt_password, current_db, opt_port,\n                           opt_unix_socket, 0)))\n  {\n    myerror(\"connection failed\");\n    exit(1);\n  }\n  if (!opt_silent)\n    fprintf(stdout, \"OK\");\n  thread_id= mysql_thread_id(lmysql);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  rc= mysql_query(lmysql, \"SELECT 'bug17309863'\");\n  myquery(rc);\n  mysql_close(lmysql);\n}", "target": 0}
{"code": "static void ulaw2linear_buf (const uint8_t *ulaw, int16_t *linear, int nsamples)\n{\n\tfor (int i=0; i < nsamples; i++)\n\t\tlinear[i] = _af_ulaw2linear(ulaw[i]);\n}", "target": 0}
{"code": "zdeletefile(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    gs_parsed_file_name_t pname;\n    int code = parse_real_file_name(op, &pname, imemory, \"deletefile\");\n    if (code < 0)\n        return code;\n    if (pname.iodev == iodev_default(imemory)) {\n        if ((code = check_file_permissions(i_ctx_p, pname.fname, pname.len,\n                pname.iodev, \"PermitFileControl\")) < 0 &&\n                 !file_is_tempfile(i_ctx_p, op->value.bytes, r_size(op))) {\n            return code;\n        }\n    }\n    code = (*pname.iodev->procs.delete_file)(pname.iodev, pname.fname);\n    gs_free_file_name(&pname, \"deletefile\");\n    if (code < 0)\n        return code;\n    pop(1);\n    return 0;\n}", "target": 0}
{"code": "int reds_on_migrate_dst_set_seamless(RedsState *reds, MainChannelClient *mcc, uint32_t src_version)\n{\n    if (reds->allow_multiple_clients  || src_version > SPICE_MIGRATION_PROTOCOL_VERSION) {\n        reds->dst_do_seamless_migrate = FALSE;\n    } else {\n        RedClient *client = mcc->get_client();\n        client->set_migration_seamless();\n        reds->dst_do_seamless_migrate = reds_link_mig_target_channels(reds, client);\n    }\n    return reds->dst_do_seamless_migrate;\n}", "target": 0}
{"code": "get_smb2_acl_by_path(struct cifs_sb_info *cifs_sb,\n\t\t     const char *path, u32 *pacllen, u32 info)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tu8 oplock = SMB2_OPLOCK_LEVEL_NONE;\n\tunsigned int xid;\n\tint rc;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\t__le16 *utf16_path;\n\tcifs_dbg(FYI, \"get smb3 acl for path %s\\n\", path);\n\tif (IS_ERR(tlink))\n\t\treturn ERR_CAST(tlink);\n\ttcon = tlink_tcon(tlink);\n\txid = get_xid();\n\tutf16_path = cifs_convert_path_to_utf16(path, cifs_sb);\n\tif (!utf16_path) {\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn ERR_PTR(rc);\n\t}\n\toparms.tcon = tcon;\n\toparms.desired_access = READ_CONTROL;\n\toparms.disposition = FILE_OPEN;\n\toparms.create_options = cifs_create_options(cifs_sb, 0) | OPEN_REPARSE_POINT;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\tif (info & SACL_SECINFO)\n\t\toparms.desired_access |= SYSTEM_SECURITY;\n\trc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,\n\t\t       NULL);\n\tkfree(utf16_path);\n\tif (!rc) {\n\t\trc = SMB2_query_acl(xid, tlink_tcon(tlink), fid.persistent_fid,\n\t\t\t\t    fid.volatile_fid, (void **)&pntsd, pacllen,\n\t\t\t\t    info);\n\t\tSMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);\n\t}\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"%s: rc = %d ACL len %d\\n\", __func__, rc, *pacllen);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\treturn pntsd;\n}", "target": 0}
{"code": "spnego_gss_inquire_cred(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tgss_cred_id_t cred_handle,\n\t\t\tgss_name_t *name,\n\t\t\tOM_uint32 *lifetime,\n\t\t\tint *cred_usage,\n\t\t\tgss_OID_set *mechanisms)\n{\n\tOM_uint32 status;\n\tspnego_gss_cred_id_t spcred = NULL;\n\tgss_cred_id_t creds = GSS_C_NO_CREDENTIAL;\n\tOM_uint32 tmp_minor_status;\n\tOM_uint32 initiator_lifetime, acceptor_lifetime;\n\tdsyslog(\"Entering inquire_cred\\n\");\n\tspcred = (spnego_gss_cred_id_t)cred_handle;\n\tif (spcred == NULL) {\n\t\tstatus = get_available_mechs(minor_status,\n\t\t\tGSS_C_NO_NAME,\n\t\t\tGSS_C_BOTH,\n\t\t\tGSS_C_NO_CRED_STORE,\n\t\t\t&creds,\n\t\t\tmechanisms);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif ((*mechanisms)->count == 0) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tgss_release_oid_set(&tmp_minor_status, mechanisms);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (GSS_S_DEFECTIVE_CREDENTIAL);\n\t\t}\n\t\tassert((*mechanisms)->elements != NULL);\n\t\tstatus = gss_inquire_cred_by_mech(minor_status,\n\t\t\tcreds,\n\t\t\t&(*mechanisms)->elements[0],\n\t\t\tname,\n\t\t\t&initiator_lifetime,\n\t\t\t&acceptor_lifetime,\n\t\t\tcred_usage);\n\t\tif (status != GSS_S_COMPLETE) {\n\t\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t\t\tdsyslog(\"Leaving inquire_cred\\n\");\n\t\t\treturn (status);\n\t\t}\n\t\tif (lifetime != NULL)\n\t\t\t*lifetime = (*cred_usage == GSS_C_ACCEPT) ?\n\t\t\t\tacceptor_lifetime : initiator_lifetime;\n\t\tgss_release_cred(&tmp_minor_status, &creds);\n\t} else {\n\t\tstatus = gss_inquire_cred(minor_status, spcred->mcred,\n\t\t\t\t\t  name, lifetime,\n\t\t\t\t\t  cred_usage, mechanisms);\n\t}\n\tdsyslog(\"Leaving inquire_cred\\n\");\n\treturn (status);\n}", "target": 0}
{"code": "RGB_to_HWB (RGBType RGB, HWBType * HWB)\n{\n\tfloat R = RGB.R, G = RGB.G, B = RGB.B, w, v, b, f;\n\tint i;\n\tw = MIN3 (R, G, B);\n\tv = MAX3 (R, G, B);\n\tb = 1 - v;\n\tif (v == w)\n\t\tRETURN_HWB (HWB_UNDEFINED, w, b);\n\tf = (R == w) ? G - B : ((G == w) ? B - R : R - G);\n\ti = (R == w) ? 3 : ((G == w) ? 5 : 1);\n\tRETURN_HWB (i - f / (v - w), w, b);\n}", "target": 0}
{"code": "int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\tlock_sock(sk);\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\terr = -EADDRINUSE;\n\tping_set_saddr(sk, uaddr);\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\tping_clear_saddr(sk, dif);\n\t\tgoto out;\n\t}\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}", "target": 0}
{"code": "psf_d2i_clip_array (const double *src, int *dest, int count, int normalize)\n{\tdouble\t\t\tnormfact, scaled_value ;\n\tnormfact = normalize ? (8.0 * 0x10000000) : 1.0 ;\n\twhile (--count >= 0)\n\t{\tscaled_value = src [count] * normfact ;\n\t\tif (CPU_CLIPS_POSITIVE == 0 && scaled_value >= (1.0 * 0x7FFFFFFF))\n\t\t{\tdest [count] = 0x7FFFFFFF ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tif (CPU_CLIPS_NEGATIVE == 0 && scaled_value <= (-8.0 * 0x10000000))\n\t\t{\tdest [count] = 0x80000000 ;\n\t\t\tcontinue ;\n\t\t\t} ;\n\t\tdest [count] = lrint (scaled_value) ;\n\t\t} ;\n\treturn ;\n} ", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static int fuse_get_user_pages(struct fuse_req *req, const char __user *buf,\n\t\t\t       size_t *nbytesp, int write)\n{\n\tsize_t nbytes = *nbytesp;\n\tunsigned long user_addr = (unsigned long) buf;\n\tunsigned offset = user_addr & ~PAGE_MASK;\n\tint npages;\n\tif (segment_eq(get_fs(), KERNEL_DS)) {\n\t\tif (write)\n\t\t\treq->in.args[1].value = (void *) user_addr;\n\t\telse\n\t\t\treq->out.args[0].value = (void *) user_addr;\n\t\treturn 0;\n\t}\n\tnbytes = min_t(size_t, nbytes, FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT);\n\tnpages = (nbytes + offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tnpages = clamp(npages, 1, FUSE_MAX_PAGES_PER_REQ);\n\tdown_read(&current->mm->mmap_sem);\n\tnpages = get_user_pages(current, current->mm, user_addr, npages, !write,\n\t\t\t\t0, req->pages, NULL);\n\tup_read(&current->mm->mmap_sem);\n\tif (npages < 0)\n\t\treturn npages;\n\treq->num_pages = npages;\n\treq->page_offset = offset;\n\tif (write)\n\t\treq->in.argpages = 1;\n\telse\n\t\treq->out.argpages = 1;\n\tnbytes = (req->num_pages << PAGE_SHIFT) - req->page_offset;\n\t*nbytesp = min(*nbytesp, nbytes);\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret;\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "static u8 vgacon_build_attr(struct vc_data *c, u8 color,\n\t\t\t    enum vc_intensity intensity,\n\t\t\t    bool blink, bool underline, bool reverse,\n\t\t\t    bool italic)\n{\n\tu8 attr = color;\n\tif (vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF0) | c->vc_itcolor;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf0) | c->vc_ulcolor;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | c->vc_halfcolor;\n\t}\n\tif (reverse)\n\t\tattr =\n\t\t    ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) &\n\t\t\t\t       0x77);\n\tif (blink)\n\t\tattr ^= 0x80;\n\tif (intensity == VCI_BOLD)\n\t\tattr ^= 0x08;\n\tif (!vga_can_do_color) {\n\t\tif (italic)\n\t\t\tattr = (attr & 0xF8) | 0x02;\n\t\telse if (underline)\n\t\t\tattr = (attr & 0xf8) | 0x01;\n\t\telse if (intensity == VCI_HALF_BRIGHT)\n\t\t\tattr = (attr & 0xf0) | 0x08;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "void WebContentsImpl::DidFailProvisionalLoadWithError(\n    RenderViewHost* render_view_host,\n    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {\n  VLOG(1) << \"Failed Provisional Load: \" << params.url.possibly_invalid_spec()\n          << \", error_code: \" << params.error_code\n          << \", error_description: \" << params.error_description\n          << \", is_main_frame: \" << params.is_main_frame\n          << \", showing_repost_interstitial: \" <<\n            params.showing_repost_interstitial\n          << \", frame_id: \" << params.frame_id;\n  GURL validated_url(params.url);\n  RenderProcessHost* render_process_host =\n      render_view_host->GetProcess();\n  RenderViewHost::FilterURL(render_process_host, false, &validated_url);\n  if (net::ERR_ABORTED == params.error_code) {\n    if (ShowingInterstitialPage()) {\n      LOG(WARNING) << \"Discarding message during interstitial.\";\n      return;\n    }\n    render_manager_.RendererAbortedProvisionalLoad(render_view_host);\n  }\n  if (controller_.GetPendingEntry() != controller_.GetVisibleEntry())\n    controller_.DiscardPendingEntry();\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    DidFailProvisionalLoad(params.frame_id,\n                                           params.is_main_frame,\n                                           validated_url,\n                                           params.error_code,\n                                           params.error_description,\n                                           render_view_host));\n}", "target": 0}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_fill(AACContext *ac, GetBitContext *gb, int len) {\n    uint8_t buf[256];\n    int i, major, minor;\n    if (len < 13+7*8)\n        goto unknown;\n    get_bits(gb, 13); len -= 13;\n    for(i=0; i+1<sizeof(buf) && len>=8; i++, len-=8)\n        buf[i] = get_bits(gb, 8);\n    buf[i] = 0;\n    if (ac->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(ac->avctx, AV_LOG_DEBUG, \"FILL:%s\\n\", buf);\n    if (sscanf(buf, \"libfaac %d.%d\", &major, &minor) == 2){\n        ac->avctx->internal->skip_samples = 1024;\n    }\nunknown:\n    skip_bits_long(gb, len);\n    return 0;\n}", "target": 0}
{"code": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n  order_group_num*= 2;\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n  return array == NULL;\n}", "target": 1}
{"code": "ex_put(exarg_T *eap)\n{\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}", "target": 1}
{"code": "_cdf_tole2(uint16_t sv)\n{\n\tuint16_t rv;\n\tuint8_t *s = (uint8_t *)(void *)&sv;\n\tuint8_t *d = (uint8_t *)(void *)&rv;\n\td[0] = s[1];\n\td[1] = s[0];\n\treturn rv;\n}", "target": 0}
{"code": "static int print_branch_option(const char *refname, const struct object_id *oid,\n\t\t\t       int flags, void *cb_data)\n{\n\tchar *name = (char *)refname;\n\thtml_option(name, name, ctx.qry.head);\n\treturn 0;\n}", "target": 0}
{"code": "unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; \n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}", "target": 1}
{"code": "status_t MPEG4Extractor::parseAC3SpecificBox(\n off64_t offset, uint16_t sampleRate) {\n uint32_t size;\n const uint32_t kAC3SpecificBoxSize = 11;\n if (!mDataSource->getUInt32(offset, &size) || size < kAC3SpecificBoxSize) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 block: cannot read specific box size\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n uint32_t type;\n if (!mDataSource->getUInt32(offset, &type) || type != FOURCC('d', 'a', 'c', '3')) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: header not dac3\");\n return ERROR_MALFORMED;\n }\n    offset += 4;\n const uint32_t kAC3SpecificBoxPayloadSize = 3;\n uint8_t chunk[kAC3SpecificBoxPayloadSize];\n if (mDataSource->readAt(offset, chunk, sizeof(chunk)) != sizeof(chunk)) {\n        ALOGE(\"MPEG4Extractor: error while reading ac-3 specific block: bitstream fields\");\n return ERROR_MALFORMED;\n }\n ABitReader br(chunk, sizeof(chunk));\n static const unsigned channelCountTable[] = {2, 1, 2, 3, 3, 4, 4, 5};\n static const unsigned sampleRateTable[] = {48000, 44100, 32000};\n unsigned fscod = br.getBits(2);\n if (fscod == 3) {\n        ALOGE(\"Incorrect fscod (3) in AC3 header\");\n return ERROR_MALFORMED;\n }\n unsigned boxSampleRate = sampleRateTable[fscod];\n if (boxSampleRate != sampleRate) {\n        ALOGE(\"sample rate mismatch: boxSampleRate = %d, sampleRate = %d\",\n            boxSampleRate, sampleRate);\n return ERROR_MALFORMED;\n }\n unsigned bsid = br.getBits(5);\n if (bsid > 8) {\n        ALOGW(\"Incorrect bsid in AC3 header. Possibly E-AC-3?\");\n return ERROR_MALFORMED;\n }\n unsigned bsmod __unused = br.getBits(3);\n unsigned acmod = br.getBits(3);\n unsigned lfeon = br.getBits(1);\n unsigned channelCount = channelCountTable[acmod] + lfeon;\n if (mLastTrack == NULL) {\n return ERROR_MALFORMED;\n }\n    mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_AC3);\n    mLastTrack->meta->setInt32(kKeyChannelCount, channelCount);\n    mLastTrack->meta->setInt32(kKeySampleRate, sampleRate);\n return OK;\n}", "target": 0}
{"code": "static int check_is_mount_child(void *p)\n{\n\tconst char **a = p;\n\tconst char *last = a[0];\n\tconst char *mnt = a[1];\n\tint res;\n\tconst char *procmounts = \"/proc/mounts\";\n\tint found;\n\tFILE *fp;\n\tstruct mntent *entp;\n\tint count;\n\tres = mount(\"\", \"/\", \"\", MS_PRIVATE | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to mark mounts private: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tcount = 0;\n\twhile (getmntent(fp) != NULL)\n\t\tcount++;\n\tendmntent(fp);\n\tfp = setmntent(procmounts, \"r\");\n\tif (fp == NULL) {\n\t\tfprintf(stderr, \"%s: failed to open %s: %s\\n\", progname,\n\t\t\tprocmounts, strerror(errno));\n\t\treturn 1;\n\t}\n\tres = mount(\".\", \"/\", \"\", MS_BIND | MS_REC, NULL);\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to bind parent to /: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn 1;\n\t}\n\tfound = 0;\n\twhile ((entp = getmntent(fp)) != NULL) {\n\t\tif (count > 0) {\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (entp->mnt_dir[0] == '/' &&\n\t\t    strcmp(entp->mnt_dir + 1, last) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tendmntent(fp);\n\tif (!found) {\n\t\tfprintf(stderr, \"%s: %s not mounted\\n\", progname, mnt);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline u32 netlink_group_mask(u32 group)\n{\n\treturn group ? 1 << (group - 1) : 0;\n}", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "int phar_is_tar(char *buf, char *fname) \n{\n\ttar_header *header = (tar_header *) buf;\n\tphp_uint32 checksum = phar_tar_number(header->checksum, sizeof(header->checksum));\n\tphp_uint32 ret;\n\tchar save[sizeof(header->checksum)], *bname;\n\tif (!strncmp(buf, \"<?php\", sizeof(\"<?php\")-1)) {\n\t\treturn 0;\n\t}\n\tmemcpy(save, header->checksum, sizeof(header->checksum));\n\tmemset(header->checksum, ' ', sizeof(header->checksum));\n\tret = (checksum == phar_tar_checksum(buf, 512));\n\tmemcpy(header->checksum, save, sizeof(header->checksum));\n\tif ((bname = strrchr(fname, PHP_DIR_SEPARATOR))) {\n\t\tfname = bname;\n\t}\n\tif (!ret && (bname = strstr(fname, \".tar\")) && (bname[4] == '\\0' || bname[4] == '.')) {\n\t\treturn 1;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "private uint64_t\nfile_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)\n{\n\tflags = 0;", "target": 0}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "unsigned long __ref init_memory_mapping(unsigned long start,\n\t\t\t\t\t       unsigned long end)\n{\n\tstruct map_range mr[NR_RANGE_MR];\n\tunsigned long ret = 0;\n\tint nr_range, i;\n\tpr_debug(\"init_memory_mapping: [mem %#010lx-%#010lx]\\n\",\n\t       start, end - 1);\n\tmemset(mr, 0, sizeof(mr));\n\tnr_range = split_mem_range(mr, 0, start, end);\n\tfor (i = 0; i < nr_range; i++)\n\t\tret = kernel_physical_mapping_init(mr[i].start, mr[i].end,\n\t\t\t\t\t\t   mr[i].page_size_mask);\n\tadd_pfn_range_mapped(start >> PAGE_SHIFT, ret >> PAGE_SHIFT);\n\treturn ret >> PAGE_SHIFT;\n}", "target": 0}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "empty_param_read(iparam_list * plist, const ref * pkey, iparam_loc * ploc)\n{\n    return 1;\n}", "target": 0}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn)\n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "static int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\tstruct cma_work *work;\n\tdev_addr = &id_priv->id.route.addr.dev_addr;\n\tif ((dev_addr->bound_dev_if == ndev->ifindex) &&\n\t    (net_eq(dev_net(ndev), dev_addr->net)) &&\n\t    memcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\n\t\tpr_info(\"RDMA CM addr change for ndev %s used by id %p\\n\",\n\t\t\tndev->name, &id_priv->id);\n\t\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, cma_work_handler);\n\t\twork->id = id_priv;\n\t\twork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\n\t\tcma_id_get(id_priv);\n\t\tqueue_work(cma_wq, &work->work);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "Status FunctionLibraryDefinition::AddGradientDef(const GradientDef& grad) {\n  mutex_lock l(mu_);\n  bool added;\n  return AddGradientDefHelper(grad, &added);\n}", "target": 0}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "linux_md_remove_component_device_not_seen_cb (gpointer user_data)\n{\n  RemoveComponentData *data = user_data;\n  throw_error (data->context,\n               ERROR_FAILED,\n               \"Error removing component: timeout (10s) waiting for slave to stop being busy\");\n  g_signal_handler_disconnect (data->slave->priv->daemon, data->device_changed_signal_handler_id);\n  remove_component_data_unref (data);\n  return FALSE;\n}", "target": 0}
{"code": "Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {\n  if (find_local_field(name, sig, fd)) {\n    if (fd->is_static() == is_static) return const_cast<InstanceKlass*>(this);\n  }\n  if (is_static) {\n    Klass* intf = find_interface_field(name, sig, fd);\n    if (intf != NULL) return intf;\n  }\n  { Klass* supr = super();\n    if (supr != NULL) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n  }\n  return NULL;\n}", "target": 0}
{"code": "pa2l(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = L(&palette[in[0] * 4]) / 1000;\n    }\n}", "target": 0}
{"code": "format_versions_list(config_line_t *ln)\n{\n  smartlist_t *versions;\n  char *result;\n  versions = smartlist_new();\n  for ( ; ln; ln = ln->next) {\n    smartlist_split_string(versions, ln->value, \",\",\n                           SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);\n  }\n  sort_version_list(versions, 1);\n  result = smartlist_join_strings(versions,\",\",0,NULL);\n  SMARTLIST_FOREACH(versions,char *,s,tor_free(s));\n  smartlist_free(versions);\n  return result;\n}", "target": 0}
{"code": "SPL_METHOD(SplDoublyLinkedList, unserialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *flags, *elem;\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (buf_len == 0) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");\n\t\treturn;\n\t}\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(flags);\n\tif (!php_var_unserialize(&flags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG) {\n\t\tzval_ptr_dtor(&flags);\n\t\tgoto error;\n\t}\n\tintern->flags = Z_LVAL_P(flags);\n\tzval_ptr_dtor(&flags);\n\twhile(*p == ':') {\n\t\t++p;\n\t\tALLOC_INIT_ZVAL(elem);\n\t\tif (!php_var_unserialize(&elem, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tzval_ptr_dtor(&elem);\n\t\t\tgoto error;\n\t\t}\n\t\tspl_ptr_llist_push(intern->llist, elem TSRMLS_CC);\n\t}\n\tif (*p != '\\0') {\n\t\tgoto error;\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\nerror:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n} ", "target": 1}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}", "target": 0}
{"code": "static void disk_del_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\tdisk_block_events(disk);\n\tmutex_lock(&disk_events_mutex);\n\tlist_del_init(&disk->ev->node);\n\tmutex_unlock(&disk_events_mutex);\n\tsysfs_remove_files(&disk_to_dev(disk)->kobj, disk_events_attrs);\n}", "target": 0}
{"code": "char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n{\n\tsize_t end, nb = 0, i, f_begin, f_end;\n\twhile (nb < size && data[nb] == '`')\n\t\tnb++;\n\ti = 0;\n\tfor (end = nb; end < size && i < nb; end++) {\n\t\tif (data[end] == '`') i++;\n\t\telse i = 0;\n\t}\n\tif (i < nb && end >= size)\n\t\treturn 0; \n\tf_begin = nb;\n\twhile (f_begin < end && data[f_begin] == ' ')\n\t\tf_begin++;\n\tf_end = end - nb;\n\twhile (f_end > nb && data[f_end-1] == ' ')\n\t\tf_end--;\n\tif (f_begin < f_end) {\n\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n\t\t\tend = 0;\n\t} else {\n\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n\t\t\tend = 0;\n\t}\n\treturn end;\n}", "target": 0}
{"code": "static inline void ok_png_premultiply(uint8_t *dst) {\n    const uint8_t a = dst[3];\n    if (a == 0) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    } else if (a < 255) {\n        dst[0] = (a * dst[0] + 127) / 255;\n        dst[1] = (a * dst[1] + 127) / 255;\n        dst[2] = (a * dst[2] + 127) / 255;\n    }\n}", "target": 0}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "static int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int *uaddr_len, int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\treturn -ENOBUFS;\n\t*uaddr_len = sizeof(struct sockaddr_at);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\treturn 0;\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 0}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "JANET_CORE_FN(cfun_array_new_filled,\n              \"(array/new-filled count &opt value)\",\n              \"Creates a new array of `count` elements, all set to `value`, which defaults to nil. Returns the new array.\") {\n    janet_arity(argc, 1, 2);\n    int32_t count = janet_getinteger(argv, 0);\n    if (count < 0) janet_panic(\"expected positive integer\");\n    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();\n    JanetArray *array = janet_array(count);\n    for (int32_t i = 0; i < count; i++) {\n        array->data[i] = x;\n    }\n    array->count = count;\n    return janet_wrap_array(array);\n}", "target": 0}
{"code": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n        bool bASCII = false;\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }", "target": 1}
{"code": "bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,\n                                uint8_t pin_len, bt_pin_code_t *pin_code)\n {\n     BTIF_TRACE_EVENT(\"%s: accept=%d\", __FUNCTION__, accept);\n    if (pin_code == NULL)\n         return BT_STATUS_FAIL;\n #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\n if (pairing_cb.is_le_only)\n {\n int i;\n        UINT32 passkey = 0;\n int multi[] = {100000, 10000, 1000, 100, 10,1};\n        BD_ADDR remote_bd_addr;\n        bdcpy(remote_bd_addr, bd_addr->address);\n for (i = 0; i < 6; i++)\n {\n            passkey += (multi[i] * (pin_code->pin[i] - '0'));\n }\n        BTIF_TRACE_DEBUG(\"btif_dm_pin_reply: passkey: %d\", passkey);\n        BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);\n }\n else\n {\n        BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n            pairing_cb.pin_code_len = pin_len;\n }\n#else\n    BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n        pairing_cb.pin_code_len = pin_len;\n#endif\n return BT_STATUS_SUCCESS;\n}", "target": 1}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static int mxf_read_sync(AVIOContext *pb, const uint8_t *key, unsigned size)\n{\n    int i, b;\n    for (i = 0; i < size && !avio_feof(pb); i++) {\n        b = avio_r8(pb);\n        if (b == key[0])\n            i = 0;\n        else if (b != key[i])\n            i = -1;\n    }\n    return i == size;\n}", "target": 0}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n    ptr = buf;\n    chunk = 3 * state->xsize;\n    for (;;) {\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\tptr += chunk;\n\tbytes -= chunk;\n    }\n}", "target": 1}
{"code": "static void madvise_cold_page_range(struct mmu_gather *tlb,\n\t\t\t     struct vm_area_struct *vma,\n\t\t\t     unsigned long addr, unsigned long end)\n{\n\tstruct madvise_walk_private walk_private = {\n\t\t.pageout = false,\n\t\t.tlb = tlb,\n\t};\n\ttlb_start_vma(tlb, vma);\n\twalk_page_range(vma->vm_mm, addr, end, &cold_walk_ops, &walk_private);\n\ttlb_end_vma(tlb, vma);\n}", "target": 0}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,\n  const double pad)\n{\n  double\n    extent;\n  size_t\n    quantum;\n  quantum=sizeof(**mvg_info->primitive_info);\n  extent=(double) mvg_info->offset+pad+PrimitiveExtentPad*quantum+1.0;\n  if (extent <= (double) *mvg_info->extent)\n    return(MagickTrue);\n  if (extent == (double) CastDoubleToLong(extent))\n    {\n      *mvg_info->primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(\n        *mvg_info->primitive_info,(size_t) extent,quantum);\n      if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n        {\n          ssize_t\n            i;\n          *mvg_info->extent=(size_t) extent;\n          for (i=mvg_info->offset+1; i < (ssize_t) extent; i++)\n            (*mvg_info->primitive_info)[i].primitive=UndefinedPrimitive;\n          return(MagickTrue);\n        }\n    }\n  if (*mvg_info->primitive_info != (PrimitiveInfo *) NULL)\n    *mvg_info->primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(\n      *mvg_info->primitive_info);\n  (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n  *mvg_info->primitive_info=(PrimitiveInfo *)  AcquireCriticalMemory(\n    (size_t) (PrimitiveExtentPad*quantum));\n  (void) memset(*mvg_info->primitive_info,0,(size_t)\n    (PrimitiveExtentPad*quantum));\n  *mvg_info->extent=1;\n  return(MagickFalse);\n}", "target": 0}
{"code": "bool Item_param::set_from_user_var(THD *thd, const user_var_entry *entry)\n{\n  DBUG_ENTER(\"Item_param::set_from_user_var\");\n  if (entry && entry->value)\n  {\n    item_result_type= entry->type;\n    unsigned_flag= entry->unsigned_flag;\n    if (limit_clause_param)\n    {\n      bool unused;\n      set_int(entry->val_int(&unused), MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      DBUG_RETURN(!unsigned_flag && value.integer < 0 ? 1 : 0);\n    }\n    switch (item_result_type) {\n    case REAL_RESULT:\n      set_double(*(double*)entry->value);\n      item_type= Item::REAL_ITEM;\n      param_type= MYSQL_TYPE_DOUBLE;\n      break;\n    case INT_RESULT:\n      set_int(*(longlong*)entry->value, MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      param_type= MYSQL_TYPE_LONGLONG;\n      break;\n    case STRING_RESULT:\n    {\n      CHARSET_INFO *fromcs= entry->collation.collation;\n      CHARSET_INFO *tocs= thd->variables.collation_connection;\n      uint32 dummy_offset;\n      value.cs_info.character_set_of_placeholder= fromcs;\n      value.cs_info.character_set_client= thd->variables.character_set_client;\n      value.cs_info.final_character_set_of_str_value=\n        String::needs_conversion(0, fromcs, tocs, &dummy_offset) ?\n        tocs : fromcs;\n      item_type= Item::STRING_ITEM;\n      param_type= MYSQL_TYPE_VARCHAR;\n      if (set_str((const char *)entry->value, entry->length))\n        DBUG_RETURN(1);\n      break;\n    }\n    case DECIMAL_RESULT:\n    {\n      const my_decimal *ent_value= (const my_decimal *)entry->value;\n      my_decimal2decimal(ent_value, &decimal_value);\n      state= DECIMAL_VALUE;\n      decimals= ent_value->frac;\n      max_length=\n        my_decimal_precision_to_length_no_truncation(ent_value->precision(),\n                                                     decimals, unsigned_flag);\n      item_type= Item::DECIMAL_ITEM;\n      param_type= MYSQL_TYPE_NEWDECIMAL;\n      break;\n    }\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n      set_null();\n    }\n  }\n  else\n    set_null();\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\tsc = vsc;\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\t\tassert(len > 0);\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t\n}", "target": 1}
{"code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "void SyncManager::SyncInternal::OnIPAddressChanged() {\n  DVLOG(1) << \"IP address change detected\";\n  if (!observing_ip_address_changes_) {\n    DVLOG(1) << \"IP address change dropped.\";\n     return;\n   }\n#if defined (OS_CHROMEOS)\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&SyncInternal::OnIPAddressChangedImpl,\n                 weak_ptr_factory_.GetWeakPtr()),\n      kChromeOSNetworkChangeReactionDelayHackMsec);\n#else\n   OnIPAddressChangedImpl();\n#endif  \n }", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "static noinline void __schedule_bug(struct task_struct *prev)\n{\n\tif (oops_in_progress)\n\t\treturn;\n\tprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->comm, prev->pid, preempt_count());\n\tdebug_show_held_locks(prev);\n\tprint_modules();\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(prev);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (in_atomic_preempt_off()) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n\tadd_taint(TAINT_WARN, LOCKDEP_STILL_OK);\n}", "target": 0}
{"code": "static int decode_attr_security_label(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t\tstruct nfs4_label *label)\n{\n\tuint32_t pi = 0;\n\tuint32_t lfs = 0;\n\t__u32 len;\n\t__be32 *p;\n\tint status = 0;\n\tif (unlikely(bitmap[2] & (FATTR4_WORD2_SECURITY_LABEL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[2] & FATTR4_WORD2_SECURITY_LABEL)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlfs = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tpi = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tlen = be32_to_cpup(p++);\n\t\tp = xdr_inline_decode(xdr, len);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\tif (len < NFS4_MAXLABELLEN) {\n\t\t\tif (label) {\n\t\t\t\tmemcpy(label->label, p, len);\n\t\t\t\tlabel->len = len;\n\t\t\t\tlabel->pi = pi;\n\t\t\t\tlabel->lfs = lfs;\n\t\t\t\tstatus = NFS_ATTR_FATTR_V4_SECURITY_LABEL;\n\t\t\t}\n\t\t\tbitmap[2] &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"%s: label too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t}\n\tif (label && label->label)\n\t\tdprintk(\"%s: label=%s, len=%d, PI=%d, LFS=%d\\n\", __func__,\n\t\t\t(char *)label->label, label->len, label->pi, label->lfs);\n\treturn status;\n}", "target": 1}
{"code": "smp_fetch_url_port(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                   const struct arg *args, struct sample *smp)\n{\n\tstruct http_txn *txn = l7;\n\tCHECK_HTTP_MESSAGE_FIRST();\n\turl2sa(txn->req.chn->buf->p + txn->req.sl.rq.u, txn->req.sl.rq.u_l, &l4->req->cons->conn->addr.to);\n\tsmp->type = SMP_T_UINT;\n\tsmp->data.uint = ntohs(((struct sockaddr_in *)&l4->req->cons->conn->addr.to)->sin_port);\n\tif (px->options & PR_O_HTTP_PROXY)\n\t\tl4->flags |= SN_ADDR_SET;\n\tsmp->flags = 0;\n\treturn 1;\n}", "target": 0}
{"code": "static void do_busid_cmd(ESPState *s, uint8_t busid)\n{\n    uint32_t cmdlen;\n    int32_t datalen;\n    int lun;\n    SCSIDevice *current_lun;\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    trace_esp_do_busid_cmd(busid);\n    lun = busid & 7;\n    cmdlen = fifo8_num_used(&s->cmdfifo);\n    esp_fifo_pop_buf(&s->cmdfifo, buf, cmdlen);\n    current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);\n    s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);\n    datalen = scsi_req_enqueue(s->current_req);\n    s->ti_size = datalen;\n    fifo8_reset(&s->cmdfifo);\n    if (datalen != 0) {\n        s->rregs[ESP_RSTAT] = STAT_TC;\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n        s->ti_cmd = 0;\n        esp_set_tc(s, 0);\n        if (datalen > 0) {\n            s->data_in_ready = false;\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n        } else {\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            esp_raise_irq(s);\n            esp_lower_drq(s);\n        }\n        scsi_req_continue(s->current_req);\n        return;\n    }\n}", "target": 1}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "static void WritePackbitsLength(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  unsigned char *compact_pixels,const QuantumType quantum_type,\n  ExceptionInfo *exception)\n{\n  QuantumInfo\n    *quantum_info;\n  register const Quantum\n    *p;\n  size_t\n    length,\n    packet_size;\n  ssize_t\n    y;\n  unsigned char\n    *pixels;\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n      exception);\n    (void) SetPSDOffset(psd_info,image,length);\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}", "target": 0}
{"code": "int git_delta_read_header_fromstream(\n\tsize_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\t\tif (read == 0)\n\t\t\tbreak;\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\t\tlen += read;\n\t}\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t\t(hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}", "target": 0}
{"code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static AgentMsgFilterResult vdi_port_read_buf_process(RedCharDeviceVDIPort *dev,\n                                                      RedVDIReadBuf& buf)\n{\n    switch (dev->priv->vdi_chunk_header.port) {\n    case VDP_CLIENT_PORT:\n        return agent_msg_filter_process_data(&dev->priv->read_filter, buf.data, buf.len);\n    case VDP_SERVER_PORT:\n        return AGENT_MSG_FILTER_DISCARD;\n    default:\n        spice_warning(\"invalid port\");\n        return AGENT_MSG_FILTER_PROTO_ERROR;\n    }\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "void LibRaw::layer_thumb(){}", "target": 0}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "struct file *file_open_name(struct filename *name, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\treturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "ConnStateData::checkLogging()\n{\n    if (bodyPipe)\n        return;\n    if (!pipeline.empty() && pipeline.back()->mayUseConnection())\n        return;\n    if (pipeline.nrequests && inBuf.isEmpty())\n        return;\n    ClientHttpRequest http(this);\n    http.req_sz = inBuf.length();\n    http.setErrorUri(\"error:transaction-end-before-headers\");\n}", "target": 0}
{"code": "static void sigchld_reaper(void) {\n\tWAIT_T waiter;\n\tPID_T pid;\n\tdo {\n\t\tpid = waitpid(-1, &waiter, WNOHANG);\n\t\tswitch (pid) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no children\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tcase 0:\n\t\t\tDebug(DPROC, (\"[%ld] sigchld...no dead kids\\n\", (long) getpid()))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tDebug(DPROC,\n\t\t\t\t(\"[%ld] sigchld...pid #%ld died, stat=%d\\n\",\n\t\t\t\t\t(long) getpid(), (long) pid, WEXITSTATUS(waiter)))\n\t\t\t\tbreak;\n\t\t}\n\t} while (pid > 0);\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}", "target": 0}
{"code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    ss->cs = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "vg_resource_attach_backing(VuGpu *g,\n                           struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n    VUGPU_FILL_CMD(ab);\n    virtio_gpu_bswap_32(&ab, sizeof(ab));\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        g_critical(\"%s: illegal resource specified %d\",\n                   __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n    if (res->iov) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n    res->iov_cnt = ab.nr_entries;\n}", "target": 0}
{"code": "init_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "virNodeDeviceGetMdevTypesCaps(const char *sysfspath,\n                              virMediatedDeviceTypePtr **mdev_types,\n                              size_t *nmdev_types)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n    for (i = 0; i < *nmdev_types; i++)\n       virMediatedDeviceTypeFree(*mdev_types[i]);\n    VIR_FREE(*mdev_types);\n    *nmdev_types = 0;\n    if (virMediatedDeviceGetMdevTypes(sysfspath, &types, &ntypes) < 0)\n        return -1;\n    *mdev_types = g_steal_pointer(&types);\n    *nmdev_types = ntypes;\n    return 0;\n}", "target": 1}
{"code": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\trq->prev_mm = NULL;\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_lock_switch(rq, prev);\n\tfinish_arch_post_lock_switch();\n\tfire_sched_in_preempt_notifiers(current);\n\tif (mm)\n\t\tmmdrop(mm);\n\tif (unlikely(prev_state == TASK_DEAD)) {\n\t\tif (prev->sched_class->task_dead)\n\t\t\tprev->sched_class->task_dead(prev);\n\t\tkprobe_flush_task(prev);\n\t\tput_task_struct(prev);\n\t}\n\ttick_nohz_task_switch();\n\treturn rq;\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": " void LayerWebKitThread::setNeedsCommit()\n {\n     if (m_owner)\n        m_owner->notifySyncRequired();\n }", "target": 1}
{"code": "static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n{\n\tstruct resv_map *resv = vma_resv_map(vma);\n\tif (resv && is_vma_resv_set(vma, HPAGE_RESV_OWNER)) {\n\t\tresv_map_dup_hugetlb_cgroup_uncharge_info(resv);\n\t\tkref_get(&resv->refs);\n\t}\n}", "target": 0}
{"code": "int unit_name_to_prefix(const char *n, char **ret) {\n        const char *p;\n        char *s;\n        assert(n);\n        assert(ret);\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n        p = strchr(n, '@');\n        if (!p)\n                p = strrchr(n, '.');\n        assert_se(p);\n        s = strndup(n, p - n);\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 0}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnGpuSwapBuffersCompletedInternal(\n    const ui::LatencyInfo& latency_info) {\n  ui::LatencyInfo::LatencyComponent window_snapshot_component;\n  if (latency_info.FindLatency(ui::BROWSER_SNAPSHOT_FRAME_NUMBER_COMPONENT,\n                               GetLatencyComponentId(),\n                               &window_snapshot_component)) {\n    int sequence_number =\n        static_cast<int>(window_snapshot_component.sequence_number);\n#if defined(OS_MACOSX) || defined(OS_WIN)\n    base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n        FROM_HERE,\n        base::Bind(&RenderWidgetHostImpl::WindowSnapshotReachedScreen,\n                   weak_factory_.GetWeakPtr(), sequence_number),\n        base::TimeDelta::FromSecondsD(1. / 6));\n#else\n    WindowSnapshotReachedScreen(sequence_number);\n#endif\n  }\n  latency_tracker_.OnGpuSwapBuffersCompleted(latency_info);\n}", "target": 0}
{"code": "compat_sys_writev(unsigned long fd, const struct compat_iovec __user *vec, unsigned long vlen)\n{\n\tstruct file *file;\n\tssize_t ret = -EBADF;\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (!file->f_op || (!file->f_op->aio_write && !file->f_op->write))\n\t\tgoto out;\n\tret = compat_do_readv_writev(WRITE, file, vec, vlen, &file->f_pos);\nout:\n\tfput(file);\n\treturn ret;\n}", "target": 0}
{"code": "int git_treebuilder_create(git_treebuilder **builder_p, const git_tree *source)\n{\n\tgit_treebuilder *bld;\n\tsize_t i, source_entries = DEFAULT_TREE_SIZE;\n\tassert(builder_p);\n\tbld = git__calloc(1, sizeof(git_treebuilder));\n\tGITERR_CHECK_ALLOC(bld);\n\tif (source != NULL)\n\t\tsource_entries = source->entries.length;\n\tif (git_vector_init(&bld->entries, source_entries, entry_sort_cmp) < 0)\n\t\tgoto on_error;\n\tif (source != NULL) {\n\t\tgit_tree_entry *entry_src;\n\t\tgit_vector_foreach(&source->entries, i, entry_src) {\n\t\t\tif (append_entry(\n\t\t\t\tbld, entry_src->filename,\n\t\t\t\t&entry_src->oid,\n\t\t\t\tentry_src->attr) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\t*builder_p = bld;\n\treturn 0;\non_error:\n\tgit_treebuilder_free(bld);\n\treturn -1;\n}", "target": 0}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static void dump_thread32(struct pt_regs * regs, struct user32 * dump)\n{\n\tu32 fs,gs;\n\tdump->magic = CMAGIC;\n\tdump->start_code = 0;\n\tdump->start_stack = regs->rsp & ~(PAGE_SIZE - 1);\n\tdump->u_tsize = ((unsigned long) current->mm->end_code) >> PAGE_SHIFT;\n\tdump->u_dsize = ((unsigned long) (current->mm->brk + (PAGE_SIZE-1))) >> PAGE_SHIFT;\n\tdump->u_dsize -= dump->u_tsize;\n\tdump->u_ssize = 0;\n\tdump->u_debugreg[0] = current->thread.debugreg0;  \n\tdump->u_debugreg[1] = current->thread.debugreg1;  \n\tdump->u_debugreg[2] = current->thread.debugreg2;  \n\tdump->u_debugreg[3] = current->thread.debugreg3;  \n\tdump->u_debugreg[4] = 0;  \n\tdump->u_debugreg[5] = 0;  \n\tdump->u_debugreg[6] = current->thread.debugreg6;  \n\tdump->u_debugreg[7] = current->thread.debugreg7;  \n\tif (dump->start_stack < 0xc0000000)\n\t\tdump->u_ssize = ((unsigned long) (0xc0000000 - dump->start_stack)) >> PAGE_SHIFT;\n\tdump->regs.ebx = regs->rbx;\n\tdump->regs.ecx = regs->rcx;\n\tdump->regs.edx = regs->rdx;\n\tdump->regs.esi = regs->rsi;\n\tdump->regs.edi = regs->rdi;\n\tdump->regs.ebp = regs->rbp;\n\tdump->regs.eax = regs->rax;\n\tdump->regs.ds = current->thread.ds;\n\tdump->regs.es = current->thread.es;\n\tasm(\"movl %%fs,%0\" : \"=r\" (fs)); dump->regs.fs = fs;\n\tasm(\"movl %%gs,%0\" : \"=r\" (gs)); dump->regs.gs = gs; \n\tdump->regs.orig_eax = regs->orig_rax;\n\tdump->regs.eip = regs->rip;\n\tdump->regs.cs = regs->cs;\n\tdump->regs.eflags = regs->eflags;\n\tdump->regs.esp = regs->rsp;\n\tdump->regs.ss = regs->ss;\n#if 1 \n\tdump->u_fpvalid = 0;\n#else\n\tdump->u_fpvalid = dump_fpu (regs, &dump->i387);\n#endif\n}", "target": 0}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": " NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(\n     BrowserFrame* browser_frame,\n     BrowserView* browser_view) {\n  if (views::Widget::IsPureViews())\n     return new BrowserFrameViews(browser_frame, browser_view);\n   return new BrowserFrameGtk(browser_frame, browser_view);\n }", "target": 1}
{"code": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": "FILE *mingw_freopen (const char *filename, const char *otype, FILE *stream)\n{\n\tint hide = needs_hiding(filename);\n\tFILE *file;\n\twchar_t wfilename[MAX_PATH], wotype[4];\n\tif (filename && !strcmp(filename, \"/dev/null\"))\n\t\tfilename = \"nul\";\n\tif (xutftowcs_path(wfilename, filename) < 0 ||\n\t\txutftowcs(wotype, otype, ARRAY_SIZE(wotype)) < 0)\n\t\treturn NULL;\n\tif (hide && !access(filename, F_OK) && set_hidden_flag(wfilename, 0)) {\n\t\terror(\"could not unhide %s\", filename);\n\t\treturn NULL;\n\t}\n\tfile = _wfreopen(wfilename, wotype, stream);\n\tif (file && hide && set_hidden_flag(wfilename, 1))\n\t\twarning(\"could not mark '%s' as hidden.\", filename);\n\treturn file;\n}", "target": 0}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Char *str; \n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  XML_Content *dest = ret; \n  XML_Content *const destLimit = &ret[dtd->scaffCount];\n  XML_Content *const stackBottom = &ret[dtd->scaffCount];\n  XML_Content *stackTop = stackBottom; \n  str = (XML_Char *)&ret[dtd->scaffCount];\n  (--stackTop)->numchildren = 0;\n  for (; dest < destLimit; dest++) {\n    const int src_node = (int)(stackTop++)->numchildren;\n    dest->type = dtd->scaffold[src_node].type;\n    dest->quant = dtd->scaffold[src_node].quant;\n    if (dest->type == XML_CTYPE_NAME) {\n      const XML_Char *src;\n      dest->name = str;\n      src = dtd->scaffold[src_node].name;\n      for (;;) {\n        *str++ = *src;\n        if (! *src)\n          break;\n        src++;\n      }\n      dest->numchildren = 0;\n      dest->children = NULL;\n    } else {\n      unsigned int i;\n      int cn;\n      dest->name = NULL;\n      dest->numchildren = dtd->scaffold[src_node].childcnt;\n      dest->children = &dest[1];\n      stackTop -= dest->numchildren;\n      for (i = 0, cn = dtd->scaffold[src_node].firstchild;\n           i < dest->numchildren; i++, cn = dtd->scaffold[cn].nextsib) {\n        (stackTop + i)->numchildren = (unsigned int)cn;\n      }\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "ExecuteSoapAction(struct upnphttp * h, const char * action, int n)\n{\n\tchar * p;\n\tchar * p2;\n\tint i, len, methodlen;\n\tchar namespace[256];\n\tp = strchr(action, '#');\n\tif(p && (p - action) < n) {\n\t\tfor(i = 0; i < ((int)sizeof(namespace) - 1) && (action + i) < p; i++)\n\t\t\tnamespace[i] = action[i];\n\t\tnamespace[i] = '\\0';\n\t\tp++;\n\t\tp2 = strchr(p, '\"');\n\t\tif(p2 && (p2 - action) <= n)\n\t\t\tmethodlen = p2 - p;\n\t\telse\n\t\t\tmethodlen = n - (p - action);\n\t\tfor(i = 0; soapMethods[i].methodName; i++) {\n\t\t\tlen = strlen(soapMethods[i].methodName);\n\t\t\tif((len == methodlen) && memcmp(p, soapMethods[i].methodName, len) == 0) {\n#ifdef DEBUG\n\t\t\t\tsyslog(LOG_DEBUG, \"Remote Call of SoapMethod '%s' %s\",\n\t\t\t\t       soapMethods[i].methodName, namespace);\n#endif \n\t\t\t\tsoapMethods[i].methodImpl(h, soapMethods[i].methodName, namespace);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tsyslog(LOG_NOTICE, \"SoapMethod: Unknown: %.*s %s\", methodlen, p, namespace);\n\t} else {\n\t\tsyslog(LOG_NOTICE, \"cannot parse SoapAction\");\n\t}\n\tSoapError(h, 401, \"Invalid Action\");\n}", "target": 0}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}", "target": 1}
{"code": "static void early_init_amd(struct cpuinfo_x86 *c)\n{\n\tearly_init_amd_mc(c);\n\tif (c->x86_power & (1 << 8)) {\n\t\tset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\n\t\tset_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);\n\t\tif (!check_tsc_unstable())\n\t\t\tsched_clock_stable = 1;\n\t}\n#ifdef CONFIG_X86_64\n\tset_cpu_cap(c, X86_FEATURE_SYSCALL32);\n#else\n\tif (c->x86 == 5)\n\t\tif (c->x86_model == 13 || c->x86_model == 9 ||\n\t\t    (c->x86_model == 8 && c->x86_mask >= 8))\n\t\t\tset_cpu_cap(c, X86_FEATURE_K6_MTRR);\n#endif\n#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_PCI)\n\tif (cpu_has_apic && c->x86 >= 0xf) {\n\t\tunsigned int val;\n\t\tval = read_pci_config(0, 24, 0, 0x68);\n\t\tif ((val & ((1 << 17) | (1 << 18))) == ((1 << 17) | (1 << 18)))\n\t\t\tset_cpu_cap(c, X86_FEATURE_EXTD_APICID);\n\t}\n#endif\n}", "target": 1}
{"code": "int js_tointeger(js_State *J, int idx)\n{\n\treturn jsV_numbertointeger(jsV_tonumber(J, stackidx(J, idx)));\n}", "target": 0}
{"code": "rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)\n{\n\tstruct list_head *tail_page, *to_remove, *next_page;\n\tstruct buffer_page *to_remove_page, *tmp_iter_page;\n\tstruct buffer_page *last_page, *first_page;\n\tunsigned long nr_removed;\n\tunsigned long head_bit;\n\tint page_entries;\n\thead_bit = 0;\n\traw_spin_lock_irq(&cpu_buffer->reader_lock);\n\tatomic_inc(&cpu_buffer->record_disabled);\n\ttail_page = &cpu_buffer->tail_page->list;\n\tif (cpu_buffer->tail_page == cpu_buffer->reader_page)\n\t\ttail_page = rb_list_head(tail_page->next);\n\tto_remove = tail_page;\n\tfirst_page = list_entry(rb_list_head(to_remove->next),\n\t\t\t\tstruct buffer_page, list);\n\tfor (nr_removed = 0; nr_removed < nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->next;\n\t\thead_bit |= (unsigned long)to_remove & RB_PAGE_HEAD;\n\t}\n\tnext_page = rb_list_head(to_remove)->next;\n\ttail_page->next = (struct list_head *)((unsigned long)next_page |\n\t\t\t\t\t\thead_bit);\n\tnext_page = rb_list_head(next_page);\n\tnext_page->prev = tail_page;\n\tcpu_buffer->pages = next_page;\n\tif (head_bit)\n\t\tcpu_buffer->head_page = list_entry(next_page,\n\t\t\t\t\t\tstruct buffer_page, list);\n\tcpu_buffer->read = 0;\n\tatomic_dec(&cpu_buffer->record_disabled);\n\traw_spin_unlock_irq(&cpu_buffer->reader_lock);\n\tRB_WARN_ON(cpu_buffer, list_empty(cpu_buffer->pages));\n\tlast_page = list_entry(rb_list_head(to_remove), struct buffer_page,\n\t\t\t\tlist);\n\ttmp_iter_page = first_page;\n\tdo {\n\t\tto_remove_page = tmp_iter_page;\n\t\trb_inc_page(cpu_buffer, &tmp_iter_page);\n\t\tpage_entries = rb_page_entries(to_remove_page);\n\t\tif (page_entries) {\n\t\t\tlocal_add(page_entries, &cpu_buffer->overrun);\n\t\t\tlocal_sub(BUF_PAGE_SIZE, &cpu_buffer->entries_bytes);\n\t\t}\n\t\tfree_buffer_page(to_remove_page);\n\t\tnr_removed--;\n\t} while (to_remove_page != last_page);\n\tRB_WARN_ON(cpu_buffer, nr_removed);\n\treturn nr_removed == 0;\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,\n\tconst unsigned char *srcBuf, int width, int pitch, int height,\n\tint pixelFormat, unsigned char *dstBuf, int pad, int subsamp, int flags)\n{\n\tunsigned char *dstPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\tif(width<=0 || height<=0 || dstBuf==NULL || pad<0 || !isPow2(pad)\n\t\t|| subsamp<0 || subsamp>=NUMSUBOPT)\n\t\t_throw(\"tjEncodeYUV3(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tdstPlanes[0]=dstBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tdstPlanes[1]=dstPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tdstPlanes[1]=dstPlanes[0]+strides[0]*ph0;\n\t\tdstPlanes[2]=dstPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjEncodeYUVPlanes(handle, srcBuf, width, pitch, height, pixelFormat,\n\t\tdstPlanes, strides, subsamp, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\tcase NOSY_IOC_START:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "cd_device_db_set_property (CdDeviceDb *ddb,\n\t\t\t   const gchar *device_id,\n\t\t\t   const gchar *property,\n\t\t\t   const gchar *value,\n\t\t\t   GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tgboolean ret = TRUE;\n\tgchar *error_msg = NULL;\n\tgchar *statement;\n\tgint rc;\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db != NULL, FALSE);\n\tg_debug (\"CdDeviceDb: add device property %s [%s=%s]\",\n\t\t device_id, property, value);\n\tstatement = sqlite3_mprintf (\"INSERT OR REPLACE INTO properties_v2 (device_id, property, value) \"\n\t\t\t\t     \"VALUES ('%q', '%q', '%q');\",\n\t\t\t\t     device_id, property, value);\n\trc = sqlite3_exec (priv->db, statement, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\nout:\n\tsqlite3_free (statement);\n\treturn ret;\n}", "target": 0}
{"code": "lexer_scan_identifier (parser_context_t *context_p, \n                       bool propety_name) \n{\n  skip_spaces (context_p);\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  if (context_p->source_p < context_p->source_end_p\n      && (lit_char_is_identifier_start (context_p->source_p) || context_p->source_p[0] == LIT_CHAR_BACKSLASH))\n  {\n    lexer_parse_identifier (context_p, false);\n    if (propety_name && context_p->token.lit_location.length == 3)\n    {\n      skip_spaces (context_p);\n      if (context_p->source_p < context_p->source_end_p\n          && context_p->source_p[0] != LIT_CHAR_COLON)\n      {\n        if (lexer_compare_identifier_to_current (context_p, &lexer_get_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_GETTER;\n        }\n        else if (lexer_compare_identifier_to_current (context_p, &lexer_set_literal))\n        {\n          context_p->token.type = LEXER_PROPERTY_SETTER;\n        }\n      }\n    }\n    return;\n  }\n  if (propety_name)\n  {\n    lexer_next_token (context_p);\n    if (context_p->token.type == LEXER_LITERAL\n        || context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      return;\n    }\n  }\n  parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n} ", "target": 0}
{"code": "static int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);\n\tunsigned long vsize = vma->vm_end - vma->vm_start;\n\tpgprot_t prot = vma->vm_page_prot;\n\tif (vma->vm_pgoff + vma_pages(vma) > lpc_ctrl->mem_size >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tprot = pgprot_noncached(prot);\n\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,\n\t\tvsize, prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  Address pending_message_obj_address() {\n    return reinterpret_cast<Address>(&thread_local_top_.pending_message_obj_);\n  }", "target": 0}
{"code": "ospf_ls_req_send (struct ospf_neighbor *nbr)\n{\n  struct ospf_interface *oi;\n  struct ospf_packet *op;\n  u_int16_t length = OSPF_HEADER_SIZE;\n  oi = nbr->oi;\n  op = ospf_packet_new (oi->ifp->mtu);\n  ospf_make_header (OSPF_MSG_LS_REQ, oi, op->s);\n  length += ospf_make_ls_req (nbr, op->s);\n  if (length == OSPF_HEADER_SIZE)\n    {\n      ospf_packet_free (op);\n      return;\n    }\n  ospf_fill_header (oi, op->s, length);\n  op->length = length;\n  if (oi->type == OSPF_IFTYPE_POINTOPOINT) \n    op->dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    op->dst = nbr->address.u.prefix4;\n  ospf_packet_add (oi, op);\n  OSPF_ISM_WRITE_ON (oi->ospf);\n  OSPF_NSM_TIMER_ON (nbr->t_ls_req, ospf_ls_req_timer, nbr->v_ls_req);\n}", "target": 0}
{"code": "void WebGraphicsContext3DDefaultImpl::getIntegerv(unsigned long pname, int* value)\n{\n    makeContextCurrent();\n    switch (pname) {\n    case IMPLEMENTATION_COLOR_READ_FORMAT:\n        *value = GL_RGB;\n        break;\n    case IMPLEMENTATION_COLOR_READ_TYPE:\n        *value = GL_UNSIGNED_BYTE;\n        break;\n    case MAX_FRAGMENT_UNIFORM_VECTORS:\n        glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_COMPONENTS, value);\n        *value /= 4;\n        break;\n    case MAX_VERTEX_UNIFORM_VECTORS:\n        glGetIntegerv(GL_MAX_VERTEX_UNIFORM_COMPONENTS, value);\n        *value /= 4;\n        break;\n    case MAX_VARYING_VECTORS:\n        glGetIntegerv(GL_MAX_VARYING_FLOATS, value);\n        *value /= 4;\n        break;\n    default:\n        glGetIntegerv(pname, value);\n    }\n}", "target": 0}
{"code": "static int php_zip_ops_close(php_stream *stream, int close_handle TSRMLS_DC)\n{\n\tSTREAM_DATA_FROM_STREAM();\n\tif (close_handle) {\n\t\tif (self->zf) {\n\t\t\tzip_fclose(self->zf);\n\t\t\tself->zf = NULL;\n\t\t}\n\t\tif (self->za) {\n\t\t\tzip_close(self->za);\n\t\t\tself->za = NULL;\n\t\t}\n\t}\n\tefree(self);\n\tstream->abstract = NULL;\n\treturn EOF;\n}", "target": 0}
{"code": "handle_bap(netdissect_options *ndo _U_,\n           const u_char *p _U_, int length _U_)\n{\n}", "target": 0}
{"code": "static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t\tstruct dj_report *dj_report)\n{\n\tstruct dj_device *dj_dev;\n\tunsigned long flags;\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tdj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\n\tdjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\tif (dj_dev != NULL) {\n\t\thid_destroy_device(dj_dev->hdev);\n\t\tkfree(dj_dev);\n\t} else {\n\t\tdev_err(&djrcv_dev->hdev->dev, \"%s: can't destroy a NULL device\\n\",\n\t\t\t__func__);\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 5,\n        errors::InvalidArgument(\"tensor_in must be 1-dimensional and 5 \"\n                                \"elements\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      output_shape.AddDim(shape_vec(i));\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> padding, out;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    LaunchAvgPooling3dGradOp<Device, T>::launch(\n        context, output_shape, out_backprop, window, stride, out, padding,\n        data_format_, output);\n  }", "target": 1}
{"code": "static inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn (void *)ipcp;\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}", "target": 0}
{"code": "NTSTATUS ldapsrv_queue_reply(struct ldapsrv_call *call, struct ldapsrv_reply *reply)\n{\n\tNTSTATUS status = ldapsrv_encode(call, reply);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\tif (call->reply_size > call->reply_size + reply->blob.length\n\t    || call->reply_size + reply->blob.length > LDAP_SERVER_MAX_REPLY_SIZE) {\n\t\tDBG_WARNING(\"Refusing to queue LDAP search response size \"\n\t\t\t    \"of more than %zu bytes\\n\",\n\t\t\t    LDAP_SERVER_MAX_REPLY_SIZE);\n\t\tTALLOC_FREE(reply->blob.data);\n\t\treturn NT_STATUS_FILE_TOO_LARGE;\n\t}\n\tcall->reply_size += reply->blob.length;\n\tDLIST_ADD_END(call->replies, reply);\n\treturn status;\n}", "target": 0}
{"code": "fillline(struct readbuffer *obuf, int indent)\n{\n    push_spaces(obuf, 1, indent - obuf->pos);\n    obuf->flag &= ~RB_NFLUSHED;\n}", "target": 0}
{"code": "static size_t\nphp_mysqlnd_change_auth_response_write(MYSQLND_CONN_DATA * conn, void * _packet)\n{\n\tMYSQLND_PACKET_CHANGE_AUTH_RESPONSE *packet= (MYSQLND_PACKET_CHANGE_AUTH_RESPONSE *) _packet;\n\tMYSQLND_ERROR_INFO * error_info = conn->error_info;\n\tMYSQLND_PFC * pfc = conn->protocol_frame_codec;\n\tMYSQLND_VIO * vio = conn->vio;\n\tMYSQLND_STATS * stats = conn->stats;\n\tMYSQLND_CONNECTION_STATE * connection_state = &conn->state;\n\tzend_uchar * const buffer = pfc->cmd_buffer.length >= packet->auth_data_len? pfc->cmd_buffer.buffer : mnd_emalloc(packet->auth_data_len);\n\tzend_uchar * p = buffer + MYSQLND_HEADER_SIZE; \n\tDBG_ENTER(\"php_mysqlnd_change_auth_response_write\");\n\tif (packet->auth_data_len) {\n\t\tmemcpy(p, packet->auth_data, packet->auth_data_len);\n\t\tp+= packet->auth_data_len;\n\t}\n\t{\n\t\tconst size_t sent = pfc->data->m.send(pfc, vio, buffer, p - buffer - MYSQLND_HEADER_SIZE, stats, error_info);\n\t\tif (buffer != pfc->cmd_buffer.buffer) {\n\t\t\tmnd_efree(buffer);\n\t\t}\n\t\tif (!sent) {\n\t\t\tSET_CONNECTION_STATE(connection_state, CONN_QUIT_SENT);\n\t\t}\n\t\tDBG_RETURN(sent);\n\t}", "target": 1}
{"code": "  TextureManager::TextureInfo* GetTextureInfoForTarget(GLenum target) {\n    TextureUnit& unit = texture_units_[active_texture_unit_];\n    TextureManager::TextureInfo* info = NULL;\n    switch (target) {\n      case GL_TEXTURE_2D:\n        info = unit.bound_texture_2d;\n        break;\n      case GL_TEXTURE_CUBE_MAP:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:\n      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:\n      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:\n        info = unit.bound_texture_cube_map;\n        break;\n      default:\n        NOTREACHED();\n        return NULL;\n    }\n    return (info && !info->IsDeleted()) ? info : NULL;\n  }", "target": 0}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "filesystem_list_open_files_completed_cb (DBusGMethodInvocation *context,\n                                         Device *device,\n                                         gboolean job_was_cancelled,\n                                         int status,\n                                         const char *stderr,\n                                         const char *stdout,\n                                         gpointer user_data)\n{\n  if ((WEXITSTATUS (status) == 0 || WEXITSTATUS (status) == 1) && !job_was_cancelled)\n    {\n      GPtrArray *processes;\n      processes = g_ptr_array_new ();\n      lsof_parse (stdout, processes);\n      dbus_g_method_return (context, processes);\n      g_ptr_array_foreach (processes, (GFunc) g_value_array_free, NULL);\n      g_ptr_array_free (processes, TRUE);\n    }\n  else\n    {\n      throw_error (context,\n                   ERROR_FAILED,\n                   \"Error listing open files: lsof exited with exit code %d: %s\",\n                   WEXITSTATUS (status),\n                   stderr);\n    }\n}", "target": 0}
{"code": "static inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}", "target": 0}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "static inline int track_pfn_copy(struct vm_area_struct *vma)\n{\n\treturn 0;\n}", "target": 0}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "op_reindent(oparg_T *oap, int (*how)(void))\n{\n    long\ti = 0;\n    char_u\t*l;\n    int\t\tamount;\n    linenr_T\tfirst_changed = 0;\n    linenr_T\tlast_changed = 0;\n    linenr_T\tstart_lnum = curwin->w_cursor.lnum;\n    if (!curbuf->b_p_ma)\n    {\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n    if (u_savecommon(start_lnum - 1, start_lnum + oap->line_count,\n\t\t\t\t     start_lnum + oap->line_count, FALSE) == OK)\n\tfor (i = oap->line_count; --i >= 0 && !got_int; )\n\t{\n\t    if (i > 1\n\t\t    && (i % 50 == 0 || i == oap->line_count - 1)\n\t\t    && oap->line_count > p_report)\n\t\tsmsg(_(\"%ld lines to indent... \"), i);\n\t    if (i != oap->line_count - 1 || oap->line_count == 1\n\t\t\t\t\t\t     || how != get_lisp_indent)\n\t    {\n\t\tl = skipwhite(ml_get_curline());\n\t\tif (*l == NUL)\t\t    \n\t\t    amount = 0;\n\t\telse\n\t\t    amount = how();\t    \n\t\tif (amount >= 0 && set_indent(amount, 0))\n\t\t{\n\t\t    if (first_changed == 0)\n\t\t\tfirst_changed = curwin->w_cursor.lnum;\n\t\t    last_changed = curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;  \n\t}\n    curwin->w_cursor.lnum = start_lnum;\n    beginline(BL_SOL | BL_FIX);\n    if (last_changed != 0)\n\tchanged_lines(first_changed, 0,\n\t\toap->is_VIsual ? start_lnum + oap->line_count :\n\t\tlast_changed + 1, 0L);\n    else if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if (oap->line_count > p_report)\n    {\n\ti = oap->line_count - (i + 1);\n\tsmsg(NGETTEXT(\"%ld line indented \",\n\t\t\t\t\t\t \"%ld lines indented \", i), i);\n    }\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n    }\n}", "target": 0}
{"code": "passIsKeyword (const char *token)\n{\n  int k;\n  int length = strlen (token);\n  int ch = passLine.chars[passLinepos + length + 1];\n  if (((ch | 32) >= 'a' && (ch | 32) <= 'z') || (ch >= '0' && ch <= '9'))\n    return 0;\n  for (k = 0; k < length && passLine.chars[passLinepos + k + 1]\n       == (widechar) token[k]; k++);\n  if (k == length)\n    {\n      passLinepos += length + 1;\n      return 1;\n    }\n  return 0;\n}", "target": 0}
{"code": "static int mpeg4_update_thread_context(AVCodecContext *dst,\n                                       const AVCodecContext *src)\n{\n    Mpeg4DecContext *s = dst->priv_data;\n    const Mpeg4DecContext *s1 = src->priv_data;\n    int ret = ff_mpeg_update_thread_context(dst, src);\n    if (ret < 0)\n        return ret;\n    memcpy(((uint8_t*)s) + sizeof(MpegEncContext), ((uint8_t*)s1) + sizeof(MpegEncContext), sizeof(Mpeg4DecContext) - sizeof(MpegEncContext));\n    return 0;\n}", "target": 0}
{"code": "void ScanLineInputFile::initialize(const Header& header)\n{\n        _data->header = header;\n        _data->lineOrder = _data->header.lineOrder();\n        const Box2i &dataWindow = _data->header.dataWindow();\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n        Compression comp = _data->header.compression();\n        _data->linesInBuffer =\n            numLinesInBuffer (comp);\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n        if (lineOffsetSize > gLargeChunkTableSize)\n        {\n            Int64 pos = _streamData->is->tellg();\n            _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n            _streamData->is->seekg(pos);\n        }\n        size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                    _data->bytesPerLine);\n        if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n        {\n            throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n        }\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n        {\n            _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                 maxBytesPerLine,\n                                                 _data->header));\n        }\n        _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n        if (!_streamData->is->isMemoryMapped())\n        {\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            {\n                _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                if (!_data->lineBuffers[i]->buffer)\n                {\n                    throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                }\n            }\n        }\n        _data->nextLineBufferMinY = _data->minY - 1;\n        offsetInLineBufferTable (_data->bytesPerLine,\n                                 _data->linesInBuffer,\n                                 _data->offsetInLineBuffer);\n        _data->lineOffsets.resize (lineOffsetSize);\n}", "target": 1}
{"code": "check_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 1}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ENCHANT_GET_BROKER;\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        if (WriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            continue;\n        }\n        if (WriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 1}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "void RootWindow::OnWindowTransformed(Window* window, bool contained_mouse) {\n  if (contained_mouse ||\n      (window->IsVisible() &&\n       window->ContainsPointInRoot(last_mouse_location_))) {\n    PostMouseMoveEventAfterWindowChange();\n  }\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "DEATH_TEST(LteOp, InvalidEooOperand, \"Invariant failure _rhs\") {\n    BSONObj operand;\n    LTEMatchExpression lte(\"\", operand.firstElement());\n}", "target": 0}
{"code": "int get_netnsid_from_name(const char *name)\n{\n\tstruct {\n\t\tstruct nlmsghdr n;\n\t\tstruct rtgenmsg g;\n\t\tchar            buf[1024];\n\t} req = {\n\t\t.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)),\n\t\t.n.nlmsg_flags = NLM_F_REQUEST,\n\t\t.n.nlmsg_type = RTM_GETNSID,\n\t\t.g.rtgen_family = AF_UNSPEC,\n\t};\n\tstruct nlmsghdr *answer;\n\tstruct rtattr *tb[NETNSA_MAX + 1];\n\tstruct rtgenmsg *rthdr;\n\tint len, fd;\n\tnetns_nsid_socket_init();\n\tfd = netns_get_fd(name);\n\tif (fd < 0)\n\t\treturn fd;\n\taddattr32(&req.n, 1024, NETNSA_FD, fd);\n\tif (rtnl_talk(&rtnsh, &req.n, &answer) < 0) {\n\t\tclose(fd);\n\t\treturn -2;\n\t}\n\tclose(fd);\n\tif (answer->nlmsg_type == NLMSG_ERROR)\n\t\tgoto err_out;\n\trthdr = NLMSG_DATA(answer);\n\tlen = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr));\n\tif (len < 0)\n\t\tgoto err_out;\n\tparse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len);\n\tif (tb[NETNSA_NSID]) {\n\t\tfree(answer);\n\t\treturn rta_getattr_u32(tb[NETNSA_NSID]);\n\t}\nerr_out:\n\tfree(answer);\n\treturn -1;\n}", "target": 1}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  MagickPixelPacket\n    **pixels;\n  register ssize_t\n    i,\n    j;\n   size_t\n     columns,\n    number_threads;\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (MagickPixelPacket **) NULL)\n     return((MagickPixelPacket **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n   columns=images->columns;\n   for (next=images; next != (Image *) NULL; next=next->next)\n     columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(columns,\n       sizeof(**pixels));\n    if (pixels[i] == (MagickPixelPacket *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n      GetMagickPixelPacket(images,&pixels[i][j]);\n  }\n  return(pixels);\n}", "target": 1}
{"code": "bgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n    if (tptr == pptr + len) {\n        return 2;\n    }\ntrunc:\n   return 4;\n}", "target": 0}
{"code": "int jpc_pi_init(jpc_pi_t *pi)\n{\n\tint compno;\n\tint rlvlno;\n\tint prcno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tint *prclyrno;\n\tpi->prgvolfirst = 0;\n\tpi->valid = 0;\n\tpi->pktno = -1;\n\tpi->pchgno = -1;\n\tpi->pchg = 0;\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t  ++compno, ++picomp) {\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if (length>0) {\n        buffer=malloc(length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;\n}", "target": 1}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "void start_auth_vnc(VncState *vs)\n{\n    Error *err = NULL;\n    if (qcrypto_random_bytes(vs->challenge, sizeof(vs->challenge), &err)) {\n        trace_vnc_auth_fail(vs, vs->auth, \"cannot get random bytes\",\n                            error_get_pretty(err));\n        error_free(err);\n        authentication_failed(vs);\n        return;\n    }\n    vnc_write(vs, vs->challenge, sizeof(vs->challenge));\n    vnc_flush(vs);\n    vnc_read_when(vs, protocol_client_auth_vnc, sizeof(vs->challenge));\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_put_line)\n{\n\tchar *query;\n\tzval *pgsql_link = NULL;\n\tint query_len, id = -1;\n\tPGconn *pgsql;\n\tint result = 0, argc = ZEND_NUM_ARGS();\n\tif (argc == 1) {\n\t\tif (zend_parse_parameters(argc TSRMLS_CC, \"s\", &query, &query_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tid = PGG(default_link);\n\t\tCHECK_DEFAULT_LINK(id);\n\t} else {\n\t\tif (zend_parse_parameters(argc TSRMLS_CC, \"rs\", &pgsql_link, &query, &query_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\t\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tresult = PQputline(pgsql, query);\n\tif (result==EOF) {\n\t\tPHP_PQ_ERROR(\"Query failed: %s\", pgsql);\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "void WebContentsImpl::HandleKeyboardEvent(const NativeWebKeyboardEvent& event) {\n  if (browser_plugin_embedder_ &&\n      browser_plugin_embedder_->HandleKeyboardEvent(event)) {\n    return;\n  }\n  if (delegate_)\n    delegate_->HandleKeyboardEvent(this, event);\n}", "target": 0}
{"code": "static bool ok_jpg_read_dqt(ok_jpg_decoder *decoder) {\n    ok_jpg *jpg = decoder->jpg;\n    uint8_t buffer[2];\n    if (!ok_read(decoder, buffer, sizeof(buffer))) {\n        return false;\n    }\n    int length = readBE16(buffer) - 2;\n    while (length >= 65) {\n        uint8_t pt = ok_read_uint8(decoder);\n        int Pq = pt >> 4;\n        int Tq = pt & 0x0f;\n        if (Pq == 1) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_UNSUPPORTED, \"Unsupported JPEG (16-bit q_table)\");\n            return false;\n        }\n        if (Pq != 0 || Tq > 3) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid JPEG (Pq/Tq)\");\n            return false;\n        }\n        if (!ok_read(decoder, decoder->q_table[Tq], 64)) {\n            return false;\n        }\n        length -= 65;\n    }\n    if (length != 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"Invalid DQT segment length\");\n        return false;\n    } else {\n        return true;\n    }\n}", "target": 0}
{"code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\tif (thread)\n\t\tCloseHandle (thread);\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\tg_free (this->name);\n}", "target": 1}
{"code": "coolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static void save_state_to_tss16(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tstruct tss_segment_16 *tss)\n{\n\ttss->ip = ctxt->_eip;\n\ttss->flag = ctxt->eflags;\n\ttss->ax = ctxt->regs[VCPU_REGS_RAX];\n\ttss->cx = ctxt->regs[VCPU_REGS_RCX];\n\ttss->dx = ctxt->regs[VCPU_REGS_RDX];\n\ttss->bx = ctxt->regs[VCPU_REGS_RBX];\n\ttss->sp = ctxt->regs[VCPU_REGS_RSP];\n\ttss->bp = ctxt->regs[VCPU_REGS_RBP];\n\ttss->si = ctxt->regs[VCPU_REGS_RSI];\n\ttss->di = ctxt->regs[VCPU_REGS_RDI];\n\ttss->es = get_segment_selector(ctxt, VCPU_SREG_ES);\n\ttss->cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n\ttss->ss = get_segment_selector(ctxt, VCPU_SREG_SS);\n\ttss->ds = get_segment_selector(ctxt, VCPU_SREG_DS);\n\ttss->ldt = get_segment_selector(ctxt, VCPU_SREG_LDTR);\n}", "target": 0}
{"code": "static int cens_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret, rem_bytes;\n    uint8_t *data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    } else if (!sample->crypt_byte_block && !sample->skip_byte_block) {\n        av_log(c->fc, AV_LOG_ERROR, \"pattern encryption is not present in 'cens' scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        data = input;\n        rem_bytes = sample->subsamples[i].bytes_of_protected_data;\n        while (rem_bytes > 0) {\n            if (rem_bytes < 16*sample->crypt_byte_block) {\n                break;\n            }\n            av_aes_ctr_crypt(sc->cenc.aes_ctr, data, data, 16*sample->crypt_byte_block);\n            data += 16*sample->crypt_byte_block;\n            rem_bytes -= 16*sample->crypt_byte_block;\n            data += FFMIN(16*sample->skip_byte_block, rem_bytes);\n            rem_bytes -= FFMIN(16*sample->skip_byte_block, rem_bytes);\n        }\n        input += sample->subsamples[i].bytes_of_protected_data;\n        size -= sample->subsamples[i].bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "void kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tkvm_x86_ops->get_segment(vcpu, var, seg);\n}", "target": 0}
{"code": "static int result(void)\n{\n\tint i;\n\tint status = 0;\n\tfor (i = 0; i < MAX_REPLIES; i++) {\n\t\tstatus = wait_til_ready();\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tstatus &= STATUS_DIR | STATUS_READY | STATUS_BUSY | STATUS_DMA;\n\t\tif ((status & ~STATUS_BUSY) == STATUS_READY) {\n\t\t\tresultjiffies = jiffies;\n\t\t\tresultsize = i;\n\t\t\treturn i;\n\t\t}\n\t\tif (status == (STATUS_DIR | STATUS_READY | STATUS_BUSY))\n\t\t\treply_buffer[i] = fd_inb(FD_DATA);\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (initialized) {\n\t\tDPRINT(\"get result error. Fdc=%d Last status=%x Read bytes=%d\\n\",\n\t\t       fdc, status, i);\n\t\tshow_floppy();\n\t}\n\tFDCS->reset = 1;\n\treturn -1;\n}", "target": 0}
{"code": "newVar5(char *var,char *var2, char *var3,char *var4,char *var5)\n{\n\tstruct SWF_ACTIONPUSHPARAM *v;\n\tv=malloc(sizeof(struct SWF_ACTIONPUSHPARAM));\n\tv->Type = PUSH_VARIABLE; \n\tv->p.String = malloc(strlen(var)+strlen(var2)+strlen(var3)+strlen(var4)+strlen(var5)+1);\n\tstrcpy(v->p.String,var);\n\tstrcat(v->p.String,var2);\n\tstrcat(v->p.String,var3);\n\tstrcat(v->p.String,var4);\n\tstrcat(v->p.String,var5);\n\treturn v;\n}", "target": 0}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::UniquePtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::UniquePtr(new CiffDirectory); break;\n            default: m = CiffComponent::UniquePtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(std::move(m));\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,\n                                   const unsigned char* image, unsigned w, unsigned h,\n                                   const LodePNGColorMode* mode_in)\n{\n  LodePNGColorProfile prof;\n  unsigned error = 0;\n  unsigned i, n, palettebits, grey_ok, palette_ok;\n  lodepng_color_profile_init(&prof);\n  error = get_color_profile(&prof, image, w, h, mode_in);\n  if(error) return error;\n  mode_out->key_defined = 0;\n  if(prof.key && w * h <= 16) prof.alpha = 1; \n  grey_ok = !prof.colored && !prof.alpha; \n  n = prof.numcolors;\n  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));\n  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;\n  if(w * h < n * 2) palette_ok = 0; \n  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; \n  if(palette_ok)\n  {\n    unsigned char* p = prof.palette;\n    lodepng_palette_clear(mode_out); \n    for(i = 0; i < prof.numcolors; i++)\n    {\n      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);\n      if(error) break;\n    }\n    mode_out->colortype = LCT_PALETTE;\n    mode_out->bitdepth = palettebits;\n    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize\n        && mode_in->bitdepth == mode_out->bitdepth)\n    {\n      lodepng_color_mode_cleanup(mode_out);\n      lodepng_color_mode_copy(mode_out, mode_in);\n    }\n  }\n  else \n  {\n    mode_out->bitdepth = prof.bits;\n    mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)\n                                     : (prof.colored ? LCT_RGB : LCT_GREY);\n    if(prof.key && !prof.alpha)\n    {\n      unsigned mask = (1u << mode_out->bitdepth) - 1u; \n      mode_out->key_r = prof.key_r & mask;\n      mode_out->key_g = prof.key_g & mask;\n      mode_out->key_b = prof.key_b & mask;\n      mode_out->key_defined = 1;\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "bool cond_is_datetime_is_null(Item *cond)\n{\n  if (cond->type() == Item::FUNC_ITEM &&\n      ((Item_func*) cond)->functype() == Item_func::ISNULL_FUNC)\n  {\n    return ((Item_func_isnull*) cond)->arg_is_datetime_notnull_field();\n  }\n  return false;\n}", "target": 0}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "void php_gd_error(const char *format, ...)\n{\n\tva_list args;\n\tTSRMLS_FETCH();\n\tva_start(args, format);\n\tphp_verror(NULL, \"\", E_WARNING, format, args TSRMLS_CC);\n\tva_end(args);\n}", "target": 0}
{"code": "int vfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 0);\n\tif (error)\n\t\treturn error;\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (d_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error)\n\t\t\t\tdont_mount(dentry);\n\t\t}\n\t}\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(dentry->d_inode);\n\t\td_delete(dentry);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "xmlCreateMemoryParserCtxt(const char *buffer, int size) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr input;\n    xmlParserInputBufferPtr buf;\n    if (buffer == NULL)\n\treturn(NULL);\n    if (size <= 0)\n\treturn(NULL);\n    ctxt = xmlNewParserCtxt();\n    if (ctxt == NULL)\n\treturn(NULL);\n    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (buf == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input = xmlNewInputStream(ctxt);\n    if (input == NULL) {\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n\treturn(NULL);\n    }\n    input->filename = NULL;\n    input->buf = buf;\n    xmlBufResetInput(input->buf->buffer, input);\n    inputPush(ctxt, input);\n    return(ctxt);\n}", "target": 0}
{"code": "void http_capture_bad_message(struct error_snapshot *es, struct session *s,\n                              struct buffer *buf, struct http_msg *msg,\n\t\t\t      int state, struct proxy *other_end)\n{\n\tif (buf->r <= (buf->data + msg->som)) { \n\t\tint len1 = buf->size - msg->som;\n\t\tes->len = buf->r - (buf->data + msg->som) + buf->size;\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(len1, sizeof(es->buf)));\n\t\tif (es->len > len1 && len1 < sizeof(es->buf))\n\t\t\tmemcpy(es->buf + len1, buf->data, MIN(es->len, sizeof(es->buf)) - len1);\n\t}\n\telse {\n\t\tes->len = buf->r - (buf->data + msg->som);\n\t\tmemcpy(es->buf, buf->data + msg->som, MIN(es->len, sizeof(es->buf)));\n\t}\n\tif (msg->err_pos >= 0)\n\t\tes->pos  = msg->err_pos - msg->som;\n\telse if (buf->lr >= (buf->data + msg->som))\n\t\tes->pos  = buf->lr - (buf->data + msg->som);\n\telse\n\t\tes->pos  = buf->lr - (buf->data + msg->som) + buf->size;\n\tes->when = date; \n\tes->sid  = s->uniq_id;\n\tes->srv  = s->srv;\n\tes->oe   = other_end;\n\tes->src  = s->cli_addr;\n\tes->state = state;\n\tes->flags = buf->flags;\n\tes->ev_id = error_snapshot_id++;\n}", "target": 0}
{"code": "int mempool_releasebuffer(MemoryPoolHandle handle, void *buf,\n                          size_t released_buffer_size) {\n  struct mempool *pool = (struct mempool *)handle;\n  struct memory_pool_element *pool_item = (struct memory_pool_element *)buf;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_releasebuffer called for invalid \"\n      \"released_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if ((pool == NULL) || (pool_item == NULL)) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n  if (pool->mempool_item_size != released_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               released_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return S3_MEMPOOL_INVALID_ARG;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if ((pool->flags & ZEROED_BUFFER) != 0) {\n    memset(pool_item, 0, pool->mempool_item_size);\n  }\n  pool_item->next = pool->free_list;\n  pool->free_list = pool_item;\n  pool->free_bufs_in_pool++;\n  pool_item = NULL;\n  pool->number_of_bufs_shared--;\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return 0;\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}", "target": 1}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 1}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tu32 phys;\n\tint pkt_status;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PHY:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tphys = hci_conn_get_phy(sco_pi(sk)->conn->hcon);\n\t\tif (put_user(phys, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_PKT_STATUS:\n\t\tpkt_status = (sco_pi(sk)->cmsg_mask & SCO_CMSG_PKT_STATUS);\n\t\tif (put_user(pkt_status, (int __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_SNDMTU:\n\tcase BT_RCVMTU:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(sco_pi(sk)->conn->mtu, (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\tif (!*buf || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\tif (!strcmp(buf, \"list\")) {\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "TIFFjpeg_start_compress(JPEGState* sp, boolean write_all_tables)\n{\n\treturn CALLVJPEG(sp,\n\t    jpeg_start_compress(&sp->cinfo.c, write_all_tables));\n}", "target": 0}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "mrb_prev_pc(codegen_scope *s, const mrb_code *pc)\n{\n  const mrb_code *prev_pc = NULL;\n  const mrb_code *i = s->iseq;\n  while (i<pc) {\n    uint8_t insn = i[0];\n    prev_pc = i;\n    switch (insn) {\n    case OP_EXT1:\n      i += mrb_insn_size1[i[1]] + 1;\n      break;\n    case OP_EXT2:\n      i += mrb_insn_size2[i[1]] + 1;\n      break;\n    case OP_EXT3:\n      i += mrb_insn_size3[i[1]] + 1;\n      break;\n    default:\n      i += mrb_insn_size[insn];\n      break;\n    }\n  }\n  return prev_pc;\n}", "target": 0}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n  ssize_t\n    intensity;\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": " static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n    return OPJ_FALSE;\n}", "target": 1}
{"code": "static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport)\n{\n\tstruct hnae3_knic_private_info *kinfo = &vport->nic.kinfo;\n\tstruct hclge_dev *hdev = vport->back;\n\tint ret;\n\tu8 i;\n\tret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < kinfo->num_tc; i++) {\n\t\tu8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode;\n\t\tret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i,\n\t\t\t\t\t\tsch_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "void LinkResolver::throw_abstract_method_error(const methodHandle& resolved_method,\n                                               const methodHandle& selected_method,\n                                               Klass *recv_klass, TRAPS) {\n  Klass *resolved_klass = resolved_method->method_holder();\n  ResourceMark rm(THREAD);\n  stringStream ss;\n  if (recv_klass != NULL) {\n    ss.print(\"Receiver class %s does not define or inherit an \"\n             \"implementation of the\",\n             recv_klass->external_name());\n  } else {\n    ss.print(\"Missing implementation of\");\n  }\n  assert(resolved_method.not_null(), \"Sanity\");\n  ss.print(\" resolved method '%s%s\",\n           resolved_method->is_abstract() ? \"abstract \" : \"\",\n           resolved_method->is_private()  ? \"private \"  : \"\");\n  resolved_method->signature()->print_as_signature_external_return_type(&ss);\n  ss.print(\" %s(\", resolved_method->name()->as_C_string());\n  resolved_method->signature()->print_as_signature_external_parameters(&ss);\n  ss.print(\")' of %s %s.\",\n           resolved_klass->external_kind(),\n           resolved_klass->external_name());\n  if (selected_method.not_null() && !(resolved_method == selected_method)) {\n    ss.print(\" Selected method is '%s%s\",\n             selected_method->is_abstract() ? \"abstract \" : \"\",\n             selected_method->is_private()  ? \"private \"  : \"\");\n    selected_method->print_external_name(&ss);\n    ss.print(\"'.\");\n  }\n  THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());\n}", "target": 0}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "static u32 nested_vmx_load_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tstruct msr_data msr;\n\tmsr.host_initiated = false;\n\tfor (i = 0; i < count; i++) {\n\t\tif (kvm_vcpu_read_guest(vcpu, gpa + i * sizeof(e),\n\t\t\t\t\t&e, sizeof(e))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\tgoto fail;\n\t\t}\n\t\tif (nested_vmx_load_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\tgoto fail;\n\t\t}\n\t\tmsr.index = e.index;\n\t\tmsr.data = e.value;\n\t\tif (kvm_set_msr(vcpu, &msr)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, e.value);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\nfail:\n\treturn i + 1;\n}", "target": 0}
{"code": "static void __init acpi_request_region (struct acpi_generic_address *gas,\n\tunsigned int length, char *desc)\n{\n\tu64 addr;\n\tmemcpy(&addr, &gas->address, sizeof(addr));\n\tif (!addr || !length)\n\t\treturn;\n\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\n\t\trequest_region(addr, length, desc);\n\telse if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\trequest_mem_region(addr, length, desc);\n}", "target": 0}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}", "target": 1}
{"code": "gst_mpegts_section_new (guint16 pid, guint8 * data, gsize data_size)\n{\n  GstMpegtsSection *res = NULL;\n  guint8 tmp;\n  guint8 table_id;\n  guint16 section_length;\n  section_length = GST_READ_UINT16_BE (data + 1) & 0x0FFF;\n  if (G_UNLIKELY (data_size < section_length + 3))\n    goto short_packet;\n  table_id = *data;\n  res = _gst_mpegts_section_init (pid, table_id);\n  res->data = data;\n  data++;\n  res->short_section = (*data & 0x80) == 0x00;\n  res->section_length = section_length + 3;\n  if (!res->short_section) {\n    res->crc = GST_READ_UINT32_BE (res->data + res->section_length - 4);\n    data += 2;\n    res->subtable_extension = GST_READ_UINT16_BE (data);\n    data += 2;\n    tmp = *data++;\n    res->version_number = tmp >> 1 & 0x1f;\n    res->current_next_indicator = tmp & 0x01;\n    res->section_number = *data++;\n    res->last_section_number = *data;\n  }\n  return res;\nshort_packet:\n  {\n    GST_WARNING\n        (\"PID 0x%04x section extends past provided data (got:%\" G_GSIZE_FORMAT\n        \", need:%d)\", pid, data_size, section_length + 3);\n    g_free (data);\n    return NULL;\n  }\n}", "target": 1}
{"code": "BOOL license_read_product_info(wStream* s, PRODUCT_INFO* productInfo)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, productInfo->dwVersion); \n\tStream_Read_UINT32(s, productInfo->cbCompanyName); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbCompanyName + 4)\n\t\treturn FALSE;\n\tproductInfo->pbCompanyName = (BYTE*) malloc(productInfo->cbCompanyName);\n\tStream_Read(s, productInfo->pbCompanyName, productInfo->cbCompanyName);\n\tStream_Read_UINT32(s, productInfo->cbProductId); \n\tif (Stream_GetRemainingLength(s) < productInfo->cbProductId)\n\t{\n\t\tfree(productInfo->pbCompanyName);\n\t\tproductInfo->pbCompanyName = NULL;\n\t\treturn FALSE;\n\t}\n\tproductInfo->pbProductId = (BYTE*) malloc(productInfo->cbProductId);\n\tStream_Read(s, productInfo->pbProductId, productInfo->cbProductId);\n\treturn TRUE;\n}", "target": 0}
{"code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tif (!card)\n\t\treturn -EINVAL;\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\tsnd_device_disconnect_all(card);\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}", "target": 1}
{"code": "static int midi_setup_trackname(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_trackname;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "static void apply_independent_coupling(AACContext *ac,\n                                       SingleChannelElement *target,\n                                       ChannelElement *cce, int index)\n{\n    int i;\n    const float gain = cce->coup.gain[index][0];\n    const float *src = cce->ch[0].ret;\n    float *dest = target->ret;\n    const int len = 1024 << (ac->oc[1].m4ac.sbr == 1);\n    for (i = 0; i < len; i++)\n        dest[i] += gain * src[i];\n}", "target": 0}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n   AddChildView(label_);\n   const auto buttons = delegate_ptr->GetButtons();\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {\n    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);\n    ok_button_->SetProminent(true);\n    if (delegate_ptr->OKButtonTriggersUACPrompt()) {\n      elevation_icon_setter_.reset(new ElevationIconSetter(\n          ok_button_,\n          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));\n    }\n  }\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {\n    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);\n    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)\n      cancel_button_->SetProminent(true);\n  }\n  link_ = CreateLink(delegate_ptr->GetLinkText(), this);\n  AddChildView(link_);\n}", "target": 1}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "AP_DECLARE(const char *) ap_context_prefix(request_rec *r)\n{\n    core_request_config *conf = ap_get_core_module_config(r->request_config);\n    if (conf->context_prefix)\n        return conf->context_prefix;\n    else\n        return \"\";\n}", "target": 0}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\tulong2bebytes(&params.object_id[0], object_id);\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\treturn out_len;\nfail:\n\treturn r;\n}", "target": 0}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "TEST(MultiplyAndCheckOverflow, Validate) {\n  size_t res = 0;\n  EXPECT_TRUE(MultiplyAndCheckOverflow(1, 2, &res) == kTfLiteOk);\n  EXPECT_FALSE(MultiplyAndCheckOverflow(static_cast<size_t>(123456789023),\n                                        1223423425, &res) == kTfLiteOk);\n}", "target": 0}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "pch_normalize (enum diff format)\n{\n  lin old = 1;\n  lin new = p_ptrn_lines + 1;\n  while (p_Char[new] == '=' || p_Char[new] == '\\n')\n    new++;\n  if (format == UNI_DIFF)\n    {\n      for (; old <= p_ptrn_lines; old++)\n\tif (p_Char[old] == '!')\n\t  p_Char[old] = '-';\n      for (; new <= p_end; new++)\n\tif (p_Char[new] == '!')\n\t  p_Char[new] = '+';\n    }\n  else\n    {\n      while (old <= p_ptrn_lines)\n\t{\n\t  if (p_Char[old] == '-')\n\t    {\n\t      if (new <= p_end && p_Char[new] == '+')\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      p_Char[old] = '!';\n\t\t      old++;\n\t\t    }\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t  do\n\t\t    {\n\t\t      p_Char[new] = '!';\n\t\t      new++;\n\t\t    }\n\t\t  while (new <= p_end && p_Char[new] == '+');\n\t\t}\n\t      else\n\t\t{\n\t\t  do\n\t\t    old++;\n\t\t  while (old <= p_ptrn_lines && p_Char[old] == '-');\n\t\t}\n\t    }\n\t  else if (new <= p_end && p_Char[new] == '+')\n\t    {\n\t      do\n\t\tnew++;\n\t      while (new <= p_end && p_Char[new] == '+');\n\t    }\n\t  else\n\t    {\n\t      old++;\n\t      new++;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "compile_length_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n  return add_compile_string_length(sn->s, 1 , sn->end - sn->s, reg, 0);\n}", "target": 0}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "void PDFiumEngine::PostPaint() {\n  for (size_t i = 0; i < progressive_paints_.size(); ++i) {\n    if (progressive_paints_[i].painted_)\n      continue;\n    FPDF_RenderPage_Close(\n        pages_[progressive_paints_[i].page_index]->GetPage());\n    FPDFBitmap_Destroy(progressive_paints_[i].bitmap);\n    progressive_paints_.erase(progressive_paints_.begin() + i);\n    --i;\n  }\n}", "target": 0}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "RGWOp *RGWHandler_REST_Bucket_S3::op_put()\n{\n  if (s->info.args.sub_resource_exists(\"logging\"))\n    return NULL;\n  if (s->info.args.sub_resource_exists(\"versioning\"))\n    return new RGWSetBucketVersioning_ObjStore_S3;\n  if (s->info.args.sub_resource_exists(\"website\")) {\n    if (!s->cct->_conf->rgw_enable_static_website) {\n      return NULL;\n    }\n    return new RGWSetBucketWebsite_ObjStore_S3;\n  }\n  if (is_acl_op()) {\n    return new RGWPutACLs_ObjStore_S3;\n  } else if (is_cors_op()) {\n    return new RGWPutCORS_ObjStore_S3;\n  } else if (is_request_payment_op()) {\n    return new RGWSetRequestPayment_ObjStore_S3;\n  } else if(is_lc_op()) {\n    return new RGWPutLC_ObjStore_S3;\n  } else if(is_policy_op()) {\n    return new RGWPutBucketPolicy;\n  } else if (is_object_lock_op()) {\n    return new RGWPutBucketObjectLock_ObjStore_S3;\n  } else if (is_notification_op()) {\n    return RGWHandler_REST_PSNotifs_S3::create_put_op();\n  }\n  return new RGWCreateBucket_ObjStore_S3;\n}", "target": 0}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\nout:\n    g_free(elem);\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static inline bool ieee80211_rx_reorder_ready(struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t      int index)\n{\n\tstruct sk_buff_head *frames = &tid_agg_rx->reorder_buf[index];\n\tstruct sk_buff *tail = skb_peek_tail(frames);\n\tstruct ieee80211_rx_status *status;\n\tif (tid_agg_rx->reorder_buf_filtered & BIT_ULL(index))\n\t\treturn true;\n\tif (!tail)\n\t\treturn false;\n\tstatus = IEEE80211_SKB_RXCB(tail);\n\tif (status->flag & RX_FLAG_AMSDU_MORE)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "pa2ycbcr(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    pa2rgb(out, in, xsize, palette);\n    ImagingConvertRGB2YCbCr(out, out, xsize);\n}", "target": 0}
{"code": "int fz_colorspace_device_n_has_only_cmyk(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && ((cs->flags & FZ_CS_HAS_CMYK_AND_SPOTS) == FZ_CS_HAS_CMYK);\n}", "target": 0}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 0}
{"code": "static inline int is_zero_pfn(unsigned long pfn)\n{\n\textern unsigned long zero_pfn;\n\treturn pfn == zero_pfn;\n}", "target": 0}
{"code": "acl_fetch_proto_http(struct proxy *px, struct session *s, void *l7, int dir,\n\t\t     struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct buffer *req = s->req;\n\tstruct http_txn *txn = &s->txn;\n\tstruct http_msg *msg = &txn->req;\n\tif (!s || !req)\n\t\treturn 0;\n\tif (unlikely(msg->msg_state >= HTTP_MSG_BODY)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->r > req->data + req->size - global.tune.maxrewrite)) &&\n\t    (req->l <= req->size - global.tune.maxrewrite))\n\t\thttp_buffer_heavy_realign(req, msg);\n\tif (likely(req->lr < req->r))\n\t\thttp_msg_analyzer(req, msg, &txn->hdr_idx);\n\tif (unlikely(msg->msg_state < HTTP_MSG_BODY)) {\n\t\tif ((msg->msg_state == HTTP_MSG_ERROR) || (req->flags & BF_FULL)) {\n\t\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\t\treturn 1;\n\t\t}\n\t\ttest->flags |= ACL_TEST_F_MAY_CHANGE;\n\t\treturn 0;\n\t}\n\tif (unlikely(req->lr > req->data &&\n\t    (req->r < req->lr || req->l > req->size - global.tune.maxrewrite ||\n\t     req->r > req->data + req->size - global.tune.maxrewrite))) {\n\t\tmsg->msg_state = HTTP_MSG_ERROR;\n\t\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\t\treturn 1;\n\t}\n\ttxn->meth = find_http_meth(msg->sol, msg->sl.rq.m_l);\n\tif (txn->meth == HTTP_METH_GET || txn->meth == HTTP_METH_HEAD)\n\t\ts->flags |= SN_REDIRECTABLE;\n\tif (unlikely(msg->sl.rq.v_l == 0) && !http_upgrade_v09_to_v10(req, msg, txn)) {\n\t\ttest->flags |= ACL_TEST_F_SET_RES_FAIL;\n\t\treturn 1;\n\t}\n\ttest->flags |= ACL_TEST_F_SET_RES_PASS;\n\treturn 1;\n}", "target": 0}
{"code": "ieee80211_rx_h_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\treturn ieee80211_rx_mesh_check(rx);\n\tif (unlikely((ieee80211_is_data(hdr->frame_control) ||\n\t\t      ieee80211_is_pspoll(hdr->frame_control)) &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_WDS &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {\n\t\tif (rx->sta && rx->sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    ieee80211_is_data_present(hdr->frame_control)) {\n\t\t\tunsigned int hdrlen;\n\t\t\t__be16 ethertype;\n\t\t\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\t\t\tif (rx->skb->len < hdrlen + 8)\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tskb_copy_bits(rx->skb, hdrlen + 6, &ethertype, 2);\n\t\t\tif (ethertype == rx->sdata->control_port_protocol)\n\t\t\t\treturn RX_CONTINUE;\n\t\t}\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t    cfg80211_rx_spurious_frame(rx->sdata->dev,\n\t\t\t\t\t       hdr->addr2,\n\t\t\t\t\t       GFP_ATOMIC))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\treturn RX_DROP_MONITOR;\n\t}\n\treturn RX_CONTINUE;\n}", "target": 0}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "const GF_MasteringDisplayColourVolumeInfo *gf_isom_get_mastering_display_colour_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return NULL;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn NULL;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return NULL;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return NULL;\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) return NULL;\n\treturn &mdcvb->mdcv;\n}", "target": 0}
{"code": "void mwifiex_set_vht_width(struct mwifiex_private *priv,\n\t\t\t   enum nl80211_chan_width width,\n\t\t\t   bool ap_11ac_enable)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_11ac_vht_cfg vht_cfg;\n\tvht_cfg.band_config = VHT_CFG_5GHZ;\n\tvht_cfg.cap_info = adapter->hw_dot_11ac_dev_cap;\n\tif (!ap_11ac_enable) {\n\t\tvht_cfg.mcs_tx_set = DISABLE_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DISABLE_VHT_MCS_SET;\n\t} else {\n\t\tvht_cfg.mcs_tx_set = DEFAULT_VHT_MCS_SET;\n\t\tvht_cfg.mcs_rx_set = DEFAULT_VHT_MCS_SET;\n\t}\n\tvht_cfg.misc_config  = VHT_CAP_UAP_ONLY;\n\tif (ap_11ac_enable && width >= NL80211_CHAN_WIDTH_80)\n\t\tvht_cfg.misc_config |= VHT_BW_80_160_80P80;\n\tmwifiex_send_cmd(priv, HostCmd_CMD_11AC_CFG,\n\t\t\t HostCmd_ACT_GEN_SET, 0, &vht_cfg, true);\n\treturn;\n}", "target": 0}
{"code": "static MagickPixelPacket **DestroyPixelThreadSet(const Image *images,\n  MagickPixelPacket **pixels)\n{\n  ssize_t\n    i;\n  size_t\n    rows;\n  assert(pixels != (MagickPixelPacket **) NULL);\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  for (i=0; i < (ssize_t) rows; i++)\n    if (pixels[i] != (MagickPixelPacket *) NULL)\n      pixels[i]=(MagickPixelPacket *) RelinquishMagickMemory(pixels[i]);\n  pixels=(MagickPixelPacket **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "bool EmbFile::save2(FILE *f) {\n  int c;\n  m_objStr.streamReset();\n  while ((c = m_objStr.streamGetChar()) != EOF) {\n    fputc(c, f);\n  }\n  return true;\n}", "target": 1}
{"code": "SampleEncrypter::Create(const AP4_UI08* key, const AP4_UI08* iv, SampleEncrypter*& encrypter) {\n    encrypter = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    encrypter = new SampleEncrypter(stream_cipher, iv);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "flatpak_run_add_cups_args (FlatpakBwrap *bwrap)\n{\n  g_autofree char * sandbox_server_name = g_strdup (\"/var/run/cups/cups.sock\");\n  g_autofree char * cups_server_name = flatpak_run_get_cups_server_name ();\n  if (!g_file_test (cups_server_name, G_FILE_TEST_EXISTS))\n    {\n      g_debug (\"Could not find CUPS server\");\n      return;\n    }\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", cups_server_name, sandbox_server_name,\n                          NULL);\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "static int update_frag_index(MOVContext *c, int64_t offset)\n{\n    int index, i;\n    MOVFragmentIndexItem * item;\n    MOVFragmentStreamInfo * frag_stream_info;\n    index = search_frag_moof_offset(&c->frag_index, offset);\n    if (index < c->frag_index.nb_items &&\n        c->frag_index.item[index].moof_offset == offset)\n        return index;\n    item = av_fast_realloc(c->frag_index.item,\n                           &c->frag_index.allocated_size,\n                           (c->frag_index.nb_items + 1) *\n                           sizeof(*c->frag_index.item));\n    if (!item)\n        return -1;\n    c->frag_index.item = item;\n    frag_stream_info = av_realloc_array(NULL, c->fc->nb_streams,\n                                        sizeof(*item->stream_info));\n    if (!frag_stream_info)\n        return -1;\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id < 0) {\n            av_free(frag_stream_info);\n            return AVERROR_INVALIDDATA;\n        }\n        frag_stream_info[i].id = c->fc->streams[i]->id;\n        frag_stream_info[i].sidx_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;\n        frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;\n        frag_stream_info[i].index_base = -1;\n        frag_stream_info[i].index_entry = -1;\n        frag_stream_info[i].encryption_index = NULL;\n    }\n    if (index < c->frag_index.nb_items)\n        memmove(c->frag_index.item + index + 1, c->frag_index.item + index,\n                (c->frag_index.nb_items - index) * sizeof(*c->frag_index.item));\n    item = &c->frag_index.item[index];\n    item->headers_read = 0;\n    item->current = 0;\n    item->nb_stream_info = c->fc->nb_streams;\n    item->moof_offset = offset;\n    item->stream_info = frag_stream_info;\n    c->frag_index.nb_items++;\n    return index;\n}", "target": 0}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static __init int vdso_fixup_datapage(struct lib32_elfinfo *v32,\n\t\t\t\t       struct lib64_elfinfo *v64)\n{\n\tElf32_Sym *sym32;\n#ifdef CONFIG_PPC64\n\tElf64_Sym *sym64;\n       \tsym64 = find_symbol64(v64, \"__kernel_datapage_offset\");\n\tif (sym64 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso64_kbase + sym64->st_value - VDSO64_LBASE)) =\n\t\t(vdso64_pages << PAGE_SHIFT) -\n\t\t(sym64->st_value - VDSO64_LBASE);\n#endif \n\tsym32 = find_symbol32(v32, \"__kernel_datapage_offset\");\n\tif (sym32 == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: Can't find symbol \"\n\t\t       \"__kernel_datapage_offset !\\n\");\n\t\treturn -1;\n\t}\n\t*((int *)(vdso32_kbase + (sym32->st_value - VDSO32_LBASE))) =\n\t\t(vdso32_pages << PAGE_SHIFT) -\n\t\t(sym32->st_value - VDSO32_LBASE);\n\treturn 0;\n}", "target": 0}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "int RGWHandler_REST_S3::init(RGWRados *store, struct req_state *s,\n                             rgw::io::BasicClient *cio)\n{\n  int ret;\n  s->dialect = \"s3\";\n  ret = rgw_validate_tenant_name(s->bucket_tenant);\n  if (ret)\n    return ret;\n  bool relaxed_names = s->cct->_conf->rgw_relaxed_s3_bucket_names;\n  if (!s->bucket_name.empty()) {\n    ret = valid_s3_bucket_name(s->bucket_name, relaxed_names);\n    if (ret)\n      return ret;\n    ret = validate_object_name(s->object.name);\n    if (ret)\n      return ret;\n  }\n  const char *cacl = s->info.env->get(\"HTTP_X_AMZ_ACL\");\n  if (cacl)\n    s->canned_acl = cacl;\n  s->has_acl_header = s->info.env->exists_prefix(\"HTTP_X_AMZ_GRANT\");\n  const char *copy_source = s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE\");\n  if (copy_source &&\n      (! s->info.env->get(\"HTTP_X_AMZ_COPY_SOURCE_RANGE\")) &&\n      (! s->info.args.exists(\"uploadId\"))) {\n    ret = RGWCopyObj::parse_copy_location(copy_source,\n                                          s->init_state.src_bucket,\n                                          s->src_object);\n    if (!ret) {\n      ldout(s->cct, 0) << \"failed to parse copy location\" << dendl;\n      return -EINVAL; \n    }\n  }\n  return RGWHandler_REST::init(store, s, cio);\n}", "target": 0}
{"code": "bool HTMLFormControlElement::isAutofocusable() const\n {\n    if (!fastHasAttribute(autofocusAttr))\n        return false;\n    if (hasTagName(inputTag))\n        return !toHTMLInputElement(this)->isInputTypeHidden();\n    if (hasTagName(selectTag))\n        return true;\n    if (hasTagName(keygenTag))\n        return true;\n    if (hasTagName(buttonTag))\n        return true;\n    if (hasTagName(textareaTag))\n        return true;\n     return false;\n }", "target": 1}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "void nhml_get_bs(GF_BitStream **bs, char *data, u32 size, u32 mode)\n{\n\tif (*bs) gf_bs_reassign_buffer(*bs, data, size);\n\telse  (*bs) = gf_bs_new(data, size, mode);", "target": 0}
{"code": "handle_keywordonly_args(struct compiling *c, const node *n, int start,\n                        asdl_seq *kwonlyargs, asdl_seq *kwdefaults)\n{\n    PyObject *argname;\n    node *ch;\n    expr_ty expression, annotation;\n    arg_ty arg;\n    int i = start;\n    int j = 0; \n    if (kwonlyargs == NULL) {\n        ast_error(c, CHILD(n, start), \"named arguments must follow bare *\");\n        return -1;\n    }\n    assert(kwdefaults != NULL);\n    while (i < NCH(n)) {\n        ch = CHILD(n, i);\n        switch (TYPE(ch)) {\n            case vfpdef:\n            case tfpdef:\n                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {\n                    expression = ast_for_expr(c, CHILD(n, i + 2));\n                    if (!expression)\n                        goto error;\n                    asdl_seq_SET(kwdefaults, j, expression);\n                    i += 2; \n                }\n                else { \n                    asdl_seq_SET(kwdefaults, j, NULL);\n                }\n                if (NCH(ch) == 3) {\n                    annotation = ast_for_expr(c, CHILD(ch, 2));\n                    if (!annotation)\n                        goto error;\n                }\n                else {\n                    annotation = NULL;\n                }\n                ch = CHILD(ch, 0);\n                argname = NEW_IDENTIFIER(ch);\n                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, LINENO(ch), ch->n_col_offset,\n                          ch->n_end_lineno, ch->n_end_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 2; \n                break;\n            case DOUBLESTAR:\n                return i;\n            default:\n                ast_error(c, ch, \"unexpected node\");\n                goto error;\n        }\n    }\n    return i;\n error:\n    return -1;\n}", "target": 1}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static PassRefPtr<CSSValue> getPositionOffsetValue(RenderStyle* style, CSSPropertyID propertyID, RenderView* renderView)\n{\n    if (!style)\n        return 0;\n    Length l;\n    switch (propertyID) {\n        case CSSPropertyLeft:\n            l = style->left();\n            break;\n        case CSSPropertyRight:\n            l = style->right();\n            break;\n        case CSSPropertyTop:\n            l = style->top();\n            break;\n        case CSSPropertyBottom:\n            l = style->bottom();\n            break;\n        default:\n            return 0;\n    }\n    if (style->position() == AbsolutePosition || style->position() == FixedPosition) {\n        if (l.type() == WebCore::Fixed)\n            return zoomAdjustedPixelValue(l.value(), style);\n        else if (l.isViewportPercentage())\n            return zoomAdjustedPixelValue(valueForLength(l, 0, renderView), style);\n         return cssValuePool().createValue(l);\n     }\n    if (style->position() == RelativePosition)\n         return cssValuePool().createValue(l);\n     return cssValuePool().createIdentifierValue(CSSValueAuto);\n }", "target": 1}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "ldap_pvt_tls_get_peer_dn( void *s, struct berval *dn,\n\tLDAPDN_rewrite_dummy *func, unsigned flags )\n{\n\ttls_session *session = s;\n\tstruct berval bvdn;\n\tint rc;\n\trc = tls_imp->ti_session_peer_dn( session, &bvdn );\n\tif ( rc ) return rc;\n\trc = ldap_X509dn2bv( &bvdn, dn, \n\t\t\t    (LDAPDN_rewrite_func *)func, flags);\n\treturn rc;\n}", "target": 0}
{"code": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n    frame = window->frame();\n    if (!frame)\n        return;\n     Document* doc = frame->document();\n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n{\n    if ((s->data_count & 0x3) != byte_num) {\n        trace_sdhci_error(\"Non-sequential access to Buffer Data Port register\"\n                          \"is prohibited\\n\");\n        return false;\n    }\n    return true;\n}", "target": 0}
{"code": "void LibRaw::fuji_compressed_load_raw()\n{\n  struct fuji_compressed_params common_info;\n  int cur_block;\n  unsigned line_size, *block_sizes;\n  INT64 raw_offset, *raw_block_offsets;\n  init_fuji_compr(&common_info);\n  line_size = sizeof(ushort) * (common_info.line_width + 2);\n  block_sizes = (unsigned *)malloc(\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(block_sizes, \"fuji_compressed_load_raw()\");\n  raw_block_offsets = (INT64 *)malloc(\n      sizeof(INT64) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  merror(raw_block_offsets, \"fuji_compressed_load_raw()\");\n  raw_offset =\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks;\n  if (raw_offset & 0xC)\n    raw_offset += 0x10 - (raw_offset & 0xC);\n  raw_offset += libraw_internal_data.unpacker_data.data_offset;\n  libraw_internal_data.internal_data.input->seek(\n      libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n  libraw_internal_data.internal_data.input->read(\n      block_sizes, 1,\n      sizeof(unsigned) * libraw_internal_data.unpacker_data.fuji_total_blocks);\n  raw_block_offsets[0] = raw_offset;\n  for (cur_block = 0;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n  {\n    unsigned bsize = sgetn(4, (uchar *)(block_sizes + cur_block));\n    block_sizes[cur_block] = bsize;\n  }\n  for (cur_block = 1;\n       cur_block < libraw_internal_data.unpacker_data.fuji_total_blocks;\n       cur_block++)\n    raw_block_offsets[cur_block] =\n        raw_block_offsets[cur_block - 1] + block_sizes[cur_block - 1];\n  fuji_decode_loop(&common_info,\n                   libraw_internal_data.unpacker_data.fuji_total_blocks,\n                   raw_block_offsets, block_sizes);\n  free(block_sizes);\n  free(raw_block_offsets);\n  free(common_info.q_table);\n}", "target": 0}
{"code": "static inline void packet_increment_rx_head(struct packet_sock *po,\n\t\t\t\t\t    struct packet_ring_buffer *rb)\n{\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\tcase TPACKET_V2:\n\t\treturn packet_increment_head(rb);\n\tcase TPACKET_V3:\n\tdefault:\n\t\tWARN(1, \"TPACKET version not supported.\\n\");\n\t\tBUG();\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "Opal::Call::Call (OpalManager& _manager,\n\t\t  Ekiga::ServiceCore& _core,\n\t\t  const std::string& uri)\n  : OpalCall (_manager), Ekiga::Call (), core (_core), remote_uri (uri),\n    call_setup(false), jitter(0), outgoing(false)\n{\n  notification_core = core.get<Ekiga::NotificationCore> (\"notification-core\");\n  re_a_bytes = tr_a_bytes = re_v_bytes = tr_v_bytes = 0.0;\n  last_v_tick = last_a_tick = PTime ();\n  total_a =\n    total_v =\n    lost_a =\n    too_late_a =\n    out_of_order_a =\n    lost_v =\n    too_late_v =\n    out_of_order_v = 0;\n  lost_packets = late_packets = out_of_order_packets = 0.0;\n  re_a_bw = tr_a_bw = re_v_bw = tr_v_bw = 0.0;\n  NoAnswerTimer.SetNotifier (PCREATE_NOTIFIER (OnNoAnswerTimeout));\n}", "target": 0}
{"code": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\tgeneric_fillattr(inode, stat);\n\trcu_read_lock();\n\tstat->uid = 0;\n\tstat->gid = 0;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "void RenderView::OnPepperPluginDestroy(\n    WebPluginDelegatePepper* pepper_plugin) {\n  std::set<WebPluginDelegatePepper*>::iterator found_pepper =\n      current_oldstyle_pepper_plugins_.find(pepper_plugin);\n  if (found_pepper == current_oldstyle_pepper_plugins_.end()) {\n    NOTREACHED();\n    return;\n  }\n  current_oldstyle_pepper_plugins_.erase(found_pepper);\n  for (std::deque< linked_ptr<PendingFileChooser> >::iterator i =\n           file_chooser_completions_.begin();\n       i != file_chooser_completions_.end(); ) {\n    if ((*i)->completion == pepper_plugin) {\n      if (i == file_chooser_completions_.begin())\n        (*i)->completion = NULL;\n      else\n        i = file_chooser_completions_.erase(i);\n    } else {\n      ++i;\n    }\n  }\n}", "target": 0}
{"code": "static zend_long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, size_t sql_len) \n{\n\tpdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;\n\tisc_stmt_handle stmt = PDO_FIREBIRD_HANDLE_INITIALIZER;\n\tstatic char const info_count[] = { isc_info_sql_records };\n\tchar result[64];\n\tint ret = 0;\n\tXSQLDA in_sqlda, out_sqlda;\n\tin_sqlda.version = out_sqlda.version = PDO_FB_SQLDA_VERSION;\n\tin_sqlda.sqld = out_sqlda.sqld = 0;\n\tout_sqlda.sqln = 1;\n\tif (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &out_sqlda, &stmt, 0)) {\n\t\treturn -1;\n\t}\n\tif (isc_dsql_execute2(H->isc_status, &H->tr, &stmt, PDO_FB_SQLDA_VERSION, &in_sqlda, &out_sqlda)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (isc_dsql_sql_info(H->isc_status, &stmt, sizeof(info_count), const_cast(info_count),\n\t\t\tsizeof(result),\tresult)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (result[0] == isc_info_sql_records) {\n\t\tunsigned i = 3, result_size = isc_vax_integer(&result[1],2);\n\t\twhile (result[i] != isc_info_end && i < result_size) {\n\t\t\tshort len = (short)isc_vax_integer(&result[i+1],2);\n\t\t\tif (result[i] != isc_info_req_select_count) {\n\t\t\t\tret += isc_vax_integer(&result[i+3],len);\n\t\t\t}\n\t\t\ti += len+3;\n\t\t}\n\t}\n\tif (dbh->auto_commit && isc_commit_retaining(H->isc_status, &H->tr)) {\n\t\tRECORD_ERROR(dbh);\n\t}\nfree_statement:\n\tif (isc_dsql_free_statement(H->isc_status, &stmt, DSQL_drop)) {\n\t\tRECORD_ERROR(dbh);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "  void* GetData() { return embedder_data_; }", "target": 0}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "static TPM_RESULT SWTPM_NVRAM_GetFilenameForName(char *filename,        \n                                                 size_t bufsize,\n                                                 uint32_t tpm_number,\n                                                 const char *name,      \n                                                 bool is_tempfile)      \n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n    switch (tpmversion) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"%s/TMP%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"%s/tpm%s-%02lx.%s\",\n                     state_directory, suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n    return res;\n}", "target": 0}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1}
{"code": "exif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\tif (!data || !data->priv) \n\t\treturn;\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\t} else\n\t\tdoff = offset + 8;\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}", "target": 1}
{"code": "TEST(QuantizedInt8PoolingOpTest16, MaxPool) {\n  const float ulp = 1.f / 4096.f;\n  SymmetricQuantizedPoolingOpModel16 m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_INT16, {1, 2, 4, 1}, 0, 16 - ulp},\n      2, 2,\n      {TensorType_INT16, {}, 0, 16 - ulp});\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({6, 10})));\n  EXPECT_THAT(m.GetOutput(),\n              ElementsAreArray({(96 - 128) * 256, (160 - 128) * 256}));\n}", "target": 0}
{"code": "void nl80211_send_remain_on_channel_cancel(\n\tstruct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev,\n\tu64 cookie, struct ieee80211_channel *chan, gfp_t gfp)\n{\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}", "target": 0}
{"code": "void metx_box_del(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox*)s;\n\tif (ptr == NULL) return;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tif (ptr->content_encoding) gf_free(ptr->content_encoding);\n\tif (ptr->xml_namespace) gf_free(ptr->xml_namespace);\n\tif (ptr->xml_schema_loc) gf_free(ptr->xml_schema_loc);\n\tif (ptr->mime_type) gf_free(ptr->mime_type);\n\tgf_free(ptr);\n}", "target": 0}
{"code": " OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                            OPJ_UINT32 p_tile_no,\n                            OPJ_UINT32 p_comp_no,\n                            OPJ_UINT32 nb_comps,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_rgn_size;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_UINT32 l_comp_room;\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        if (nb_comps <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n        l_rgn_size = 6 + l_comp_room;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 \n        l_current_data += 2;\n        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          \n        l_current_data+=l_comp_room;\n        opj_write_bytes(l_current_data, 0,1);                                           \n        ++l_current_data;\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            \n        ++l_current_data;\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "flatpak_context_merge (FlatpakContext *context,\n                       FlatpakContext *other)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  context->shares &= ~other->shares_valid;\n  context->shares |= other->shares;\n  context->shares_valid |= other->shares_valid;\n  context->sockets &= ~other->sockets_valid;\n  context->sockets |= other->sockets;\n  context->sockets_valid |= other->sockets_valid;\n  context->devices &= ~other->devices_valid;\n  context->devices |= other->devices;\n  context->devices_valid |= other->devices_valid;\n  context->features &= ~other->features_valid;\n  context->features |= other->features;\n  context->features_valid |= other->features_valid;\n  g_hash_table_iter_init (&iter, other->env_vars);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));\n  g_hash_table_iter_init (&iter, other->persistent);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->persistent, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->filesystems);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->filesystems, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->session_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->system_bus_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);\n  g_hash_table_iter_init (&iter, other->generic_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char **policy_values = (const char **) value;\n      int i;\n      for (i = 0; policy_values[i] != NULL; i++)\n        flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);\n    }\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "void diff_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\tchar concatpath[PATH_MAX];\n\tstruct diff_filespec *one, *two;\n\tif (DIFF_OPT_TST(options, IGNORE_SUBMODULES) && S_ISGITLINK(old_mode)\n\t\t\t&& S_ISGITLINK(new_mode))\n\t\treturn;\n\tif (DIFF_OPT_TST(options, REVERSE_DIFF)) {\n\t\tunsigned tmp;\n\t\tconst unsigned char *tmp_c;\n\t\ttmp = old_mode; old_mode = new_mode; new_mode = tmp;\n\t\ttmp_c = old_sha1; old_sha1 = new_sha1; new_sha1 = tmp_c;\n\t}\n\tif (!path) path = \"\";\n\tsprintf(concatpath, \"%s%s\", base, path);\n\tif (options->prefix &&\n\t    strncmp(concatpath, options->prefix, options->prefix_length))\n\t\treturn;\n\tone = alloc_filespec(concatpath);\n\ttwo = alloc_filespec(concatpath);\n\tfill_filespec(one, old_sha1, old_mode);\n\tfill_filespec(two, new_sha1, new_mode);\n\tdiff_queue(&diff_queued_diff, one, two);\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "void RemoteFsDevice::saveProperties(const DeviceOptions &newOpts, const Details &nd)\n{\n    bool connected=isConnected();\n    if (configured && (!connected || opts==newOpts) && (connected || details==nd)) {\n        return;\n    }\n    bool isLocal=details.isLocalFile();\n    if (connected) {\n        if (!configured) {\n            details.configured=configured=true;\n            details.save();\n        }\n        if (opts.useCache!=newOpts.useCache) {\n            if (opts.useCache) {\n                saveCache();\n            } else if (opts.useCache && !newOpts.useCache) {\n                removeCache();\n            }\n        }\n        opts=newOpts;\n        writeOpts(settingsFileName(), opts, true);\n    }\n    if (!connected || isLocal) {\n        Details newDetails=nd;\n        Details oldDetails=details;\n        bool newName=!oldDetails.name.isEmpty() && oldDetails.name!=newDetails.name;\n        bool newDir=oldDetails.url.path()!=newDetails.url.path();\n        if (isLocal && newDir && opts.useCache) {\n            removeCache();\n        }\n        details=newDetails;\n        details.configured=configured=true;\n        details.save();\n        if (newName) {\n            if (!details.isLocalFile()) {\n                QString oldMount=mountPoint(oldDetails, false);\n                if (!oldMount.isEmpty() && QDir(oldMount).exists()) {\n                    ::rmdir(QFile::encodeName(oldMount).constData());\n                }\n            }\n            setData(details.name);\n            renamed(oldDetails.name, details.name);\n            deviceId=createUdi(details.name);\n            emit udiChanged();\n            m_itemData=details.name;\n            setStatusMessage(QString());\n        }\n        if (isLocal && newDir && scanned) {\n            rescan(true);\n        }\n    }\n    emit configurationChanged();\n}", "target": 0}
{"code": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n        return CR_OK;\n}", "target": 1}
{"code": "mm_answer_pam_start(int socket, Buffer *m)\n{\n\tchar *user;\n\tuser = buffer_get_string(m, NULL);\n\tstart_pam(user);\n\txfree(user);\n\treturn (0);\n}", "target": 0}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "int snd_card_register(struct snd_card *card)\n{\n\tint err;\n\tif (snd_BUG_ON(!card))\n\t\treturn -EINVAL;\n\tif (!card->registered) {\n\t\terr = device_add(&card->card_dev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcard->registered = true;\n\t}\n\tif ((err = snd_device_register_all(card)) < 0)\n\t\treturn err;\n\tmutex_lock(&snd_card_mutex);\n\tif (snd_cards[card->number]) {\n\t\tmutex_unlock(&snd_card_mutex);\n\t\treturn 0;\n\t}\n\tif (*card->id) {\n\t\tchar tmpid[sizeof(card->id)];\n\t\tmemcpy(tmpid, card->id, sizeof(card->id));\n\t\tsnd_card_set_id_no_lock(card, tmpid, tmpid);\n\t} else {\n\t\tconst char *src;\n\t\tsrc = *card->shortname ? card->shortname : card->longname;\n\t\tsnd_card_set_id_no_lock(card, src,\n\t\t\t\t\tretrieve_id_from_card_name(src));\n\t}\n\tsnd_cards[card->number] = card;\n\tmutex_unlock(&snd_card_mutex);\n\tinit_info_for_card(card);\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "    int32_t RotationMap::degrees(uint16_t orientation)\n    {\n        int32_t d = 0;\n        for (int i = 0; omList_[i].orientation != 0; ++i) {\n            if (omList_[i].orientation == orientation) {\n                d = omList_[i].degrees;\n                break;\n            }\n        }\n        return d;\n    }", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "vm_fault_t gru_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct gru_thread_state *gts;\n\tunsigned long paddr, vaddr;\n\tunsigned long expires;\n\tvaddr = vmf->address;\n\tgru_dbg(grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\",\n\t\tvma, vaddr, GSEG_BASE(vaddr));\n\tSTAT(nopfn);\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\tgru_check_context_placement(gts);\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))\n\t\t\t\tgru_steal_context(gts);\n\t\t\tgoto again;\n\t\t}\n\t\tgru_load_context(gts);\n\t\tpaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\n\t\tremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\n\t\t\t\tpaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\n\t\t\t\tvma->vm_page_prot);\n\t}\n\tpreempt_enable();\n\tmutex_unlock(&gts->ts_ctxlock);\n\treturn VM_FAULT_NOPAGE;\n}", "target": 1}
{"code": "void RenderView::removeAutofillSuggestions(const WebString& name,\n                                           const WebString& value) {\n  autofill_helper_.RemoveAutocompleteSuggestion(name, value);\n}", "target": 0}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}", "target": 1}
{"code": "ZEND_API int add_property_string_ex(zval *arg, const char *key, uint key_len, const char *str, int duplicate TSRMLS_DC) \n{\n\tzval *tmp;\n\tzval *z_key;\n\tsize_t _len = strlen(str);\n\tif (UNEXPECTED(_len > INT_MAX)) {\n\t\tzend_error_noreturn(E_ERROR, \"String overflow, max size is %d\", INT_MAX);\n\t}\n\tMAKE_STD_ZVAL(tmp);\n\tZVAL_STRINGL(tmp, str, _len, duplicate);\n\tMAKE_STD_ZVAL(z_key);\n\tZVAL_STRINGL(z_key, key, key_len-1, 1);\n\tZ_OBJ_HANDLER_P(arg, write_property)(arg, z_key, tmp, 0 TSRMLS_CC);\n\tzval_ptr_dtor(&tmp); \n\tzval_ptr_dtor(&z_key);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int check_cert(X509_STORE_CTX *ctx)\n{\n    X509_CRL *crl = NULL, *dcrl = NULL;\n    X509 *x = NULL;\n    int ok = 0, cnum = 0;\n    unsigned int last_reasons = 0;\n    cnum = ctx->error_depth;\n    x = sk_X509_value(ctx->chain, cnum);\n    ctx->current_cert = x;\n    ctx->current_issuer = NULL;\n    ctx->current_crl_score = 0;\n    ctx->current_reasons = 0;\n    while (ctx->current_reasons != CRLDP_ALL_REASONS) {\n        last_reasons = ctx->current_reasons;\n        if (ctx->get_crl)\n            ok = ctx->get_crl(ctx, &crl, x);\n        else\n            ok = get_crl_delta(ctx, &crl, &dcrl, x);\n        if (!ok) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n        ctx->current_crl = crl;\n        ok = ctx->check_crl(ctx, crl);\n        if (!ok)\n            goto err;\n        if (dcrl) {\n            ok = ctx->check_crl(ctx, dcrl);\n            if (!ok)\n                goto err;\n            ok = ctx->cert_crl(ctx, dcrl, x);\n            if (!ok)\n                goto err;\n        } else\n            ok = 1;\n        if (ok != 2) {\n            ok = ctx->cert_crl(ctx, crl, x);\n            if (!ok)\n                goto err;\n        }\n        X509_CRL_free(crl);\n        X509_CRL_free(dcrl);\n        crl = NULL;\n        dcrl = NULL;\n        if (last_reasons == ctx->current_reasons) {\n            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\n            ok = ctx->verify_cb(0, ctx);\n            goto err;\n        }\n    }\n err:\n    X509_CRL_free(crl);\n    X509_CRL_free(dcrl);\n    ctx->current_crl = NULL;\n    return ok;\n}", "target": 0}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "static void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\tsp = sctp_sk(sk);\n\tif (sp->ep == NULL)\n\t\treturn;\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}", "target": 1}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "static int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}", "target": 0}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\tif (kvm_x86_ops->has_wbinvd_exit()) {\n\t\tint cpu = get_cpu();\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\tsmp_call_function_many(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "struct bio *bio_map_kern(struct request_queue *q, void *data, unsigned int len,\n\t\t\t gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tint offset, i;\n\tstruct bio *bio;\n\tbio = bio_kmalloc(gfp_mask, nr_pages);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\t\tif (bio_add_pc_page(q, bio, virt_to_page(data), bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\tbio_put(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}", "target": 0}
{"code": "static int __feat_register_sp(struct list_head *fn, u8 feat, u8 is_local,\n\t\t\t      u8 mandatory, u8 const *sp_val, u8 sp_len)\n{\n\tdccp_feat_val fval;\n\tif (dccp_feat_type(feat) != FEAT_SP ||\n\t    !dccp_feat_sp_list_ok(feat, sp_val, sp_len))\n\t\treturn -EINVAL;\n\tif (feat == DCCPF_CCID && !ccid_support_check(sp_val, sp_len))\n\t\treturn -EOPNOTSUPP;\n\tif (dccp_feat_clone_sp_val(&fval, sp_val, sp_len))\n\t\treturn -ENOMEM;\n\treturn dccp_feat_push_change(fn, feat, is_local, mandatory, &fval);\n}", "target": 1}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "RenderViewImpl* RenderViewImpl::Create(\n    int32 opener_id,\n    const RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int32 surface_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name,\n    bool is_renderer_created,\n    bool swapped_out,\n    int32 next_page_id,\n    const WebKit::WebScreenInfo& screen_info,\n    AccessibilityMode accessibility_mode) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  RenderViewImplParams params(\n      opener_id,\n      renderer_prefs,\n      webkit_prefs,\n      counter,\n      routing_id,\n      surface_id,\n      session_storage_namespace_id,\n      frame_name,\n      is_renderer_created,\n      swapped_out,\n      next_page_id,\n      screen_info,\n      accessibility_mode);\n  if (g_create_render_view_impl)\n    return g_create_render_view_impl(&params);\n  return new RenderViewImpl(&params);\n}", "target": 0}
{"code": "static int dump_suid_policy()\n{\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n    return suid_dump_policy;\n}", "target": 0}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 1}
{"code": "static void evdev_cleanup(struct evdev *evdev)\n{\n\tstruct input_handle *handle = &evdev->handle;\n\tevdev_mark_dead(evdev);\n\tevdev_hangup(evdev);\n\tcdev_del(&evdev->cdev);\n\tif (evdev->open) {\n\t\tinput_flush_device(handle, NULL);\n\t\tinput_close_device(handle);\n\t}\n}", "target": 0}
{"code": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "void ZeroSuggestProvider::Run(const GURL& suggest_url) {\n  if (OmniboxFieldTrial::InZeroSuggestMostVisitedFieldTrial()) {\n    most_visited_urls_.clear();\n    scoped_refptr<history::TopSites> ts = client()->GetTopSites();\n    if (ts) {\n      waiting_for_most_visited_urls_request_ = true;\n      ts->GetMostVisitedURLs(\n          base::Bind(&ZeroSuggestProvider::OnMostVisitedUrlsAvailable,\n                     weak_ptr_factory_.GetWeakPtr()), false);\n    }\n  } else {\n    net::NetworkTrafficAnnotationTag traffic_annotation =\n        net::DefineNetworkTrafficAnnotation(\"omnibox_zerosuggest\", R\"(\n        semantics {\n          sender: \"Omnibox\"\n          description:\n            \"When the user focuses the omnibox, Chrome can provide search or \"\n            \"navigation suggestions from the default search provider in the \"\n            \"omnibox dropdown, based on the current page URL.\\n\"\n            \"This is limited to users whose default search engine is Google, \"\n            \"as no other search engines currently support this kind of \"\n            \"suggestion.\"\n          trigger: \"The omnibox receives focus.\"\n          data: \"The URL of the current page.\"\n          destination: GOOGLE_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: true\n          cookies_store: \"user\"\n          setting:\n            \"Users can control this feature via the 'Use a prediction service \"\n            \"to help complete searches and URLs typed in the address bar' \"\n            \"settings under 'Privacy'. The feature is enabled by default.\"\n          chrome_policy {\n            SearchSuggestEnabled {\n                policy_options {mode: MANDATORY}\n                SearchSuggestEnabled: false\n            }\n          }\n        })\");\n    const int kFetcherID = 1;\n    fetcher_ =\n        net::URLFetcher::Create(kFetcherID, suggest_url, net::URLFetcher::GET,\n                                this, traffic_annotation);\n    data_use_measurement::DataUseUserData::AttachToFetcher(\n        fetcher_.get(), data_use_measurement::DataUseUserData::OMNIBOX);\n    fetcher_->SetRequestContext(client()->GetRequestContext());\n    fetcher_->SetLoadFlags(net::LOAD_DO_NOT_SAVE_COOKIES);\n    net::HttpRequestHeaders headers;\n    bool is_signed_in = false;\n    variations::AppendVariationHeaders(fetcher_->GetOriginalURL(),\n                                       client()->IsOffTheRecord(), false,\n                                       is_signed_in, &headers);\n    fetcher_->SetExtraRequestHeaders(headers.ToString());\n    fetcher_->Start();\n    LogOmniboxZeroSuggestRequest(ZERO_SUGGEST_REQUEST_SENT);\n  }\n}", "target": 0}
{"code": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n    return schema.detach();\n  }", "target": 1}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "static inline void skb_get_timestampns(const struct sk_buff *skb,\n\t\t\t\t       struct timespec *stamp)\n{\n\t*stamp = ktime_to_timespec(skb->tstamp);\n}", "target": 0}
{"code": "njs_string_to_number(const njs_value_t *value, njs_bool_t parse_float)\n{\n    double             num;\n    njs_bool_t         minus;\n    const u_char       *p, *start, *end;\n    njs_string_prop_t  string;\n    const size_t  infinity = njs_length(\"Infinity\");\n    (void) njs_string_trim(value, &string, NJS_TRIM_START);\n    p = string.start;\n    end = p + string.size;\n    if (p == end) {\n        return parse_float ? NAN : 0.0;\n    }\n    minus = 0;\n    if (*p == '+') {\n        p++;\n    } else if (*p == '-') {\n        p++;\n        minus = 1;\n    }\n    if (p == end) {\n        return NAN;\n    }\n    if (!parse_float\n        && p + 2 < end && p[0] == '0' && (p[1] == 'x' || p[1] == 'X'))\n    {\n        p += 2;\n        num = njs_number_hex_parse(&p, end, 0);\n    } else {\n        start = p;\n        num = njs_number_dec_parse(&p, end, 0);\n        if (p == start) {\n            if (p + infinity > end || memcmp(p, \"Infinity\", infinity) != 0) {\n                return NAN;\n            }\n            num = INFINITY;\n            p += infinity;\n        }\n    }\n    if (!parse_float) {\n        while (p < end) {\n            if (*p != ' ' && *p != '\\t') {\n                return NAN;\n            }\n            p++;\n        }\n    }\n    return minus ? -num : num;\n}", "target": 0}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::IncrementInFlightEventCount() {\n  increment_in_flight_event_count();\n  if (!is_hidden_)\n    StartHangMonitorTimeout(hung_renderer_delay_);\n}", "target": 0}
{"code": "struct vfsmount *mnt_clone_internal(struct path *path)\n{\n\tstruct mount *p;\n\tp = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);\n\tif (IS_ERR(p))\n\t\treturn ERR_CAST(p);\n\tp->mnt.mnt_flags |= MNT_INTERNAL;\n\treturn &p->mnt;\n}", "target": 0}
{"code": "static inline unsigned char *PopLongPixel(const EndianType endian,\n  const unsigned int pixel,unsigned char *pixels)\n{\n  register unsigned int\n    quantum;\n  quantum=(unsigned int) pixel;\n  if (endian == LSBEndian)\n    {\n      *pixels++=(unsigned char) (quantum);\n      *pixels++=(unsigned char) (quantum >> 8);\n      *pixels++=(unsigned char) (quantum >> 16);\n      *pixels++=(unsigned char) (quantum >> 24);\n      return(pixels);\n    }\n  *pixels++=(unsigned char) (quantum >> 24);\n  *pixels++=(unsigned char) (quantum >> 16);\n  *pixels++=(unsigned char) (quantum >> 8);\n  *pixels++=(unsigned char) (quantum);\n  return(pixels);\n}", "target": 0}
{"code": "GF_Err mdia_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 cookie = gf_bs_get_cookie(bs);\n\tcookie &= ~GF_ISOM_BS_COOKIE_VISUAL_TRACK;\n\tgf_bs_set_cookie(bs, cookie);\n\te = gf_isom_box_array_read(s, bs, mdia_on_child_box);\n\tgf_bs_set_cookie(bs, cookie);\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "is_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}", "target": 0}
{"code": "void encode(ArgumentEncoder* encoder, CFNumberRef number)\n{\n    CFNumberType numberType = CFNumberGetType(number);\n    Vector<uint8_t> buffer(CFNumberGetByteSize(number));\n    bool result = CFNumberGetValue(number, numberType, buffer.data());\n    ASSERT_UNUSED(result, result);\n    encoder->encodeEnum(numberType);\n    encoder->encodeVariableLengthByteArray(buffer);\n}", "target": 0}
{"code": "static void exif_process_TIFF_in_JPEG(image_info_type *ImageInfo, char *CharBuf, size_t length, size_t displacement)\n{\n\tunsigned exif_value_2a, offset_of_ifd;\n\tif (memcmp(CharBuf, \"II\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 0;\n\t} else if (memcmp(CharBuf, \"MM\", 2) == 0) {\n\t\tImageInfo->motorola_intel = 1;\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF alignment marker\");\n\t\treturn;\n\t}\n\tif (length < 8) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\texif_value_2a = php_ifd_get16u(CharBuf+2, ImageInfo->motorola_intel);\n\toffset_of_ifd = php_ifd_get32u(CharBuf+4, ImageInfo->motorola_intel);\n\tif (exif_value_2a != 0x2a || offset_of_ifd < 0x08) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid TIFF start (1)\");\n\t\treturn;\n\t}\n\tif (offset_of_ifd > length) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Invalid IFD start\");\n\t\treturn;\n\t}\n\tImageInfo->sections_found |= FOUND_IFD0;\n\texif_process_IFD_in_JPEG(ImageInfo, CharBuf+offset_of_ifd, CharBuf, length, displacement, SECTION_IFD0, 0);\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process TIFF in JPEG done\");\n#endif\n\tif (ImageInfo->FocalplaneXRes != 0) {\n\t\tImageInfo->CCDWidth = (float)(ImageInfo->ExifImageWidth * ImageInfo->FocalplaneUnits / ImageInfo->FocalplaneXRes);\n\t}\n}", "target": 0}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "isdn_statstr(void)\n{\n\tstatic char istatbuf[2048];\n\tchar *p;\n\tint i;\n\tsprintf(istatbuf, \"idmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", (dev->drvmap[i] < 0) ? \"-\" : dev->drvid[dev->drvmap[i]]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nchmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->chanmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\ndrmap:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->drvmap[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nusage:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%d \", dev->usage[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\nflags:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++) {\n\t\tif (dev->drv[i]) {\n\t\t\tsprintf(p, \"%ld \", dev->drv[i]->online);\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t} else {\n\t\t\tsprintf(p, \"? \");\n\t\t\tp = istatbuf + strlen(istatbuf);\n\t\t}\n\t}\n\tsprintf(p, \"\\nphone:\\t\");\n\tp = istatbuf + strlen(istatbuf);\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\tsprintf(p, \"%s \", dev->num[i]);\n\t\tp = istatbuf + strlen(istatbuf);\n\t}\n\tsprintf(p, \"\\n\");\n\treturn istatbuf;\n}", "target": 0}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::CreateBrowserAccessibilityManagerIfNeeded() {\n  if (GetBrowserAccessibilityManager())\n    return;\n#if defined(OS_WIN)\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (!dispatcher)\n    return;\n  HWND hwnd = dispatcher->host()->GetAcceleratedWidget();\n  gfx::NativeViewAccessible accessible_parent =\n      host_->GetParentNativeViewAccessible();\n  BrowserAccessibilityManager* manager = new BrowserAccessibilityManagerWin(\n      hwnd, accessible_parent,\n      BrowserAccessibilityManagerWin::GetEmptyDocument(), this);\n#else\n  BrowserAccessibilityManager* manager = BrowserAccessibilityManager::Create(\n      BrowserAccessibilityManager::GetEmptyDocument(), this);\n#endif\n  SetBrowserAccessibilityManager(manager);\n}", "target": 0}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "mm_request_send(int socket, enum monitor_reqtype type, Buffer *m)\n{\n\tu_int mlen = buffer_len(m);\n\tu_char buf[5];\n\tdebug3(\"%s entering: type %d\", __func__, type);\n\tPUT_32BIT(buf, mlen + 1);\n\tbuf[4] = (u_char) type;\t\t\n\tif (atomicio(write, socket, buf, sizeof(buf)) != sizeof(buf))\n\t\tfatal(\"%s: write\", __func__);\n\tif (atomicio(write, socket, buffer_ptr(m), mlen) != mlen)\n\t\tfatal(\"%s: write\", __func__);\n}", "target": 0}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "static int __iommu_calculate_agaw(struct intel_iommu *iommu, int max_gaw)\n{\n\tunsigned long sagaw;\n\tint agaw = -1;\n\tsagaw = cap_sagaw(iommu->cap);\n\tfor (agaw = width_to_agaw(max_gaw);\n\t     agaw >= 0; agaw--) {\n\t\tif (test_bit(agaw, &sagaw))\n\t\t\tbreak;\n\t}\n\treturn agaw;\n}", "target": 0}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\tdata->flags = 0;\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\treturn 0;\n}", "target": 1}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "static size_t php_pgsql_fd_read(php_stream *stream, char *buf, size_t count) \n{\n\treturn 0;\n}", "target": 0}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "static int find_length(struct pdf_struct *pdf,\n\t\t       struct pdf_obj *obj,\n\t\t       const char *start, off_t len)\n{\n    int length;\n    const char *q;\n    q = cli_memstr(start, len, \"/Length\", 7);\n    if (!q)\n\treturn 0;\n    q++;\n    len -= q - start;\n    start = pdf_nextobject(q, len);\n    if (!start)\n\treturn 0;\n    q = start;\n    length = atoi(q);\n    while (isdigit(*q)) q++;\n    if (*q == ' ') {\n\tint genid;\n\tq++;\n\tgenid = atoi(q);\n\twhile(isdigit(*q)) q++;\n\tif (q[0] == ' ' && q[1] == 'R') {\n\t    cli_dbgmsg(\"cli_pdf: length is in indirect object %u %u\\n\", length, genid);\n\t    obj = find_obj(pdf, obj, (length << 8) | (genid&0xff));\n\t    if (!obj) {\n\t\tcli_dbgmsg(\"cli_pdf: indirect object not found\\n\");\n\t\treturn 0;\n\t    }\n\t    q = pdf_nextobject(pdf->map+obj->start, pdf->size - obj->start);\n\t    length = atoi(q);\n\t}\n    }\n    if (start - pdf->map + length+5 > pdf->size) {\n\tlength = pdf->size - (start - pdf->map)-5;\n    }\n    return length;\n}", "target": 0}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "static ssize_t store_int_with_restart(struct device *s,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tssize_t ret = device_store_int(s, attr, buf, size);\n\tmce_restart();\n\treturn ret;\n}", "target": 1}
{"code": "bool Virtual_tmp_table::sp_set_all_fields_from_item(THD *thd, Item *value)\n{\n  DBUG_ASSERT(value->is_fixed());\n  DBUG_ASSERT(value->cols() == s->fields);\n  for (uint i= 0; i < value->cols(); i++)\n  {\n    if (field[i]->sp_prepare_and_store_item(thd, value->addr(i)))\n      return true;\n  }\n  return false;\n}", "target": 0}
{"code": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\t\tif (len >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\treturn ret;\n}", "target": 1}
{"code": "void FoFiTrueType::cvtCharStrings(char **encoding,\n\t\t\t\t  int *codeToGID,\n\t\t\t\t  FoFiOutputFunc outputFunc,\n\t\t\t\t  void *outputStream) {\n  char *name;\n  GooString *buf;\n  char buf2[16];\n  int i, k;\n  (*outputFunc)(outputStream, \"/CharStrings 256 dict dup begin\\n\", 32);\n  (*outputFunc)(outputStream, \"/.notdef 0 def\\n\", 15);\n  if (nCmaps == 0) {\n    goto err;\n  }\n  k = 0; \n  for (i = 255; i >= 0; --i) {\n    if (encoding) {\n      name = encoding[i];\n    } else {\n      sprintf(buf2, \"c%02x\", i);\n      name = buf2;\n    }\n    if (name && strcmp(name, \".notdef\")) {\n      k = codeToGID[i];\n      if (k > 0 && k < nGlyphs) {\n\t(*outputFunc)(outputStream, \"/\", 1);\n\t(*outputFunc)(outputStream, name, strlen(name));\n\tbuf = GooString::format(\" {0:d} def\\n\", k);\n\t(*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n\tdelete buf;\n      }\n    }\n  }\n err:\n  (*outputFunc)(outputStream, \"end readonly def\\n\", 17);\n}", "target": 0}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": "SV*\nPerl_reg_named_buff_nextkey(pTHX_ REGEXP * const r, const U32 flags)\n{\n    struct regexp *const rx = ReANY(r);\n    GET_RE_DEBUG_FLAGS_DECL;\n    PERL_ARGS_ASSERT_REG_NAMED_BUFF_NEXTKEY;\n    if (rx && RXp_PAREN_NAMES(rx)) {\n        HV *hv = RXp_PAREN_NAMES(rx);\n        HE *temphe;\n        while ( (temphe = hv_iternext_flags(hv, 0)) ) {\n            IV i;\n            IV parno = 0;\n            SV* sv_dat = HeVAL(temphe);\n            I32 *nums = (I32*)SvPVX(sv_dat);\n            for ( i = 0; i < SvIVX(sv_dat); i++ ) {\n                if ((I32)(rx->lastparen) >= nums[i] &&\n                    rx->offs[nums[i]].start != -1 &&\n                    rx->offs[nums[i]].end != -1)\n                {\n                    parno = nums[i];\n                    break;\n                }\n            }\n            if (parno || flags & RXapif_ALL) {\n\t\treturn newSVhek(HeKEY_hek(temphe));\n            }\n        }\n    }\n    return NULL;", "target": 0}
{"code": "bool HTMLMediaElement::HasNativeControls() {\n  return ShouldShowControls(RecordMetricsBehavior::kDoRecord);\n}", "target": 0}
{"code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }", "target": 1}
{"code": "onigenc_mb4_code_to_mbc(OnigEncoding enc, OnigCodePoint code, UChar *buf)\n{\n  UChar *p = buf;\n  if ((code & 0xff000000) != 0) {\n    *p++ = (UChar )((code >> 24) & 0xff);\n  }\n  if ((code & 0xff0000) != 0 || p != buf) {\n    *p++ = (UChar )((code >> 16) & 0xff);\n  }\n  if ((code & 0xff00) != 0 || p != buf) {\n    *p++ = (UChar )((code >> 8) & 0xff);\n  }\n  *p++ = (UChar )(code & 0xff);\n#if 1\n  if (enclen(enc, buf, p) != (p - buf))\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n#endif\n  return (int )(p - buf);\n}", "target": 0}
{"code": "int posix_cpu_clock_get(const clockid_t which_clock, struct timespec *tp)\n{\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\tint error = -EINVAL;\n\tunion cpu_time_count rtn;\n\tif (pid == 0) {\n\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t current, &rtn);\n\t\t} else {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\terror = cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t       current, &rtn);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p) {\n\t\t\tif (CPUCLOCK_PERTHREAD(which_clock)) {\n\t\t\t\tif (same_thread_group(p, current)) {\n\t\t\t\t\terror = cpu_clock_sample(which_clock,\n\t\t\t\t\t\t\t\t p, &rtn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tread_lock(&tasklist_lock);\n\t\t\t\tif (thread_group_leader(p) && p->signal) {\n\t\t\t\t\terror =\n\t\t\t\t\t    cpu_clock_sample_group(which_clock,\n\t\t\t\t\t\t\t           p, &rtn);\n\t\t\t\t}\n\t\t\t\tread_unlock(&tasklist_lock);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (error)\n\t\treturn error;\n\tsample_to_timespec(which_clock, rtn, tp);\n\treturn 0;\n}", "target": 0}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)\n{\n\tmutex_lock(&speakup_tty_mutex);\n\tif (in_synth->alive && speakup_tty && speakup_tty->ops->write) {\n\t\tint ret = speakup_tty->ops->write(speakup_tty, &ch, 1);\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"%s: I/O error, deactivating speakup\\n\",\n\t\t\t\tin_synth->long_name);\n\t\t\tin_synth->alive = 0;\n\t\t\tspeakup_start_ttys();\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tmutex_unlock(&speakup_tty_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\tnested_free_all_saved_vmcss(vmx);\n}", "target": 0}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_not_impl(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}", "target": 0}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "TranslateInfoBarDelegate* TranslateManager::GetTranslateInfoBarDelegate(\n    TabContents* tab) {\n  for (int i = 0; i < tab->infobar_delegate_count(); ++i) {\n    TranslateInfoBarDelegate* delegate =\n        tab->GetInfoBarDelegateAt(i)->AsTranslateInfoBarDelegate();\n    if (delegate)\n      return delegate;\n  }\n  return NULL;\n}", "target": 0}
{"code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n  idata->state = IMAP_CONNECTED;\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n  return 0;\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}", "target": 1}
{"code": " cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const cdf_directory_t *root_storage)\n {\n         cdf_summary_info_header_t si;\n         cdf_property_info_t *info;\n        size_t count;\n        int m;\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n                if (file_printf(ms, \"Composite Document File V2 Document\")\n\t\t    == -1)\n                        return -1;\n                if (file_printf(ms, \", %s Endian\",\n                    si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \", Os: Windows, Version %d.%d\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \", Os: MacOS, Version %d.%d\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                 return -2;\n                         break;\n                 }\n\t\tif (root_storage) {\n\t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);\n\t\t\tif (str)\n\t\t\t\tif (file_printf(ms, \", %s\", str) == -1)\n\t\t\t\t\treturn -2;\n\t\t\t}\n\t\t}\n        m = cdf_file_property_info(ms, info, count, root_storage);\n         free(info);\n         return m == -1 ? -2 : m;\n}", "target": 0}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "cursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    \n{\n    linenr_T\tlnum;\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    while (n--)\n\t    {\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\tif (n > 0 || !((State & INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n    coladvance(curwin->w_curswant);\n    if (upd_topline)\n\tupdate_topline();\t\n    return OK;\n}", "target": 0}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}", "target": 1}
{"code": "smb2_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease *buf;\n\tbuf = kzalloc(sizeof(struct create_lease), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}", "target": 0}
{"code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "spice_server_char_device_add_interface(SpiceServer *reds, SpiceBaseInstance *sin)\n{\n    SpiceCharDeviceInstance* char_device =\n            SPICE_UPCAST(SpiceCharDeviceInstance, sin);\n    red::shared_ptr<RedCharDevice> dev_state;\n    spice_debug(\"CHAR_DEVICE %s\", char_device->subtype);\n    if (strcmp(char_device->subtype, SUBTYPE_VDAGENT) == 0) {\n        if (reds->vdagent) {\n            spice_warning(\"vdagent already attached\");\n            return -1;\n        }\n        dev_state = attach_to_red_agent(reds, char_device);\n    }\n#ifdef USE_SMARTCARD\n    else if (strcmp(char_device->subtype, SUBTYPE_SMARTCARD) == 0) {\n        dev_state = smartcard_device_connect(reds, char_device);\n        if (!dev_state) {\n            return -1;\n        }\n    }\n#endif\n    else if (strcmp(char_device->subtype, SUBTYPE_USBREDIR) == 0) {\n        dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_USBREDIR);\n    }\n    else if (strcmp(char_device->subtype, SUBTYPE_PORT) == 0) {\n        if (strcmp(char_device->portname, \"org.spice-space.webdav.0\") == 0) {\n            dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_WEBDAV);\n        } else if (strcmp(char_device->portname, \"org.spice-space.stream.0\") == 0) {\n            dev_state = stream_device_connect(reds, char_device);\n        } else {\n            dev_state = spicevmc_device_connect(reds, char_device, SPICE_CHANNEL_PORT);\n        }\n    }\n    if (dev_state) {\n        spice_assert(dev_state.get() == char_device->st);\n        if (reds->vm_running) {\n            dev_state->start();\n        }\n        reds_add_char_device(reds, dev_state);\n    } else {\n        spice_warning(\"failed to create device state for %s\", char_device->subtype);\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "cmd_genkey (assuan_context_t ctx, char *line)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  int rc;\n  char *keyno;\n  int force;\n  const char *s;\n  time_t timestamp;\n  if ( IS_LOCKED (ctrl) )\n    return gpg_error (GPG_ERR_LOCKED);\n  force = has_option (line, \"--force\");\n  if ((s=has_option_name (line, \"--timestamp\")))\n    {\n      if (*s != '=')\n        return set_error (GPG_ERR_ASS_PARAMETER, \"missing value for option\");\n      timestamp = isotime2epoch (s+1);\n      if (timestamp < 1)\n        return set_error (GPG_ERR_ASS_PARAMETER, \"invalid time value\");\n    }\n  else\n    timestamp = 0;\n  line = skip_options (line);\n  if (!*line)\n    return set_error (GPG_ERR_ASS_PARAMETER, \"no key number given\");\n  keyno = line;\n  while (*line && !spacep (line))\n    line++;\n  *line = 0;\n  if ((rc = open_card (ctrl, NULL)))\n    return rc;\n  if (!ctrl->app_ctx)\n    return gpg_error (GPG_ERR_UNSUPPORTED_OPERATION);\n  keyno = xtrystrdup (keyno);\n  if (!keyno)\n    return out_of_core ();\n  rc = app_genkey (ctrl->app_ctx, ctrl, keyno, force? 1:0,\n                   timestamp, pin_cb, ctx);\n  xfree (keyno);\n  TEST_CARD_REMOVAL (ctrl, rc);\n  return rc;\n}", "target": 0}
{"code": "GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                   int64_t count, Error **errp)\n{\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    HANDLE fh;\n    bool is_ok;\n    DWORD read_count;\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64\n                   \"' is invalid for argument count\", count);\n        return NULL;\n    }\n    fh = gfh->fh;\n    buf = g_malloc0(count+1);\n    is_ok = ReadFile(fh, buf, count, &read_count, NULL);\n    if (!is_ok) {\n        error_setg_win32(errp, GetLastError(), \"failed to read file\");\n        slog(\"guest-file-read failed, handle %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = (size_t)read_count;\n        read_data->eof = read_count == 0;\n        if (read_count != 0) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n    }\n    g_free(buf);\n    return read_data;\n}", "target": 1}
{"code": "static void xmlGROW (xmlParserCtxtPtr ctxt) {\n    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;\n    unsigned long curBase = ctxt->input->cur - ctxt->input->base;\n    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||\n         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&\n         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != (xmlInputReadCallback) xmlNop)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        ctxt->instate = XML_PARSER_EOF;\n    }\n    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&\n        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n\t    xmlPopInput(ctxt);\n}", "target": 1}
{"code": "g_Ctoc(const Char *str, char *buf, unsigned int len)\n{\n    while (len--) {\n        if ((*buf++ = *str++) == EOS) {\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n  smatch match;\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n    return a;\n  }\n  return none;\n}", "target": 1}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n}", "target": 1}
{"code": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui);\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n        return get_manuf_name(oui);\n    }\n    return \"\";\n}", "target": 1}
{"code": "SPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}", "target": 0}
{"code": "storageConnectStoragePoolEventDeregisterAny(virConnectPtr conn,\n                                            int callbackID)\n{\n    if (virConnectStoragePoolEventDeregisterAnyEnsureACL(conn) < 0)\n        return -1;\n    if (virObjectEventStateDeregisterID(conn,\n                                        driver->storageEventState,\n                                        callbackID, true) < 0)\n        return -1;\n    return 0;\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int vsock_create(struct net *net, struct socket *sock,\n\t\t\tint protocol, int kern)\n{\n\tif (!sock)\n\t\treturn -EINVAL;\n\tif (protocol && protocol != PF_VSOCK)\n\t\treturn -EPROTONOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tsock->ops = &vsock_dgram_ops;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsock->ops = &vsock_stream_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock->state = SS_UNCONNECTED;\n\treturn __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;\n}", "target": 0}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}", "target": 1}
{"code": "unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);\n}", "target": 0}
{"code": "static int proc_fd_permission(struct inode *inode, int mask,\n\t\t\t\tstruct nameidata *nd)\n{\n\tint rv;\n\trv = generic_permission(inode, mask, NULL);\n\tif (rv == 0)\n\t\treturn 0;\n\tif (task_pid(current) == proc_pid(inode))\n\t\trv = 0;\n\treturn rv;\n}", "target": 0}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "    void registerMockedHttpURLLoad(const std::string& fileName)\n    {\n        URLTestHelpers::registerMockedURLFromBaseURL(WebString::fromUTF8(m_baseURL.c_str()), WebString::fromUTF8(fileName.c_str()));\n    }", "target": 0}
{"code": "xfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\tASSERT(args->index < ichdr.count);\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "static void edge_heartbeat_schedule(struct edgeport_serial *edge_serial)\n{\n\tif (!edge_serial->use_heartbeat)\n\t\treturn;\n\tschedule_delayed_work(&edge_serial->heartbeat_work,\n\t\t\tFW_HEARTBEAT_SECS * HZ);\n}", "target": 0}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "static NTSTATUS ldapsrv_DelRequest(struct ldapsrv_call *call)\n{\n\tstruct ldap_DelRequest *req = &call->request->r.DelRequest;\n\tstruct ldap_Result *del_result;\n\tstruct ldapsrv_reply *del_reply;\n\tTALLOC_CTX *local_ctx;\n\tstruct ldb_context *samdb = call->conn->ldb;\n\tstruct ldb_dn *dn;\n\tconst char *errstr = NULL;\n\tint result = LDAP_SUCCESS;\n\tint ldb_ret;\n\tstruct ldb_result *res = NULL;\n\tDEBUG(10, (\"DelRequest\"));\n\tDEBUGADD(10, (\" dn: %s\\n\", req->dn));\n\tlocal_ctx = talloc_named(call, 0, \"DelRequest local memory context\");\n\tNT_STATUS_HAVE_NO_MEMORY(local_ctx);\n\tdn = ldb_dn_new(local_ctx, samdb, req->dn);\n\tNT_STATUS_HAVE_NO_MEMORY(dn);\n\tDEBUG(10, (\"DelRequest: dn: [%s]\\n\", req->dn));\n\tdel_reply = ldapsrv_init_reply(call, LDAP_TAG_DelResponse);\n\tNT_STATUS_HAVE_NO_MEMORY(del_reply);\n\tif (result == LDAP_SUCCESS) {\n\t\tres = talloc_zero(local_ctx, struct ldb_result);\n\t\tNT_STATUS_HAVE_NO_MEMORY(res);\n\t\tldb_ret = ldapsrv_del_with_controls(call, dn, call->request->controls, res);\n\t\tresult = map_ldb_error(local_ctx, ldb_ret, ldb_errstring(samdb),\n\t\t\t\t       &errstr);\n\t}\n\tdel_result = &del_reply->msg->r.DelResponse;\n\tdel_result->dn = NULL;\n\tif ((res != NULL) && (res->refs != NULL)) {\n\t\tdel_result->resultcode = map_ldb_error(local_ctx,\n\t\t\t\t\t\t       LDB_ERR_REFERRAL, NULL,\n\t\t\t\t\t\t       &errstr);\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = talloc_strdup(call, *res->refs);\n\t} else {\n\t\tdel_result->resultcode = result;\n\t\tdel_result->errormessage = (errstr?talloc_strdup(del_reply,errstr):NULL);\n\t\tdel_result->referral = NULL;\n\t}\n\ttalloc_free(local_ctx);\n\treturn ldapsrv_queue_reply(call, del_reply);\n}", "target": 0}
{"code": "void setup_work_tree(void)\n{\n\tconst char *work_tree, *git_dir;\n\tstatic int initialized = 0;\n\tif (initialized)\n\t\treturn;\n\twork_tree = get_git_work_tree();\n\tgit_dir = get_git_dir();\n\tif (!is_absolute_path(git_dir))\n\t\tset_git_dir(make_absolute_path(git_dir));\n\tif (!work_tree || chdir(work_tree))\n\t\tdie(\"This operation must be run in a work tree\");\n\tinitialized = 1;\n}", "target": 0}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "static const char *subtype_to_string(uint32_t subtype)\n{\n\tswitch (subtype & 0x03) {\n\tcase 0x01:\n\t\treturn \"Audio Book\";\n\tcase 0x02:\n\t\treturn \"Podcast\";\n\tcase 0x03:\n\t\treturn \"Audio Book, Podcast\";\n\t}\n\treturn \"None\";\n}", "target": 0}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = udp_hdr(p);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n\t\t    uh->len != uh2->len ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\t\treturn pp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void slab_bug(struct kmem_cache *s, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"=============================================================================\\n\");\n\tpr_err(\"BUG %s (%s): %pV\\n\", s->name, print_tainted(), &vaf);\n\tpr_err(\"-----------------------------------------------------------------------------\\n\\n\");\n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n\tva_end(args);\n}", "target": 0}
{"code": "static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tpgtable_pmd_page_dtor(virt_to_page(pmd));\n\tcrst_table_free(mm, (unsigned long *) pmd);\n}", "target": 0}
{"code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldl_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static PHP_INI_MH(OnUpdateInternalEncoding)\n{\n\tif (new_value) {\n\t\tOnUpdateString(entry, new_value, mh_arg1, mh_arg2, mh_arg3, stage);\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "void bootp_input(struct mbuf *m)\n{\n    struct bootp_t *bp = mtod_check(m, sizeof(struct bootp_t));\n    if (bp && bp->bp_op == BOOTP_REQUEST) {\n        bootp_reply(m->slirp, bp, m_end(m));\n    }\n}", "target": 0}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "int nfs4_destroy_clientid(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\tint ret = 0;\n\tif (clp->cl_mvops->minor_version < 1)\n\t\tgoto out;\n\tif (clp->cl_exchange_flags == 0)\n\t\tgoto out;\n\tif (clp->cl_preserve_clid)\n\t\tgoto out;\n\tcred = nfs4_get_exchange_id_cred(clp);\n\tret = nfs4_proc_destroy_clientid(clp, cred);\n\tif (cred)\n\t\tput_rpccred(cred);\n\tswitch (ret) {\n\tcase 0:\n\tcase -NFS4ERR_STALE_CLIENTID:\n\t\tclp->cl_exchange_flags = 0;\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": "ospf_header_dump (struct ospf_header *ospfh)\n{\n  char buf[9];\n  u_int16_t auth_type = ntohs (ospfh->auth_type);\n  zlog_debug (\"Header\");\n  zlog_debug (\"  Version %d\", ospfh->version);\n  zlog_debug (\"  Type %d (%s)\", ospfh->type,\n\t     LOOKUP (ospf_packet_type_str, ospfh->type));\n  zlog_debug (\"  Packet Len %d\", ntohs (ospfh->length));\n  zlog_debug (\"  Router ID %s\", inet_ntoa (ospfh->router_id));\n  zlog_debug (\"  Area ID %s\", inet_ntoa (ospfh->area_id));\n  zlog_debug (\"  Checksum 0x%x\", ntohs (ospfh->checksum));\n  zlog_debug (\"  AuType %s\", LOOKUP (ospf_auth_type_str, auth_type));\n  switch (auth_type)\n    {\n    case OSPF_AUTH_NULL:\n      break;\n    case OSPF_AUTH_SIMPLE:\n      memset (buf, 0, 9);\n      strncpy (buf, (char *) ospfh->u.auth_data, 8);\n      zlog_debug (\"  Simple Password %s\", buf);\n      break;\n    case OSPF_AUTH_CRYPTOGRAPHIC:\n      zlog_debug (\"  Cryptographic Authentication\");\n      zlog_debug (\"  Key ID %d\", ospfh->u.crypt.key_id);\n      zlog_debug (\"  Auth Data Len %d\", ospfh->u.crypt.auth_data_len);\n      zlog_debug (\"  Sequence number %ld\",\n\t\t (u_long)ntohl (ospfh->u.crypt.crypt_seqnum));\n      break;\n    default:\n      zlog_debug (\"* This is not supported authentication type\");\n      break;\n    }\n}", "target": 0}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "char *_q_makeword(char *str, char stop)\n{\n    char *word;\n    int  len, i;\n    for (len = 0; ((str[len] != stop) && (str[len])); len++);\n    word = (char *)malloc(sizeof(char) * (len + 1));\n    for (i = 0; i < len; i++) word[i] = str[i];\n    word[i] = '\\0';\n    if (str[len])len++;\n    for (i = len; str[i]; i++) str[i - len] = str[i];\n    str[i - len] = '\\0';\n    return word;\n}", "target": 0}
{"code": "HttpStateData::getMoreRequestBody(MemBuf &buf)\n{\n    if (!flags.chunked_request)\n        return Client::getMoreRequestBody(buf);\n    MemBuf raw;\n    Must(requestBodySource != NULL);\n    if (!requestBodySource->getMoreData(raw))\n        return false; \n    const mb_size_t rawDataSize = raw.contentSize();\n    buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);\n    buf.appendf(\"%x\\r\\n\", static_cast<unsigned int>(rawDataSize));\n    buf.append(raw.content(), rawDataSize);\n    buf.append(\"\\r\\n\", 2);\n    Must(rawDataSize > 0); \n    if (receivedWholeRequestBody) {\n        Must(!flags.sentLastChunk);\n        flags.sentLastChunk = true;\n        buf.append(\"0\\r\\n\\r\\n\", 5);\n    }\n    return true;\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_get_play_status(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tstruct avrcp_player *player = target_get_player(session);\n\tuint16_t len = ntohs(pdu->params_len);\n\tuint32_t position;\n\tuint32_t duration;\n\tif (len != 0) {\n\t\tpdu->params_len = htons(1);\n\t\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\t\treturn AVC_CTYPE_REJECTED;\n\t}\n\tposition = player_get_position(player);\n\tduration = player_get_duration(player);\n\tposition = htonl(position);\n\tduration = htonl(duration);\n\tmemcpy(&pdu->params[0], &duration, 4);\n\tmemcpy(&pdu->params[4], &position, 4);\n\tpdu->params[8] = player_get_status(player);\n\tpdu->params_len = htons(9);\n\treturn AVC_CTYPE_STABLE;\n}", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n \tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 1}
{"code": "static bool blit_is_unsafe(struct CirrusVGAState *s)\n{\n    assert(s->cirrus_blt_width > 0);\n    assert(s->cirrus_blt_height > 0);\n    if (blit_region_is_unsafe(s, s->cirrus_blt_dstpitch,\n                              s->cirrus_blt_dstaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    if (blit_region_is_unsafe(s, s->cirrus_blt_srcpitch,\n                              s->cirrus_blt_srcaddr & s->cirrus_addr_mask)) {\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "options_transports(void)\n{\nstruct transport_info * ti;\nuschar buf[64];\noptions_from_list(optionlist_transports, nelem(optionlist_transports), US\"TRANSPORTS\", NULL);\nfor (ti = transports_available; ti->driver_name[0]; ti++)\n  {\n  spf(buf, sizeof(buf), US\"_DRIVER_TRANSPORT_%T\", ti->driver_name);\n  builtin_macro_create(buf);\n  options_from_list(ti->options, (unsigned)*ti->options_count, US\"TRANSPORT\", ti->driver_name);\n  }\n}", "target": 0}
{"code": "xfs_inode_free_callback(\n\tstruct rcu_head\t\t*head)\n{\n\tstruct inode\t\t*inode = container_of(head, struct inode, i_rcu);\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tswitch (VFS_I(ip)->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\tcase S_IFLNK:\n\t\txfs_idestroy_fork(ip, XFS_DATA_FORK);\n\t\tbreak;\n\t}\n\tif (ip->i_afp)\n\t\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tif (ip->i_cowfp)\n\t\txfs_idestroy_fork(ip, XFS_COW_FORK);\n\tif (ip->i_itemp) {\n\t\tASSERT(!(ip->i_itemp->ili_item.li_flags & XFS_LI_IN_AIL));\n\t\txfs_inode_item_destroy(ip);\n\t\tip->i_itemp = NULL;\n\t}\n\tkmem_zone_free(xfs_inode_zone, ip);\n}", "target": 0}
{"code": "GF_Err prhd_box_size(GF_Box *s)\n{\n\ts->size += 12;\n\treturn GF_OK;\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "void RootWindow::OnWindowAddedToRootWindow(Window* attached) {\n  if (attached->IsVisible() &&\n      attached->ContainsPointInRoot(last_mouse_location_))\n    PostMouseMoveEventAfterWindowChange();\n}", "target": 0}
{"code": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}", "target": 1}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n    if (!sb)\n        return;\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}", "target": 1}
{"code": "static Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,\n  const char *id,const char *mask_path,ExceptionInfo *exception)\n{\n  Image\n    *composite_mask;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  composite_mask=AcquireImage((const ImageInfo *) NULL);\n  status=SetImageExtent(composite_mask,image->columns,image->rows);\n  if (status == MagickFalse)\n    return(DestroyImage(composite_mask));\n  status=SetImageMask(image,(Image *) NULL);\n  status=QueryColorCompliance(\"#0000\",AllCompliance,\n    &composite_mask->background_color,exception);\n  composite_mask->background_color.opacity=(Quantum) TransparentOpacity;\n  (void) SetImageBackgroundColor(composite_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin mask-path %s\",\n      id);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,mask_path);\n  status=QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  status=QueryColorCompliance(\"#00000000\",AllCompliance,&clone_info->stroke,\n    exception);\n  clone_info->stroke_width=0.0;\n  clone_info->opacity=OpaqueOpacity;\n  status=RenderMVGContent(composite_mask,clone_info,0);\n  clone_info=DestroyDrawInfo(clone_info);\n  status&=SeparateImageChannel(composite_mask,TrueAlphaChannel);\n  status&=NegateImage(composite_mask,MagickFalse);\n  if (status == MagickFalse)\n    composite_mask=DestroyImage(composite_mask);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end mask-path\");\n  return(composite_mask);\n}", "target": 0}
{"code": "static int intel_iommu_add_device(struct device *dev)\n{\n\tstruct intel_iommu *iommu;\n\tstruct iommu_group *group;\n\tu8 bus, devfn;\n\tiommu = device_to_iommu(dev, &bus, &devfn);\n\tif (!iommu)\n\t\treturn -ENODEV;\n\tiommu_device_link(&iommu->iommu, dev);\n\tgroup = iommu_group_get_for_dev(dev);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tiommu_group_put(group);\n\treturn 0;\n}", "target": 0}
{"code": "static void unmask_payload(handler_ctx *hctx) {\n    buffer * const b = hctx->frame.payload;\n    for (size_t i = 0, used = buffer_clen(b); i < used; ++i) {\n        b->ptr[i] ^= hctx->frame.ctl.mask[hctx->frame.ctl.mask_cnt];\n        hctx->frame.ctl.mask_cnt = (hctx->frame.ctl.mask_cnt + 1) % 4;\n    }\n}", "target": 0}
{"code": "int ff_init_buffer_info(AVCodecContext *avctx, AVFrame *frame)\n{\n    if (avctx->internal->pkt) {\n        frame->pkt_pts = avctx->internal->pkt->pts;\n        av_frame_set_pkt_pos     (frame, avctx->internal->pkt->pos);\n        av_frame_set_pkt_duration(frame, avctx->internal->pkt->duration);\n        av_frame_set_pkt_size    (frame, avctx->internal->pkt->size);\n    } else {\n        frame->pkt_pts = AV_NOPTS_VALUE;\n        av_frame_set_pkt_pos     (frame, -1);\n        av_frame_set_pkt_duration(frame, 0);\n        av_frame_set_pkt_size    (frame, -1);\n    }\n    frame->reordered_opaque = avctx->reordered_opaque;\n    switch (avctx->codec->type) {\n    case AVMEDIA_TYPE_VIDEO:\n        frame->format              = avctx->pix_fmt;\n        if (!frame->sample_aspect_ratio.num)\n            frame->sample_aspect_ratio = avctx->sample_aspect_ratio;\n        if (av_frame_get_colorspace(frame) == AVCOL_SPC_UNSPECIFIED)\n            av_frame_set_colorspace(frame, avctx->colorspace);\n        if (av_frame_get_color_range(frame) == AVCOL_RANGE_UNSPECIFIED)\n            av_frame_set_color_range(frame, avctx->color_range);\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        if (!frame->sample_rate)\n            frame->sample_rate    = avctx->sample_rate;\n        if (frame->format < 0)\n            frame->format         = avctx->sample_fmt;\n        if (!frame->channel_layout) {\n            if (avctx->channel_layout) {\n                 if (av_get_channel_layout_nb_channels(avctx->channel_layout) !=\n                     avctx->channels) {\n                     av_log(avctx, AV_LOG_ERROR, \"Inconsistent channel \"\n                            \"configuration.\\n\");\n                     return AVERROR(EINVAL);\n                 }\n                frame->channel_layout = avctx->channel_layout;\n            } else {\n                if (avctx->channels > FF_SANE_NB_CHANNELS) {\n                    av_log(avctx, AV_LOG_ERROR, \"Too many channels: %d.\\n\",\n                           avctx->channels);\n                    return AVERROR(ENOSYS);\n                }\n            }\n        }\n        av_frame_set_channels(frame, avctx->channels);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    int bn_data_num;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data_num = num / BN_DEC_NUM + 1;\n    bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            if (*lp == (BN_ULONG)-1)\n                goto err;\n            lp++;\n            if (lp - bn_data >= bn_data_num)\n                goto err;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    if (bn_data != NULL)\n        OPENSSL_free(bn_data);\n    if (t != NULL)\n        BN_free(t);\n    if (!ok && buf) {\n        OPENSSL_free(buf);\n        buf = NULL;\n    }\n    return (buf);\n}", "target": 1}
{"code": "GF_Err mvcg_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_MultiviewGroupBox *ptr = (GF_MultiviewGroupBox *) s;\n\tptr->size += 7;\n\tfor (i=0; i<ptr->num_entries; i++) {\n\t\tswitch (ptr->entries[i].entry_type) {\n\t\tcase 0:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tptr->size += 1 + 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tptr->size += 1 + 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tptr->size += 1 + 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}", "target": 1}
{"code": "handle_action(netdissect_options *ndo,\n              const uint8_t *src, const u_char *p, u_int length)\n{\n\tif (!ND_TTEST2(*p, 2))\n\t\treturn 0;\n\tif (length < 2)\n\t\treturn 0;\n\tif (ndo->ndo_eflag) {\n\t\tND_PRINT((ndo, \": \"));\n\t} else {\n\t\tND_PRINT((ndo, \" (%s): \", etheraddr_string(ndo, src)));\n\t}\n\tswitch (p[0]) {\n\tcase 0: ND_PRINT((ndo, \"Spectrum Management Act#%d\", p[1])); break;\n\tcase 1: ND_PRINT((ndo, \"QoS Act#%d\", p[1])); break;\n\tcase 2: ND_PRINT((ndo, \"DLS Act#%d\", p[1])); break;\n\tcase 3: ND_PRINT((ndo, \"BA \")); PRINT_BA_ACTION(p[1]); break;\n\tcase 7: ND_PRINT((ndo, \"HT \")); PRINT_HT_ACTION(p[1]); break;\n\tcase 13: ND_PRINT((ndo, \"MeshAction \")); PRINT_MESH_ACTION(p[1]); break;\n\tcase 14:\n\t\tND_PRINT((ndo, \"MultiohopAction \"));\n\t\tPRINT_MULTIHOP_ACTION(p[1]); break;\n\tcase 15:\n\t\tND_PRINT((ndo, \"SelfprotectAction \"));\n\t\tPRINT_SELFPROT_ACTION(p[1]); break;\n\tcase 127: ND_PRINT((ndo, \"Vendor Act#%d\", p[1])); break;\n\tdefault:\n\t\tND_PRINT((ndo, \"Reserved(%d) Act#%d\", p[0], p[1]));\n\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "void bio_trim(struct bio *bio, int offset, int size)\n{\n\tsize <<= 9;\n\tif (offset == 0 && size == bio->bi_iter.bi_size)\n\t\treturn;\n\tbio_clear_flag(bio, BIO_SEG_VALID);\n\tbio_advance(bio, offset << 9);\n\tbio->bi_iter.bi_size = size;\n\tif (bio_integrity(bio))\n\t\tbio_integrity_trim(bio);\n}", "target": 0}
{"code": "vhost_user_set_log_base(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tuint64_t size, off;\n\tvoid *addr;\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR, \"invalid log fd: %d\\n\", fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (msg->size != sizeof(VhostUserLog)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid log base msg size: %\"PRId32\" != %d\\n\",\n\t\t\tmsg->size, (int)sizeof(VhostUserLog));\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tsize = msg->payload.log.mmap_size;\n\toff  = msg->payload.log.mmap_offset;\n\tif (off > size) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"log offset %#\"PRIx64\" exceeds log size %#\"PRIx64\"\\n\",\n\t\t\toff, size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"log mmap size: %\"PRId64\", offset: %\"PRId64\"\\n\",\n\t\tsize, off);\n\taddr = mmap(0, size + off, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tclose(fd);\n\tif (addr == MAP_FAILED) {\n\t\tVHOST_LOG_CONFIG(ERR, \"mmap log base failed!\\n\");\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t}\n\tdev->log_addr = (uint64_t)(uintptr_t)addr;\n\tdev->log_base = dev->log_addr + off;\n\tdev->log_size = size;\n\tmsg->size = 0;\n\tmsg->fd_num = 0;\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}", "target": 1}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "copy_plats_to_inter (class ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n{\n  vec<ipa_agg_value> res = vNULL;\n  if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n    return vNULL;\n  for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n    if (aglat->is_single_const ())\n      {\n\tstruct ipa_agg_value ti;\n\tti.offset = aglat->offset - offset;\n\tti.value = aglat->values->value;\n\tres.safe_push (ti);\n      }\n  return res;\n}", "target": 0}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "void InstanceKlass::check_prohibited_package(Symbol* class_name,\n                                             ClassLoaderData* loader_data,\n                                             TRAPS) {\n  if (!loader_data->is_boot_class_loader_data() &&\n      !loader_data->is_platform_class_loader_data() &&\n      class_name != NULL && class_name->utf8_length() >= 5) {\n    ResourceMark rm(THREAD);\n    bool prohibited;\n    const u1* base = class_name->base();\n    if ((base[0] | base[1] | base[2] | base[3] | base[4]) & 0x80) {\n      prohibited = is_prohibited_package_slow(class_name);\n    } else {\n      char* name = class_name->as_C_string();\n      prohibited = (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '/');\n    }\n    if (prohibited) {\n      TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n      assert(pkg_name != NULL, \"Error in parsing package name starting with 'java/'\");\n      char* name = pkg_name->as_C_string();\n      const char* class_loader_name = loader_data->loader_name_and_id();\n      StringUtils::replace_no_expand(name, \"/\", \".\");\n      const char* msg_text1 = \"Class loader (instance of): \";\n      const char* msg_text2 = \" tried to load prohibited package name: \";\n      size_t len = strlen(msg_text1) + strlen(class_loader_name) + strlen(msg_text2) + strlen(name) + 1;\n      char* message = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, len);\n      jio_snprintf(message, len, \"%s%s%s%s\", msg_text1, class_loader_name, msg_text2, name);\n      THROW_MSG(vmSymbols::java_lang_SecurityException(), message);\n    }\n  }\n  return;\n}", "target": 0}
{"code": "bitset_invert_to(BitSetRef from, BitSetRef to)\n{\n  int i;\n  for (i = 0; i < BITSET_SIZE; i++) { to[i] = ~(from[i]); }\n}", "target": 0}
{"code": "bool GLSurfaceOzoneSurfaceless::IsOffscreen() {\n  return false;\n}", "target": 0}
{"code": "int tipc_nl_node_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_net *tn = net_generic(net, tipc_net_id);\n\tint done = cb->args[0];\n\tint last_addr = cb->args[1];\n\tstruct tipc_node *node;\n\tstruct tipc_nl_msg msg;\n\tif (done)\n\t\treturn 0;\n\tmsg.skb = skb;\n\tmsg.portid = NETLINK_CB(cb->skb).portid;\n\tmsg.seq = cb->nlh->nlmsg_seq;\n\trcu_read_lock();\n\tif (last_addr) {\n\t\tnode = tipc_node_find(net, last_addr);\n\t\tif (!node) {\n\t\t\trcu_read_unlock();\n\t\t\tcb->prev_seq = 1;\n\t\t\treturn -EPIPE;\n\t\t}\n\t\ttipc_node_put(node);\n\t}\n\tlist_for_each_entry_rcu(node, &tn->node_list, list) {\n\t\tif (node->preliminary)\n\t\t\tcontinue;\n\t\tif (last_addr) {\n\t\t\tif (node->addr == last_addr)\n\t\t\t\tlast_addr = 0;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\ttipc_node_read_lock(node);\n\t\terr = __tipc_nl_add_node(&msg, node);\n\t\tif (err) {\n\t\t\tlast_addr = node->addr;\n\t\t\ttipc_node_read_unlock(node);\n\t\t\tgoto out;\n\t\t}\n\t\ttipc_node_read_unlock(node);\n\t}\n\tdone = 1;\nout:\n\tcb->args[0] = done;\n\tcb->args[1] = last_addr;\n\trcu_read_unlock();\n\treturn skb->len;\n}", "target": 0}
{"code": "void free_key_material(key_material_t* pkey)\n{\n\tint i;\n\tif (!pkey)\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; i < TAG_MAX; i++)\n\t{\n\t\tif (pkey[i].big)\n\t\t{\n\t\t\tfree(pkey[i].big);\n\t\t}\n\t}\n}", "target": 0}
{"code": "string Print(const FunctionDef& fdef) {\n  string out;\n  const OpDef& sig = fdef.signature();\n  strings::StrAppend(&out, \"\\n\", sig.name());\n  if (sig.attr_size() > 0) {\n    strings::StrAppend(&out, \"[\");\n    for (int i = 0; i < sig.attr_size(); ++i) {\n      const auto& a = sig.attr(i);\n      if (i > 0) strings::StrAppend(&out, \", \");\n      if (a.type() == \"type\") {\n        strings::StrAppend(&out, a.name(), \":\", Print(a.allowed_values()));\n      } else {\n        strings::StrAppend(&out, a.name(), \":\", a.type());\n      }\n    }\n    strings::StrAppend(&out, \"]\");\n  }\n  strings::StrAppend(&out, \"(\");\n  for (int i = 0; i < sig.input_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.input_arg(i)));\n  }\n  strings::StrAppend(&out, \") -> (\");\n  for (int i = 0; i < sig.output_arg_size(); ++i) {\n    if (i > 0) strings::StrAppend(&out, \", \");\n    strings::StrAppend(&out, Print(sig.output_arg(i)));\n  }\n  strings::StrAppend(&out, \") {\\n\");\n  for (const auto& n : fdef.node_def()) {\n    strings::StrAppend(&out, \"  \", Print(n), \"\\n\");\n  }\n  for (const auto& cr : fdef.control_ret()) {\n    strings::StrAppend(&out, \"  @return \", cr.first, \" = \", cr.second, \"\\n\");\n  }\n  for (const auto& r : fdef.ret()) {\n    strings::StrAppend(&out, \"  return \", r.first, \" = \", r.second, \"\\n\");\n  }\n  strings::StrAppend(&out, \"}\\n\");\n  return out;\n}", "target": 0}
{"code": "bool RenderView::runFileChooser(\n    const WebKit::WebFileChooserParams& params,\n    WebFileChooserCompletion* chooser_completion) {\n  ViewHostMsg_RunFileChooser_Params ipc_params;\n  ipc_params.mode = params.multiSelect ?\n      ViewHostMsg_RunFileChooser_Params::OpenMultiple :\n      ViewHostMsg_RunFileChooser_Params::Open;\n  ipc_params.title = params.title;\n  ipc_params.default_file_name =\n      webkit_glue::WebStringToFilePath(params.initialValue);\n  return ScheduleFileChooser(ipc_params, chooser_completion);\n}", "target": 0}
{"code": "GfxShading *GfxShading::parse(GfxResources *res, Object *obj, OutputDev *out, GfxState *state)\n{\n    GfxShading *shading;\n    Dict *dict;\n    int typeA;\n    Object obj1;\n    if (obj->isDict()) {\n        dict = obj->getDict();\n    } else if (obj->isStream()) {\n        dict = obj->streamGetDict();\n    } else {\n        return nullptr;\n    }\n    obj1 = dict->lookup(\"ShadingType\");\n    if (!obj1.isInt()) {\n        error(errSyntaxWarning, -1, \"Invalid ShadingType in shading dictionary\");\n        return nullptr;\n    }\n    typeA = obj1.getInt();\n    switch (typeA) {\n    case 1:\n        shading = GfxFunctionShading::parse(res, dict, out, state);\n        break;\n    case 2:\n        shading = GfxAxialShading::parse(res, dict, out, state);\n        break;\n    case 3:\n        shading = GfxRadialShading::parse(res, dict, out, state);\n        break;\n    case 4:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 4, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 4 shading object\");\n            goto err1;\n        }\n        break;\n    case 5:\n        if (obj->isStream()) {\n            shading = GfxGouraudTriangleShading::parse(res, 5, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 5 shading object\");\n            goto err1;\n        }\n        break;\n    case 6:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 6, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 6 shading object\");\n            goto err1;\n        }\n        break;\n    case 7:\n        if (obj->isStream()) {\n            shading = GfxPatchMeshShading::parse(res, 7, dict, obj->getStream(), out, state);\n        } else {\n            error(errSyntaxWarning, -1, \"Invalid Type 7 shading object\");\n            goto err1;\n        }\n        break;\n    default:\n        error(errSyntaxWarning, -1, \"Unimplemented shading type {0:d}\", typeA);\n        goto err1;\n    }\n    return shading;\nerr1:\n    return nullptr;\n}", "target": 0}
{"code": "nfs_idmap_new(struct nfs_client *clp)\n{\n\tstruct idmap *idmap;\n\tstruct rpc_pipe *pipe;\n\tint error;\n\tidmap = kzalloc(sizeof(*idmap), GFP_KERNEL);\n\tif (idmap == NULL)\n\t\treturn -ENOMEM;\n\trpc_init_pipe_dir_object(&idmap->idmap_pdo,\n\t\t\t&nfs_idmap_pipe_dir_object_ops,\n\t\t\tidmap);\n\tpipe = rpc_mkpipe_data(&idmap_upcall_ops, 0);\n\tif (IS_ERR(pipe)) {\n\t\terror = PTR_ERR(pipe);\n\t\tgoto err;\n\t}\n\tidmap->idmap_pipe = pipe;\n\tmutex_init(&idmap->idmap_mutex);\n\terror = rpc_add_pipe_dir_object(clp->cl_net,\n\t\t\t&clp->cl_rpcclient->cl_pipedir_objects,\n\t\t\t&idmap->idmap_pdo);\n\tif (error)\n\t\tgoto err_destroy_pipe;\n\tclp->cl_idmap = idmap;\n\treturn 0;\nerr_destroy_pipe:\n\trpc_destroy_pipe_data(idmap->idmap_pipe);\nerr:\n\tkfree(idmap);\n\treturn error;\n}", "target": 0}
{"code": "int wmi_set_ie(struct wil6210_priv *wil, u8 type, u16 ie_len, const void *ie)\n{\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\tcmd->mgmt_frm_type = type;\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static BOOL update_gdi_mem3blt(rdpContext* context, MEM3BLT_ORDER* mem3blt)\n{\n\tBYTE style;\n\trdpBitmap* bitmap;\n\trdpCache* cache = context->cache;\n\trdpBrush* brush = &mem3blt->brush;\n\tBOOL ret = TRUE;\n\tif (mem3blt->cacheId == 0xFF)\n\t\tbitmap = offscreen_cache_get(cache->offscreen, mem3blt->cacheIndex);\n\telse\n\t\tbitmap = bitmap_cache_get(cache->bitmap, (BYTE)mem3blt->cacheId, mem3blt->cacheIndex);\n\tif (!bitmap)\n\t\treturn TRUE;\n\tstyle = brush->style;\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->data = brush_cache_get(cache->brush, brush->index, &brush->bpp);\n\t\tif (!brush->data)\n\t\t\treturn FALSE;\n\t\tbrush->style = 0x03;\n\t}\n\tmem3blt->bitmap = bitmap;\n\tIFCALLRET(cache->bitmap->Mem3Blt, ret, context, mem3blt);\n\tbrush->style = style;\n\treturn ret;\n}", "target": 0}
{"code": "my_pipe_sig_handler(int sig __attribute__((unused)))\n{\n  DBUG_PRINT(\"info\",(\"Hit by signal %d\",sig));\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  (void) signal(SIGPIPE, my_pipe_sig_handler);\n#endif\n}", "target": 0}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n {\n         uint8* bufp = buf;\n         int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n         uint32 stripsize = TIFFStripSize(in);\n         uint32 rows = 0;\n         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n        return 1;\n} ", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "reallocWrapper (void *address, size_t size)\n{\n  if (!(address = realloc (address, size)) && size)\n    outOfMemory ();\n  return address;\n}", "target": 0}
{"code": "    CImg<T>& LabtoXYZ(const bool use_D65=true) {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"LabtoXYZ(): Instance is not a Lab image.\",\n                                    cimg_instance);\n      const CImg<Tfloat> white = CImg<Tfloat>(1,1,1,3,255).RGBtoXYZ(use_D65);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=128))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          L = (Tfloat)p1[N],\n          a = (Tfloat)p2[N],\n          b = (Tfloat)p3[N],\n          cY = (L + 16)/116,\n          cZ = cY - b/200,\n          cX = a/500 + cY,\n          X = (Tfloat)(24389*cX>216?cX*cX*cX:(116*cX - 16)*27/24389),\n          Y = (Tfloat)(27*L>216?cY*cY*cY:27*L/24389),\n          Z = (Tfloat)(24389*cZ>216?cZ*cZ*cZ:(116*cZ - 16)*27/24389);\n        p1[N] = (T)(X*white[0]);\n        p2[N] = (T)(Y*white[1]);\n        p3[N] = (T)(Z*white[2]);\n      }\n      return *this;", "target": 0}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "copy_creds_except(krb5_context context, krb5_ccache incc,\n                  krb5_ccache outcc, krb5_principal princ)\n{\n    krb5_error_code ret, ret2;\n    krb5_cc_cursor cur;\n    krb5_creds creds;\n    ret = krb5_cc_set_flags(context, incc, 0);\n    if (ret)\n        return ret;\n    ret = krb5_cc_start_seq_get(context, incc, &cur);\n    if (ret)\n        goto cleanup;\n    while (!(ret = krb5_cc_next_cred(context, incc, &cur, &creds))) {\n        if (krb5_principal_compare(context, princ, creds.server))\n            continue;\n        ret = krb5_cc_store_cred(context, outcc, &creds);\n        krb5_free_cred_contents(context, &creds);\n        if (ret)\n            goto cleanup;\n    }\n    if (ret != KRB5_CC_END)\n        goto cleanup;\n    ret = 0;\ncleanup:\n    ret2 = krb5_cc_set_flags(context, incc, KRB5_TC_OPENCLOSE);\n    return (ret == 0) ? ret2 : ret;\n}", "target": 0}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 1}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "process_button(struct parsed_tag *tag)\n{\n    Str tmp = NULL;\n    char *p, *q, *r, *qq = \"\";\n    int qlen, v;\n    if (cur_form_id < 0) {\n       char *s = \"<form_int method=internal action=none>\";\n       tmp = process_form(parse_tag(&s, TRUE));\n    }\n    if (tmp == NULL)\n       tmp = Strnew();\n    p = \"submit\";\n    parsedtag_get_value(tag, ATTR_TYPE, &p);\n    q = NULL;\n    parsedtag_get_value(tag, ATTR_VALUE, &q);\n    r = \"\";\n    parsedtag_get_value(tag, ATTR_NAME, &r);\n    v = formtype(p);\n    if (v == FORM_UNKNOWN)\n       return NULL;\n    if (!q) {\n       switch (v) {\n       case FORM_INPUT_SUBMIT:\n       case FORM_INPUT_BUTTON:\n           q = \"SUBMIT\";\n           break;\n       case FORM_INPUT_RESET:\n           q = \"RESET\";\n           break;\n       }\n    }\n    if (q) {\n       qq = html_quote(q);\n       qlen = strlen(q);\n    }\n    Strcat(tmp, Sprintf(\"<input_alt hseq=\\\"%d\\\" fid=\\\"%d\\\" type=\\\"%s\\\" \"\n                       \"name=\\\"%s\\\" value=\\\"%s\\\">\",\n                       cur_hseq++, cur_form_id, html_quote(p),\n                       html_quote(r), qq));\n    return tmp;\n}", "target": 1}
{"code": "  UpdatePersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      int new_quota,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota_, 0);\n  }", "target": 0}
{"code": "static inline void CoefficientsToAffineArgs(double *coeff)\n{\n  double tmp[4];  \n  tmp[0]=coeff[3]; tmp[1]=coeff[1]; tmp[2]=coeff[4]; tmp[3]=coeff[2];\n  coeff[1]=tmp[0]; coeff[2]=tmp[1]; coeff[3]=tmp[2]; coeff[4]=tmp[3];\n}", "target": 0}
{"code": "  bool const_item() const { return used_tables() == 0; }", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 count, now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\n\t\tchallenge_timestamp = now;\n\t\tWRITE_ONCE(challenge_count, half +\n\t\t\t   prandom_u32_max(sysctl_tcp_challenge_ack_limit));\n\t}\n\tcount = READ_ONCE(challenge_count);\n\tif (count > 0) {\n\t\tWRITE_ONCE(challenge_count, count - 1);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 0}
{"code": "int CSoundFile::FrequencyToTranspose(DWORD freq)\n{\n\treturn int(1536*(log(freq/8363.0)/log(2.0)));\n#ifdef MSC_VER\n\tconst float _f1_8363 = 1.0f / 8363.0f;\n\tconst float _factor = 128 * 12;\n\tLONG result;\n\tif (!freq) return 0;\n\t_asm {\n\tfld _factor\n\tfild freq\n\tfld _f1_8363\n\tfmulp st(1), st(0)\n\tfyl2x\n\tfistp result\n\t}\n\treturn result;\n#endif\n}", "target": 0}
{"code": "ram_addr_t qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n                                   void (*resized)(const char*,\n                                                   uint64_t length,\n                                                   void *host),\n                                   void *host, bool resizeable,\n                                   MemoryRegion *mr, Error **errp)\n{\n    RAMBlock *new_block;\n    ram_addr_t addr;\n    Error *local_err = NULL;\n    size = TARGET_PAGE_ALIGN(size);\n    max_size = TARGET_PAGE_ALIGN(max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    new_block->mr = mr;\n    new_block->resized = resized;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->fd = -1;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    if (resizeable) {\n        new_block->flags |= RAM_RESIZEABLE;\n    }\n    addr = ram_block_add(new_block, &local_err);\n    if (local_err) {\n        g_free(new_block);\n        error_propagate(errp, local_err);\n        return -1;\n    }\n    return addr;\n}", "target": 0}
{"code": "Variant array_search(const Variant& needle,\n                     const Variant& haystack,\n                     bool strict ) {\n  Variant ret = false;\n  auto ok = strict ?\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; }) :\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; });\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"array_search() expects parameter 2 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n  return ret;\n}", "target": 0}
{"code": "void PacketReader::getDnsrecordheader(struct dnsrecordheader &ah)\n{\n  unsigned int n;\n  unsigned char *p=reinterpret_cast<unsigned char*>(&ah);\n  for(n=0; n < sizeof(dnsrecordheader); ++n) \n    p[n]=d_content.at(d_pos++);\n  ah.d_type=ntohs(ah.d_type);\n  ah.d_class=ntohs(ah.d_class);\n  ah.d_clen=ntohs(ah.d_clen);\n  ah.d_ttl=ntohl(ah.d_ttl);\n  d_startrecordpos=d_pos; \n  d_recordlen=ah.d_clen;\n}", "target": 0}
{"code": "static void *_clua_allocator(void *ud, void *ptr, size_t osize, size_t nsize)\n{\n    CLua *cl = static_cast<CLua *>(ud);\n    cl->memory_used += nsize - osize;\n    if (nsize > osize && cl->memory_used >= CLUA_MAX_MEMORY_USE * 1024\n        && cl->mixed_call_depth)\n    {\n        return nullptr;\n    }\n    if (!nsize)\n    {\n        free(ptr);\n        return nullptr;\n    }\n    else\n        return realloc(ptr, nsize);\n}", "target": 0}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n    pause_all_vcpus();\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n    switch (opcode[0]) {\n    case 0x89: \n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  \n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: \n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: \n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: \n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: \n        patch_byte(cpu, ip, 0x68);  \n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: \n        patch_byte(cpu, ip, 0x50); \n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n    resume_all_vcpus();\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}", "target": 1}
{"code": "void btrfs_init_devices_late(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\twhile (fs_devices) {\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list)\n\t\t\tdevice->fs_info = fs_info;\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\tfs_devices = fs_devices->seed;\n\t}\n}", "target": 0}
{"code": "static void HuffmanTree_cleanup(HuffmanTree* tree)\n{\n  free(tree->tree2d);\n  free(tree->tree1d);\n  free(tree->lengths);\n}", "target": 0}
{"code": "static void exif_process_CME (image_info_type *image_info, char *value, size_t length)\n{\n\tif (length>3) {\n\t\tswitch(value[2]) {\n\t\t\tcase 0:\n\t\t\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_UNDEFINED, length, value, length);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_STRING, length, value, length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL, E_NOTICE, \"Undefined JPEG2000 comment encoding\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\texif_iif_add_tag(image_info, SECTION_COMMENT, \"Comment\", TAG_COMPUTED_VALUE, TAG_FMT_UNDEFINED, 0, NULL, 0);\n\t\tphp_error_docref(NULL, E_NOTICE, \"JPEG2000 comment section too small\");\n\t}\n}", "target": 0}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 1}
{"code": "static void _gnutls_handshake_internal_state_init(gnutls_session_t session)\n{\n\tsession->internals.adv_version_major = 0;\n\tsession->internals.adv_version_minor = 0;\n\tsession->internals.direction = 0;\n\tsession->internals.last_handshake_in = -1;\n\tsession->internals.last_handshake_out = -1;\n\tsession->internals.resumable = RESUME_TRUE;\n\tsession->internals.handshake_large_loops = 0;\n\tsession->internals.dtls.hsk_read_seq = 0;\n\tsession->internals.dtls.hsk_write_seq = 0;\n}", "target": 1}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "TEST(BitTestMatchExpression, DoesNotMatchBinary2) {\n    BSONArray bas = BSON_ARRAY(21 << 22 << 23 << 24 << 25);\n    BSONArray bac = BSON_ARRAY(20 << 23 << 21);\n    std::vector<uint32_t> bitPositionsSet = bsonArrayToBitPositions(bas);\n    std::vector<uint32_t> bitPositionsClear = bsonArrayToBitPositions(bac);\n    BSONObj match1 = fromjson(\"{a: {$binary: 'AANgAAAAAAAAAAAAAAAAAAAAAAAA', $type: '00'}}\");\n    BSONObj match2 = fromjson(\"{a: {$binary: 'JANgqwetkqwklEWRbWERKKJREtbq', $type: '00'}}\");\n    BitsAllSetMatchExpression balls(\"a\", bitPositionsSet);\n    BitsAllClearMatchExpression ballc(\"a\", bitPositionsClear);\n    BitsAnySetMatchExpression banys(\"a\", bitPositionsSet);\n    BitsAnyClearMatchExpression banyc(\"a\", bitPositionsClear);\n    ASSERT_EQ((size_t)5, balls.numBitPositions());\n    ASSERT_EQ((size_t)3, ballc.numBitPositions());\n    ASSERT_EQ((size_t)5, banys.numBitPositions());\n    ASSERT_EQ((size_t)3, banyc.numBitPositions());\n    ASSERT(!balls.matchesSingleElement(match1[\"a\"]));\n    ASSERT(!balls.matchesSingleElement(match2[\"a\"]));\n    ASSERT(!ballc.matchesSingleElement(match1[\"a\"]));\n    ASSERT(!ballc.matchesSingleElement(match2[\"a\"]));\n    ASSERT(banys.matchesSingleElement(match1[\"a\"]));\n    ASSERT(banys.matchesSingleElement(match2[\"a\"]));\n    ASSERT(banyc.matchesSingleElement(match1[\"a\"]));\n    ASSERT(banyc.matchesSingleElement(match2[\"a\"]));\n}", "target": 0}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "std::map<string, AttrValue> GetSetAttrs(const FunctionDef& fdef) {\n  std::map<string, AttrValue> set_attrs;\n  for (const auto& pair : fdef.attr()) {\n    if (pair.second.value_case() != AttrValue::VALUE_NOT_SET) {\n      set_attrs[pair.first] = pair.second;\n    }\n  }\n  return set_attrs;\n}", "target": 0}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "ModuleExport size_t RegisterWMFImage(void)\n{\n  MagickInfo\n    *entry;\n  entry = AcquireMagickInfo(\"WMF\",\"WMZ\",\"Compressed Windows Meta File\");\n#if defined(MAGICKCORE_SANS_DELEGATE) || defined(MAGICKCORE_WMF_DELEGATE)\n  entry->decoder=ReadWMFImage;\n#endif\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"WMF\",\"WMF\",\"Windows Meta File\");\n#if defined(MAGICKCORE_SANS_DELEGATE) || defined(MAGICKCORE_WMF_DELEGATE)\n  entry->decoder=ReadWMFImage;\n#endif\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\ttmp = !!tmp; \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\treturn count;\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 1}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n  }", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}", "target": 1}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "void set_cron_watched(int fd) {\n\tpid_t pid = getpid();\n\tint i;\n\tif (fd < 0) {\n\t\tinotify_enabled = 0;\n\t\treturn;\n\t}\n\tfor (i = 0; i < sizeof (wd) / sizeof (wd[0]); ++i) {\n\t\tint w;\n\t\tif (open(watchpaths[i], O_RDONLY | O_NONBLOCK, 0) != -1) {\n\t\t\tw = inotify_add_watch(fd, watchpaths[i],\n\t\t\t\tIN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MODIFY | IN_MOVED_TO |\n\t\t\t\tIN_MOVED_FROM | IN_MOVE_SELF | IN_DELETE | IN_DELETE_SELF);\n\t\t\tif (w < 0) {\n\t\t\t\tif (wd[i] != -1) {\n\t\t\t\t\tlog_it(\"CRON\", pid, \"This directory or file can't be watched\",\n\t\t\t\t\t\twatchpaths[i], errno);\n\t\t\t\t\tlog_it(\"CRON\", pid, \"INFO\", \"running without inotify support\", 0);\n\t\t\t\t}\n\t\t\t\tinotify_enabled = 0;\n\t\t\t\tset_cron_unwatched(fd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twd[i] = w;\n\t\t}\n\t}\n\tif (!inotify_enabled) {\n\t\tlog_it(\"CRON\", pid, \"INFO\", \"running with inotify support\", 0);\n\t}\n\tinotify_enabled = 1;\n}", "target": 1}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "bits_set(unsigned int *selector, size_t selsize, int *bits)\n{\nfor(; *bits != -1; ++bits)\n  BIT_SET(selector, selsize, *bits);\n}", "target": 0}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "    const CImgList<T>& save_gzip_external(const char *const filename) const {\n      if (!filename)\n        throw CImgIOException(_cimglist_instance\n                              \"save_gzip_external(): Specified filename is (null).\",\n                              cimglist_instance);\n      CImg<charT> command(1024), filename_tmp(256), body(256);\n      const char\n        *ext = cimg::split_filename(filename,body),\n        *ext2 = cimg::split_filename(body,0);\n      std::FILE *file;\n      do {\n        if (!cimg::strcasecmp(ext,\"gz\")) {\n          if (*ext2) cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.%s\",\n                                   cimg::temporary_path(),cimg_file_separator,cimg::filenamerand(),ext2);\n          else cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.cimg\",\n                             cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        } else {\n          if (*ext) cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.%s\",\n                                  cimg::temporary_path(),cimg_file_separator,cimg::filenamerand(),ext);\n          else cimg_snprintf(filename_tmp,filename_tmp._width,\"%s%c%s.cimg\",\n                             cimg::temporary_path(),cimg_file_separator,cimg::filenamerand());\n        }\n        if ((file=std_fopen(filename_tmp,\"rb\"))!=0) cimg::fclose(file);\n      } while (file);\n      if (is_saveable(body)) {\n        save(filename_tmp);\n        cimg_snprintf(command,command._width,\"%s -c \\\"%s\\\" > \\\"%s\\\"\",\n                      cimg::gzip_path(),\n                      CImg<charT>::string(filename_tmp)._system_strescape().data(),\n                      CImg<charT>::string(filename)._system_strescape().data());\n        cimg::system(command);\n        file = std_fopen(filename,\"rb\");\n        if (!file)\n          throw CImgIOException(_cimglist_instance\n                                \"save_gzip_external(): Failed to save file '%s' with external command 'gzip'.\",\n                                cimglist_instance,\n                                filename);\n        else cimg::fclose(file);\n        std::remove(filename_tmp);\n      } else {\n        CImg<charT> nfilename(1024);\n        cimglist_for(*this,l) {\n          cimg::number_filename(body,l,6,nfilename);\n          if (*ext) cimg_sprintf(nfilename._data + std::strlen(nfilename),\".%s\",ext);\n          _data[l].save_gzip_external(nfilename);", "target": 0}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": " HarfBuzzShaperBase::HarfBuzzShaperBase(const Font* font, const TextRun& run)\n     : m_font(font)\n     , m_run(run)\n     , m_wordSpacingAdjustment(font->wordSpacing())\n     , m_letterSpacing(font->letterSpacing())\n {\n }", "target": 1}
{"code": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive?\"recursive \":\"\",\n            scp->location);\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    }\n    if (ssh_channel_request_exec(scp->channel, execbuffer) == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 1}
{"code": "is_valid_mbc_string(const UChar* s, const UChar* end)\n{\n  return onigenc_length_check_is_valid_mbc_string(ONIG_ENCODING_UTF16_BE, s, end);\n}", "target": 0}
{"code": "CLua::~CLua()\n{\n    const vector<lua_shutdown_listener*> slisteners = shutdown_listeners;\n    for (lua_shutdown_listener *listener : slisteners)\n        listener->shutdown(*this);\n    shutting_down = true;\n    if (_state)\n        lua_close(_state);\n}", "target": 0}
{"code": "static int switch_listening_mode(GDHCPClient *dhcp_client,\n\t\t\t\t\tListenMode listen_mode)\n{\n\tGIOChannel *listener_channel;\n\tint listener_sockfd;\n\tif (dhcp_client->listen_mode == listen_mode)\n\t\treturn 0;\n\tdebug(dhcp_client, \"switch listening mode (%d ==> %d)\",\n\t\t\t\tdhcp_client->listen_mode, listen_mode);\n\tif (dhcp_client->listen_mode != L_NONE) {\n\t\tif (dhcp_client->listener_watch > 0)\n\t\t\tg_source_remove(dhcp_client->listener_watch);\n\t\tdhcp_client->listen_mode = L_NONE;\n\t\tdhcp_client->listener_sockfd = -1;\n\t\tdhcp_client->listener_watch = 0;\n\t}\n\tif (listen_mode == L_NONE)\n\t\treturn 0;\n\tif (listen_mode == L2)\n\t\tlistener_sockfd = dhcp_l2_socket(dhcp_client->ifindex);\n\telse if (listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6)\n\t\t\tlistener_sockfd = dhcp_l3_socket(DHCPV6_CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET6);\n\t\telse\n\t\t\tlistener_sockfd = dhcp_l3_socket(CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET);\n\t} else if (listen_mode == L_ARP)\n\t\tlistener_sockfd = arp_socket(dhcp_client->ifindex);\n\telse\n\t\treturn -EIO;\n\tif (listener_sockfd < 0)\n\t\treturn -EIO;\n\tlistener_channel = g_io_channel_unix_new(listener_sockfd);\n\tif (!listener_channel) {\n\t\tclose(listener_sockfd);\n\t\treturn -EIO;\n\t}\n\tdhcp_client->listen_mode = listen_mode;\n\tdhcp_client->listener_sockfd = listener_sockfd;\n\tg_io_channel_set_close_on_unref(listener_channel, TRUE);\n\tdhcp_client->listener_watch =\n\t\t\tg_io_add_watch_full(listener_channel, G_PRIORITY_HIGH,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_ERR | G_IO_HUP,\n\t\t\t\t\t\tlistener_event, g_dhcp_client_ref(dhcp_client),\n\t\t\t\t\t\t\t\tlistener_watch_destroy);\n\tg_io_channel_unref(listener_channel);\n\treturn 0;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "static void lag_pred_line(LagarithContext *l, uint8_t *buf,\n                          int width, int stride, int line)\n{\n    int L, TL;\n    if (!line) {\n        int i, align_width = (width - 1) & ~31;\n        L = l->dsp.add_hfyu_left_prediction(buf + 1, buf + 1,\n                                            align_width, buf[0]);\n        for (i = align_width + 1; i < width; i++)\n            buf[i] += buf[i - 1];\n    } else {\n        L = buf[width - stride - 1];\n        if (line == 1) {\n            TL = l->avctx->pix_fmt == AV_PIX_FMT_YUV420P ? buf[-stride] : L;\n        } else {\n            TL = buf[width - (2 * stride) - 1];\n        }\n        add_lag_median_prediction(buf, buf - stride, buf,\n                                  width, &L, &TL);\n    }\n}", "target": 0}
{"code": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}", "target": 1}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static int vidioc_try_fmt_out(struct file *file, void *priv, struct v4l2_format *fmt)\n{\n\tstruct v4l2_loopback_device *dev;\n\tMARK();\n\tdev = v4l2loopback_getdevice(file);\n\tif (dev->ready_for_capture) {\n\t\tfmt->fmt.pix = dev->pix_format;\n\t} else {\n\t\t__u32 w = fmt->fmt.pix.width;\n\t\t__u32 h = fmt->fmt.pix.height;\n\t\t__u32 pixfmt = fmt->fmt.pix.pixelformat;\n\t\tconst struct v4l2l_format *format = format_by_fourcc(pixfmt);\n\t\tif (w > max_width)\n\t\t\tw = max_width;\n\t\tif (h > max_height)\n\t\t\th = max_height;\n\t\tdprintk(\"trying image %dx%d\\n\", w, h);\n\t\tif (w < 1)\n\t\t\tw = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;\n\t\tif (h < 1)\n\t\t\th = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;\n\t\tif (NULL == format)\n\t\t\tformat = &formats[0];\n\t\tpix_format_set_size(&fmt->fmt.pix, format, w, h);\n\t\tfmt->fmt.pix.pixelformat = format->fourcc;\n\t\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\t\tif (V4L2_FIELD_ANY == fmt->fmt.pix.field)\n\t\t\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\t\tdev->pix_format = fmt->fmt.pix;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "ospf_auth_type (struct ospf_interface *oi)\n{\n  int auth_type;\n  if (OSPF_IF_PARAM (oi, auth_type) == OSPF_AUTH_NOTSET)\n    auth_type = oi->area->auth_type;\n  else\n    auth_type = OSPF_IF_PARAM (oi, auth_type);\n  if (auth_type == OSPF_AUTH_CRYPTOGRAPHIC &&\n      list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    return OSPF_AUTH_NULL;\n  return auth_type;\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "gtime2generalTime(time_t gtime, char *str_time, size_t str_time_size)\n{\n\tsize_t ret;\n\tstruct tm _tm;\n\tif (gtime == (time_t)-1\n#if SIZEOF_LONG == 8\n\t\t|| gtime >= 253402210800\n#endif\n\t ) {\n        \tsnprintf(str_time, str_time_size, \"99991231235959Z\");\n        \treturn 0;\n\t}\n\tif (!gmtime_r(&gtime, &_tm)) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_INTERNAL_ERROR;\n\t}\n\tret = strftime(str_time, str_time_size, \"%Y%m%d%H%M%SZ\", &_tm);\n\tif (!ret) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_SHORT_MEMORY_BUFFER;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  TestHeaderMapImplBase(const HeaderMap& rhs) {\n    HeaderMapImpl::copyFrom(*header_map_, rhs);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "njs_string_slice(njs_vm_t *vm, njs_value_t *dst,\n    const njs_string_prop_t *string, const njs_slice_prop_t *slice)\n{\n    njs_string_prop_t  prop;\n    njs_string_slice_string_prop(&prop, string, slice);\n    if (njs_fast_path(prop.size != 0)) {\n        return njs_string_new(vm, dst, prop.start, prop.size, prop.length);\n    }\n    *dst = njs_string_empty;\n    return NJS_OK;\n}", "target": 0}
{"code": "virSecuritySELinuxMCSGetProcessRange(char **sens,\n                                     int *catMin,\n                                     int *catMax)\n{\n    char *ourSecContext = NULL;\n    context_t ourContext = NULL;\n    char *cat = NULL;\n    char *tmp;\n    const char *contextRange;\n    int ret = -1;\n    if (getcon_raw(&ourSecContext) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current process SELinux context\"));\n        goto cleanup;\n    }\n    if (!(ourContext = context_new(ourSecContext))) {\n        virReportSystemError(errno,\n                             _(\"Unable to parse current SELinux context '%s'\"),\n                             ourSecContext);\n        goto cleanup;\n    }\n    if (!(contextRange = context_range_get(ourContext)))\n        contextRange = \"s0\";\n    *sens = g_strdup(contextRange);\n    tmp = strchr(*sens, ':');\n    if (tmp) {\n        *tmp = '\\0';\n        cat = tmp + 1;\n    }\n    if ((tmp = strchr(*sens, '-')))\n        *tmp = '\\0';\n    if (!cat) {\n        *catMin = 0;\n        *catMax = 1023;\n        ret = 0;\n        goto cleanup;\n    }\n    tmp = cat;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMin) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    if (!tmp[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No category range available\"));\n        goto cleanup;\n    }\n    if (tmp[0] != '.') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (tmp[0] != 'c') {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    tmp++;\n    if (virStrToLong_i(tmp, &tmp, 10, catMax) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot parse category in %s\"),\n                       cat);\n        goto cleanup;\n    }\n    ret = 0;\n cleanup:\n    if (ret < 0)\n        VIR_FREE(*sens);\n    freecon(ourSecContext);\n    context_free(ourContext);\n    return ret;\n}", "target": 0}
{"code": "void InstanceKlass::release_C_heap_structures_internal() {\n  Klass::release_C_heap_structures();\n  if (_oop_map_cache != NULL) {\n    delete _oop_map_cache;\n    _oop_map_cache = NULL;\n  }\n  JNIid::deallocate(jni_ids());\n  set_jni_ids(NULL);\n  jmethodID* jmeths = methods_jmethod_ids_acquire();\n  if (jmeths != (jmethodID*)NULL) {\n    release_set_methods_jmethod_ids(NULL);\n    FreeHeap(jmeths);\n  }\n  assert(_dep_context == NULL,\n         \"dependencies should already be cleaned\");\n#if INCLUDE_JVMTI\n  if (breakpoints() != 0x0) {\n    methods_do(clear_all_breakpoints);\n    assert(breakpoints() == 0x0, \"should have cleared breakpoints\");\n  }\n  if (_cached_class_file != NULL) {\n    os::free(_cached_class_file);\n    _cached_class_file = NULL;\n  }\n#endif\n  FREE_C_HEAP_ARRAY(char, _source_debug_extension);\n}", "target": 0}
{"code": "    bool getTextValue(std::string& value, const XmpData::iterator& pos)\n    {\n        if (pos->typeId() == langAlt) {\n            value = pos->toString(0);\n            if (!pos->value().ok() && pos->count() == 1) {\n                value = pos->toString();\n                if (   pos->value().ok()\n                    && value.length() > 5 && value.substr(0, 5) == \"lang=\") {\n                    const std::string::size_type first_space_pos = value.find_first_of(' ');\n                    if (first_space_pos != std::string::npos) {\n                        value = value.substr(first_space_pos + 1);\n                    }\n                    else {\n                        value.clear();\n                    }\n                }\n            }\n        }\n        else {\n            value = pos->toString();\n        }\n        return pos->value().ok();\n    }", "target": 0}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "iasecc_pin_get_status(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data info;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for status\");\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = SC_PIN_CMD_GET_INFO;\n\tinfo.pin_type = data->pin_type;\n\tinfo.pin_reference = data->pin_reference;\n\trv = iso_ops->pin_cmd(card, &info, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"Failed to get PIN info\");\n\tdata->pin1.max_tries = info.pin1.max_tries;\n\tdata->pin1.tries_left = info.pin1.tries_left;\n\tdata->pin1.logged_in = info.pin1.logged_in;\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,\n\tint jpegSubsamp)\n{\n\tunsigned long retval=0;  int mcuw, mcuh, chromasf;\n\tif(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)\n\t\t_throwg(\"tjBufSize(): Invalid argument\");\n\tmcuw=tjMCUWidth[jpegSubsamp];\n\tmcuh=tjMCUHeight[jpegSubsamp];\n\tchromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);\n\tretval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "static bool ok_inflater_compressed_block(ok_inflater *inflater) {\n    const bool is_fixed = inflater->state == OK_INFLATER_STATE_READING_FIXED_COMPRESSED_BLOCK;\n    const ok_inflater_huffman_tree *literal_tree =\n        (is_fixed ? inflater->fixed_literal_huffman : inflater->literal_huffman);\n    const ok_inflater_huffman_tree *distance_tree =\n        (is_fixed ? inflater->fixed_distance_huffman : inflater->distance_huffman);\n    size_t max_write = ok_inflater_can_write_total(inflater);\n    const uint16_t *tree_lookup_table = literal_tree->lookup_table;\n    const unsigned int tree_bits = literal_tree->bits;\n    while (max_write > 0) {\n        int value = ok_inflater_decode_literal(inflater, tree_lookup_table, tree_bits);\n        if (value < 0) {\n            return false;\n        } else if (value < 256) {\n            ok_inflater_write_byte(inflater, (uint8_t)value);\n            max_write--;\n        } else if (value == 256) {\n            inflater->state = OK_INFLATER_STATE_READY_FOR_NEXT_BLOCK;\n            return true;\n        } else if (value < 286) {\n            inflater->huffman_code = value - 257;\n            inflater->state_count = -1;\n            inflater->state_distance = -1;\n            if (ok_inflater_distance_with_tree(inflater, distance_tree)) {\n                max_write = ok_inflater_can_write_total(inflater);\n            } else {\n                if (is_fixed) {\n                    inflater->state = OK_INFLATER_STATE_READING_FIXED_DISTANCE;\n                } else {\n                    inflater->state = OK_INFLATER_STATE_READING_DYNAMIC_DISTANCE;\n                }\n                return false;\n            }\n        } else {\n            ok_inflater_error(inflater, \"Invalid inflater literal\");\n            return false;\n        }\n    }\n    return false;\n}", "target": 0}
{"code": "Item *Item_cache_wrapper::check_cache()\n{\n  DBUG_ENTER(\"Item_cache_wrapper::check_cache\");\n  if (expr_cache)\n  {\n    Expression_cache_tmptable::result res;\n    Item *cached_value;\n    init_on_demand();\n    res= expr_cache->check_value(&cached_value);\n    if (res == Expression_cache_tmptable::HIT)\n      DBUG_RETURN(cached_value);\n  }\n  DBUG_RETURN(NULL);\n}", "target": 0}
{"code": "int x509_get_name( unsigned char **p, const unsigned char *end,\n                   x509_name *cur )\n{\n    int ret;\n    size_t len;\n    const unsigned char *end2;\n    x509_name *use;\n    if( ( ret = asn1_get_tag( p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SET ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n    end2 = end;\n    end  = *p + len;\n    use = cur;\n    do\n    {\n        if( ( ret = x509_get_attr_type_value( p, end, use ) ) != 0 )\n            return( ret );\n        if( *p != end )\n        {\n            use->next = (x509_name *) polarssl_malloc(\n                    sizeof( x509_name ) );\n            if( use->next == NULL )\n                return( POLARSSL_ERR_X509_MALLOC_FAILED );\n            memset( use->next, 0, sizeof( x509_name ) );\n            use = use->next;\n        }\n    }\n    while( *p != end );\n    if( *p == end2 )\n        return( 0 );\n    cur->next = (x509_name *) polarssl_malloc(\n         sizeof( x509_name ) );\n    if( cur->next == NULL )\n        return( POLARSSL_ERR_X509_MALLOC_FAILED );\n    memset( cur->next, 0, sizeof( x509_name ) );\n    return( x509_get_name( p, end2, cur->next ) );\n}", "target": 1}
{"code": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\treturn ret;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::OnSyntheticGestureCompleted(\n    SyntheticGesture::Result result) {\n  Send(new InputMsg_SyntheticGestureCompleted(GetRoutingID()));\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(sb))))\n\t\treturn;\n\ttrace_ext4_error(sb, function, line);\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\text4_unlock_group(sb, grp);\n\text4_commit_super(sb, 1);\n\text4_handle_error(sb);\n\text4_lock_group(sb, grp);\n\treturn;\n}", "target": 0}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "swallow_until_crlf(int fd, uschar *base, int already, int capacity)\n{\nuschar *to = base + already;\nuschar *cr;\nint have = 0;\nint ret;\nint last = 0;\ncr = memchr(base, '\\r', already);\nif (cr != NULL)\n  {\n  if ((cr - base) < already - 1)\n    {\n    return 0;\n    }\n  last = 1;\n  }\nwhile (capacity > 0)\n  {\n  do { ret = recv(fd, to, 1, 0); } while (ret == -1 && errno == EINTR);\n  if (ret == -1)\n    return -1;\n  have++;\n  if (last)\n    return have;\n  if (*to == '\\r')\n    last = 1;\n  capacity--;\n  to++;\n  }\nerrno = EOVERFLOW;\nreturn -1;\n}", "target": 0}
{"code": "static authz_status oidc_handle_unauthorized_user24(request_rec *r) {\n\toidc_debug(r, \"enter\");\n\toidc_cfg *c = ap_get_module_config(r->server->module_config, &auth_openidc_module);\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\t\t\t\t  OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_debug(r, \"setting environment variable %s to \\\"%s\\\" for usage in mod_headers\", OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\tapr_table_set(r->subprocess_env, OIDC_OAUTH_BEARER_SCOPE_ERROR, OIDC_OAUTH_BEARER_SCOPE_ERROR_VALUE);\n\t\treturn AUTHZ_DENIED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\t\tcase OIDC_UNAUTZ_RETURN403:\n\t\tcase OIDC_UNAUTZ_RETURN401:\n\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\t\treturn AUTHZ_DENIED;\n\t\t\tbreak;\n\t}\n\toidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n\tconst char *location = oidc_util_hdr_out_location_get(r);\n\tif (location != NULL) {\n\t\toidc_debug(r, \"send HTML refresh with authorization redirect: %s\", location);\n\t\tchar *html_head =\n\t\t\t\tapr_psprintf(r->pool, \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=%s\\\">\", location);\n\t\toidc_util_html_send(r, \"Stepup Authentication\", html_head, NULL, NULL,\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t\tr->header_only = 1;\n\t}\n\treturn AUTHZ_DENIED;\n}", "target": 0}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": "ffi_prep_closure_loc (ffi_closure *closure,\n                      ffi_cif* cif,\n                      void (*fun)(ffi_cif*,void*,void**,void*),\n                      void *user_data,\n                      void *codeloc)\n{\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n  void (*start)(void);\n  if (cif->flags & AARCH64_FLAG_ARG_V)\n    start = ffi_closure_SYSV_V;\n  else\n    start = ffi_closure_SYSV;\n#if FFI_EXEC_TRAMPOLINE_TABLE\n#ifdef __MACH__\n  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n  config[0] = closure;\n  config[1] = start;\n#endif\n#else\n  static const unsigned char trampoline[16] = {\n    0x90, 0x00, 0x00, 0x58,\t\n    0xf1, 0xff, 0xff, 0x10,\t\n    0x00, 0x02, 0x1f, 0xd6\t\n  };\n  char *tramp = closure->tramp;\n  memcpy (tramp, trampoline, sizeof(trampoline));\n  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n#endif\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n  return FFI_OK;\n}", "target": 1}
{"code": "MagickExport ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelPerceptualHash\n    *perceptual_hash;\n  char\n    *colorspaces,\n    *p,\n    *q;\n  const char\n    *artifact;\n  MagickBooleanType\n    status;\n  ssize_t\n    i;\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    MaxPixelChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  artifact=GetImageArtifact(image,\"phash:colorspaces\");\n  if (artifact != NULL)\n    colorspaces=AcquireString(artifact);\n  else\n    colorspaces=AcquireString(\"sRGB,HCLp\");\n  perceptual_hash[0].number_colorspaces=0;\n  perceptual_hash[0].number_channels=0;\n  q=colorspaces;\n  for (i=0; (p=StringToken(\",\",&q)) != (char *) NULL; i++)\n  {\n    ChannelMoments\n      *moments;\n    Image\n      *hash_image;\n    size_t\n      j;\n    ssize_t\n      channel,\n      colorspace;\n    if (i >= MaximumNumberOfPerceptualColorspaces)\n      break;\n    colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,p);\n    if (colorspace < 0)\n      break;\n    perceptual_hash[0].colorspace[i]=(ColorspaceType) colorspace;\n    hash_image=BlurImage(image,0.0,1.0,exception);\n    if (hash_image == (Image *) NULL)\n      break;\n    hash_image->depth=8;\n    status=TransformImageColorspace(hash_image,(ColorspaceType) colorspace,\n      exception);\n    if (status == MagickFalse)\n      break;\n    moments=GetImageMoments(hash_image,exception);\n    perceptual_hash[0].number_colorspaces++;\n    perceptual_hash[0].number_channels+=GetImageChannels(hash_image);\n    hash_image=DestroyImage(hash_image);\n    if (moments == (ChannelMoments *) NULL)\n      break;\n    for (channel=0; channel <= MaxPixelChannels; channel++)\n      for (j=0; j < MaximumNumberOfImageMoments; j++)\n        perceptual_hash[channel].phash[i][j]=\n          (-MagickLog10(moments[channel].invariant[j]));\n    moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  }\n  colorspaces=DestroyString(colorspaces);\n  return(perceptual_hash);\n}", "target": 0}
{"code": "read_data_stored(struct archive_read *a, const void **buff, size_t *size,\n                 int64_t *offset)\n{\n  struct rar *rar;\n  ssize_t bytes_avail;\n  rar = (struct rar *)(a->format->data);\n  if (rar->bytes_remaining == 0 &&\n    !(rar->main_flags & MHD_VOLUME && rar->file_flags & FHD_SPLIT_AFTER))\n  {\n    *buff = NULL;\n    *size = 0;\n    *offset = rar->offset;\n    if (rar->file_crc != rar->crc_calculated) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"File CRC error\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->entry_eof = 1;\n    return (ARCHIVE_EOF);\n  }\n  *buff = rar_read_ahead(a, 1, &bytes_avail);\n  if (bytes_avail <= 0)\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    return (ARCHIVE_FATAL);\n  }\n  *size = bytes_avail;\n  *offset = rar->offset;\n  rar->offset += bytes_avail;\n  rar->offset_seek += bytes_avail;\n  rar->bytes_remaining -= bytes_avail;\n  rar->bytes_unconsumed = bytes_avail;\n  rar->crc_calculated = crc32(rar->crc_calculated, *buff,\n    (unsigned)bytes_avail);\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "bool Virtual_tmp_table::add(List<Spvar_definition> &field_list)\n{\n  Spvar_definition *cdef;            \n  List_iterator_fast<Spvar_definition> it(field_list);\n  DBUG_ENTER(\"Virtual_tmp_table::add\");\n  while ((cdef= it++))\n  {\n    Field *tmp;\n    Record_addr addr(f_maybe_null(cdef->pack_flag));\n    if (!(tmp= cdef->make_field(s, in_use->mem_root, &addr, &cdef->field_name)))\n      DBUG_RETURN(true);\n    add(tmp);\n  }\n  DBUG_RETURN(false);\n}", "target": 0}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "int git_treebuilder_insert(\n\tconst git_tree_entry **entry_out,\n\tgit_treebuilder *bld,\n\tconst char *filename,\n\tconst git_oid *id,\n\tgit_filemode_t filemode)\n{\n\tgit_tree_entry *entry;\n\tsize_t pos;\n\tassert(bld && id && filename);\n\tif (!valid_filemode(filemode))\n\t\treturn tree_error(\"Failed to insert entry. Invalid filemode for file\", filename);\n\tif (!valid_entry_name(filename))\n\t\treturn tree_error(\"Failed to insert entry. Invalid name for a tree entry\", filename);\n\tif (!tree_key_search(&pos, &bld->entries, filename, strlen(filename))) {\n\t\tentry = git_vector_get(&bld->entries, pos);\n\t\tif (entry->removed) {\n\t\t\tentry->removed = 0;\n\t\t\tbld->entrycount++;\n\t\t}\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t} else {\n\t\tentry = alloc_entry(filename);\n\t\tGITERR_CHECK_ALLOC(entry);\n\t\tentry->attr = filemode;\n\t\tgit_oid_cpy(&entry->oid, id);\n\t\tif (git_vector_insert_sorted(&bld->entries, entry, NULL) < 0) {\n\t\t\tgit__free(entry);\n\t\t\treturn -1;\n\t\t}\n\t\tbld->entrycount++;\n\t}\n\tif (entry_out)\n\t\t*entry_out = entry;\n\treturn 0;\n}", "target": 0}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype) {\n  return [t, dtype](OpDef* op_def) {\n    FullTypeDef* tdef =\n        op_def->mutable_output_arg(0)->mutable_experimental_full_type();\n    tdef->set_type_id(t);\n    FullTypeDef* arg = tdef->add_args();\n    arg->set_type_id(TFT_TENSOR);\n    FullTypeDef* targ = arg->add_args();\n    targ->set_type_id(dtype);\n    return Status::OK();\n  };\n}", "target": 0}
{"code": "populate_lr_context(struct intel_context *ce,\n\t\t    struct drm_i915_gem_object *ctx_obj,\n\t\t    struct intel_engine_cs *engine,\n\t\t    struct intel_ring *ring)\n{\n\tbool inhibit = true;\n\tvoid *vaddr;\n\tu32 *regs;\n\tint ret;\n\tvaddr = i915_gem_object_pin_map(ctx_obj, I915_MAP_WB);\n\tif (IS_ERR(vaddr)) {\n\t\tret = PTR_ERR(vaddr);\n\t\tDRM_DEBUG_DRIVER(\"Could not map object pages! (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tset_redzone(vaddr, engine);\n\tif (engine->default_state) {\n\t\tvoid *defaults;\n\t\tdefaults = i915_gem_object_pin_map(engine->default_state,\n\t\t\t\t\t\t   I915_MAP_WB);\n\t\tif (IS_ERR(defaults)) {\n\t\t\tret = PTR_ERR(defaults);\n\t\t\tgoto err_unpin_ctx;\n\t\t}\n\t\tmemcpy(vaddr, defaults, engine->context_size);\n\t\ti915_gem_object_unpin_map(engine->default_state);\n\t\tinhibit = false;\n\t}\n\tregs = vaddr + LRC_STATE_PN * PAGE_SIZE;\n\texeclists_init_reg_state(regs, ce, engine, ring, inhibit);\n\tif (inhibit)\n\t\tregs[CTX_CONTEXT_CONTROL] |=\n\t\t\t_MASKED_BIT_ENABLE(CTX_CTRL_ENGINE_CTX_RESTORE_INHIBIT);\n\tret = 0;\nerr_unpin_ctx:\n\t__i915_gem_object_flush_map(ctx_obj, 0, engine->context_size);\n\ti915_gem_object_unpin_map(ctx_obj);\n\treturn ret;\n}", "target": 0}
{"code": "static bool rbuf_switch_to_malloc(conn *c) {\n    size_t size = c->rsize * 2;\n    char *tmp = malloc(size);\n    if (!tmp)\n        return false;\n    do_cache_free(c->thread->rbuf_cache, c->rbuf);\n    memcpy(tmp, c->rcurr, c->rbytes);\n    c->rcurr = c->rbuf = tmp;\n    c->rsize = size;\n    c->rbuf_malloced = true;\n    return true;\n}", "target": 0}
{"code": "static IHEVCD_ERROR_T ihevcd_parse_profile_tier_level_layer(bitstrm_t *ps_bitstrm,\n profile_tier_lvl_t *ps_ptl)\n{\n    WORD32 value;\n    WORD32 i;\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n    BITS_PARSE(\"XXX_profile_space[]\", value, ps_bitstrm, 2);\n    ps_ptl->i1_profile_space = value;\n    BITS_PARSE(\"XXX_tier_flag[]\", value, ps_bitstrm, 1);\n    ps_ptl->i1_tier_flag = value;\n    BITS_PARSE(\"XXX_profile_idc[]\", value, ps_bitstrm, 5);\n    ps_ptl->i1_profile_idc = value;\n for(i = 0; i < MAX_PROFILE_COMPATBLTY; i++)\n {\n        BITS_PARSE(\"XXX_profile_compatibility_flag[][j]\", value, ps_bitstrm, 1);\n        ps_ptl->ai1_profile_compatibility_flag[i] = value;\n }\n    BITS_PARSE(\"general_progressive_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_progressive_source_flag = value;\n    BITS_PARSE(\"general_interlaced_source_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_interlaced_source_flag = value;\n    BITS_PARSE(\"general_non_packed_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_general_non_packed_constraint_flag = value;\n    BITS_PARSE(\"general_frame_only_constraint_flag\", value, ps_bitstrm, 1);\n    ps_ptl->i1_frame_only_constraint_flag = value;\n    BITS_PARSE(\"XXX_reserved_zero_44bits[0..15]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[16..31]\", value, ps_bitstrm, 16);\n    BITS_PARSE(\"XXX_reserved_zero_44bits[32..43]\", value, ps_bitstrm, 12);\n return ret;\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\tint ioapic;\n\tint pin;\n\tstruct mpc_intsrc mp_irq;\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn;\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\t\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic); \n\tmp_irq.dstirq = pin;\t\n\tmp_save_irq(&mp_irq);\n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}", "target": 1}
{"code": "static void nfs4_xdr_enc_setclientid_confirm(struct rpc_rqst *req,\n\t\t\t\t\t     struct xdr_stream *xdr,\n\t\t\t\t\t     struct nfs4_setclientid_res *arg)\n{\n\tstruct compound_hdr hdr = {\n\t\t.nops\t= 0,\n\t};\n\tconst u32 lease_bitmap[3] = { FATTR4_WORD0_LEASE_TIME };\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_setclientid_confirm(xdr, arg, &hdr);\n\tencode_putrootfh(xdr, &hdr);\n\tencode_fsinfo(xdr, lease_bitmap, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "waitfd(int fd, int *timeoutp, short events)\n{\n\tstruct pollfd pfd;\n\tstruct timeval t_start;\n\tint oerrno, r;\n\tpfd.fd = fd;\n\tpfd.events = events;\n\tfor (; *timeoutp >= 0;) {\n\t\tmonotime_tv(&t_start);\n\t\tr = poll(&pfd, 1, *timeoutp);\n\t\toerrno = errno;\n\t\tms_subtract_diff(&t_start, timeoutp);\n\t\terrno = oerrno;\n\t\tif (r > 0)\n\t\t\treturn 0;\n\t\telse if (r == -1 && errno != EAGAIN && errno != EINTR)\n\t\t\treturn -1;\n\t\telse if (r == 0)\n\t\t\tbreak;\n\t}\n\terrno = ETIMEDOUT;\n\treturn -1;\n}", "target": 0}
{"code": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\tif(d_len<8) return;\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}", "target": 1}
{"code": "static int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  \n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  \n    return 0;\n  }\n  else return iswhite(o);\n}", "target": 0}
{"code": "    TiffComponent* newSonyMn(uint16_t    tag,\n                             IfdId       group,\n                             IfdId       ,\n                             const byte* pData,\n                             uint32_t    size,\n                             ByteOrder   )\n    {\n        if (size < 12 ||   std::string(reinterpret_cast<const char*>(pData), 12)\n                        != std::string(\"SONY DSC \\0\\0\\0\", 12)) {\n            if (size < 18) return 0;\n            return newSony2Mn2(tag, group, sony2Id);\n        }\n        if (size < SonyMnHeader::sizeOfSignature() + 14) return 0;\n        return newSony1Mn2(tag, group, sony1Id);\n    }", "target": 0}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "static int call_usermodehelper_keys(char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\treturn call_usermodehelper_fns(path, argv, envp, wait,\n\t\t\t\t       umh_keys_init, umh_keys_cleanup,\n\t\t\t\t       key_get(session_keyring));\n}", "target": 0}
{"code": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tchar src[PATH_MAX + 1];\n\tmemcpy(src, dir, dir_len);\n\tsrc[dir_len] = 0;\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\treturn NULL;\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "separate_nextcmd(exarg_T *eap, int keep_backslash)\n{\n    char_u\t*p;\n#ifdef FEAT_QUICKFIX\n    p = skip_grep_pat(eap);\n#else\n    p = eap->arg;\n#endif\n    for ( ; *p; MB_PTR_ADV(p))\n    {\n\tif (*p == Ctrl_V)\n\t{\n\t    if ((eap->argt & (EX_CTRLV | EX_XFILE)) || keep_backslash)\n\t\t++p;\t\t\n\t    else\n\t\tSTRMOVE(p, p + 1);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#ifdef FEAT_EVAL\n\telse if (p[0] == '`' && p[1] == '=' && (eap->argt & EX_XFILE))\n\t{\n\t    p += 2;\n\t    (void)skip_expr(&p, NULL);\n\t    if (*p == NUL)\t\t\n\t\tbreak;\n\t}\n#endif\n\telse if ((*p == '\"'\n#ifdef FEAT_EVAL\n\t\t    && !in_vim9script()\n#endif\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && ((eap->cmdidx != CMD_at && eap->cmdidx != CMD_star)\n\t\t\t\t\t\t\t      || p != eap->arg)\n\t\t    && (eap->cmdidx != CMD_redir\n\t\t\t\t\t || p != eap->arg + 1 || p[-1] != '@'))\n#ifdef FEAT_EVAL\n\t\t|| (*p == '#'\n\t\t    && in_vim9script()\n\t\t    && !(eap->argt & EX_NOTRLCOM)\n\t\t    && p > eap->cmd && VIM_ISWHITE(p[-1]))\n#endif\n\t\t|| *p == '|' || *p == '\\n')\n\t{\n\t    if ((vim_strchr(p_cpo, CPO_BAR) == NULL\n\t\t\t      || !(eap->argt & EX_CTRLV)) && *(p - 1) == '\\\\')\n\t    {\n\t\tif (!keep_backslash)\n\t\t{\n\t\t    STRMOVE(p - 1, p);\t\n\t\t    --p;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\teap->nextcmd = check_nextcmd(p);\n\t\t*p = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (!(eap->argt & EX_NOTRLCOM))\t\n\tdel_trailing_spaces(eap->arg);\n}", "target": 0}
{"code": "connection *connection_accept(server *srv, server_socket *srv_socket) {\n\tint cnt;\n\tsock_addr cnt_addr;\n\tsize_t cnt_len = sizeof(cnt_addr); \n\tif (srv->conns.used >= srv->max_conns) {\n\t\treturn NULL;\n\t}\n\tcnt = fdevent_accept_listenfd(srv_socket->fd, (struct sockaddr *) &cnt_addr, &cnt_len);\n\tif (-1 == cnt) {\n\t\tswitch (errno) {\n\t\tcase EAGAIN:\n#if EWOULDBLOCK != EAGAIN\n\t\tcase EWOULDBLOCK:\n#endif\n\t\tcase EINTR:\n\t\tcase ECONNABORTED: \n\t\t\tbreak;\n\t\tcase EMFILE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_perror(srv->errh, __FILE__, __LINE__, \"accept failed\");\n\t\t}\n\t\treturn NULL;\n\t} else {\n\t\tif (sock_addr_get_family(&cnt_addr) != AF_UNIX) {\n\t\t\tnetwork_accept_tcp_nagle_disable(cnt);\n\t\t}\n\t\treturn connection_accepted(srv, srv_socket, &cnt_addr, cnt);\n\t}\n}", "target": 0}
{"code": "ns_client_shuttingdown(ns_client_t *client) {\n\treturn (client->newstate == NS_CLIENTSTATE_FREED);\n}", "target": 0}
{"code": "ssize_t qemu_deliver_packet_iov(NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                void *opaque)\n{\n    NetClientState *nc = opaque;\n    size_t size = iov_size(iov, iovcnt);\n    int ret;\n    if (size > INT_MAX) {\n        return size;\n    }\n    if (nc->link_down) {\n        return size;\n    }\n    if (nc->receive_disabled) {\n        return 0;\n    }\n    if (nc->info->receive_iov && !(flags & QEMU_NET_PACKET_FLAG_RAW)) {\n        ret = nc->info->receive_iov(nc, iov, iovcnt);\n    } else {\n        ret = nc_sendv_compat(nc, iov, iovcnt, flags);\n    }\n    if (ret == 0) {\n        nc->receive_disabled = 1;\n    }\n    return ret;\n}", "target": 1}
{"code": "onig_node_str_cat(Node* node, const UChar* s, const UChar* end)\n{\n  ptrdiff_t addlen = end - s;\n  if (addlen > 0) {\n    ptrdiff_t len  = NSTR(node)->end - NSTR(node)->s;\n    if (NSTR(node)->capa > 0 || (len + addlen > NODE_STR_BUF_SIZE - 1)) {\n      UChar* p;\n      ptrdiff_t capa = len + addlen + NODE_STR_MARGIN;\n      if (capa <= NSTR(node)->capa) {\n\tonig_strcpy(NSTR(node)->s + len, s, end);\n      }\n      else {\n\tif (NSTR(node)->s == NSTR(node)->buf)\n\t  p = strcat_capa_from_static(NSTR(node)->s, NSTR(node)->end,\n\t\t\t\t      s, end, capa);\n\telse\n\t  p = strcat_capa(NSTR(node)->s, NSTR(node)->end, s, end, capa);\n\tCHECK_NULL_RETURN_MEMERR(p);\n\tNSTR(node)->s    = p;\n\tNSTR(node)->capa = (int )capa;\n      }\n    }\n    else {\n      onig_strcpy(NSTR(node)->s + len, s, end);\n    }\n    NSTR(node)->end = NSTR(node)->s + len + addlen;\n  }\n  return 0;\n}", "target": 0}
{"code": "void ax25_fillin_cb(ax25_cb *ax25, ax25_dev *ax25_dev)\n{\n\tax25->ax25_dev = ax25_dev;\n\tif (ax25->ax25_dev != NULL) {\n\t\tax25_fillin_cb_from_dev(ax25, ax25_dev);\n\t\treturn;\n\t}\n\tax25->rtt     = msecs_to_jiffies(AX25_DEF_T1) / 2;\n\tax25->t1      = msecs_to_jiffies(AX25_DEF_T1);\n\tax25->t2      = msecs_to_jiffies(AX25_DEF_T2);\n\tax25->t3      = msecs_to_jiffies(AX25_DEF_T3);\n\tax25->n2      = AX25_DEF_N2;\n\tax25->paclen  = AX25_DEF_PACLEN;\n\tax25->idle    = msecs_to_jiffies(AX25_DEF_IDLE);\n\tax25->backoff = AX25_DEF_BACKOFF;\n\tif (AX25_DEF_AXDEFMODE) {\n\t\tax25->modulus = AX25_EMODULUS;\n\t\tax25->window  = AX25_DEF_EWINDOW;\n\t} else {\n\t\tax25->modulus = AX25_MODULUS;\n\t\tax25->window  = AX25_DEF_WINDOW;\n\t}\n}", "target": 0}
{"code": "void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n   tBTM_LE_PENC_KEYS le_key;\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);\n   STREAM_TO_UINT16(le_key.ediv, p);\n  STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN);\n  memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);\n  le_key.sec_level = p_cb->sec_level;\n  le_key.key_size = p_cb->loc_enc_size;\n if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&\n (p_cb->loc_auth_req & SMP_AUTH_BOND))\n    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,\n (tBTM_LE_KEY_VALUE*)&le_key, true);\n  smp_key_distribution(p_cb, NULL);\n}", "target": 1}
{"code": "void dev_init_scheduler(struct net_device *dev)\n{\n\tqdisc_lock_tree(dev);\n\tdev->qdisc = &noop_qdisc;\n\tdev->qdisc_sleeping = &noop_qdisc;\n\tINIT_LIST_HEAD(&dev->qdisc_list);\n\tqdisc_unlock_tree(dev);\n\tsetup_timer(&dev->watchdog_timer, dev_watchdog, (unsigned long)dev);\n}", "target": 0}
{"code": "aspath_print_vty (struct vty *vty, const char *format, struct aspath *as, const char * suffix)\n{\n  assert (format);\n  vty_out (vty, format, as->str);\n  if (as->str_len && strlen (suffix))\n    vty_out (vty, \"%s\", suffix);\n}", "target": 0}
{"code": "void bnx2x__init_func_obj(struct bnx2x *bp)\n{\n\tbnx2x_setup_dmae(bp);\n\tbnx2x_init_func_obj(bp, &bp->func_obj,\n\t\t\t    bnx2x_sp(bp, func_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_rdata),\n\t\t\t    bnx2x_sp(bp, func_afex_rdata),\n\t\t\t    bnx2x_sp_mapping(bp, func_afex_rdata),\n\t\t\t    &bnx2x_func_sp_drv);\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "static UInt32 GetUsedMemory(const CPpmd8 *p)\n{\n  UInt32 v = 0;\n  unsigned i;\n  for (i = 0; i < PPMD_NUM_INDEXES; i++)\n    v += p->Stamps[i] * I2U(i);\n  return p->Size - (UInt32)(p->HiUnit - p->LoUnit) - (UInt32)(p->UnitsStart - p->Text) - U2B(v);\n}", "target": 0}
{"code": "  AudioContextTest() :\n      platform_(new ScopedTestingPlatformSupport<AudioContextTestPlatform>) {}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "static int __init si_domain_init(int hw)\n{\n\tint nid, ret;\n\tsi_domain = alloc_domain(DOMAIN_FLAG_STATIC_IDENTITY);\n\tif (!si_domain)\n\t\treturn -EFAULT;\n\tif (md_domain_init(si_domain, DEFAULT_DOMAIN_ADDRESS_WIDTH)) {\n\t\tdomain_exit(si_domain);\n\t\treturn -EFAULT;\n\t}\n\tpr_debug(\"Identity mapping domain allocated\\n\");\n\tif (hw)\n\t\treturn 0;\n\tfor_each_online_node(nid) {\n\t\tunsigned long start_pfn, end_pfn;\n\t\tint i;\n\t\tfor_each_mem_pfn_range(i, nid, &start_pfn, &end_pfn, NULL) {\n\t\t\tret = iommu_domain_identity_map(si_domain,\n\t\t\t\t\tPFN_PHYS(start_pfn), PFN_PHYS(end_pfn));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TEST_F(LuaHeaderMapWrapperTest, ModifyAfterIteration) {\n  const std::string SCRIPT{R\"EOF(\n    function callMe(object)\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n      object:add(\"hello\", \"world\")\n      for key, value in pairs(object) do\n        testPrint(string.format(\"'%s' '%s'\", key, value))\n      end\n    end\n  )EOF\"};\n  InSequence s;\n  setup(SCRIPT);\n  Http::TestRequestHeaderMapImpl headers{{\"foo\", \"bar\"}};\n  HeaderMapWrapper::create(coroutine_->luaState(), headers, []() { return true; });\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'foo' 'bar'\"));\n  EXPECT_CALL(printer_, testPrint(\"'hello' 'world'\"));\n  start(\"callMe\");\n}", "target": 0}
{"code": "static int cenc_scheme_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    int i, ret;\n    int bytes_of_protected_data;\n    if (!sc->cenc.aes_ctr) {\n        sc->cenc.aes_ctr = av_aes_ctr_alloc();\n        if (!sc->cenc.aes_ctr) {\n            return AVERROR(ENOMEM);\n        }\n        ret = av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    av_aes_ctr_set_full_iv(sc->cenc.aes_ctr, sample->iv);\n    if (!sample->subsample_count) {\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n    for (i = 0; i < sample->subsample_count; i++) {\n        if (sample->subsamples[i].bytes_of_clear_data + sample->subsamples[i].bytes_of_protected_data > size) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        input += sample->subsamples[i].bytes_of_clear_data;\n        size -= sample->subsamples[i].bytes_of_clear_data;\n        bytes_of_protected_data = sample->subsamples[i].bytes_of_protected_data;\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, bytes_of_protected_data);\n        input += bytes_of_protected_data;\n        size -= bytes_of_protected_data;\n    }\n    if (size > 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    return 0;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int nf_tables_set_notify(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tint event, gfp_t gfp_flags)\n{\n\tstruct sk_buff *skb;\n\tu32 portid = ctx->portid;\n\tint err;\n\tif (!ctx->report &&\n\t    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))\n\t\treturn 0;\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(NLMSG_GOODSIZE, gfp_flags);\n\tif (skb == NULL)\n\t\tgoto err;\n\terr = nf_tables_fill_set(skb, ctx, set, event, 0);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto err;\n\t}\n\terr = nfnetlink_send(skb, ctx->net, portid, NFNLGRP_NFTABLES,\n\t\t\t     ctx->report, gfp_flags);\nerr:\n\tif (err < 0)\n\t\tnfnetlink_set_err(ctx->net, portid, NFNLGRP_NFTABLES, err);\n\treturn err;\n}", "target": 0}
{"code": "  void Parser::parse_block_comments()\n  {\n    Block_Obj block = block_stack.back();\n    while (lex< block_comment >()) {\n      bool is_important = lexed.begin[2] == '!';\n      String_Obj contents = parse_interpolated_chunk(lexed, true, false);\n      block->append(SASS_MEMORY_NEW(Comment, pstate, contents, is_important));\n    }\n  }", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "void rsi_mac80211_detach(struct rsi_hw *adapter)\n{\n\tstruct ieee80211_hw *hw = adapter->hw;\n\tenum nl80211_band band;\n\tif (hw) {\n\t\tieee80211_stop_queues(hw);\n\t\tieee80211_unregister_hw(hw);\n\t\tieee80211_free_hw(hw);\n\t}\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\t\t&adapter->sbands[band];\n\t\tkfree(sband->channels);\n\t}\n#ifdef CONFIG_RSI_DEBUGFS\n\trsi_remove_dbgfs(adapter);\n\tkfree(adapter->dfsentry);\n#endif\n}", "target": 1}
{"code": "print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef CONFIG_TIMER_STATS\n\tchar tmp[TASK_COMM_LEN + 1];\n#endif\n\tSEQ_printf(m, \" #%d: \", idx);\n\tprint_name_offset(m, taddr);\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n#ifdef CONFIG_TIMER_STATS\n\tSEQ_printf(m, \", \");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, TASK_COMM_LEN);\n\ttmp[TASK_COMM_LEN] = 0;\n\tSEQ_printf(m, \", %s/%d\", tmp, timer->start_pid);\n#endif\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}", "target": 1}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 1}
{"code": "isdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\tif (p) {\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "bool unit_suffix_is_valid(const char *s) {\n        if (isempty(s))\n                return false;\n        if (s[0] != '.')\n                return false;\n        if (unit_type_from_string(s + 1) < 0)\n                return false;\n        return true;\n}", "target": 0}
{"code": "static int sco_connect(struct sock *sk)\n{\n\tbdaddr_t *src = &bt_sk(sk)->src;\n\tbdaddr_t *dst = &bt_sk(sk)->dst;\n\tstruct sco_conn *conn;\n\tstruct hci_conn *hcon;\n\tstruct hci_dev  *hdev;\n\tint err, type;\n\tBT_DBG(\"%s -> %s\", batostr(src), batostr(dst));\n\thdev = hci_get_route(dst, src);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock_bh(hdev);\n\terr = -ENOMEM;\n\tif (lmp_esco_capable(hdev) && !disable_esco)\n\t\ttype = ESCO_LINK;\n\telse\n\t\ttype = SCO_LINK;\n\thcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);\n\tif (!hcon)\n\t\tgoto done;\n\tconn = sco_conn_add(hcon, 0);\n\tif (!conn) {\n\t\thci_conn_put(hcon);\n\t\tgoto done;\n\t}\n\tbacpy(src, conn->src);\n\terr = sco_chan_add(conn, sk, NULL);\n\tif (err)\n\t\tgoto done;\n\tif (hcon->state == BT_CONNECTED) {\n\t\tsco_sock_clear_timer(sk);\n\t\tsk->sk_state = BT_CONNECTED;\n\t} else {\n\t\tsk->sk_state = BT_CONNECT;\n\t\tsco_sock_set_timer(sk, sk->sk_sndtimeo);\n\t}\ndone:\n\thci_dev_unlock_bh(hdev);\n\thci_dev_put(hdev);\n\treturn err;\n}", "target": 0}
{"code": "xsltGetKey(xsltTransformContextPtr ctxt, const xmlChar *name,\n\t   const xmlChar *nameURI, const xmlChar *value) {\n    xmlNodeSetPtr ret;\n    xsltKeyTablePtr table;\n    int init_table = 0;\n    if ((ctxt == NULL) || (name == NULL) || (value == NULL) ||\n\t(ctxt->document == NULL))\n\treturn(NULL);\n#ifdef WITH_XSLT_DEBUG_KEYS\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"Get key %s, value %s\\n\", name, value);\n#endif\n    if ((ctxt->document->nbKeysComputed < ctxt->nbKeys) &&\n        (ctxt->keyInitLevel == 0)) {\n\tif (xsltInitAllDocKeys(ctxt))\n\t    return(NULL);\n    }\nretry:\n    table = (xsltKeyTablePtr) ctxt->document->keys;\n    while (table != NULL) {\n\tif (((nameURI != NULL) == (table->nameURI != NULL)) &&\n\t    xmlStrEqual(table->name, name) &&\n\t    xmlStrEqual(table->nameURI, nameURI))\n\t{\n\t    ret = (xmlNodeSetPtr)xmlHashLookup(table->keys, value);\n\t    return(ret);\n\t}\n\ttable = table->next;\n    }\n    if ((ctxt->keyInitLevel != 0) && (init_table == 0)) {\n        xsltInitDocKeyTable(ctxt, name, nameURI);\n\tinit_table = 1;\n\tgoto retry;\n    }\n    return(NULL);\n}", "target": 0}
{"code": "AP_DECLARE(const char *) ap_get_useragent_host(request_rec *r,\n                                               int type, int *str_is_ip)\n{\n    conn_rec *conn = r->connection;\n    int hostname_lookups;\n    int ignored_str_is_ip;\n    if (!r->useragent_addr || (r->useragent_addr == conn->client_addr)) {\n        return ap_get_remote_host(conn, r->per_dir_config, type, str_is_ip);\n    }\n    if (!str_is_ip) { \n        str_is_ip = &ignored_str_is_ip;\n    }\n    *str_is_ip = 0;\n    hostname_lookups = ((core_dir_config *)\n                        ap_get_core_module_config(r->per_dir_config))\n                            ->hostname_lookups;\n    if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {\n        hostname_lookups = HOSTNAME_LOOKUP_OFF;\n    }\n    if (type != REMOTE_NOLOOKUP\n        && r->useragent_host == NULL\n        && (type == REMOTE_DOUBLE_REV\n        || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {\n        if (apr_getnameinfo(&r->useragent_host, r->useragent_addr, 0)\n            == APR_SUCCESS) {\n            ap_str_tolower(r->useragent_host);\n            if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {\n                r->double_reverse = do_double_reverse(r->double_reverse,\n                                                      r->useragent_host,\n                                                      r->useragent_addr,\n                                                      r->pool);\n                if (r->double_reverse != 1) {\n                    r->useragent_host = NULL;\n                }\n            }\n        }\n        if (r->useragent_host == NULL) {\n            r->useragent_host = \"\";\n        }\n    }\n    if (type == REMOTE_DOUBLE_REV) {\n        r->double_reverse = do_double_reverse(r->double_reverse,\n                                              r->useragent_host,\n                                              r->useragent_addr, r->pool);\n        if (r->double_reverse == -1) {\n            return NULL;\n        }\n    }\n    if (r->useragent_host != NULL && r->useragent_host[0] != '\\0') {\n        return r->useragent_host;\n    }\n    else {\n        if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {\n            return NULL;\n        }\n        else {\n            *str_is_ip = 1;\n            return r->useragent_ip;\n        }\n    }\n}", "target": 0}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": "static void build_probe_list(struct inode *inode,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long start, unsigned long end,\n\t\t\t\tstruct list_head *head)\n{\n\tloff_t min, max;\n\tstruct rb_node *n, *t;\n\tstruct uprobe *u;\n\tINIT_LIST_HEAD(head);\n\tmin = vaddr_to_offset(vma, start);\n\tmax = min + (end - start) - 1;\n\tspin_lock(&uprobes_treelock);\n\tn = find_node_in_range(inode, min, max);\n\tif (n) {\n\t\tfor (t = n; t; t = rb_prev(t)) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset < min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t\tfor (t = n; (t = rb_next(t)); ) {\n\t\t\tu = rb_entry(t, struct uprobe, rb_node);\n\t\t\tif (u->inode != inode || u->offset > max)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->pending_list, head);\n\t\t\tget_uprobe(u);\n\t\t}\n\t}\n\tspin_unlock(&uprobes_treelock);\n}", "target": 0}
{"code": "static void *m_start(struct seq_file *seq, loff_t *ppos, struct uid_gid_map *map)\n{\n\tstruct uid_gid_extent *extent = NULL;\n\tloff_t pos = *ppos;\n\tif (pos < map->nr_extents)\n\t\textent = &map->extent[pos];\n\treturn extent;\n}", "target": 0}
{"code": "set_num_712(unsigned char *p, char value)\n{\n\t*((char *)p) = value;\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "_dbus_printf_string_upper_bound (const char *format,\n                                 va_list     args)\n{\n  char static_buf[1024];\n  int bufsize = sizeof (static_buf);\n  int len;\n  len = vsnprintf (static_buf, bufsize, format, args);\n  if (len == bufsize)\n    {\n      if (vsnprintf (static_buf, 1, format, args) == 1)\n        len = -1;\n    }\n  while (len < 0)\n    {\n      char *buf;\n      bufsize *= 2;\n      buf = dbus_malloc (bufsize);\n      if (buf == NULL)\n        return -1;\n      len = vsnprintf (buf, bufsize, format, args);\n      dbus_free (buf);\n      if (len == bufsize)\n        len = -1;\n    }\n  return len;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}", "target": 1}
{"code": "static int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (event->attr.config != PERF_COUNT_SW_TASK_CLOCK)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tperf_swevent_init_hrtimer(event);\n\treturn 0;\n}", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "static void dtls1_set_handshake_header(SSL *s, int htype, unsigned long len)\n{\n    unsigned char *p = (unsigned char *)s->init_buf->data;\n    dtls1_set_message_header(s, p, htype, len, 0, len);\n    s->init_num = (int)len + DTLS1_HM_HEADER_LENGTH;\n    s->init_off = 0;\n    dtls1_buffer_message(s, 0);\n}", "target": 0}
{"code": "vte_sequence_handler_fs (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->status_line = FALSE;\n}", "target": 0}
{"code": "void UpdateWebTouchEventAfterDispatch(blink::WebTouchEvent* event,\n                                      blink::WebTouchPoint* point) {\n  if (point->state != blink::WebTouchPoint::StateReleased &&\n      point->state != blink::WebTouchPoint::StateCancelled)\n    return;\n  --event->touchesLength;\n  for (unsigned i = point - event->touches;\n       i < event->touchesLength;\n       ++i) {\n    event->touches[i] = event->touches[i + 1];\n  }\n}", "target": 0}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "bool HeaderToMetadataFilter::addMetadata(StructMap& map, const std::string& meta_namespace,\n                                         const std::string& key, std::string value, ValueType type,\n                                         ValueEncode encode) const {\n  ProtobufWkt::Value val;\n  ASSERT(!value.empty());\n  if (value.size() >= MAX_HEADER_VALUE_LEN) {\n    ENVOY_LOG(debug, \"metadata value is too long\");\n    return false;\n  }\n  if (encode == envoy::extensions::filters::http::header_to_metadata::v3::Config::BASE64) {\n    value = Base64::decodeWithoutPadding(value);\n    if (value.empty()) {\n      ENVOY_LOG(debug, \"Base64 decode failed\");\n      return false;\n    }\n  }\n  switch (type) {\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::STRING:\n    val.set_string_value(std::move(value));\n    break;\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::NUMBER: {\n    double dval;\n    if (absl::SimpleAtod(StringUtil::trim(value), &dval)) {\n      val.set_number_value(dval);\n    } else {\n      ENVOY_LOG(debug, \"value to number conversion failed\");\n      return false;\n    }\n    break;\n  }\n  case envoy::extensions::filters::http::header_to_metadata::v3::Config::PROTOBUF_VALUE: {\n    if (!val.ParseFromString(value)) {\n      ENVOY_LOG(debug, \"parse from decoded string failed\");\n      return false;\n    }\n    break;\n  }\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n  auto namespace_iter = map.find(meta_namespace);\n  if (namespace_iter == map.end()) {\n    map[meta_namespace] = ProtobufWkt::Struct();\n    namespace_iter = map.find(meta_namespace);\n  }\n  auto& keyval = namespace_iter->second;\n  (*keyval.mutable_fields())[key] = val;\n  return true;\n}", "target": 0}
{"code": "int HeaderMapWrapper::luaGet(lua_State* state) {\n  const char* key = luaL_checkstring(state, 2);\n  const auto value =\n      Http::HeaderUtility::getAllOfHeaderAsString(headers_, Http::LowerCaseString(key));\n  if (value.result().has_value()) {\n    lua_pushlstring(state, value.result().value().data(), value.result().value().length());\n    return 1;\n  } else {\n    return 0;\n  }\n}", "target": 0}
{"code": "std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 1}
{"code": "Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size)\n{\n  if (p->Base == 0 || p->Size != size)\n  {\n    Ppmd8_Free(p);\n    p->AlignOffset =\n      #ifdef PPMD_32BIT\n        (4 - size) & 3;\n      #else\n        4 - (size & 3);\n      #endif\n    if ((p->Base = (Byte *)malloc(p->AlignOffset + size)) == 0)\n      return False;\n    p->Size = size;\n  }\n  return True;\n}", "target": 0}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 1}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "pushvar(struct SWF_ACTIONPUSHPARAM *val)\n{\n\tstruct _stack *t;\n#ifdef DEBUG\n\tprintf(\"*pushvar*\\n\");\n#endif\n\tt = calloc(1,sizeof(*Stack));\n\tt->type = 'v'; \n\tt->val = val;\n\tt->next = Stack;\n\tStack = t;\n}", "target": 0}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "const GURL& WebContentsImpl::GetURL() const {\n  NavigationEntry* entry = controller_.GetVisibleEntry();\n  return entry ? entry->GetVirtualURL() : GURL::EmptyGURL();\n}", "target": 0}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "dirserv_cache_measured_bw(const measured_bw_line_t *parsed_line,\n                          time_t as_of)\n{\n  mbw_cache_entry_t *e = NULL;\n  tor_assert(parsed_line);\n  if (!mbw_cache) mbw_cache = digestmap_new();\n  e = digestmap_get(mbw_cache, parsed_line->node_id);\n  if (e) {\n    if (as_of > e->as_of) {\n      e->mbw_kb = parsed_line->bw_kb;\n      e->as_of = as_of;\n    }\n  } else {\n    e = tor_malloc(sizeof(*e));\n    e->mbw_kb = parsed_line->bw_kb;\n    e->as_of = as_of;\n    digestmap_set(mbw_cache, parsed_line->node_id, e);\n  }\n}", "target": 0}
{"code": "void PrintHeaderFooterText(\n    string16 text,\n    WebKit::WebCanvas* canvas,\n    HeaderFooterPaint paint,\n    float webkit_scale_factor,\n    const PageSizeMargins& page_layout,\n    printing::HorizontalHeaderFooterPosition horizontal_position,\n    printing::VerticalHeaderFooterPosition vertical_position,\n    double offset_to_baseline) {\n#if defined(USE_SKIA)\n  size_t text_byte_length = text.length() * sizeof(char16);\n  double text_width_in_points = SkScalarToDouble(paint.measureText(\n      text.c_str(), text_byte_length));\n  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor, page_layout,\n                                          horizontal_position,\n                                          vertical_position, offset_to_baseline,\n                                          text_width_in_points);\n  paint.setTextSize(SkDoubleToScalar(\n      paint.getTextSize() / webkit_scale_factor));\n  canvas->drawText(text.c_str(), text_byte_length, point.x(), point.y(),\n                   paint);\n#elif defined(OS_MACOSX)\n  ScopedCFTypeRef<CFStringRef> cf_text(base::SysUTF16ToCFStringRef(text));\n  ScopedCFTypeRef<CFAttributedStringRef> cf_attr_text(\n      CFAttributedStringCreate(NULL, cf_text, paint));\n  ScopedCFTypeRef<CTLineRef> line(CTLineCreateWithAttributedString(\n      cf_attr_text));\n  double text_width_in_points =\n      CTLineGetTypographicBounds(line, NULL, NULL, NULL) * webkit_scale_factor;\n  SkPoint point = GetHeaderFooterPosition(webkit_scale_factor,\n                                          page_layout, horizontal_position,\n                                          vertical_position, offset_to_baseline,\n                                          text_width_in_points);\n  CGContextSetTextPosition(canvas, SkScalarToDouble(point.x()),\n                           SkScalarToDouble(point.y()));\n  CTLineDraw(line, canvas);\n#endif\n}", "target": 0}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": "Browser::CreateParams::CreateParams(Type type, Profile* profile)\n    : type(type),\n      profile(profile),\n      trusted_source(false),\n      initial_show_state(ui::SHOW_STATE_DEFAULT),\n      is_session_restore(false),\n      window(NULL) {}", "target": 0}
{"code": "  void set_simulator_redirection(Redirection* redirection) {\n    simulator_redirection_ = redirection;\n  }", "target": 0}
{"code": "static void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint base;\n\tif (up_flag)\n\t\treturn;\n\tif (value < 10) {\n\t\tbase = 10;\n\t} else {\n\t\tvalue -= 10;\n\t\tbase = 16;\n\t}\n\tif (npadch == -1)\n\t\tnpadch = value;\n\telse\n\t\tnpadch = npadch * base + value;\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "bool kvm_check_and_clear_guest_paused(void)\n{\n\tbool ret = false;\n\tstruct pvclock_vcpu_time_info *src;\n\tint cpu = smp_processor_id();\n\tif (!hv_clock)\n\t\treturn ret;\n\tsrc = &hv_clock[cpu].pvti;\n\tif ((src->flags & PVCLOCK_GUEST_STOPPED) != 0) {\n\t\tsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\n\t\tpvclock_touch_watchdogs();\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\treturn count;\n}", "target": 1}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  \n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }\n  }", "target": 1}
{"code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn whichfork != XFS_COW_FORK &&\n\t\tXFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}", "target": 0}
{"code": "GF_Err srpp_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_SRTPProcessBox *ptr = (GF_SRTPProcessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tif (ptr->info) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->info = (GF_SchemeInformationBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tif (ptr->scheme_type) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->scheme_type = (GF_SchemeTypeBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "void MultiplySum(const size_t xsize,\n                 const pixel_type* const JXL_RESTRICT row_in,\n                 const pixel_type* const JXL_RESTRICT row_in_Y,\n                 const float factor, float* const JXL_RESTRICT row_out) {\n  const HWY_FULL(float) df;\n  const Rebind<pixel_type, HWY_FULL(float)> di;  \n  const auto factor_v = Set(df, factor);\n  for (size_t x = 0; x < xsize; x += Lanes(di)) {\n    const auto in = Load(di, row_in + x) + Load(di, row_in_Y + x);\n    const auto out = ConvertTo(df, in) * factor_v;\n    Store(out, df, row_out + x);\n  }\n}", "target": 0}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "PHP_FUNCTION(move_uploaded_file)\n{\n\tchar *path, *new_path;\n\tint path_len, new_path_len;\n\tzend_bool successful = 0;\n#ifndef PHP_WIN32\n\tint oldmask; int ret;\n#endif\n\tif (!SG(rfc1867_uploaded_files)) {\n                RETURN_FALSE;\n        }\n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &path, &path_len, &new_path, &new_path_len) == FAILURE) {\n                return;\n        }\n\tif (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (php_check_open_basedir(new_path TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (VCWD_RENAME(path, new_path) == 0) {\n\t\tsuccessful = 1;\n#ifndef PHP_WIN32\n\t\toldmask = umask(077);\n\t\tumask(oldmask);\n\t\tret = VCWD_CHMOD(new_path, 0666 & ~oldmask);\n\t\tif (ret == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t}\n#endif\n\t} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {\n\t\tVCWD_UNLINK(path);\n\t\tsuccessful = 1;\n\t}\n\tif (successful) {\n\t\tzend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to move '%s' to '%s'\", path, new_path);\n\t}\n\tRETURN_BOOL(successful);\n}", "target": 1}
{"code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "sg_release(struct inode *inode, struct file *filp)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, \"sg_release\\n\"));\n\tmutex_lock(&sdp->open_rel_lock);\n\tscsi_autopm_put_device(sdp->device);\n\tkref_put(&sfp->f_ref, sg_remove_sfp);\n\tsdp->open_cnt--;\n\tif (sdp->exclude) {\n\t\tsdp->exclude = false;\n\t\twake_up_interruptible_all(&sdp->open_wait);\n\t} else if (0 == sdp->open_cnt) {\n\t\twake_up_interruptible(&sdp->open_wait);\n\t}\n\tmutex_unlock(&sdp->open_rel_lock);\n\treturn 0;\n}", "target": 0}
{"code": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}", "target": 1}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ChildProcessSecurityPolicyImpl::RegisterPseudoScheme(\n    const std::string& scheme) {\n  base::AutoLock lock(lock_);\n  DCHECK(pseudo_schemes_.count(scheme) == 0) << \"Add schemes at most once.\";\n  DCHECK(web_safe_schemes_.count(scheme) == 0) <<\n      \"Pseudo implies not web-safe.\";\n  pseudo_schemes_.insert(scheme);\n}", "target": 0}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "is_empty(const uint8_t *data, size_t size)\n{\n\tsize_t i;\n\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n\t\tif (data[i] != ' ')\n\t\t\treturn 0;\n\treturn i + 1;\n}", "target": 0}
{"code": "int udp_sendpage(struct sock *sk, struct page *page, int offset,\n\t\t size_t size, int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tint ret;\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\tif (!up->pending) {\n\t\tstruct msghdr msg = {\t.msg_flags = flags|MSG_MORE };\n\t\tret = udp_sendmsg(sk, &msg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tlock_sock(sk);\n\tif (unlikely(!up->pending)) {\n\t\trelease_sock(sk);\n\t\tnet_dbg_ratelimited(\"udp cork app bug 3\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = ip_append_page(sk, &inet->cork.fl.u.ip4,\n\t\t\t     page, offset, size, flags);\n\tif (ret == -EOPNOTSUPP) {\n\t\trelease_sock(sk);\n\t\treturn sock_no_sendpage(sk->sk_socket, page, offset,\n\t\t\t\t\tsize, flags);\n\t}\n\tif (ret < 0) {\n\t\tudp_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\tup->len += size;\n\tif (!(up->corkflag || (flags&MSG_MORE)))\n\t\tret = udp_push_pending_frames(sk);\n\tif (!ret)\n\t\tret = size;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "static void bnx2x_oem_event(struct bnx2x *bp, u32 event)\n{\n\tu32 cmd_ok, cmd_fail;\n\tif (event & DRV_STATUS_DCC_EVENT_MASK &&\n\t    event & DRV_STATUS_OEM_EVENT_MASK) {\n\t\tBNX2X_ERR(\"Received simultaneous events %08x\\n\", event);\n\t\treturn;\n\t}\n\tif (event & DRV_STATUS_DCC_EVENT_MASK) {\n\t\tcmd_fail = DRV_MSG_CODE_DCC_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_DCC_OK;\n\t} else  {\n\t\tcmd_fail = DRV_MSG_CODE_OEM_FAILURE;\n\t\tcmd_ok = DRV_MSG_CODE_OEM_OK;\n\t}\n\tDP(BNX2X_MSG_MCP, \"oem_event 0x%x\\n\", event);\n\tif (event & (DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t     DRV_STATUS_OEM_DISABLE_ENABLE_PF)) {\n\t\tif (bp->mf_config[BP_VN(bp)] & FUNC_MF_CFG_FUNC_DISABLED) {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function disabled\\n\");\n\t\t\tbp->flags |= MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_disable(bp);\n\t\t} else {\n\t\t\tDP(BNX2X_MSG_MCP, \"mf_cfg function enabled\\n\");\n\t\t\tbp->flags &= ~MF_FUNC_DIS;\n\t\t\tbnx2x_e1h_enable(bp);\n\t\t}\n\t\tevent &= ~(DRV_STATUS_DCC_DISABLE_ENABLE_PF |\n\t\t\t   DRV_STATUS_OEM_DISABLE_ENABLE_PF);\n\t}\n\tif (event & (DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t     DRV_STATUS_OEM_BANDWIDTH_ALLOCATION)) {\n\t\tbnx2x_config_mf_bw(bp);\n\t\tevent &= ~(DRV_STATUS_DCC_BANDWIDTH_ALLOCATION |\n\t\t\t   DRV_STATUS_OEM_BANDWIDTH_ALLOCATION);\n\t}\n\tif (event)\n\t\tbnx2x_fw_command(bp, cmd_fail, 0);\n\telse\n\t\tbnx2x_fw_command(bp, cmd_ok, 0);\n}", "target": 0}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int rtnl_dump_all(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx;\n\tint s_idx = cb->family;\n\tif (s_idx == 0)\n\t\ts_idx = 1;\n\tfor (idx = 1; idx <= RTNL_FAMILY_MAX; idx++) {\n\t\tint type = cb->nlh->nlmsg_type-RTM_BASE;\n\t\tif (idx < s_idx || idx == PF_PACKET)\n\t\t\tcontinue;\n\t\tif (rtnl_msg_handlers[idx] == NULL ||\n\t\t    rtnl_msg_handlers[idx][type].dumpit == NULL)\n\t\t\tcontinue;\n\t\tif (idx > s_idx) {\n\t\t\tmemset(&cb->args[0], 0, sizeof(cb->args));\n\t\t\tcb->prev_seq = 0;\n\t\t\tcb->seq = 0;\n\t\t}\n\t\tif (rtnl_msg_handlers[idx][type].dumpit(skb, cb))\n\t\t\tbreak;\n\t}\n\tcb->family = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "JPEGDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\t(*sp->deftparent)(tif, tw, th);\n\t*tw = TIFFroundup_32(*tw, td->td_ycbcrsubsampling[0] * DCTSIZE);\n\t*th = TIFFroundup_32(*th, td->td_ycbcrsubsampling[1] * DCTSIZE);\n}", "target": 0}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "kadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n    CHECK_HANDLE(server_handle);\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n    return KADM5_OK;\n}", "target": 0}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr)\n{\n\tvoid *ext_hdrs[SADB_EXT_MAX];\n\tint err;\n\tpfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,\n\t\t\tBROADCAST_PROMISC_ONLY, NULL, sock_net(sk));\n\tmemset(ext_hdrs, 0, sizeof(ext_hdrs));\n\terr = parse_exthdrs(skb, hdr, ext_hdrs);\n\tif (!err) {\n\t\terr = -EOPNOTSUPP;\n\t\tif (pfkey_funcs[hdr->sadb_msg_type])\n\t\t\terr = pfkey_funcs[hdr->sadb_msg_type](sk, skb, hdr, ext_hdrs);\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int iommu_no_mapping(struct device *dev)\n{\n\tint found;\n\tif (iommu_dummy(dev))\n\t\treturn 1;\n\tif (!iommu_identity_mapping)\n\t\treturn 0;\n\tfound = identity_mapping(dev);\n\tif (found) {\n\t\tif (iommu_should_identity_map(dev, 0))\n\t\t\treturn 1;\n\t\telse {\n\t\t\tdmar_remove_one_dev_info(si_domain, dev);\n\t\t\tpr_info(\"32bit %s uses non-identity mapping\\n\",\n\t\t\t\tdev_name(dev));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (iommu_should_identity_map(dev, 0)) {\n\t\t\tint ret;\n\t\t\tret = domain_add_dev_info(si_domain, dev);\n\t\t\tif (!ret) {\n\t\t\t\tpr_info(\"64bit %s uses identity mapping\\n\",\n\t\t\t\t\tdev_name(dev));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void ImageLoader::DecodeRequest::Resolve() {\n  resolver_->Resolve();\n  loader_ = nullptr;\n}", "target": 0}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "device_filesystem_create_authorized_cb (Daemon *daemon,\n                                        Device *device,\n                                        DBusGMethodInvocation *context,\n                                        const gchar *action_id,\n                                        guint num_user_data,\n                                        gpointer *user_data_elements)\n{\n  const gchar *fstype = user_data_elements[0];\n  gchar **options = user_data_elements[1];\n  device_filesystem_create_internal (device, fstype, options, NULL, NULL, context);\n}", "target": 0}
{"code": "_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\tif (directory == NULL)\n\t\treturn TRUE;\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\tg_object_unref (enumerator);\n\treturn ! error_occurred;\n}", "target": 1}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static MOVFragmentStreamInfo *get_frag_stream_info_from_pkt(MOVFragmentIndex *frag_index, AVPacket *pkt, int id)\n{\n    int current = frag_index->current;\n    if (!frag_index->nb_items)\n        return NULL;\n    if (current >= 0 && current < frag_index->nb_items) {\n        if (frag_index->item[current].moof_offset < pkt->pos &&\n            (current + 1 == frag_index->nb_items ||\n             frag_index->item[current + 1].moof_offset > pkt->pos))\n            return get_frag_stream_info(frag_index, current, id);\n    }\n    for (int i = 0; i < frag_index->nb_items; i++) {\n        if (frag_index->item[i].moof_offset > pkt->pos)\n            break;\n        current = i;\n    }\n    frag_index->current = current;\n    return get_frag_stream_info(frag_index, current, id);\n}", "target": 0}
{"code": "isdn_minor2drv(int minor)\n{\n\treturn (dev->drvmap[minor]);\n}", "target": 0}
{"code": "cdf_read_header(const cdf_info_t *info, cdf_header_t *h)\n{\n\tchar buf[512];\n\t(void)memcpy(cdf_bo.s, \"\\01\\02\\03\\04\", 4);\n\tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)\n\t\treturn -1;\n\tcdf_unpack_header(h, buf);\n\tcdf_swap_header(h);\n\tif (h->h_magic != CDF_MAGIC) {\n\t\tDPRINTF((\"Bad magic 0x%\" INT64_T_FORMAT \"x != 0x%\"\n\t\t    INT64_T_FORMAT \"x\\n\",\n\t\t    (unsigned long long)h->h_magic,\n\t\t    (unsigned long long)CDF_MAGIC));\n\t\tgoto out;\n\t}\n\tif (h->h_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad sector size 0x%u\\n\", h->h_sec_size_p2));\n\t\tgoto out;\n\t}\n\tif (h->h_short_sec_size_p2 > 20) {\n\t\tDPRINTF((\"Bad short sector size 0x%u\\n\",\n\t\t    h->h_short_sec_size_p2));\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\tif (!tun)\n\t\treturn POLLERR;\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\tpoll_wait(file, &tun->socket.wait, wait);\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NEOnMultikeyIndex) {\n    addIndex(BSON(\"a\" << 1), true);\n    runQuery(fromjson(\"{a: {$ne: 3}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$ne:3}}, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [['MinKey',3,true,false],\"\n        \"[3,'MaxKey',false,true]]}}}}}\");\n}", "target": 0}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "  int libraw_open_file(libraw_data_t *lr, const char *file)\n  {\n    if (!lr)\n      return EINVAL;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    return ip->open_file(file);\n  }", "target": 0}
{"code": "void exit_mmap(struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tunsigned long nr_accounted = 0;\n\tmmu_notifier_release(mm);\n\tif (mm->locked_vm) {\n\t\tvma = mm->mmap;\n\t\twhile (vma) {\n\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\tmunlock_vma_pages_all(vma);\n\t\t\tvma = vma->vm_next;\n\t\t}\n\t}\n\tarch_exit_mmap(mm);\n\tvma = mm->mmap;\n\tif (!vma)\t\n\t\treturn;\n\tlru_add_drain();\n\tflush_cache_mm(mm);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tunmap_vmas(&tlb, vma, 0, -1);\n\tif (unlikely(mm_is_oom_victim(mm))) {\n\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\tdown_write(&mm->mmap_sem);\n\t\tup_write(&mm->mmap_sem);\n\t}\n\tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, 0, -1);\n\twhile (vma) {\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += vma_pages(vma);\n\t\tvma = remove_vma(vma);\n\t}\n\tvm_unacct_memory(nr_accounted);\n}", "target": 1}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}", "target": 0}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "static void unix_dgram_peer_wake_disconnect(struct sock *sk,\n\t\t\t\t\t    struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (u->peer_wake.private == other) {\n\t\t__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\tu->peer_wake.private = NULL;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n}", "target": 0}
{"code": "_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t\n    const char     *key,\t\t\n    _pdfio_value_t *value)\t\t\n{\n  _pdfio_pair_t\t*pair;\t\t\t\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t\n    pkey.key = key;\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n  pair->key   = key;\n  pair->value = *value;\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif \n  return (true);\n}", "target": 1}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "bool __init __weak hugetlb_node_alloc_supported(void)\n{\n\treturn true;\n}", "target": 0}
{"code": "int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tunsigned long flags;\n\tint ret;\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\tret = -1;\n\tif (!likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\tret = 1; \n\tif (!prepare_signal(sig, t, 0))\n\t\tgoto out;\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\tsignalfd_notify(t, sig);\n\tpending = group ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, group);\nout:\n\tunlock_task_sighand(t, &flags);\nret:\n\treturn ret;\n}", "target": 0}
{"code": "xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,\n                  const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n    if (ctxt == NULL)\n        return (NULL);\n    if (buffer == NULL)\n        return (NULL);\n    xmlInitParser();\n    xmlCtxtReset(ctxt);\n    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n    if (input == NULL) {\n\treturn(NULL);\n    }\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n\treturn(NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}", "target": 0}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "bool WebContentsImpl::IsLoading() const {\n  return is_loading_;\n}", "target": 0}
{"code": "uid_t session_info_uid_for_session(struct session_info *si, const char *session)\n{\n    uid_t ret = -1;\n    if (sd_session_get_uid(session, &ret) < 0) {\n        return -1;\n    }\n    return ret;\n}", "target": 0}
{"code": "DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n{\n\tres = new unsigned char[sizeof(DNSHeader) * 2];\n\t*res = 0;\n\torig = original;\n\tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n\tServerInstance->Timers->AddTimer(RT); \n}", "target": 0}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "decompileSUBSTRING(int n, SWF_ACTION *actions,int maxn)\n{\n\tpush(newVar_N(\"\",\"\",\"substr\",\"(\", 3,\")\"));\n\tif (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n\t{\n\t\tINDENT\n\t\tputs(getName(pop()));\n\t\tprintln(\";\" );\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int setup_conds(THD *thd, TABLE_LIST *tables, List<TABLE_LIST> &leaves,\n                COND **conds)\n{\n  SELECT_LEX *select_lex= thd->lex->current_select;\n  TABLE_LIST *table= NULL;\t\n  bool it_is_update= (select_lex == &thd->lex->select_lex) &&\n    thd->lex->which_check_option_applicable();\n  bool save_is_item_list_lookup= select_lex->is_item_list_lookup;\n  TABLE_LIST *derived= select_lex->master_unit()->derived;\n  DBUG_ENTER(\"setup_conds\");\n  if (derived && derived->merged)\n    DBUG_RETURN(0);\n  select_lex->is_item_list_lookup= 0;\n  thd->mark_used_columns= MARK_COLUMNS_READ;\n  DBUG_PRINT(\"info\", (\"thd->mark_used_columns: %d\", thd->mark_used_columns));\n  select_lex->cond_count= 0;\n  select_lex->between_count= 0;\n  select_lex->max_equal_elems= 0;\n  for (table= tables; table; table= table->next_local)\n  {\n    if (select_lex == &thd->lex->select_lex &&\n        select_lex->first_cond_optimization &&\n        table->merged_for_insert &&\n        table->prepare_where(thd, conds, FALSE))\n      goto err_no_arena;\n  }\n  if (*conds)\n  {\n    thd->where=\"where clause\";\n    DBUG_EXECUTE(\"where\",\n                 print_where(*conds,\n                             \"WHERE in setup_conds\",\n                             QT_ORDINARY););\n    if ((*conds)->type() == Item::FIELD_ITEM && !derived)\n      wrap_ident(thd, conds);\n    (*conds)->mark_as_condition_AND_part(NO_JOIN_NEST);\n    if ((!(*conds)->fixed && (*conds)->fix_fields(thd, conds)) ||\n\t(*conds)->check_cols(1))\n      goto err_no_arena;\n  }\n  if (setup_on_expr(thd, tables, it_is_update))\n    goto err_no_arena;\n  if (!thd->stmt_arena->is_conventional())\n  {\n    select_lex->where= *conds;\n  }\n  thd->lex->current_select->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(MY_TEST(thd->is_error()));\nerr_no_arena:\n  select_lex->is_item_list_lookup= save_is_item_list_lookup;\n  DBUG_RETURN(1);\n}", "target": 0}
{"code": "  bool operator!=(const HeaderMap& rhs) const override { return HeaderMapImpl::operator!=(rhs); }", "target": 0}
{"code": "void SavePackage::StopObservation() {\n  DCHECK(download_);\n  DCHECK(download_manager_);\n  download_->RemoveObserver(this);\n  download_ = NULL;\n  download_manager_ = NULL;\n}", "target": 0}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "static void irda_connect_indication(void *instance, void *sap,\n\t\t\t\t    struct qos_info *qos, __u32 max_sdu_size,\n\t\t\t\t    __u8 max_header_size, struct sk_buff *skb)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tself = instance;\n\tIRDA_DEBUG(2, \"%s(%p)\\n\", __func__, self);\n\tsk = instance;\n\tif (sk == NULL) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tself->max_header_size = max_header_size;\n\tself->max_sdu_size_tx = max_sdu_size;\n\tswitch (sk->sk_type) {\n\tcase SOCK_STREAM:\n\t\tif (max_sdu_size != 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size must be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tif (max_sdu_size == 0) {\n\t\t\tIRDA_ERROR(\"%s: max_sdu_size cannot be 0\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tself->max_data_size = max_sdu_size;\n\t\tbreak;\n\tdefault:\n\t\tself->max_data_size = irttp_get_max_seg_size(self->tsap);\n\t}\n\tIRDA_DEBUG(2, \"%s(), max_data_size=%d\\n\", __func__,\n\t\t   self->max_data_size);\n\tmemcpy(&self->qos_tx, qos, sizeof(struct qos_info));\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_state_change(sk);\n}", "target": 0}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value)\n {\n    if (*pStackPtr >= CDL_STACK_SIZE)\n         return EAS_ERROR_FILE_FORMAT;\n     *pStackPtr = *pStackPtr + 1;\n    pStack[*pStackPtr] = value;\n return EAS_SUCCESS;\n}", "target": 1}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "void tref_box_del(GF_Box *s)\n{\n\tGF_TrackReferenceBox *ptr = (GF_TrackReferenceBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "bool Virtual_tmp_table::open()\n{\n  DBUG_ASSERT(s->fields == m_alloced_field_count);\n  field[s->fields]= NULL;            \n  s->blob_field[s->blob_fields]= 0;  \n  uint null_pack_length= (s->null_fields + 7) / 8; \n  s->reclength+= null_pack_length;\n  s->rec_buff_length= ALIGN_SIZE(s->reclength + 1);\n  if (!(record[0]= (uchar*) in_use->alloc(s->rec_buff_length)))\n    return true;\n  if (null_pack_length)\n  {\n    null_flags= (uchar*) record[0];\n    s->null_bytes= s->null_bytes_for_compare= null_pack_length;\n  }\n  setup_field_pointers();\n  return false;\n}", "target": 0}
{"code": "njs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n        goto activate;\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n        args = arr->start;\n        length = arr->length;\n        goto activate;\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n    args = arr->start;\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\nactivate:\n    vm->top_frame->skip = 1;\n    frame = (njs_frame_t *) vm->top_frame;\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return NJS_DECLINED;\n}", "target": 1}
{"code": "static void imx_usdhc_init(Object *obj)\n{\n    SDHCIState *s = SYSBUS_SDHCI(obj);\n    s->io_ops = &usdhc_mmio_ops;\n    s->quirks = SDHCI_QUIRK_NO_BUSY_IRQ;\n}", "target": 0}
{"code": "static PHP_GINIT_FUNCTION(libxml)\n{\n        libxml_globals->stream_context = NULL;\n        libxml_globals->error_buffer.c = NULL;\n        libxml_globals->error_list = NULL;\n }", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if (code == 0xB5)\n      ;\n    else if ((EncCP1252_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'I')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? DOTLESS_i : 'i';\n      else\n\tcode = ENC_CP1252_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1252_CtypeTable[code]&BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 'i')\n\tcode = flags & ONIGENC_CASE_FOLD_TURKISH_AZERI ? I_WITH_DOT_ABOVE : 'I';\n      else if (code == DOTLESS_i)\n\tcode = 'I';\n      else if (code >= 0xB0 && code <= 0xBF)\n\tcode -= 0x10;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "ppp_create_interface(struct net *net, int unit, int *retp)\n{\n\tstruct ppp *ppp;\n\tstruct ppp_net *pn;\n\tstruct net_device *dev = NULL;\n\tint ret = -ENOMEM;\n\tint i;\n\tdev = alloc_netdev(sizeof(struct ppp), \"\", ppp_setup);\n\tif (!dev)\n\t\tgoto out1;\n\tpn = ppp_pernet(net);\n\tppp = netdev_priv(dev);\n\tppp->dev = dev;\n\tppp->mru = PPP_MRU;\n\tinit_ppp_file(&ppp->file, INTERFACE);\n\tppp->file.hdrlen = PPP_HDRLEN - 2;\t\n\tfor (i = 0; i < NUM_NP; ++i)\n\t\tppp->npmode[i] = NPMODE_PASS;\n\tINIT_LIST_HEAD(&ppp->channels);\n\tspin_lock_init(&ppp->rlock);\n\tspin_lock_init(&ppp->wlock);\n#ifdef CONFIG_PPP_MULTILINK\n\tppp->minseq = -1;\n\tskb_queue_head_init(&ppp->mrq);\n#endif \n\tdev_net_set(dev, net);\n\tret = -EEXIST;\n\tmutex_lock(&pn->all_ppp_mutex);\n\tif (unit < 0) {\n\t\tunit = unit_get(&pn->units_idr, ppp);\n\t\tif (unit < 0) {\n\t\t\t*retp = unit;\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tif (unit_find(&pn->units_idr, unit))\n\t\t\tgoto out2; \n\t\tunit = unit_set(&pn->units_idr, ppp, unit);\n\t\tif (unit < 0)\n\t\t\tgoto out2;\n\t}\n\tppp->file.index = unit;\n\tsprintf(dev->name, \"ppp%d\", unit);\n\tret = register_netdev(dev);\n\tif (ret != 0) {\n\t\tunit_put(&pn->units_idr, unit);\n\t\tprintk(KERN_ERR \"PPP: couldn't register device %s (%d)\\n\",\n\t\t       dev->name, ret);\n\t\tgoto out2;\n\t}\n\tppp->ppp_net = net;\n\tatomic_inc(&ppp_unit_count);\n\tmutex_unlock(&pn->all_ppp_mutex);\n\t*retp = 0;\n\treturn ppp;\nout2:\n\tmutex_unlock(&pn->all_ppp_mutex);\n\tfree_netdev(dev);\nout1:\n\t*retp = ret;\n\treturn NULL;\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &nd->path);\nout:\n\treturn ERR_PTR(error);\n}", "target": 0}
{"code": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "unsigned short bebytes2ushort(const u8 *buf)\n{\n\tif (buf == NULL)\n\t\treturn 0U;\n\treturn (unsigned short) (buf[0] << 8 | buf[1]);\n}", "target": 0}
{"code": "uint32_t sftp_parse_handle(struct sftpjob *job, struct handleid *id) {\n  uint32_t len, rc;\n  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK || len != 8 ||\n     (rc = sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n     (rc = sftp_parse_uint32(job, &id->tag) != SSH_FX_OK))\n    return rc;\n  return SSH_FX_OK;\n}", "target": 1}
{"code": "int recursive_destroy(char *dirname)\n{\n\tint ret;\n\tstruct dirent *direntp;\n\tDIR *dir;\n\tint r = 0;\n\tdir = opendir(dirname);\n\tif (!dir)\n\t\treturn -1;\n\twhile ((direntp = readdir(dir))) {\n\t\tchar *pathname;\n\t\tstruct stat mystat;\n\t\tif (!strcmp(direntp->d_name, \".\") ||\n\t\t    !strcmp(direntp->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tpathname = must_make_path(dirname, direntp->d_name, NULL);\n\t\tret = lstat(pathname, &mystat);\n\t\tif (ret < 0) {\n\t\t\tif (!r)\n\t\t\t\tWARN(\"Failed to stat \\\"%s\\\"\", pathname);\n\t\t\tr = -1;\n\t\t\tgoto next;\n\t\t}\n\t\tif (!S_ISDIR(mystat.st_mode))\n\t\t\tgoto next;\n\t\tret = recursive_destroy(pathname);\n\t\tif (ret < 0)\n\t\t\tr = -1;\n\tnext:\n\t\tfree(pathname);\n\t}\n\tret = rmdir(dirname);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\tret = closedir(dir);\n\tif (ret < 0) {\n\t\tif (!r)\n\t\t\tSYSWARN(\"Failed to delete \\\"%s\\\"\", dirname);\n\t\tr = -1;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n \t\tgoto err3;\n \t}\n \tmutex_unlock(&file->mut);\n \tucma_put_ctx(ctx);\n \treturn 0;\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}", "target": 1}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = join_session_keyring(name);\n error:\n\treturn ret;\n} ", "target": 1}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "string DebugString(gtl::ArraySlice<NodeDef> instantiated_func_nodes) {\n  std::vector<const NodeDef*> ptrs;\n  for (const NodeDef& n : instantiated_func_nodes) {\n    ptrs.push_back(&n);\n  }\n  return Print(ptrs);\n}", "target": 0}
{"code": "static int sco_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\tstruct bt_voice voice;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_SCO)\n\t\treturn sco_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *)optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_VOICE:\n\t\tvoice.setting = sco_pi(sk)->setting;\n\t\tlen = min_t(unsigned int, len, sizeof(voice));\n\t\tif (copy_to_user(optval, (char *)&voice, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "void GfxDeviceCMYKColorSpace::getCMYKLine(unsigned char *in, unsigned char *out, int length)\n{\n    for (int i = 0; i < length; i++) {\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n        *out++ = *in++;\n    }\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_getline(char *s, int n, request_rec *r, int fold)\n{\n    char *tmp_s = s;\n    apr_status_t rv;\n    apr_size_t len;\n    apr_bucket_brigade *tmp_bb;\n    tmp_bb = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n    rv = ap_rgetline(&tmp_s, n, &len, r, fold, tmp_bb);\n    apr_brigade_destroy(tmp_bb);\n    if (rv == APR_ENOSPC) {\n        return n;\n    }\n    if (rv != APR_SUCCESS) {\n        return -1;\n    }\n    return (int)len;\n}", "target": 0}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "HttpStateData::finishingBrokenPost()\n{\n#if USE_HTTP_VIOLATIONS\n    if (!Config.accessList.brokenPosts) {\n        debugs(11, 5, HERE << \"No brokenPosts list\");\n        return false;\n    }\n    ACLFilledChecklist ch(Config.accessList.brokenPosts, originalRequest(), NULL);\n    ch.al = fwd->al;\n    ch.syncAle(originalRequest(), nullptr);\n    if (!ch.fastCheck().allowed()) {\n        debugs(11, 5, HERE << \"didn't match brokenPosts\");\n        return false;\n    }\n    if (!Comm::IsConnOpen(serverConnection)) {\n        debugs(11, 3, HERE << \"ignoring broken POST for closed \" << serverConnection);\n        assert(closeHandler != NULL);\n        return true; \n    }\n    debugs(11, 3, \"finishingBrokenPost: fixing broken POST\");\n    typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;\n    requestSender = JobCallback(11,5,\n                                Dialer, this, HttpStateData::wroteLast);\n    Comm::Write(serverConnection, \"\\r\\n\", 2, requestSender, NULL);\n    return true;\n#else\n    return false;\n#endif \n}", "target": 0}
{"code": "_asn1_set_value (asn1_node node, const void *value, unsigned int len)\n{\n  if (node == NULL)\n    return node;\n  if (node->value)\n    {\n      if (node->value != node->small_value)\n\tfree (node->value);\n      node->value = NULL;\n      node->value_len = 0;\n    }\n  if (!len)\n    return node;\n  if (len < sizeof (node->small_value))\n    {\n      node->value = node->small_value;\n    }\n  else\n    {\n      node->value = malloc (len);\n      if (node->value == NULL)\n\treturn NULL;\n    }\n  node->value_len = len;\n  memcpy (node->value, value, len);\n  return node;\n}", "target": 0}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "void Rectangle(double x,double y,double w,double h) {\n    outpos += sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f re\",x,y,w,h);\n}", "target": 1}
{"code": "check_packet_auth(NTP_Packet *pkt, int length, int *has_auth, uint32_t *key_id)\n{\n  int i, remainder, ext_length;\n  unsigned char *data;\n  uint32_t id;\n  i = NTP_NORMAL_PACKET_LENGTH;\n  data = (void *)pkt;\n  while (1) {\n    remainder = length - i;\n    if (remainder >= NTP_MIN_MAC_LENGTH && remainder <= NTP_MAX_MAC_LENGTH) {\n      id = ntohl(*(uint32_t *)(data + i));\n      if (KEY_CheckAuth(id, (void *)pkt, i, (void *)(data + i + 4),\n                        remainder - 4)) {\n        if (key_id)\n          *key_id = id;\n        if (has_auth)\n          *has_auth = 1;\n        return 1;\n      }\n    }\n    if (remainder >= NTP_MIN_EXTENSION_LENGTH) {\n      ext_length = ntohs(*(uint16_t *)(data + i + 2));\n      if (ext_length >= NTP_MIN_EXTENSION_LENGTH &&\n          ext_length <= remainder && ext_length % 4 == 0) {\n        i += ext_length;\n        continue;\n      }\n    }\n    break;\n  }\n  if (has_auth)\n    *has_auth = remainder >= NTP_MIN_MAC_LENGTH;\n  return 0;\n}", "target": 0}
{"code": "accountingReportStats(XML_Parser originParser, const char *epilog) {\n  const XML_Parser rootParser = getRootParserOf(originParser, NULL);\n  assert(! rootParser->m_parentParser);\n  if (rootParser->m_accounting.debugLevel < 1) {\n    return;\n  }\n  const float amplificationFactor\n      = accountingGetCurrentAmplification(rootParser);\n  fprintf(stderr,\n          \"expat: Accounting(%p): Direct \" EXPAT_FMT_ULL(\n              \"10\") \", indirect \" EXPAT_FMT_ULL(\"10\") \", amplification %8.2f%s\",\n          (void *)rootParser, rootParser->m_accounting.countBytesDirect,\n          rootParser->m_accounting.countBytesIndirect,\n          (double)amplificationFactor, epilog);\n}", "target": 0}
{"code": "static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "static int sr9700_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *sr_skb;\n\tint len;\n\tif (unlikely(skb->len < SR_RX_OVERHEAD)) {\n\t\tnetdev_err(dev->net, \"unexpected tiny rx frame\\n\");\n\t\treturn 0;\n\t}\n\twhile (skb->len > SR_RX_OVERHEAD) {\n\t\tif (skb->data[0] != 0x40)\n\t\t\treturn 0;\n\t\tlen = (skb->data[1] | (skb->data[2] << 8)) - 4;\n\t\tif (len > ETH_FRAME_LEN || len > skb->len)\n\t\t\treturn 0;\n\t\tif (skb->len == (len + SR_RX_OVERHEAD))\t{\n\t\t\tskb_pull(skb, 3);\n\t\t\tskb->len = len;\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\tskb->truesize = len + sizeof(struct sk_buff);\n\t\t\treturn 2;\n\t\t}\n\t\tsr_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!sr_skb)\n\t\t\treturn 0;\n\t\tsr_skb->len = len;\n\t\tsr_skb->data = skb->data + 3;\n\t\tskb_set_tail_pointer(sr_skb, len);\n\t\tsr_skb->truesize = len + sizeof(struct sk_buff);\n\t\tusbnet_skb_return(dev, sr_skb);\n\t\tskb_pull(skb, len + SR_RX_OVERHEAD);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_SET) != off)\n\t\t\treturn 0;\n\t} else {\n\t\tfile->f_pos = off;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int dccp_disconnect(struct sock *sk, int flags)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\tconst int old_state = sk->sk_state;\n\tif (old_state != DCCP_CLOSED)\n\t\tdccp_set_state(sk, DCCP_CLOSED);\n\tif (old_state == DCCP_LISTEN) {\n\t\tinet_csk_listen_stop(sk);\n\t} else if (dccp_need_reset(old_state)) {\n\t\tdccp_send_reset(sk, DCCP_RESET_CODE_ABORTED);\n\t\tsk->sk_err = ECONNRESET;\n\t} else if (old_state == DCCP_REQUESTING)\n\t\tsk->sk_err = ECONNRESET;\n\tdccp_clear_xmit_timers(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_write_queue);\n\tif (sk->sk_send_head != NULL) {\n\t\t__kfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tinet->inet_dport = 0;\n\tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))\n\t\tinet_reset_saddr(sk);\n\tsk->sk_shutdown = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ticsk->icsk_backoff = 0;\n\tinet_csk_delack_init(sk);\n\t__sk_dst_reset(sk);\n\tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);\n\tsk->sk_error_report(sk);\n\treturn err;\n}", "target": 1}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "TEST(QuantizedPoolingOpTest, AveragePoolActivationRelu) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU);\n  m.SetInput({\n      0, -6, 2, 4,   \n      3, 2, -10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0.0, 0.75})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 134}));\n}", "target": 0}
{"code": "static void __exit vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\tkvm_exit();\n}", "target": 0}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "bool ping_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\tskb_push(skb, skb->data - (u8 *)icmph);\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk) {\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tif (skb2)\n\t\t\tping_queue_rcv_skb(sk, skb2);\n\t\tsock_put(sk);\n\t\treturn true;\n\t}\n\tpr_debug(\"no socket, dropping\\n\");\n\treturn false;\n}", "target": 0}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n}", "target": 1}
{"code": "void CtcpParser::packedReply(CoreNetwork *net, const QString &bufname, const QList<QByteArray> &replies) {\n  QList<QByteArray> params;\n  int answerSize = 0;\n  for(int i = 0; i < replies.count(); i++) {\n    answerSize += replies.at(i).size();\n  }\n  QByteArray quotedReply(answerSize, 0);\n  int nextPos = 0;\n  QByteArray &reply = quotedReply;\n  for(int i = 0; i < replies.count(); i++) {\n    reply = replies.at(i);\n    quotedReply.replace(nextPos, reply.size(), reply);\n    nextPos += reply.size();\n  }\n  params << net->serverEncode(bufname) << quotedReply;\n  net->putCmd(\"NOTICE\", params);\n}", "target": 1}
{"code": "int rad_packet_add_ipv6prefix(struct rad_packet_t *pack, const char *vendor_name, const char *name, struct in6_addr *prefix, int len)\n{\n\tstruct rad_attr_t *ra;\n\tstruct rad_dict_attr_t *attr;\n\tstruct rad_dict_vendor_t *vendor;\n\tif (pack->len + (vendor_name ? 8 : 2) + 18 >= REQ_LENGTH_MAX)\n\t\treturn -1;\n\tif (vendor_name) {\n\t\tvendor = rad_dict_find_vendor_name(vendor_name);\n\t\tif (!vendor)\n\t\t\treturn -1;\n\t\tattr = rad_dict_find_vendor_attr(vendor, name);\n\t} else {\n\t\tvendor = NULL;\n\t\tattr = rad_dict_find_attr(name);\n\t}\n\tif (!attr)\n\t\treturn -1;\n\tra = mempool_alloc(attr_pool);\n\tif (!ra)\n\t\treturn -1;\n\tmemset(ra, 0, sizeof(*ra));\n\tra->vendor = vendor;\n\tra->attr = attr;\n\tra->len = 18;\n\tra->val.ipv6prefix.len = len;\n\tra->val.ipv6prefix.prefix = *prefix;\n\tra->raw = &ra->val;\n\tlist_add_tail(&ra->entry, &pack->attrs);\n\tpack->len += (vendor_name ? 8 : 2) + 18;\n\treturn 0;\n}", "target": 0}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, MergeSort) {\n    addIndex(BSON(\"a\" << 1 << \"c\" << 1));\n    addIndex(BSON(\"b\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{$or: [{a:1}, {b:1}]}\"), fromjson(\"{c:1}\"), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {c: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, c: 1}}}, {ixscan: {pattern: {b: 1, c: 1}}}]}}}}\");\n}", "target": 0}
{"code": "canonicalize_path (const char *path, char **pcanonical)\n{\n  char *canonical = 0;\n  assert (path && *path);\n  assert (pcanonical);\n  canonical = MALLOC (char, 1+ LT_STRLEN (path));\n  if (!canonical)\n    return 1;\n  {\n    size_t dest = 0;\n    size_t src;\n    for (src = 0; path[src] != LT_EOS_CHAR; ++src)\n      {\n\tif (path[src] == LT_PATHSEP_CHAR)\n\t  {\n\t    if ((dest == 0)\n\t\t|| (path[1+ src] == LT_PATHSEP_CHAR)\n\t\t|| (path[1+ src] == LT_EOS_CHAR))\n\t      continue;\n\t  }\n\tif ((path[src] != '/')\n#if defined(LT_DIRSEP_CHAR)\n\t    && (path[src] != LT_DIRSEP_CHAR)\n#endif\n\t    )\n\t  {\n\t    canonical[dest++] = path[src];\n\t  }\n\telse if ((path[1+ src] != LT_PATHSEP_CHAR)\n\t\t && (path[1+ src] != LT_EOS_CHAR)\n#if defined(LT_DIRSEP_CHAR)\n\t\t && (path[1+ src] != LT_DIRSEP_CHAR)\n#endif\n\t\t && (path[1+ src] != '/'))\n\t  {\n\t    canonical[dest++] = '/';\n\t  }\n      }\n    canonical[dest] = LT_EOS_CHAR;\n  }\n  *pcanonical = canonical;\n  return 0;\n}", "target": 0}
{"code": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}", "target": 1}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "RecordCloseDown(ExtensionEntry * extEntry)\n{\n    DeleteCallback(&ClientStateCallback, RecordAClientStateChange, NULL);\n}                               ", "target": 0}
{"code": "    void CiffDirectory::readDirectory(const byte* pData,\n                                      uint32_t    size,\n                                      ByteOrder   byteOrder)\n    {\n        if (size < 4)\n            throw Error(kerCorruptedMetadata);\n        uint32_t o = getULong(pData + size - 4, byteOrder);\n        if ( o+2 > size )\n            throw Error(kerCorruptedMetadata);\n        uint16_t count = getUShort(pData + o, byteOrder);\n#ifdef DEBUG\n        std::cout << \"Directory at offset \" << std::dec << o\n                  <<\", \" << count << \" entries \\n\";\n#endif\n        o += 2;\n        if ( (o + (count * 10)) > size )\n            throw Error(kerCorruptedMetadata);\n        for (uint16_t i = 0; i < count; ++i) {\n            uint16_t tag = getUShort(pData + o, byteOrder);\n            CiffComponent::AutoPtr m;\n            switch (CiffComponent::typeId(tag)) {\n            case directory: m = CiffComponent::AutoPtr(new CiffDirectory); break;\n            default: m = CiffComponent::AutoPtr(new CiffEntry); break;\n            }\n            m->setDir(this->tag());\n            m->read(pData, size, o, byteOrder);\n            add(m);\n            o += 10;\n        }\n    }  ", "target": 1}
{"code": "convert_protocol_address(struct sockaddr* saddr, unsigned int saddrlen)\n{\n    PyObject *res_obj = NULL;\n    switch (saddr->sa_family)\n    {\n    case AF_INET:\n        {\n            struct sockaddr_in* sin = (struct sockaddr_in*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin->sin_addr, addr_str, INET_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin->sin_port));\n            PyMem_Free(addr_str);\n       }\n        break;\n    case AF_INET6:\n        {\n            struct sockaddr_in6* sin6 = (struct sockaddr_in6*)saddr;\n            char *addr_str = (char *)PyMem_Malloc(INET6_ADDRSTRLEN);\n            if (addr_str == NULL) {\n                PyErr_SetString(ErrorObject, \"Out of memory\");\n                goto error;\n            }\n            if (inet_ntop(saddr->sa_family, &sin6->sin6_addr, addr_str, INET6_ADDRSTRLEN) == NULL) {\n                PyErr_SetFromErrno(ErrorObject);\n                PyMem_Free(addr_str);\n                goto error;\n            }\n            res_obj = Py_BuildValue(\"(si)\", addr_str, ntohs(sin6->sin6_port));\n            PyMem_Free(addr_str);\n        }\n        break;\n    default:\n        PyErr_SetString(ErrorObject, \"Unsupported address family.\");\n    }\nerror:\n    return res_obj;\n}", "target": 0}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "fill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (sourcing_a_script(eap))\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}", "target": 0}
{"code": "static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n        uint32_t size;\n    } prd;", "target": 1}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "header_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} ", "target": 1}
{"code": "GF_Err proj_type_box_size(GF_Box *s)\n{\n\tGF_ProjectionTypeBox *ptr = (GF_ProjectionTypeBox *)s;\n\tif (ptr->type==GF_ISOM_BOX_TYPE_CBMP)\n\t\ts->size += 8;\n\telse if (ptr->type==GF_ISOM_BOX_TYPE_EQUI)\n\t\ts->size += 16;\n\telse\n\t\ts->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tfirm_set_break(port, break_state);\n}", "target": 0}
{"code": "static void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\tmctp_dev_put(mdev);\n}", "target": 1}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}", "target": 1}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "write_config_option_secret (int fd, const char *key, const char *value)\n{\n\tgs_free char *string = NULL;\n\tint x;\n\tstring = g_strdup_printf (\"%s %s\\n\", key, value);\n\tx = write (fd, string, strlen (string));\n\tif (x < 0)\n\t\t_LOGW (\"Unexpected error in write(): %d\", errno);\n\t_LOGD (\"Config: %s <hidden>\", key);\n}", "target": 0}
{"code": "void disk_part_iter_init(struct disk_part_iter *piter, struct gendisk *disk,\n\t\t\t  unsigned int flags)\n{\n\tstruct disk_part_tbl *ptbl;\n\trcu_read_lock();\n\tptbl = rcu_dereference(disk->part_tbl);\n\tpiter->disk = disk;\n\tpiter->part = NULL;\n\tif (flags & DISK_PITER_REVERSE)\n\t\tpiter->idx = ptbl->len - 1;\n\telse if (flags & (DISK_PITER_INCL_PART0 | DISK_PITER_INCL_EMPTY_PART0))\n\t\tpiter->idx = 0;\n\telse\n\t\tpiter->idx = 1;\n\tpiter->flags = flags;\n\trcu_read_unlock();\n}", "target": 0}
{"code": "void *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}", "target": 0}
{"code": "static u32 udp6_portaddr_hash(const struct net *net,\n\t\t\t      const struct in6_addr *addr6,\n\t\t\t      unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\treturn hash ^ port;\n}", "target": 0}
{"code": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n    return OK;\n}", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n        if (newIdx < 0)\n            return 1;\n        p_->idx_ = static_cast<long>(newIdx);   \n        p_->eof_ = false;\n        return 0;\n    }", "target": 1}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void ok_inflater_write_byte(ok_inflater *inflater, const uint8_t b) {\n    inflater->buffer[inflater->buffer_end_pos & BUFFER_SIZE_MASK] = b;\n    inflater->buffer_end_pos++;\n}", "target": 0}
{"code": "static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\tif (!idtv_info_valid)\n\t\treturn;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "fz_default_color_params(fz_context *ctx)\n{\n\treturn default_color_params;\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "static inline pte_t pte_file_mksoft_dirty(pte_t pte)\n{\n       return pte;\n}", "target": 0}
{"code": "static struct list_head *rb_list_head(struct list_head *list)\n{\n\tunsigned long val = (unsigned long)list;\n\treturn (struct list_head *)(val & ~RB_FLAG_MASK);\n}", "target": 0}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "GF_Err vmhd_box_size(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tptr->size += 8;\n\treturn GF_OK;\n}", "target": 0}
{"code": "SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -EINVAL;\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tretval = -ESRCH;\n\tp = find_process_by_pid(pid);\n\tif (p != NULL)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "static void virtio_net_announce(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    if (n->announce_timer.round) {\n        return;\n    }\n    if (virtio_vdev_has_feature(vdev, VIRTIO_NET_F_GUEST_ANNOUNCE) &&\n        virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)) {\n            virtio_net_announce_notify(n);\n    }\n}", "target": 0}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "GF_Err gf_isom_avc_config_new(GF_ISOFile *the_file, u32 trackNumber, GF_AVCConfig *cfg, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleDescriptionBox *stsd;\n\tu32 dataRefIndex;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !cfg) return GF_BAD_PARAM;\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!the_file->keep_utc && !gf_sys_is_test_mode() )\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stsd->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\tif (!entry) return GF_OUT_OF_MEM;\n\t*outDescriptionIndex = gf_list_count(stsd->child_boxes);\n\tentry->avc_config = (GF_AVCConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\tif (!entry->avc_config) return GF_OUT_OF_MEM;\n\tentry->avc_config->config = AVC_DuplicateConfig(cfg);\n\tif (!entry->avc_config->config) return GF_OUT_OF_MEM;\n\tentry->dataReferenceIndex = dataRefIndex;\n\tAVC_RewriteESDescriptor(entry);\n\treturn e;\n}", "target": 0}
{"code": "cdf_read_short_stream(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, const cdf_dir_t *dir, cdf_stream_t *scn,\n    const cdf_directory_t **root)\n{\n\tsize_t i;\n\tconst cdf_directory_t *d;\n\t*root = NULL;\n\tfor (i = 0; i < dir->dir_len; i++)\n\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n\t\t\tbreak;\n\tif (i == dir->dir_len)\n\t\tgoto out;\n\td = &dir->dir_tab[i];\n\t*root = d;\n\tif (d->d_stream_first_sector < 0)\n\t\tgoto out;\n\treturn\tcdf_read_long_sector_chain(info, h, sat,\n\t    d->d_stream_first_sector, d->d_size, scn);\nout:\n\tscn->sst_tab = NULL;\n\tscn->sst_len = 0;\n\tscn->sst_dirlen = 0;\n\treturn 0;\n}", "target": 0}
{"code": "vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\tconst char *haystack;\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n                if( i == needle_len )\n                        return( haystack );\n        }\n        return( NULL );\n}", "target": 1}
{"code": "int pam_sm_close_session (pam_handle_t * pamh, int flags,\n    int argc, const char **argv) {\n    return _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_STOP, NULL);\n}    ", "target": 0}
{"code": "    size_t Exifdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "void ConnectDialogEdit::showNotice(const QString &text) {\n\tQLabel *label = qwInlineNotice->findChild<QLabel *>(QLatin1String(\"qlPasteNotice\"));\n\tQ_ASSERT(label);\n\tlabel->setText(text);\n\tqwInlineNotice->show();\n\tadjustSize();\n}", "target": 0}
{"code": "f_kind_of_p(VALUE x, VALUE c)\n{\n    return rb_obj_is_kind_of(x, c);\n}", "target": 0}
{"code": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1}
{"code": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static lu_mem markbeingfnz (global_State *g) {\n  GCObject *o;\n  lu_mem count = 0;\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    count++;\n    markobject(g, o);\n  }\n  return count;\n}", "target": 0}
{"code": "  virtual ~FFmpegVideoDecoderTest() {}", "target": 0}
{"code": "static int fetch_uidl (char *line, void *data)\n{\n  int i, index;\n  CONTEXT *ctx = (CONTEXT *)data;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  char *endp;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n      return -1;\n  while (*endp == ' ')\n      endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  for (i = 0; i < ctx->msgcount; i++)\n    if (!mutt_strcmp (line, ctx->hdrs[i]->data))\n      break;\n  if (i == ctx->msgcount)\n  {\n    dprint (1, (debugfile, \"pop_fetch_headers: new header %d %s\\n\", index, line));\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_new_header ();\n    ctx->hdrs[i]->data = safe_strdup (line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = 1;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, AndWithNestedNE) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{a: {$gt: -1, $lt: 1, $ne: 0}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[-1,0,false,false], \"\n        \"[0,1,false,false]]}}}}}\");\n}", "target": 0}
{"code": "  bool empty() const override { return value_ == nullptr ? true : value_->empty(); }", "target": 0}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "zrenamefile(i_ctx_t *i_ctx_p)\n{\n    int code;\n    os_ptr op = osp;\n    gs_parsed_file_name_t pname1, pname2;\n    code = parse_real_file_name(op, &pname2, imemory, \"renamefile(to)\");\n    if (code < 0)\n        return code;\n    pname1.fname = 0;\n    code = parse_real_file_name(op - 1, &pname1, imemory, \"renamefile(from)\");\n    if (code >= 0) {\n        gx_io_device *iodev_dflt = iodev_default(imemory);\n        if (pname1.iodev != pname2.iodev ) {\n            if (pname1.iodev == iodev_dflt)\n                pname1.iodev = pname2.iodev;\n            if (pname2.iodev == iodev_dflt)\n                pname2.iodev = pname1.iodev;\n        }\n        if (pname1.iodev != pname2.iodev ||\n            (pname1.iodev == iodev_dflt &&\n              ((check_file_permissions(i_ctx_p, pname1.fname, pname1.len,\n                                        pname1.iodev, \"PermitFileControl\") < 0 &&\n                  !file_is_tempfile(i_ctx_p, op[-1].value.bytes, r_size(op - 1))) ||\n              (check_file_permissions(i_ctx_p, pname2.fname, pname2.len,\n                                        pname2.iodev, \"PermitFileControl\") < 0 ||\n              check_file_permissions(i_ctx_p, pname2.fname, pname2.len,\n                                        pname2.iodev, \"PermitFileWriting\") < 0 )))) {\n            code = gs_note_error(gs_error_invalidfileaccess);\n        } else {\n            code = (*pname1.iodev->procs.rename_file)(pname1.iodev,\n                            pname1.fname, pname2.fname);\n        }\n    }\n    gs_free_file_name(&pname2, \"renamefile(to)\");\n    gs_free_file_name(&pname1, \"renamefile(from)\");\n    if (code < 0)\n        return code;\n    pop(2);\n    return 0;\n}", "target": 0}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "ddxGiveUp(enum ExitCode error)\n{\n    int i;\n    xf86VGAarbiterFini();\n#ifdef XF86PM\n    if (xf86OSPMClose)\n        xf86OSPMClose();\n    xf86OSPMClose = NULL;\n#endif\n    for (i = 0; i < xf86NumScreens; i++) {\n        xf86Screens[i]->vtSema = FALSE;\n    }\n#ifdef XFreeXDGA\n    DGAShutdown();\n#endif\n    if (xorgHWOpenConsole)\n        xf86CloseConsole();\n    systemd_logind_fini();\n    dbus_core_fini();\n    xf86CloseLog(error);\n    if (xf86Info.caughtSignal)\n        OsAbort();\n}", "target": 0}
{"code": "    bool Nikon3MnHeader::read(const byte* pData,\n                              uint32_t    size,\n                              ByteOrder   )\n    {\n        if (!pData || size < sizeOfSignature()) return false;\n        if (0 != memcmp(pData, signature_, 6)) return false;\n        buf_.alloc(sizeOfSignature());\n        std::memcpy(buf_.pData_, pData, buf_.size_);\n        TiffHeader th;\n        if (!th.read(buf_.pData_ + 10, 8)) return false;\n        byteOrder_ = th.byteOrder();\n        start_ = 10 + th.offset();\n        return true;\n    } ", "target": 0}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "static uint16_t nvme_tx(NvmeCtrl *n, NvmeSg *sg, uint8_t *ptr, uint32_t len,\n                        NvmeTxDirection dir)\n{\n    assert(sg->flags & NVME_SG_ALLOC);\n    if (sg->flags & NVME_SG_DMA) {\n        const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n        dma_addr_t residual;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            dma_buf_write(ptr, len, &residual, &sg->qsg, attrs);\n        } else {\n            dma_buf_read(ptr, len, &residual, &sg->qsg, attrs);\n        }\n        if (unlikely(residual)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    } else {\n        size_t bytes;\n        if (dir == NVME_TX_DIRECTION_TO_DEVICE) {\n            bytes = qemu_iovec_to_buf(&sg->iov, 0, ptr, len);\n        } else {\n            bytes = qemu_iovec_from_buf(&sg->iov, 0, ptr, len);\n        }\n        if (unlikely(bytes != len)) {\n            trace_pci_nvme_err_invalid_dma();\n            return NVME_INVALID_FIELD | NVME_DNR;\n        }\n    }\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "static void _d_rehash(struct dentry * entry)\n{\n\t__d_rehash(entry, d_hash(entry->d_parent, entry->d_name.hash));\n}", "target": 0}
{"code": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}", "target": 1}
{"code": "static int snd_usb_cm6206_boot_quirk(struct usb_device *dev)\n{\n\tint err  = 0, reg;\n\tint val[] = {0x2004, 0x3000, 0xf800, 0x143f, 0x0000, 0x3000};\n\tfor (reg = 0; reg < ARRAY_SIZE(val); reg++) {\n\t\terr = snd_usb_cm106_write_int_reg(dev, reg, val[reg]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}", "target": 1}
{"code": "static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    *olen = 0;\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n    *olen = 5 + ssl->verify_data_len;\n}", "target": 0}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}", "target": 0}
{"code": "send_client_notifications (void)\n{\n  struct {\n    pid_t pid;\n#ifdef HAVE_W32_SYSTEM\n    HANDLE handle;\n#else\n    int signo;\n#endif\n  } killed[50];\n  int killidx = 0;\n  int kidx;\n  struct server_local_s *sl;\n  for (sl=session_list; sl; sl = sl->next_session)\n    {\n      if (sl->event_signal && sl->assuan_ctx)\n        {\n          pid_t pid = assuan_get_pid (sl->assuan_ctx);\n#ifdef HAVE_W32_SYSTEM\n          HANDLE handle = (void *)sl->event_signal;\n          for (kidx=0; kidx < killidx; kidx++)\n            if (killed[kidx].pid == pid\n                && killed[kidx].handle == handle)\n              break;\n          if (kidx < killidx)\n            log_info (\"event %lx (%p) already triggered for client %d\\n\",\n                      sl->event_signal, handle, (int)pid);\n          else\n            {\n              log_info (\"triggering event %lx (%p) for client %d\\n\",\n                        sl->event_signal, handle, (int)pid);\n              if (!SetEvent (handle))\n                log_error (\"SetEvent(%lx) failed: %s\\n\",\n                           sl->event_signal, w32_strerror (-1));\n              if (killidx < DIM (killed))\n                {\n                  killed[killidx].pid = pid;\n                  killed[killidx].handle = handle;\n                  killidx++;\n                }\n            }\n#else \n          int signo = sl->event_signal;\n          if (pid != (pid_t)(-1) && pid && signo > 0)\n            {\n              for (kidx=0; kidx < killidx; kidx++)\n                if (killed[kidx].pid == pid\n                    && killed[kidx].signo == signo)\n                  break;\n              if (kidx < killidx)\n                log_info (\"signal %d already sent to client %d\\n\",\n                          signo, (int)pid);\n              else\n                {\n                  log_info (\"sending signal %d to client %d\\n\",\n                            signo, (int)pid);\n                  kill (pid, signo);\n                  if (killidx < DIM (killed))\n                    {\n                      killed[killidx].pid = pid;\n                      killed[killidx].signo = signo;\n                      killidx++;\n                    }\n                }\n            }\n#endif \n        }\n    }\n}", "target": 0}
{"code": "static int16_t findOffset(const char* const* list, const char* key)\n{\n\tconst char* const* anchor = list;\n\twhile (*list != NULL) {\n\t\tif (strcmp(key, *list) == 0) {\n\t\t\treturn (int16_t)(list - anchor);\n\t\t}\n\t\tlist++;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "void luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  \n  white2gray(o);  \n  setage(o, G_OLD);  \n  g->allgc = o->next;  \n  o->next = g->fixedgc;  \n  g->fixedgc = o;\n}", "target": 0}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantExplodeWithEmptyBounds2) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{a: {$gt: 3, $lt: 0}}\"), BSON(\"b\" << 1), BSONObj());\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {b:1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {b:1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: {ixscan: {pattern: {a:1,b:1,c:1}}}}}}}}}\");\n}", "target": 0}
{"code": "ptaReadStream(FILE  *fp)\n{\nchar       typestr[128];\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagecropauto)\n{\n\tzval *IM;\n\tlong mode = -1;\n\tlong color = -1;\n\tdouble threshold = 0.5f;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ldl\", &IM, &mode, &threshold, &color) == FAILURE)  {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tswitch (mode) {\n\t\tcase -1:\n\t\t\tmode = GD_CROP_DEFAULT;\n\t\tcase GD_CROP_DEFAULT:\n\t\tcase GD_CROP_TRANSPARENT:\n\t\tcase GD_CROP_BLACK:\n\t\tcase GD_CROP_WHITE:\n\t\tcase GD_CROP_SIDES:\n\t\t\tim_crop = gdImageCropAuto(im, mode);\n\t\t\tbreak;\n\t\tcase GD_CROP_THRESHOLD:\n\t\t\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color argument missing with threshold mode\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tim_crop = gdImageCropThreshold(im, color, (float) threshold);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown crop mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}", "target": 0}
{"code": "    uint32_t TiffEntryBase::doWriteData(IoWrapper&,\n                                        ByteOrder ,\n                                        int32_t   ,\n                                        uint32_t  ,\n                                        uint32_t& ) const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "fbCombineOutU (CARD32 *dest, const CARD32 *src, int width)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32 s = READ(src + i);\n        CARD32 a = Alpha(~READ(dest + i));\n        FbByteMul(s, a);\n        WRITE(dest + i, s);\n    }\n}", "target": 0}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "static bool parse_namemap(RBuffer *b, ut64 bound, RIDStorage *map, ut32 *count) {\n\tsize_t i;\n\tif (!consume_u32_r (b, bound, count)) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < *count; i++) {\n\t\tut32 idx;\n\t\tif (!consume_u32_r (b, bound, &idx)) {\n\t\t\treturn false;\n\t\t}\n\t\tchar *name = NULL;\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &name)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_id_storage_add (map, name, &idx)) {\n\t\t\tR_FREE (name);\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint r;\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tr = -ENOMEM;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto err_1;\n\tif (svm_sev_enabled()) {\n\t\tr = -ENOMEM;\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto err_1;\n\t}\n\tper_cpu(svm_data, cpu) = sd;\n\treturn 0;\nerr_1:\n\tkfree(sd);\n\treturn r;\n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "static void __init config_types(void)\n{\n\tbool has_drive = false;\n\tint drive;\n\tdrive = 0;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY0_TYPE;\n\tdrive = 1;\n\tif (!UDP->cmos)\n\t\tUDP->cmos = FLOPPY1_TYPE;\n\tfor (drive = 0; drive < N_DRIVE; drive++) {\n\t\tunsigned int type = UDP->cmos;\n\t\tstruct floppy_drive_params *params;\n\t\tconst char *name = NULL;\n\t\tchar temparea[32];\n\t\tif (type < ARRAY_SIZE(default_drive_params)) {\n\t\t\tparams = &default_drive_params[type].params;\n\t\t\tif (type) {\n\t\t\t\tname = default_drive_params[type].name;\n\t\t\t\tallowed_drive_mask |= 1 << drive;\n\t\t\t} else\n\t\t\t\tallowed_drive_mask &= ~(1 << drive);\n\t\t} else {\n\t\t\tparams = &default_drive_params[0].params;\n\t\t\tsnprintf(temparea, sizeof(temparea),\n\t\t\t\t \"unknown type %d (usb?)\", type);\n\t\t\tname = temparea;\n\t\t}\n\t\tif (name) {\n\t\t\tconst char *prepend;\n\t\t\tif (!has_drive) {\n\t\t\t\tprepend = \"\";\n\t\t\t\thas_drive = true;\n\t\t\t\tpr_info(\"Floppy drive(s):\");\n\t\t\t} else {\n\t\t\t\tprepend = \",\";\n\t\t\t}\n\t\t\tpr_cont(\"%s fd%d is %s\", prepend, drive, name);\n\t\t}\n\t\t*UDP = *params;\n\t}\n\tif (has_drive)\n\t\tpr_cont(\"\\n\");\n}", "target": 0}
{"code": "POSITION::POSITION()\n{\n  table= 0;\n  records_read= cond_selectivity= read_time= 0.0;\n  prefix_record_count= 0.0;\n  key= 0;\n  use_join_buffer= 0;\n  sj_strategy= SJ_OPT_NONE;\n  n_sj_tables= 0;\n  spl_plan= 0;\n  range_rowid_filter_info= 0;\n  ref_depend_map= dups_producing_tables= 0;\n  inner_tables_handled_with_other_sjs= 0;\n  dups_weedout_picker.set_empty();\n  firstmatch_picker.set_empty();\n  loosescan_picker.set_empty();\n  sjmat_picker.set_empty();\n}", "target": 0}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) return -ENOMEM;\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "static PolygonInfo **DestroyPolygonThreadSet(PolygonInfo **polygon_info)\n{\n  ssize_t\n    i;\n  assert(polygon_info != (PolygonInfo **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (polygon_info[i] != (PolygonInfo *) NULL)\n      polygon_info[i]=DestroyPolygonInfo(polygon_info[i]);\n  polygon_info=(PolygonInfo **) RelinquishMagickMemory(polygon_info);\n  return(polygon_info);\n}", "target": 0}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "static struct nft_stats __percpu *nft_stats_alloc(const struct nlattr *attr)\n{\n\tstruct nlattr *tb[NFTA_COUNTER_MAX+1];\n\tstruct nft_stats __percpu *newstats;\n\tstruct nft_stats *stats;\n\tint err;\n\terr = nla_parse_nested(tb, NFTA_COUNTER_MAX, attr, nft_counter_policy);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\tif (!tb[NFTA_COUNTER_BYTES] || !tb[NFTA_COUNTER_PACKETS])\n\t\treturn ERR_PTR(-EINVAL);\n\tnewstats = netdev_alloc_pcpu_stats(struct nft_stats);\n\tif (newstats == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstats = this_cpu_ptr(newstats);\n\tstats->bytes = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_BYTES]));\n\tstats->pkts = be64_to_cpu(nla_get_be64(tb[NFTA_COUNTER_PACKETS]));\n\treturn newstats;\n}", "target": 0}
{"code": "static void blk_mq_exit_hw_queues(struct request_queue *q,\n\t\tstruct blk_mq_tag_set *set, int nr_queue)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned int i;\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tif (i == nr_queue)\n\t\t\tbreak;\n\t\tblk_mq_exit_hctx(q, set, hctx, i);\n\t}\n}", "target": 0}
{"code": "void DHT::illustrate_dirs()\n{\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for schedule(guided)\n#endif\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    illustrate_dline(i);\n  }\n}", "target": 0}
{"code": "  QInt32() {}", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "void js_throw(js_State *J)\n{\n\tif (J->trytop > 0) {\n\t\tjs_Value v = *stackidx(J, -1);\n\t\t--J->trytop;\n\t\tJ->E = J->trybuf[J->trytop].E;\n\t\tJ->envtop = J->trybuf[J->trytop].envtop;\n\t\tJ->tracetop = J->trybuf[J->trytop].tracetop;\n\t\tJ->top = J->trybuf[J->trytop].top;\n\t\tJ->bot = J->trybuf[J->trytop].bot;\n\t\tjs_pushvalue(J, v);\n\t\tlongjmp(J->trybuf[J->trytop].buf, 1);\n\t}\n\tif (J->panic)\n\t\tJ->panic(J);\n\tabort();\n}", "target": 0}
{"code": "init_ctx_nego(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t      OM_uint32 acc_negState, gss_OID supportedMech,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\tif (supportedMech == GSS_C_NO_OID) {\n\t\t*minor_status = ERR_SPNEGO_NO_MECH_FROM_ACCEPTOR;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (acc_negState == ACCEPT_DEFECTIVE_TOKEN) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tif (!(is_kerb_mech(supportedMech) &&\n\t      is_kerb_mech(sc->internal_mech)) &&\n\t    !g_OID_equal(supportedMech, sc->internal_mech)) {\n\t\tret = init_ctx_reselect(minor_status, sc,\n\t\t\t\t\tacc_negState, supportedMech,\n\t\t\t\t\tresponseToken, mechListMIC,\n\t\t\t\t\tnegState, tokflag);\n\t} else if (*responseToken == GSS_C_NO_BUFFER) {\n\t\tif (sc->mech_complete) {\n\t\t\t*negState = ACCEPT_COMPLETE;\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\tret = GSS_S_COMPLETE;\n\t\t} else {\n\t\t\t*minor_status = ERR_SPNEGO_NO_TOKEN_FROM_ACCEPTOR;\n\t\t\tmap_errcode(minor_status);\n\t\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if ((*responseToken)->length == 0 && sc->mech_complete) {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t} else if (sc->mech_complete) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\tsc->nego_done = 1;\n\treturn ret;\n}", "target": 0}
{"code": "TEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    \n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  \n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    \n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}", "target": 0}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "void cql_server::response::write_byte(uint8_t b)\n{\n    auto s = reinterpret_cast<const int8_t*>(&b);\n    _body.write(bytes_view(s, sizeof(b)));\n}", "target": 0}
{"code": "static char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}", "target": 1}
{"code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "find_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t\n{\n    int\t\tc;\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 1}
{"code": "void RenderFrameHostImpl::SwapOut() {\n  if (render_view_host_->IsRenderViewLive()) {\n    Send(new FrameMsg_SwapOut(routing_id_));\n  } else {\n    OnSwappedOut(true);\n  }\n}", "target": 0}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "bool AccessibilityUIElement::attributedStringRangeIsMisspelled(unsigned location, unsigned length)\n{\n    return false;\n}", "target": 0}
{"code": "void dname_pkt_copy(sldns_buffer* pkt, uint8_t* to, uint8_t* dname)\n{\n\tsize_t len = 0;\n\tuint8_t lablen;\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlen += (size_t)lablen+1;\n\t\tif(len >= LDNS_MAX_DOMAINLEN) {\n\t\t\t*to = 0; \n\t\t\tlog_err(\"bad dname in dname_pkt_copy\");\n\t\t\treturn;\n\t\t}\n\t\t*to++ = lablen;\n\t\tmemmove(to, dname, lablen);\n\t\tdname += lablen;\n\t\tto += lablen;\n\t\tlablen = *dname++;\n\t}\n\t*to = 0;\n}", "target": 1}
{"code": "check_tty(const char *tty)\n{\n\tif ((tty == NULL) || (strlen(tty) == 0)) {\n\t\treturn NULL;\n\t}\n\tif (strchr(tty, '/') != NULL) {\n\t\tif (strncmp(tty, \"/dev/\", 5) != 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\ttty = strrchr(tty, '/') + 1;\n\t}\n\tif (strlen(tty) == 0) {\n\t\treturn NULL;\n\t}\n\treturn tty;\n}", "target": 1}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "void IndexedDBDatabase::Get(IndexedDBTransaction* transaction,\n                            int64_t object_store_id,\n                            int64_t index_id,\n                            std::unique_ptr<IndexedDBKeyRange> key_range,\n                            bool key_only,\n                            scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Get\", \"txn.id\", transaction->id());\n  if (!ValidateObjectStoreIdAndOptionalIndexId(object_store_id, index_id))\n    return;\n  transaction->ScheduleTask(base::BindOnce(\n      &IndexedDBDatabase::GetOperation, this, object_store_id, index_id,\n      std::move(key_range),\n      key_only ? indexed_db::CURSOR_KEY_ONLY : indexed_db::CURSOR_KEY_AND_VALUE,\n      callbacks));\n}", "target": 0}
{"code": "ZEND_API int ZEND_FASTCALL zend_binary_strncmp(const char *s1, size_t len1, const char *s2, size_t len2, size_t length) \n{\n\tint retval;\n\tif (s1 == s2) {\n\t\treturn 0;\n\t}\n\tretval = memcmp(s1, s2, MIN(length, MIN(len1, len2)));\n\tif (!retval) {\n\t\treturn (int)(MIN(length, len1) - MIN(length, len2));\n\t} else {\n\t\treturn retval;\n\t}\n}", "target": 0}
{"code": "void HTMLSelectElement::restoreFormControlState(const FormControlState& state)\n{\n    recalcListItems();\n    const Vector<HTMLElement*>& items = listItems();\n    size_t itemsSize = items.size();\n    if (!itemsSize)\n        return;\n    for (size_t i = 0; i < itemsSize; ++i) {\n        if (!items[i]->hasLocalName(optionTag))\n            continue;\n        toHTMLOptionElement(items[i])->setSelectedState(false);\n    }\n    if (!multiple()) {\n        size_t foundIndex = searchOptionsForValue(state[0], 0, itemsSize);\n        if (foundIndex != kNotFound)\n            toHTMLOptionElement(items[foundIndex])->setSelectedState(true);\n    } else {\n        size_t startIndex = 0;\n        for (size_t i = 0; i < state.valueSize(); ++i) {\n            const String& value = state[i];\n            size_t foundIndex = searchOptionsForValue(value, startIndex, itemsSize);\n            if (foundIndex == kNotFound)\n                foundIndex = searchOptionsForValue(value, 0, startIndex);\n            if (foundIndex == kNotFound)\n                continue;\n            toHTMLOptionElement(items[foundIndex])->setSelectedState(true);\n            startIndex = foundIndex + 1;\n        }\n    }\n    setOptionsChangedOnRenderer();\n    setNeedsValidityCheck();\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "void decode_prediction_unit(base_context* ctx,\n                            const slice_segment_header* shdr,\n                            de265_image* img,\n                            const PBMotionCoding& motion,\n                            int xC,int yC, int xB,int yB, int nCS, int nPbW,int nPbH, int partIdx)\n{\n  logtrace(LogMotion,\"decode_prediction_unit POC=%d %d;%d %dx%d\\n\",\n           img->PicOrderCntVal, xC+xB,yC+yB, nPbW,nPbH);\n  PBMotion vi;\n  motion_vectors_and_ref_indices(ctx, shdr, img, motion,\n                                 xC,yC, xB,yB, nCS, nPbW,nPbH, partIdx, &vi);\n  generate_inter_prediction_samples(ctx,shdr, img, xC,yC, xB,yB, nCS, nPbW,nPbH, &vi);\n  img->set_mv_info(xC+xB,yC+yB,nPbW,nPbH, vi);\n}", "target": 0}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "set_tagstack(win_T *wp, dict_T *d, int action)\n{\n    dictitem_T\t*di;\n    list_T\t*l = NULL;\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FAIL;\n    }\n#endif\n    if ((di = dict_find(d, (char_u *)\"items\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_LIST)\n\t{\n\t    emsg(_(e_list_required));\n\t    return FAIL;\n\t}\n\tl = di->di_tv.vval.v_list;\n    }\n    if ((di = dict_find(d, (char_u *)\"curidx\", -1)) != NULL)\n\ttagstack_set_curidx(wp, (int)tv_get_number(&di->di_tv) - 1);\n    if (action == 't')\t\t    \n    {\n\ttaggy_T\t*tagstack = wp->w_tagstack;\n\tint\ttagstackidx = wp->w_tagstackidx;\n\tint\ttagstacklen = wp->w_tagstacklen;\n\twhile (tagstackidx < tagstacklen)\n\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\twp->w_tagstacklen = tagstacklen;\n    }\n    if (l != NULL)\n    {\n\tif (action == 'r')\t\t\n\t    tagstack_clear(wp);\n\ttagstack_push_items(wp, l);\n\twp->w_tagstackidx = wp->w_tagstacklen;\n    }\n    return OK;\n}", "target": 0}
{"code": "    inline char lowercase(const char x) {\n      return (char)((x<'A'||x>'Z')?x:x - 'A' + 'a');", "target": 0}
{"code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n    if (!m_scrollLayer)\n        return;\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}", "target": 1}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "static void alloc_stmt_fields(MYSQL_STMT *stmt)\n{\n  MYSQL_FIELD *fields, *field, *end;\n  MEM_ROOT *fields_mem_root= &stmt->extension->fields_mem_root;\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ASSERT(stmt->field_count);\n  free_root(fields_mem_root, MYF(0));\n  if (!(stmt->fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,\n\t\t\t\t\t\t sizeof(MYSQL_FIELD) *\n\t\t\t\t\t\t stmt->field_count)) ||\n      !(stmt->bind= (MYSQL_BIND *) alloc_root(fields_mem_root,\n\t\t\t\t\t      sizeof(MYSQL_BIND) *\n\t\t\t\t\t      stmt->field_count)))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    return;\n  }\n  for (fields= mysql->fields, end= fields+stmt->field_count,\n\t field= stmt->fields;\n       field && fields < end; fields++, field++)\n  {\n    *field= *fields; \n    field->catalog=   strmake_root(fields_mem_root,\n                                   fields->catalog,\n                                   fields->catalog_length);\n    field->db=        strmake_root(fields_mem_root,\n                                   fields->db,\n                                   fields->db_length);\n    field->table=     strmake_root(fields_mem_root,\n                                   fields->table,\n                                   fields->table_length);\n    field->org_table= strmake_root(fields_mem_root,\n                                   fields->org_table,\n                                   fields->org_table_length);\n    field->name=      strmake_root(fields_mem_root,\n                                   fields->name,\n                                   fields->name_length);\n    field->org_name=  strmake_root(fields_mem_root,\n                                   fields->org_name,\n                                   fields->org_name_length);\n    if (fields->def)\n    {\n      field->def= strmake_root(fields_mem_root,\n                               fields->def,\n                               fields->def_length);\n      field->def_length= fields->def_length;\n    }\n    else\n    {\n      field->def= NULL;\n      field->def_length= 0;\n    }\n    field->extension= 0; \n    field->max_length= 0; \n  }\n}", "target": 0}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int __init efi_load_efivars(void)\n{\n\tstruct platform_device *pdev;\n\tif (!efi_enabled(EFI_RUNTIME_SERVICES))\n\t\treturn 0;\n\tpdev = platform_device_register_simple(\"efivars\", 0, NULL, 0);\n\treturn PTR_ERR_OR_ZERO(pdev);\n}", "target": 0}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "_gnutls_x509_decode_string(unsigned int etype,\n\t\t\t   const uint8_t * der, size_t der_size,\n\t\t\t   gnutls_datum_t * output, unsigned allow_ber)\n{\n\tint ret;\n\tuint8_t *str;\n\tunsigned int str_size, len;\n\tgnutls_datum_t td;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tret =\n\t\t    asn1_decode_simple_ber(etype, der, der_size, &str, &str_size, NULL);\n\telse\n#endif\n\t\tret =\n\t\t    asn1_decode_simple_der(etype, der, der_size, (const uint8_t**)&str, &str_size);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(ret);\n\t\treturn ret;\n\t}\n\ttd.size = str_size;\n\ttd.data = gnutls_malloc(str_size + 1);\n\tif (td.data == NULL)\n\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\tmemcpy(td.data, str, str_size);\n\ttd.data[str_size] = 0;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tfree(str);\n#endif\n\tret = make_printable_string(etype, &td, output);\n\tif (ret == GNUTLS_E_INVALID_REQUEST) {\t\n\t\toutput->data = td.data;\n\t\toutput->size = td.size;\n\t\tret = 0;\n\t} else if (ret <= 0) {\n\t\t_gnutls_free_datum(&td);\n\t}\n\tif (etype != ASN1_ETYPE_OCTET_STRING) {\n\t\tif (output->data)\n\t\t\tlen = strlen((void *) output->data);\n\t\telse\n\t\t\tlen = 0;\n\t\tif (len != (size_t) output->size) {\n\t\t\t_gnutls_free_datum(output);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "static PHP_GINIT_FUNCTION(date)\n{\n\tdate_globals->default_timezone = NULL;\n\tdate_globals->timezone = NULL;\n\tdate_globals->tzcache = NULL;\n\tdate_globals->timezone_valid = 0;", "target": 0}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n{\n    gx_device *dev_old = gs_currentdevice(pgs_old);\n    gx_device *dev_new;\n    gx_device *dev_t1;\n    gx_device *dev_t2;\n    bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice,\n        &gs_int_gstate(pgs_new)->pagedevice);\n    bool LockSafetyParams = dev_old->LockSafetyParams;\n    if ((dev_t1 = (*dev_proc(dev_old, get_page_device)) (dev_old)) == 0)\n        return 0;\n    if (!samepagedevice)\n        dev_old->LockSafetyParams = false;\n    dev_new = gs_currentdevice(pgs_new);\n    if (dev_old != dev_new) {\n        if ((dev_t2 = (*dev_proc(dev_new, get_page_device)) (dev_new)) == 0)\n            samepagedevice = true;\n        else if (dev_t1 != dev_t2)\n            samepagedevice = false;\n    }\n    if (LockSafetyParams) {\n        const int required_ops = 512;\n        const int required_es = 32;\n        if (required_ops + ref_stack_count(&o_stack) >= ref_stack_max_count(&o_stack)) {\n           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n           return_error(gs_error_stackoverflow);\n        }\n        if (required_es + ref_stack_count(&e_stack) >= ref_stack_max_count(&e_stack)) {\n           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n           return_error(gs_error_execstackoverflow);\n        }\n    }\n    return samepagedevice ? 0 : 1;\n}", "target": 0}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "static ssize_t set_bank(struct device *s, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tu64 new;\n\tif (kstrtou64(buf, 0, &new) < 0)\n\t\treturn -EINVAL;\n\tattr_to_bank(attr)->ctl = new;\n\tmce_restart();\n\treturn size;\n}", "target": 0}
{"code": "gdImagePtr gdImageCreateTrueColor (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(int), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdMalloc(sizeof(gdImage));\n\tmemset(im, 0, sizeof(gdImage));\n\tim->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->tpixels[i] = (int *) gdCalloc(sx, sizeof(int));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->trueColor = 1;\n\tim->saveAlphaFlag = 0;\n\tim->alphaBlendingFlag = 1;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "writeRandomBytes_arc4random(void * target, size_t count) {\n  size_t bytesWrittenTotal = 0;\n  while (bytesWrittenTotal < count) {\n    const uint32_t random32 = arc4random();\n    size_t i = 0;\n    for (; (i < sizeof(random32)) && (bytesWrittenTotal < count);\n        i++, bytesWrittenTotal++) {\n      const uint8_t random8 = (uint8_t)(random32 >> (i * 8));\n      ((uint8_t *)target)[bytesWrittenTotal] = random8;\n    }\n  }\n}", "target": 0}
{"code": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\tgit__free(entry);\n}", "target": 0}
{"code": "read_password(FILE *in, FILE *out, char *buf, size_t bufsz)\n{\n\tint infd = fileno(in);\n\tstruct termios tio;\n\tchar *ret;\n\tret = fgets(buf, bufsz, in);\n\tif (isatty(infd)) {\n\t\tfprintf(out, \"\\n\");\n\t\tfflush(out);\n\t\ttcgetattr(infd, &tio);\n\t\ttio.c_lflag |= ECHO;\n\t\ttcsetattr(infd, TCSAFLUSH, &tio);\n\t}\n\tif (ret == NULL)\n\t\treturn -1;\n\tbuf[strlen(buf)-1] = '\\0';\n\treturn 0;\n}", "target": 0}
{"code": "static void ncq_err(NCQTransferState *ncq_tfs)\n{\n    IDEState *ide_state = &ncq_tfs->drive->port.ifs[0];\n     ide_state->error = ABRT_ERR;\n     ide_state->status = READY_STAT | ERR_STAT;\n     ncq_tfs->drive->port_regs.scr_err |= (1 << ncq_tfs->tag);\n    ncq_tfs->used = 0;\n }", "target": 0}
{"code": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n\t\t\t\t\t\tvoid __user *useraddr)\n{\n\tstruct ethtool_rxnfc info;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tint ret;\n\tvoid *rule_buf = NULL;\n\tif (!ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&info, useraddr, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n\t\tif (info.rule_cnt > 0) {\n\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n\t\t\t\t\t   GFP_USER);\n\t\t\tif (!rule_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tret = ops->get_rxnfc(dev, &info, rule_buf);\n\tif (ret < 0)\n\t\tgoto err_out;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &info, sizeof(info)))\n\t\tgoto err_out;\n\tif (rule_buf) {\n\t\tuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\n\t\tif (copy_to_user(useraddr, rule_buf,\n\t\t\t\t info.rule_cnt * sizeof(u32)))\n\t\t\tgoto err_out;\n\t}\n\tret = 0;\nerr_out:\n\tkfree(rule_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}", "target": 0}
{"code": "static void virtio_net_drop_tx_queue_data(VirtIODevice *vdev, VirtQueue *vq)\n{\n    unsigned int dropped = virtqueue_drop_all(vq);\n    if (dropped) {\n        virtio_notify(vdev, vq);\n    }\n}", "target": 0}
{"code": "void RootWindowHostWin::SetCapture() {\n  if (!has_capture_) {\n    has_capture_ = true;\n    ::SetCapture(hwnd());\n  }\n}", "target": 0}
{"code": "int unit_name_build(const char *prefix, const char *instance, const char *suffix, char **ret) {\n        UnitType type;\n        assert(prefix);\n        assert(suffix);\n        assert(ret);\n        if (suffix[0] != '.')\n                return -EINVAL;\n        type = unit_type_from_string(suffix + 1);\n        if (type < 0)\n                return -EINVAL;\n        return unit_name_build_from_type(prefix, instance, type, ret);\n}", "target": 0}
{"code": "GF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;", "target": 0}
{"code": "        Header readHeader(BasicIo& io)\n        {\n            byte header[2];\n            io.read(header, 2);\n            ByteOrder byteOrder = invalidByteOrder;\n            if (header[0] == 'I' && header[1] == 'I')\n                byteOrder = littleEndian;\n            else if (header[0] == 'M' && header[1] == 'M')\n                byteOrder = bigEndian;\n            if (byteOrder == invalidByteOrder)\n                return Header();\n            byte version[2];\n            io.read(version, 2);\n            const uint16_t magic = getUShort(version, byteOrder);\n            if (magic != 0x2A && magic != 0x2B)\n                return Header();\n            Header result;\n            if (magic == 0x2A)\n            {\n                byte buffer[4];\n                io.read(buffer, 4);\n                const uint32_t offset = getULong(buffer, byteOrder);\n                result = Header(byteOrder, magic, 4, offset);\n            }\n            else\n            {\n                byte buffer[8];\n                io.read(buffer, 2);\n                const int size = getUShort(buffer, byteOrder);\n                assert(size == 8);\n                io.read(buffer, 2); \n                io.read(buffer, 8);\n                const uint64_t offset = getULongLong(buffer, byteOrder);\n                result = Header(byteOrder, magic, size, offset);\n            }\n            return result;\n        }", "target": 1}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 1}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static bool tailmatch(const char *cooke_domain, const char *hostname)\n{\n  size_t cookie_domain_len = strlen(cooke_domain);\n  size_t hostname_len = strlen(hostname);\n  if(hostname_len < cookie_domain_len)\n    return FALSE;\n  if(!strcasecompare(cooke_domain, hostname + hostname_len-cookie_domain_len))\n    return FALSE;\n  if(hostname_len == cookie_domain_len)\n    return TRUE;\n  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "void kvm_arch_free_memslot(struct kvm_memory_slot *free,\n\t\t\t   struct kvm_memory_slot *dont)\n{\n\tint i;\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tif (!dont || free->arch.rmap[i] != dont->arch.rmap[i]) {\n\t\t\tkvm_kvfree(free->arch.rmap[i]);\n\t\t\tfree->arch.rmap[i] = NULL;\n\t\t}\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (!dont || free->arch.lpage_info[i - 1] !=\n\t\t\t     dont->arch.lpage_info[i - 1]) {\n\t\t\tkvm_kvfree(free->arch.lpage_info[i - 1]);\n\t\t\tfree->arch.lpage_info[i - 1] = NULL;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline struct rt6_info *ip6_dst_alloc(struct net *net,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct fib6_table *table)\n{\n\tstruct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,\n\t\t\t\t\t0, DST_OBSOLETE_FORCE_CHK, flags);\n\tif (rt) {\n\t\tstruct dst_entry *dst = &rt->dst;\n\t\tmemset(dst + 1, 0, sizeof(*rt) - sizeof(*dst));\n\t\trt6_init_peer(rt, table ? &table->tb6_peers : net->ipv6.peers);\n\t\trt->rt6i_genid = rt_genid(net);\n\t\tINIT_LIST_HEAD(&rt->rt6i_siblings);\n\t\trt->rt6i_nsiblings = 0;\n\t}\n\treturn rt;\n}", "target": 0}
{"code": "void set_current_connection(struct st_connection *con)\n{\n  cur_con= con;\n  var_set_int(\"$mysql_get_server_version\",\n              mysql_get_server_version(con->mysql));\n  var_set_string(\"$CURRENT_CONNECTION\", con->name);\n}", "target": 0}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "static void js_initvar(js_State *J, const char *name, int idx)\n{\n\tjsR_defproperty(J, J->E->variables, name, JS_DONTENUM | JS_DONTCONF, stackidx(J, idx), NULL, NULL);\n}", "target": 0}
{"code": "static int file_cb(\n\tconst git_diff_delta *delta,\n\tfloat progress,\n\tvoid *payload)\n{\n\tstruct diff_data *diff_data = payload;\n\tGIT_UNUSED(progress);\n\tif (delta->old_file.path)\n\t\tdiff_data->old_path = git__strdup(delta->old_file.path);\n\tif (delta->new_file.path)\n\t\tdiff_data->new_path = git__strdup(delta->new_file.path);\n\tgit_oid_cpy(&diff_data->old_id, &delta->old_file.id);\n\tgit_oid_cpy(&diff_data->new_id, &delta->new_file.id);\n\treturn 0;\n}", "target": 0}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "static void write_response(ESPState *s)\n{\n    uint32_t n;\n    trace_esp_write_response(s->status);\n    fifo8_reset(&s->fifo);\n    esp_fifo_push(s, s->status);\n    esp_fifo_push(s, 0);\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque,\n                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        s->ti_size = 2;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif \n  {\n    parser->m_processor = contentProcessor;\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}", "target": 1}
{"code": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "int LibRaw_buffer_datastream::jpeg_src(void *jpegdata)\n{\n#if defined(NO_JPEG) || !defined(USE_JPEG)\n  return -1;\n#else\n  j_decompress_ptr cinfo = (j_decompress_ptr)jpegdata;\n  jpeg_mem_src(cinfo, (unsigned char *)buf + streampos, streamsize - streampos);\n  return 0;\n#endif\n}", "target": 0}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "lexer_compare_identifier_to_current (parser_context_t *context_p,        \n                                     const lexer_lit_location_t *right)  \n{\n  lexer_lit_location_t *left = &context_p->token.lit_location;\n  const uint8_t *left_p;\n  const uint8_t *right_p;\n  size_t count;\n  JERRY_ASSERT (left->length > 0 && right->length > 0);\n  if (left->length != right->length)\n  {\n    return 0;\n  }\n  if (!left->has_escape && !right->has_escape)\n  {\n    return memcmp (left->char_p, right->char_p, left->length) == 0;\n  }\n  left_p = left->char_p;\n  right_p = right->char_p;\n  count = left->length;\n  do\n  {\n    uint8_t utf8_buf[3];\n    size_t utf8_len, offset;\n    if (*left_p != LIT_CHAR_BACKSLASH && *right_p != LIT_CHAR_BACKSLASH)\n    {\n      if (*left_p++ != *right_p++)\n      {\n        return false;\n      }\n      count--;\n      continue;\n    }\n    if (*left_p == LIT_CHAR_BACKSLASH && *right_p == LIT_CHAR_BACKSLASH)\n    {\n      uint16_t left_chr = lexer_hex_to_character (context_p, left_p, 6);\n      if (left_chr != lexer_hex_to_character (context_p, right_p, 6))\n      {\n        return false;\n      }\n      left_p += 6;\n      right_p += 6;\n      count += lit_char_get_utf8_length (left_chr);\n      continue;\n    }\n    if (*right_p == LIT_CHAR_BACKSLASH)\n    {\n      const uint8_t *swap_p = left_p;\n      left_p = right_p;\n      right_p = swap_p;\n    }\n    utf8_len = lit_char_to_utf8_bytes (utf8_buf, lexer_hex_to_character (context_p, left_p, 6));\n    JERRY_ASSERT (utf8_len > 0);\n    count -= utf8_len;\n    offset = 0;\n    do\n    {\n      if (utf8_buf[offset] != *right_p++)\n      {\n        return false;\n      }\n      offset++;\n    }\n    while (offset < utf8_len);\n    left_p += 6;\n  }\n  while (count > 0);\n  return true;\n} ", "target": 0}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}", "target": 1}
{"code": "extractDirName(const StaticString &path) {\n\tchar *path_copy = strdup(path.c_str());\n\tchar *result = dirname(path_copy);\n\tstring result_string(result);\n\tfree(path_copy);\n\treturn result_string;\n}", "target": 0}
{"code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}", "target": 1}
{"code": "static int fsck_tag(struct tag *tag, const char *data,\n\tunsigned long size, struct fsck_options *options)\n{\n\tstruct object *tagged = tag->tagged;\n\tif (!tagged)\n\t\treturn report(options, &tag->object, FSCK_MSG_BAD_TAG_OBJECT, \"could not load tagged object\");\n\treturn fsck_tag_buffer(tag, data, size, options);\n}", "target": 0}
{"code": "void scheduler_tick(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct task_struct *curr = rq->curr;\n\tsched_clock_tick();\n\traw_spin_lock(&rq->lock);\n\tupdate_rq_clock(rq);\n\tcurr->sched_class->task_tick(rq, curr, 0);\n\tupdate_cpu_load_active(rq);\n\tcalc_global_load_tick(rq);\n\traw_spin_unlock(&rq->lock);\n\tperf_event_task_tick();\n#ifdef CONFIG_SMP\n\trq->idle_balance = idle_cpu(cpu);\n\ttrigger_load_balance(rq);\n#endif\n\trq_last_tick_reset(rq);\n}", "target": 0}
{"code": "static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len,  image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short  cmap_len, cmap_entry_size;\n    unsigned short  image_w, image_h;\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    image_type = tga[2];\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n    *flip_image = !(image_desc & 32);\n    palette_size = cmap_len * (cmap_entry_size / 8);\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}", "target": 1}
{"code": "static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  \n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  \n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}", "target": 1}
{"code": "static int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\tif (inet_sk(sk)->inet_daddr) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t is_udplite);\n\t\tUDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb(skb);\n\t\ttrace_udp_fail_queue_rcv_skb(rc, sk);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}", "target": 1}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "static void FNAME_DECL(uncompress_row0_seg)(int i,\n                                            PIXEL * const cur_row,\n                                            const int end,\n                                            const unsigned int waitmask,\n                                            const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    int stopidx;\n    spice_assert(end - i > 0);\n    if (i == 0) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    while (stopidx < end) {\n        for (; i <= stopidx; i++) {\n            unsigned int codewordlen;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n        }\n        UPDATE_MODEL(stopidx);\n        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n    }\n    for (; i < end; i++) {\n        unsigned int codewordlen;\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);\n    }\n    state->waitcnt = stopidx - end;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType GetImageKurtosis(const Image *image,\n  double *kurtosis,double *skewness,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *kurtosis=channel_statistics[CompositePixelChannel].kurtosis;\n  *skewness=channel_statistics[CompositePixelChannel].skewness;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)\n{\n\tpmd_t *new = pmd_alloc_one(mm, address);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tsmp_wmb(); \n\tspin_lock(&mm->page_table_lock);\n#ifndef __ARCH_HAS_4LEVEL_HACK\n\tif (pud_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpud_populate(mm, pud, new);\n#else\n\tif (pgd_present(*pud))\t\t\n\t\tpmd_free(mm, new);\n\telse\n\t\tpgd_populate(mm, pud, new);\n#endif \n\tspin_unlock(&mm->page_table_lock);\n\treturn 0;\n}", "target": 0}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "static void zynq_slcr_reset_exit(Object *obj)\n{\n    ZynqSLCRState *s = ZYNQ_SLCR(obj);\n    zynq_slcr_compute_clocks(s);\n    zynq_slcr_propagate_clocks(s);\n}", "target": 0}
{"code": "BGD_DECLARE(int) gdImageColorReplaceThreshold (gdImagePtr im, int src, int dst, float threshold)\n{\n\tregister int x, y;\n\tint n = 0;\n\tif (src == dst) {\n\t\treturn 0;\n\t}\n#define REPLACING_LOOP(pixel) do {\t\t\t\t\t\t\t\t\t\t\\\n\t\tfor (y = im->cy1; y <= im->cy2; y++) {\t\t\t\t\t\t\t\\\n\t\t\tfor (x = im->cx1; x <= im->cx2; x++) {\t\t\t\t\t\t\\\n\t\t\t\tif (gdColorMatch(im, src, pixel(im, x, y), threshold)) { \\\n\t\t\t\t\tgdImageSetPixel(im, x, y, dst);\t\t\t\t\t\t\\\n\t\t\t\t\tn++;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\tif (im->trueColor) {\n\t\tREPLACING_LOOP(gdImageTrueColorPixel);\n\t} else {\n\t\tREPLACING_LOOP(gdImagePalettePixel);\n\t}\n#undef REPLACING_LOOP\n\treturn n;\n}", "target": 0}
{"code": "static void blk_mq_delay_work_fn(struct work_struct *work)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\thctx = container_of(work, struct blk_mq_hw_ctx, delay_work.work);\n\tif (test_and_clear_bit(BLK_MQ_S_STOPPED, &hctx->state))\n\t\t__blk_mq_run_hw_queue(hctx);\n}", "target": 0}
{"code": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\tunlock_timer(timr, flags);\n\treturn ret;\n}", "target": 1}
{"code": "coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; \n\t}\n\treturn MIN(buf_len,attribute_len+len);\n}", "target": 0}
{"code": "static int exif_rewrite_tag_format_to_unsigned(int format)\n{\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE: return TAG_FMT_BYTE;\n\t\tcase TAG_FMT_SRATIONAL: return TAG_FMT_URATIONAL;\n\t\tcase TAG_FMT_SSHORT: return TAG_FMT_USHORT;\n\t\tcase TAG_FMT_SLONG: return TAG_FMT_ULONG;\n\t}\n\treturn format;\n}", "target": 0}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "nfsd4_setattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_setattr *setattr = &u->setattr;\n\t__be32 status = nfs_ok;\n\tint err;\n\tif (setattr->sa_iattr.ia_valid & ATTR_SIZE) {\n\t\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate,\n\t\t\t\t&cstate->current_fh, &setattr->sa_stateid,\n\t\t\t\tWR_STATE, NULL, NULL);\n\t\tif (status) {\n\t\t\tdprintk(\"NFSD: nfsd4_setattr: couldn't process stateid!\\n\");\n\t\t\treturn status;\n\t\t}\n\t}\n\terr = fh_want_write(&cstate->current_fh);\n\tif (err)\n\t\treturn nfserrno(err);\n\tstatus = nfs_ok;\n\tstatus = check_attr_support(rqstp, cstate, setattr->sa_bmval,\n\t\t\t\t    nfsd_attrmask);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_acl != NULL)\n\t\tstatus = nfsd4_set_nfs4_acl(rqstp, &cstate->current_fh,\n\t\t\t\t\t    setattr->sa_acl);\n\tif (status)\n\t\tgoto out;\n\tif (setattr->sa_label.len)\n\t\tstatus = nfsd4_set_nfs4_label(rqstp, &cstate->current_fh,\n\t\t\t\t&setattr->sa_label);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd_setattr(rqstp, &cstate->current_fh, &setattr->sa_iattr,\n\t\t\t\t0, (time_t)0);\nout:\n\tfh_drop_write(&cstate->current_fh);\n\treturn status;\n}", "target": 0}
{"code": "static int ssl_get_remaining_space_in_datagram( mbedtls_ssl_context const *ssl )\n{\n    size_t const bytes_written = ssl->out_left;\n    size_t const mtu           = ssl_get_maximum_datagram_size( ssl );\n    if( bytes_written > mtu )\n    {\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n    return( (int) ( mtu - bytes_written ) );\n}", "target": 0}
{"code": "aspath_segment_add (struct aspath *as, int type)\n{\n  struct assegment *seg = as->segments;\n  struct assegment *new = assegment_new (type, 0);\n  if (seg)\n    {\n      while (seg->next)\n\tseg = seg->next;\n      seg->next = new;\n    }\n  else\n    as->segments = new;\n}", "target": 0}
{"code": "void set_task_comm(struct task_struct *tsk, char *buf)\n{\n\ttask_lock(tsk);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n}", "target": 0}
{"code": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   const struct iovec *payload_iov,\n\t\t\t\t   unsigned ioc,\n\t\t\t\t   size_t plen,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tvoid *payload;\n\tlong ret;\n\tbool vm = false;\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\trka = instkey->payload.data;\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (payload_iov) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tvm = true;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\t\tret = copy_from_user_iovec(payload, payload_iov, ioc);\n\t\tif (ret < 0)\n\t\t\tgoto error2;\n\t}\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\tkey_put(dest_keyring);\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\nerror2:\n\tif (!vm)\n\t\tkfree(payload);\n\telse\n\t\tvfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "static int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,\n\t\t\t\t  int optlen)\n{\n\tstruct rds_rx_trace_so trace;\n\tint i;\n\tif (optlen != sizeof(struct rds_rx_trace_so))\n\t\treturn -EFAULT;\n\tif (copy_from_user(&trace, optval, sizeof(trace)))\n\t\treturn -EFAULT;\n\trs->rs_rx_traces = trace.rx_traces;\n\tfor (i = 0; i < rs->rs_rx_traces; i++) {\n\t\tif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\n\t\t\trs->rs_rx_traces = 0;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\trs->rs_rx_trace[i] = trace.rx_trace_pos[i];\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static int decode_sequence(struct xdr_stream *xdr,\n\t\t\t   struct nfs4_sequence_res *res,\n\t\t\t   struct rpc_rqst *rqstp)\n{\n#if defined(CONFIG_NFS_V4_1)\n\tstruct nfs4_sessionid id;\n\tu32 dummy;\n\tint status;\n\t__be32 *p;\n\tif (!res->sr_session)\n\t\treturn 0;\n\tstatus = decode_op_hdr(xdr, OP_SEQUENCE);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &id);\n\tif (unlikely(status))\n\t\tgoto out_err;\n\tstatus = -EREMOTEIO;\n\tif (memcmp(id.data, res->sr_session->sess_id.data,\n\t\t   NFS4_MAX_SESSIONID_LEN)) {\n\t\tdprintk(\"%s Invalid session id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tp = xdr_inline_decode(xdr, 20);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot->seq_nr) {\n\t\tdprintk(\"%s Invalid sequence number\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != res->sr_slot - res->sr_session->fc_slot_table.slots) {\n\t\tdprintk(\"%s Invalid slot id\\n\", __func__);\n\t\tgoto out_err;\n\t}\n\tdummy = be32_to_cpup(p++);\n\tdummy = be32_to_cpup(p++);\n\tres->sr_status_flags = be32_to_cpup(p);\n\tstatus = 0;\nout_err:\n\tres->sr_status = status;\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\tstatus = -EIO;\n\tgoto out_err;\n#else  \n\treturn 0;\n#endif \n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "ppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *p;\n\tstruct sk_buff_head *list = &ppp->mrq;\n\tu32 seq = skb->sequence;\n\tskb_queue_walk(list, p) {\n\t\tif (seq_before(seq, p->sequence))\n\t\t\tbreak;\n\t}\n\t__skb_queue_before(list, p, skb);\n}", "target": 0}
{"code": " */\nxmlNodePtr\nxmlXPathNextPreceding(xmlXPathParserContextPtr ctxt, xmlNodePtr cur)\n{\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if (cur == NULL) {\n        cur = ctxt->context->node;\n        if (cur->type == XML_NAMESPACE_DECL)\n            return(NULL);\n        if (cur->type == XML_ATTRIBUTE_NODE)\n            return(cur->parent);\n    }\n    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))\n\treturn (NULL);\n    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    do {\n        if (cur->prev != NULL) {\n            for (cur = cur->prev; cur->last != NULL; cur = cur->last) ;\n            return (cur);\n        }\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n    } while (xmlXPathIsAncestor(cur, ctxt->context->node));", "target": 0}
{"code": "bool btrfs_check_rw_degradable(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tstruct btrfs_device *failing_dev)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tu64 next_start = 0;\n\tbool ret = true;\n\tread_lock(&map_tree->map_tree.lock);\n\tem = lookup_extent_mapping(&map_tree->map_tree, 0, (u64)-1);\n\tread_unlock(&map_tree->map_tree.lock);\n\tif (!em) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\twhile (em) {\n\t\tstruct map_lookup *map;\n\t\tint missing = 0;\n\t\tint max_tolerated;\n\t\tint i;\n\t\tmap = em->map_lookup;\n\t\tmax_tolerated =\n\t\t\tbtrfs_get_num_tolerated_disk_barrier_failures(\n\t\t\t\t\tmap->type);\n\t\tfor (i = 0; i < map->num_stripes; i++) {\n\t\t\tstruct btrfs_device *dev = map->stripes[i].dev;\n\t\t\tif (!dev || !dev->bdev ||\n\t\t\t    test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) ||\n\t\t\t    dev->last_flush_error)\n\t\t\t\tmissing++;\n\t\t\telse if (failing_dev && failing_dev == dev)\n\t\t\t\tmissing++;\n\t\t}\n\t\tif (missing > max_tolerated) {\n\t\t\tif (!failing_dev)\n\t\t\t\tbtrfs_warn(fs_info,\n\t\"chunk %llu missing %d devices, max tolerance is %d for writable mount\",\n\t\t\t\t   em->start, missing, max_tolerated);\n\t\t\tfree_extent_map(em);\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\tnext_start = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tread_lock(&map_tree->map_tree.lock);\n\t\tem = lookup_extent_mapping(&map_tree->map_tree, next_start,\n\t\t\t\t\t   (u64)(-1) - next_start);\n\t\tread_unlock(&map_tree->map_tree.lock);\n\t}\nout:\n\treturn ret;\n}", "target": 0}
{"code": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }", "target": 1}
{"code": "bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  return true;\n}", "target": 1}
{"code": " void PageClickTracker::handleEvent(const WebDOMEvent& event) {\n   last_node_clicked_.reset();\n  if (!event.isMouseEvent())\n    return;\n   const WebDOMMouseEvent mouse_event = event.toConst<WebDOMMouseEvent>();\n   DCHECK(mouse_event.buttonDown());\n   if (mouse_event.button() != 0)\n    return;  \n  last_node_clicked_ = mouse_event.target();\n  was_focused_ = (GetFocusedNode() == last_node_clicked_);\n}", "target": 0}
{"code": "static NTSTATUS smb_unix_read_symlink(connection_struct *conn,\n\t\t\t\tstruct smb_request *req,\n\t\t\t\tstruct smb_filename *smb_fname,\n\t\t\t\tchar *pdata,\n\t\t\t\tunsigned int data_size_in,\n\t\t\t\tunsigned int *pdata_size_out)\n{\n\tNTSTATUS status;\n\tsize_t len = 0;\n\tint link_len = 0;\n\tstruct smb_filename *parent_fname = NULL;\n\tstruct smb_filename *base_name = NULL;\n\tchar *buffer = talloc_array(talloc_tos(), char, PATH_MAX+1);\n\tif (!buffer) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tDBG_DEBUG(\"SMB_QUERY_FILE_UNIX_LINK for file %s\\n\",\n\t\tsmb_fname_str_dbg(smb_fname));\n\tif(!S_ISLNK(smb_fname->st.st_ex_mode)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn NT_STATUS_DOS(ERRSRV, ERRbadlink);\n\t}\n\tstatus = parent_pathref(talloc_tos(),\n\t\t\t\tconn->cwd_fsp,\n\t\t\t\tsmb_fname,\n\t\t\t\t&parent_fname,\n\t\t\t\t&base_name);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn status;\n\t}\n\tlink_len = SMB_VFS_READLINKAT(conn,\n\t\t\t\tparent_fname->fsp,\n\t\t\t\tbase_name,\n\t\t\t\tbuffer,\n\t\t\t\tPATH_MAX);\n\tTALLOC_FREE(parent_fname);\n\tif (link_len == -1) {\n\t\tTALLOC_FREE(buffer);\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\tbuffer[link_len] = 0;\n\tstatus = srvstr_push(pdata,\n\t\t\treq->flags2,\n\t\t\tpdata,\n\t\t\tbuffer,\n\t\t\tdata_size_in,\n\t\t\tSTR_TERMINATE,\n\t\t\t&len);\n\tTALLOC_FREE(buffer);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\t*pdata_size_out = len;\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(acos)\n{\n\tdouble num;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &num) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(acos(num));\n}", "target": 0}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "void ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\t\t\tServerAddress address(HostAddress(host), port);\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "unsigned ContainerNode::countChildren() const\n{\n    unsigned count = 0;\n    Node* n;\n    for (n = firstChild(); n; n = n->nextSibling())\n        count++;\n    return count;\n}", "target": 0}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) \n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int nl80211_parse_key_new(struct nlattr *key, struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested(tb, NL80211_KEY_MAX, key,\n\t\t\t\t   nl80211_key_policy);\n\tif (err)\n\t\treturn err;\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\tif (tb[NL80211_KEY_TYPE]) {\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\t\tif (k->type < 0 || k->type >= NUM_NL80211_KEYTYPES)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\terr = nla_parse_nested(kdt, NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t       tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t       nl80211_key_default_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "acpi_status acpi_os_delete_cache(acpi_cache_t * cache)\n{\n\tkmem_cache_destroy(cache);\n\treturn (AE_OK);\n}", "target": 0}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "void sev_es_prepare_guest_switch(struct vcpu_svm *svm, unsigned int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tstruct vmcb_save_area *hostsa;\n\tvmsave(__sme_page_pa(sd->save_area));\n\thostsa = (struct vmcb_save_area *)(page_address(sd->save_area) + 0x400);\n\thostsa->xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\thostsa->pkru = read_pkru();\n\thostsa->xss = host_xss;\n}", "target": 0}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "void RenderView::CaptureText(WebFrame* frame, string16* contents) {\n  contents->clear();\n  if (!frame)\n    return;\n#ifdef TIME_TEXT_RETRIEVAL\n  double begin = time_util::GetHighResolutionTimeNow();\n#endif\n  *contents = frame->contentAsText(kMaxIndexChars);\n#ifdef TIME_TEXT_RETRIEVAL\n  double end = time_util::GetHighResolutionTimeNow();\n  char buf[128];\n  sprintf_s(buf, \"%d chars retrieved for indexing in %gms\\n\",\n            contents.size(), (end - begin)*1000);\n  OutputDebugStringA(buf);\n#endif\n  if (contents->size() == kMaxIndexChars) {\n    size_t last_space_index = contents->find_last_of(kWhitespaceUTF16);\n    if (last_space_index == std::wstring::npos)\n      return;  \n    contents->resize(last_space_index);\n  }\n}", "target": 0}
{"code": "HttpStateData::statusIfComplete() const\n{\n    const HttpReply *rep = virginReply();\n    if (httpHeaderHasConnDir(&rep->header, \"close\"))\n        return COMPLETE_NONPERSISTENT_MSG;\n    if (!flags.keepalive)\n        return COMPLETE_NONPERSISTENT_MSG;\n    if (!flags.request_sent) {\n        debugs(11, 2, \"Request not yet fully sent \" << request->method << ' ' << entry->url());\n        return COMPLETE_NONPERSISTENT_MSG;\n    }\n    if (!rep->keep_alive)\n        return COMPLETE_NONPERSISTENT_MSG;\n    return COMPLETE_PERSISTENT_MSG;\n}", "target": 0}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "static inline int unserialize_allowed_class(zend_string *class_name, HashTable *classes)\n{\n\tzend_string *lcname;\n\tint res;\n\tALLOCA_FLAG(use_heap)\n\tif(classes == NULL) {\n\t\treturn 1;\n\t}\n\tif(!zend_hash_num_elements(classes)) {\n\t\treturn 0;\n\t}\n\tSTR_ALLOCA_ALLOC(lcname, class_name->len, use_heap);\n\tzend_str_tolower_copy(lcname->val, class_name->val, class_name->len);\n\tres = zend_hash_exists(classes, lcname);\n\tSTR_ALLOCA_FREE(lcname, use_heap);\n\treturn res;\n}", "target": 0}
{"code": "unix_listener(const char *path, int backlog, int unlink_first)\n{\n\tstruct sockaddr_un sunaddr;\n\tint saved_errno, sock;\n\tmemset(&sunaddr, 0, sizeof(sunaddr));\n\tsunaddr.sun_family = AF_UNIX;\n\tif (strlcpy(sunaddr.sun_path, path,\n\t    sizeof(sunaddr.sun_path)) >= sizeof(sunaddr.sun_path)) {\n\t\terror_f(\"path \\\"%s\\\" too long for Unix domain socket\", path);\n\t\terrno = ENAMETOOLONG;\n\t\treturn -1;\n\t}\n\tsock = socket(PF_UNIX, SOCK_STREAM, 0);\n\tif (sock == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"socket: %.100s\", strerror(errno));\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (unlink_first == 1) {\n\t\tif (unlink(path) != 0 && errno != ENOENT)\n\t\t\terror(\"unlink(%s): %.100s\", path, strerror(errno));\n\t}\n\tif (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot bind to path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\tif (listen(sock, backlog) == -1) {\n\t\tsaved_errno = errno;\n\t\terror_f(\"cannot listen on path %s: %s\", path, strerror(errno));\n\t\tclose(sock);\n\t\tunlink(path);\n\t\terrno = saved_errno;\n\t\treturn -1;\n\t}\n\treturn sock;\n}", "target": 0}
{"code": "onigenc_not_support_get_ctype_code_range(OnigCtype ctype,\n                       OnigCodePoint* sb_out, const OnigCodePoint* ranges[],\n\t\t       OnigEncoding enc)\n{\n  return ONIG_NO_SUPPORT_CONFIG;\n}", "target": 0}
{"code": "parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tstruct buf *work = 0;\n\tint r;\n\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (i >= size) return 0;\n\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n\t\t\t\tif (i + i < size && _isalnum(data[i + 1]))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tif (rndr->ext_flags & MKDEXT_UNDERLINE && c == '_')\n\t\t\t\tr = rndr->cb.underline(ob, work, rndr->opaque);\n\t\t\telse\n\t\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 1 : 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "escape_attach (int argc, char **argv, compose_env_t *env)\n{\n  const char *encoding = default_encoding;\n  const char *content_type = default_content_type;\n  switch (argc)\n    {\n    case 4:\n      encoding = argv[3];\n    case 3:\n      content_type = argv[2];\n    case 2:\n      return attlist_attach_file (&env->attlist,\n\t\t\t\t  -1, argv[1], argv[1], argv[1],\n\t\t\t\t  content_type, encoding);\n    default:\n      return escape_check_args (argc, argv, 2, 4);\n    }\n  return 1;\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "die(uschar *s1, uschar *s2)\n{\nif (s1)\n  {\n  write_syslog(LOG_CRIT, s1);\n  if (debug_file) debug_printf(\"%s\\n\", s1);\n  if (log_stderr && log_stderr != debug_file)\n    fprintf(log_stderr, \"%s\\n\", s1);\n  }\nif (f.receive_call_bombout) receive_bomb_out(NULL, s2);  \nif (smtp_input) smtp_closedown(s2);\nexim_exit(EXIT_FAILURE, NULL);\n}", "target": 0}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}", "target": 1}
{"code": "static int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; \n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tbool writing_zero = false;\n\tbool zero_used = false;\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif (value_reg && register_is_null(value_reg))\n\t\twriting_zero = true;\n\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n\tif (err)\n\t\treturn err;\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (!env->allow_ptr_leaks\n\t\t\t\t&& *stype != NOT_INIT\n\t\t\t\t&& *stype != SCALAR_VALUE) {\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int php_jpg_get16(void *value)\n{\n\treturn (((uchar *)value)[0] << 8) | ((uchar *)value)[1];\n}", "target": 0}
{"code": "  QInt8() {}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 1}
{"code": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup on %s\", lxcpath);\n\treturn 0;\n}", "target": 1}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "    ByteOrder TiffParser::decode(\n              ExifData& exifData,\n              IptcData& iptcData,\n              XmpData&  xmpData,\n        const byte*     pData,\n              uint32_t  size\n    )\n    {\n        return TiffParserWorker::decode(exifData,\n                                        iptcData,\n                                        xmpData,\n                                        pData,\n                                        size,\n                                        Tag::root,\n                                        TiffMapping::findDecoder);\n    } ", "target": 0}
{"code": "static av_always_inline void snow_horizontal_compose_lift_lead_out(int i, IDWTELEM * dst, IDWTELEM * src, IDWTELEM * ref, int width, int w, int lift_high, int mul, int add, int shift){\n    for(; i<w; i++){\n        dst[i] = src[i] - ((mul * (ref[i] + ref[i + 1]) + add) >> shift);\n    }\n    if((width^lift_high)&1){\n        dst[w] = src[w] - ((mul * 2 * ref[w] + add) >> shift);\n    }\n}", "target": 0}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_CONSISTENCY_CHECKS));\n}", "target": 0}
{"code": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; \n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}", "target": 1}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "dissect_header_lens_v2_large(tvbuff_t *tvb, wtap_syscall_header* syscall_header, int offset, proto_tree *tree, int encoding)\n{\n    guint32 param_count;\n    proto_item *ti;\n    proto_tree *len_tree;\n    ti = proto_tree_add_item(tree, hf_se_param_lens, tvb, offset, syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE, ENC_NA);\n    len_tree = proto_item_add_subtree(ti, ett_sysdig_parm_lens);\n    for (param_count = 0; param_count < syscall_header->nparams; param_count++) {\n        proto_tree_add_item(len_tree, hf_se_param_len, tvb, offset + (param_count * SYSDIG_PARAM_SIZE_V2_LARGE), SYSDIG_PARAM_SIZE_V2_LARGE, encoding);\n    }\n    proto_item_set_len(ti, syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE);\n    return syscall_header->nparams * SYSDIG_PARAM_SIZE_V2_LARGE;\n}", "target": 0}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static int mxf_read_tagged_value(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFTaggedValue *tagged_value = arg;\n    switch (tag){\n    case 0x5001:\n        return mxf_read_utf16be_string(pb, size, &tagged_value->name);\n    case 0x5003:\n        return mxf_read_indirect_value(tagged_value, pb, size);\n    }\n    return 0;\n}", "target": 0}
{"code": "MP4::Properties::bitrate() const\n{\n  return d->bitrate;\n}", "target": 0}
{"code": "  libraw_dng_stream(LibRaw_abstract_datastream *p)\n      : dng_stream((dng_abort_sniffer *)NULL, kBigBufferSize, 0),\n        parent_stream(p)\n  {\n    if (parent_stream)\n    {\n      off = parent_stream->tell();\n      parent_stream->seek(0UL, SEEK_SET); \n    }\n  }", "target": 0}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "static int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "static int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\tif (!cpu_has_virtual_nmis() && to_vmx(vcpu)->soft_vnmi_blocked)\n\t\treturn 0;\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}", "target": 0}
{"code": "static int __init nf_tables_module_init(void)\n{\n\tint err;\n\tinfo = kmalloc(sizeof(struct nft_expr_info) * NFT_RULE_MAXEXPRS,\n\t\t       GFP_KERNEL);\n\tif (info == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\terr = nf_tables_core_module_init();\n\tif (err < 0)\n\t\tgoto err2;\n\terr = nfnetlink_subsys_register(&nf_tables_subsys);\n\tif (err < 0)\n\t\tgoto err3;\n\tpr_info(\"nf_tables: (c) 2007-2009 Patrick McHardy <kaber@trash.net>\\n\");\n\treturn register_pernet_subsys(&nf_tables_net_ops);\nerr3:\n\tnf_tables_core_module_exit();\nerr2:\n\tkfree(info);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "lsb_32 (guchar *src)\n{\n\treturn src[0] | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);\n}", "target": 0}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "static void rm_read_metadata(AVFormatContext *s, AVIOContext *pb, int wide)\n{\n    char buf[1024];\n    int i;\n    for (i=0; i<FF_ARRAY_ELEMS(ff_rm_metadata); i++) {\n        int len = wide ? avio_rb16(pb) : avio_r8(pb);\n        get_strl(pb, buf, sizeof(buf), len);\n        av_dict_set(&s->metadata, ff_rm_metadata[i], buf, 0);\n    }\n}", "target": 0}
{"code": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}", "target": 1}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SELECTOR_TI_MASK)\t\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) \n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "  UpstreamWrapper(const StreamInfo::StreamInfo& info) : info_(info) {}", "target": 0}
{"code": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n  bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() ||\n                               delegate_->ShouldPreserveAbortedURLs();\n   if (pending_entry != controller_->GetVisibleEntry() ||\n       !should_preserve_entry) {\n     controller_->DiscardPendingEntry(true);\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}", "target": 1}
{"code": "static inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int bnx2x_set_q_rx_mode(struct bnx2x *bp, u8 cl_id,\n\t\t\t       unsigned long rx_mode_flags,\n\t\t\t       unsigned long rx_accept_flags,\n\t\t\t       unsigned long tx_accept_flags,\n\t\t\t       unsigned long ramrod_flags)\n{\n\tstruct bnx2x_rx_mode_ramrod_params ramrod_param;\n\tint rc;\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\tramrod_param.cid = 0;\n\tramrod_param.cl_id = cl_id;\n\tramrod_param.rx_mode_obj = &bp->rx_mode_obj;\n\tramrod_param.func_id = BP_FUNC(bp);\n\tramrod_param.pstate = &bp->sp_state;\n\tramrod_param.state = BNX2X_FILTER_RX_MODE_PENDING;\n\tramrod_param.rdata = bnx2x_sp(bp, rx_mode_rdata);\n\tramrod_param.rdata_mapping = bnx2x_sp_mapping(bp, rx_mode_rdata);\n\tset_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\n\tramrod_param.ramrod_flags = ramrod_flags;\n\tramrod_param.rx_mode_flags = rx_mode_flags;\n\tramrod_param.rx_accept_flags = rx_accept_flags;\n\tramrod_param.tx_accept_flags = tx_accept_flags;\n\trc = bnx2x_config_rx_mode(bp, &ramrod_param);\n\tif (rc < 0) {\n\t\tBNX2X_ERR(\"Set rx_mode %d failed\\n\", bp->rx_mode);\n\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}", "target": 0}
{"code": "int OmniboxViewWin::GetMaxEditWidth(int entry_width) const {\n  RECT formatting_rect;\n  GetRect(&formatting_rect);\n  RECT edit_bounds;\n  GetClientRect(&edit_bounds);\n  return entry_width - formatting_rect.left -\n      (edit_bounds.right - formatting_rect.right);\n}", "target": 0}
{"code": "static inline void skb_set_transport_header(struct sk_buff *skb,\n\t\t\t\t\t    const int offset)\n{\n\tskb_reset_transport_header(skb);\n\tskb->transport_header += offset;\n}", "target": 0}
{"code": "void *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}", "target": 0}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "directory_fetches_dir_info_early(or_options_t *options)\n{\n  return directory_fetches_from_authorities(options);\n}", "target": 0}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\texp = timespec64_to_ktime(*tsreq);\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}", "target": 1}
{"code": "static int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\tSCTP_DEBUG_PRINTK(\"sctp_bindx_rem (sk: %p, addrs: %p, addrcnt: %d)\\n\",\n\t\t\t  sk, addrs, addrcnt);\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tsa_addr = (union sctp_addr *)addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tif (sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static int is_printable(char p)\n{\n\tif ((p >= 'a' && p <= 'z') || (p >= 'A' && p <= 'Z') ||\n\t    (p >= '0' && p <= '9') || p == ' ' || p == '(' || p == ')' ||\n\t    p == '+' || p == ',' || p == '-' || p == '.' || p == '/' ||\n\t    p == ':' || p == '=' || p == '?')\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "static CURLcode transfer_per_config(struct GlobalConfig *global,\n                                    struct OperationConfig *config,\n                                    CURLSH *share,\n                                    bool *added)\n{\n  CURLcode result = CURLE_OK;\n  bool capath_from_env;\n  *added = FALSE;\n  if(!config->url_list || !config->url_list->url) {\n    helpf(global->errors, \"no URL specified!\\n\");\n    return CURLE_FAILED_INIT;\n  }\n  capath_from_env = false;\n  if(!config->cacert &&\n     !config->capath &&\n     (!config->insecure_ok || (config->doh_url && !config->doh_insecure_ok))) {\n    CURL *curltls = curl_easy_init();\n    struct curl_tlssessioninfo *tls_backend_info = NULL;\n    result = curl_easy_getinfo(curltls, CURLINFO_TLS_SSL_PTR,\n                               &tls_backend_info);\n    if(result)\n      return result;\n    if(tls_backend_info->backend != CURLSSLBACKEND_SCHANNEL) {\n      char *env;\n      env = curlx_getenv(\"CURL_CA_BUNDLE\");\n      if(env) {\n        config->cacert = strdup(env);\n        if(!config->cacert) {\n          curl_free(env);\n          errorf(global, \"out of memory\\n\");\n          return CURLE_OUT_OF_MEMORY;\n        }\n      }\n      else {\n        env = curlx_getenv(\"SSL_CERT_DIR\");\n        if(env) {\n          config->capath = strdup(env);\n          if(!config->capath) {\n            curl_free(env);\n            helpf(global->errors, \"out of memory\\n\");\n            return CURLE_OUT_OF_MEMORY;\n          }\n          capath_from_env = true;\n        }\n        else {\n          env = curlx_getenv(\"SSL_CERT_FILE\");\n          if(env) {\n            config->cacert = strdup(env);\n            if(!config->cacert) {\n              curl_free(env);\n              errorf(global, \"out of memory\\n\");\n              return CURLE_OUT_OF_MEMORY;\n            }\n          }\n        }\n      }\n      if(env)\n        curl_free(env);\n#ifdef WIN32\n      else {\n        result = FindWin32CACert(config, tls_backend_info->backend,\n                                 TEXT(\"curl-ca-bundle.crt\"));\n      }\n#endif\n    }\n    curl_easy_cleanup(curltls);\n  }\n  if(!result)\n    result = single_transfer(global, config, share, capath_from_env, added);\n  return result;\n}", "target": 0}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "zrcheck(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code = access_check(i_ctx_p, a_read, false);\n    if (code >= 0)\n        make_bool(op, code), code = 0;\n    return code;\n}", "target": 0}
{"code": "find_matching_ref (GHashTable  *refs,\n                   const char  *name,\n                   const char  *opt_branch,\n                   const char  *opt_default_branch,\n                   const char  *opt_arch,\n                   FlatpakKinds kinds,\n                   GError     **error)\n{\n  const char **arches = flatpak_get_arches ();\n  const char *opt_arches[] = {opt_arch, NULL};\n  int i;\n  if (opt_arch != NULL)\n    arches = opt_arches;\n  for (i = 0; arches[i] != NULL; i++)\n    {\n      g_autoptr(GPtrArray) matched_refs = NULL;\n      int j;\n      matched_refs = find_matching_refs (refs,\n                                         name,\n                                         opt_branch,\n                                         opt_default_branch,\n                                         arches[i],\n                                         NULL,\n                                         kinds,\n                                         FIND_MATCHING_REFS_FLAGS_NONE,\n                                         error);\n      if (matched_refs == NULL)\n        return NULL;\n      if (matched_refs->len == 0)\n        continue;\n      if (matched_refs->len == 1)\n        return flatpak_decomposed_ref (g_ptr_array_index (matched_refs, 0));\n      g_autoptr(GString) err = g_string_new (\"\");\n      g_string_printf (err, _(\"Multiple branches available for %s, you must specify one of: \"), name);\n      g_ptr_array_sort (matched_refs, flatpak_strcmp0_ptr);\n      for (j = 0; j < matched_refs->len; j++)\n        {\n          FlatpakDecomposed *ref = g_ptr_array_index (matched_refs, j);\n          if (j != 0)\n            g_string_append (err, \", \");\n          const char *branch = flatpak_decomposed_get_branch (ref);\n          g_string_append (err,\n                           g_strdup_printf (\"%s/%s/%s\",\n                                            name,\n                                            opt_arch ? opt_arch : \"\",\n                                            branch));\n        }\n      flatpak_fail (error, \"%s\", err->str);\n      return NULL;\n    }\n  g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND,\n               _(\"Nothing matches %s\"), name);\n  return NULL;\n}", "target": 0}
{"code": "void rdma_set_service_type(struct rdma_cm_id *id, int tos)\n{\n\tstruct rdma_id_private *id_priv;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->qp_mutex);\n\tid_priv->tos = (u8) tos;\n\tid_priv->tos_set = true;\n\tmutex_unlock(&id_priv->qp_mutex);\n}", "target": 0}
{"code": "static int nested_vmx_store_msr(struct kvm_vcpu *vcpu, u64 gpa, u32 count)\n{\n\tu32 i;\n\tstruct vmx_msr_entry e;\n\tfor (i = 0; i < count; i++) {\n\t\tstruct msr_data msr_info;\n\t\tif (kvm_vcpu_read_guest(vcpu,\n\t\t\t\t\tgpa + i * sizeof(e),\n\t\t\t\t\t&e, 2 * sizeof(u32))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR entry (%u, 0x%08llx)\\n\",\n\t\t\t\t__func__, i, gpa + i * sizeof(e));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (nested_vmx_store_msr_check(vcpu, &e)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s check failed (%u, 0x%x, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index, e.reserved);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmsr_info.host_initiated = false;\n\t\tmsr_info.index = e.index;\n\t\tif (kvm_get_msr(vcpu, &msr_info)) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot read MSR (%u, 0x%x)\\n\",\n\t\t\t\t__func__, i, e.index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (kvm_vcpu_write_guest(vcpu,\n\t\t\t\t\t gpa + i * sizeof(e) +\n\t\t\t\t\t     offsetof(struct vmx_msr_entry, value),\n\t\t\t\t\t &msr_info.data, sizeof(msr_info.data))) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"%s cannot write MSR (%u, 0x%x, 0x%llx)\\n\",\n\t\t\t\t__func__, i, e.index, msr_info.data);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void bnx2x_handle_classification_eqe(struct bnx2x *bp,\n\t\t\t\t\t    union event_ring_elem *elem)\n{\n\tunsigned long ramrod_flags = 0;\n\tint rc = 0;\n\tu32 echo = le32_to_cpu(elem->message.data.eth_event.echo);\n\tu32 cid = echo & BNX2X_SWCID_MASK;\n\tstruct bnx2x_vlan_mac_obj *vlan_mac_obj;\n\t__set_bit(RAMROD_CONT, &ramrod_flags);\n\tswitch (echo >> BNX2X_SWCID_SHIFT) {\n\tcase BNX2X_FILTER_MAC_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_MAC completions\\n\");\n\t\tif (CNIC_LOADED(bp) && (cid == BNX2X_ISCSI_ETH_CID(bp)))\n\t\t\tvlan_mac_obj = &bp->iscsi_l2_mac_obj;\n\t\telse\n\t\t\tvlan_mac_obj = &bp->sp_objs[cid].mac_obj;\n\t\tbreak;\n\tcase BNX2X_FILTER_VLAN_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_VLAN completions\\n\");\n\t\tvlan_mac_obj = &bp->sp_objs[cid].vlan_obj;\n\t\tbreak;\n\tcase BNX2X_FILTER_MCAST_PENDING:\n\t\tDP(BNX2X_MSG_SP, \"Got SETUP_MCAST completions\\n\");\n\t\tbnx2x_handle_mcast_eqe(bp);\n\t\treturn;\n\tdefault:\n\t\tBNX2X_ERR(\"Unsupported classification command: 0x%x\\n\", echo);\n\t\treturn;\n\t}\n\trc = vlan_mac_obj->complete(bp, vlan_mac_obj, elem, &ramrod_flags);\n\tif (rc < 0)\n\t\tBNX2X_ERR(\"Failed to schedule new commands: %d\\n\", rc);\n\telse if (rc > 0)\n\t\tDP(BNX2X_MSG_SP, \"Scheduled next pending commands...\\n\");\n}", "target": 0}
{"code": "void _WM_do_meta_keysignature(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "target": 0}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tSDev = cd->device;\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "void PingStats::init() {\n\tboost::array<double, 3> probs = {{0.75, 0.80, 0.95 }};\n\tasQuantile = new asQuantileType(boost::accumulators::tag::extended_p_square::probabilities = probs);\n\tdPing = 0.0;\n\tuiPing = 0;\n\tuiPingSort = 0;\n\tuiUsers = 0;\n\tuiMaxUsers = 0;\n\tuiBandwidth = 0;\n\tuiSent = 0;\n\tuiRecv = 0;\n\tuiVersion = 0;\n}", "target": 0}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}", "target": 1}
{"code": "int vfs_clone_file_range(struct file *file_in, loff_t pos_in,\n\t\tstruct file *file_out, loff_t pos_out, u64 len)\n{\n\tstruct inode *inode_in = file_inode(file_in);\n\tstruct inode *inode_out = file_inode(file_out);\n\tint ret;\n\tif (inode_in->i_sb != inode_out->i_sb ||\n\t    file_in->f_path.mnt != file_out->f_path.mnt)\n\t\treturn -EXDEV;\n\tif (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))\n\t\treturn -EINVAL;\n\tif (!(file_in->f_mode & FMODE_READ) ||\n\t    !(file_out->f_mode & FMODE_WRITE) ||\n\t    (file_out->f_flags & O_APPEND) ||\n\t    !file_in->f_op->clone_file_range)\n\t\treturn -EBADF;\n\tret = clone_verify_area(file_in, pos_in, len, false);\n\tif (ret)\n\t\treturn ret;\n\tret = clone_verify_area(file_out, pos_out, len, true);\n\tif (ret)\n\t\treturn ret;\n\tif (pos_in + len > i_size_read(inode_in))\n\t\treturn -EINVAL;\n\tret = mnt_want_write_file(file_out);\n\tif (ret)\n\t\treturn ret;\n\tret = file_in->f_op->clone_file_range(file_in, pos_in,\n\t\t\tfile_out, pos_out, len);\n\tif (!ret) {\n\t\tfsnotify_access(file_in);\n\t\tfsnotify_modify(file_out);\n\t}\n\tmnt_drop_write_file(file_out);\n\treturn ret;\n}", "target": 0}
{"code": "void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (kvm_x86_ops->has_wbinvd_exit())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\tkvm_x86_ops->vcpu_load(vcpu, cpu);\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tset_bit(KVM_REQ_CLOCK_UPDATE, &vcpu->requests);\n\t}\n\tif (unlikely(vcpu->cpu != cpu) || check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\tnative_read_tsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\t\tif (check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_x86_ops->compute_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_x86_ops->write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_migrate_timers(vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\taccumulate_steal_time(vcpu);\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}", "target": 0}
{"code": "static int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}", "target": 0}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "static int decode_transform_skip_flag(thread_context* tctx, int cIdx)\n{\n  const int context = (cIdx==0) ? 0 : 1;\n  logtrace(LogSlice,\"# transform_skip_flag (context=%d)\\n\",context);\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_TRANSFORM_SKIP_FLAG+context]);\n  logtrace(LogSymbols,\"$1 transform_skip_flag=%d\\n\",bit);\n  return bit;\n}", "target": 0}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "  scoped_refptr<TransportSocketParams> GetTcpParams() {\n    if (GetParam() != HTTP)\n      return scoped_refptr<TransportSocketParams>();\n    return ignored_transport_socket_params_;\n  }", "target": 0}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "static void FNAME(update_model)(CommonState *state, s_bucket * const bucket,\n                                const BYTE curval)\n{\n    SPICE_VERIFY(BPC >= 1);\n    spice_return_if_fail (bucket != NULL);\n    const unsigned int bpp = BPC;\n    COUNTER * const pcounters = bucket->pcounters;\n    unsigned int i;\n    unsigned int bestcode;\n    unsigned int bestcodelen;\n    bestcode = bpp - 1;\n    bestcodelen = (pcounters[bestcode] += FNAME(golomb_code_len)(curval, bestcode));\n    for (i = bpp - 2; i < bpp; i--) { \n        const unsigned int ithcodelen = (pcounters[i] += FNAME(golomb_code_len)(curval, i));\n        if (ithcodelen < bestcodelen) {\n            bestcode = i;\n            bestcodelen = ithcodelen;\n        }\n    }\n    bucket->bestcode = bestcode; \n    if (bestcodelen > state->wm_trigger) { \n        for (i = 0; i < bpp; i++) {\n            pcounters[i] >>= 1;\n        }\n    }\n}", "target": 0}
{"code": "static void __ref adjust_range_page_size_mask(struct map_range *mr,\n\t\t\t\t\t\t\t int nr_range)\n{\n\tint i;\n\tfor (i = 0; i < nr_range; i++) {\n\t\tif ((page_size_mask & (1<<PG_LEVEL_2M)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_2M))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PMD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PMD_SIZE);\n#ifdef CONFIG_X86_32\n\t\t\tif ((end >> PAGE_SHIFT) > max_low_pfn)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_2M;\n\t\t}\n\t\tif ((page_size_mask & (1<<PG_LEVEL_1G)) &&\n\t\t    !(mr[i].page_size_mask & (1<<PG_LEVEL_1G))) {\n\t\t\tunsigned long start = round_down(mr[i].start, PUD_SIZE);\n\t\t\tunsigned long end = round_up(mr[i].end, PUD_SIZE);\n\t\t\tif (memblock_is_region_memory(start, end - start))\n\t\t\t\tmr[i].page_size_mask |= 1<<PG_LEVEL_1G;\n\t\t}\n\t}\n}", "target": 0}
{"code": "ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)\n{\n  struct ospf_header *ospfh;\n  unsigned char digest[OSPF_AUTH_MD5_SIZE];\n  MD5_CTX ctx;\n  void *ibuf;\n  u_int32_t t;\n  struct crypt_key *ck;\n  const u_int8_t *auth_key;\n  ibuf = STREAM_DATA (op->s);\n  ospfh = (struct ospf_header *) ibuf;\n  if (ntohs (ospfh->auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)\n    return 0;\n  t = (time(NULL) & 0xFFFFFFFF);\n  if (t > oi->crypt_seqnum)\n    oi->crypt_seqnum = t;\n  else\n    oi->crypt_seqnum++;\n  ospfh->u.crypt.crypt_seqnum = htonl (oi->crypt_seqnum); \n  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))\n    auth_key = (const u_int8_t *) \"\";\n  else\n    {\n      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));\n      auth_key = ck->auth_key;\n    }\n  memset(&ctx, 0, sizeof(ctx));\n  MD5Init(&ctx);\n  MD5Update(&ctx, ibuf, ntohs (ospfh->length));\n  MD5Update(&ctx, auth_key, OSPF_AUTH_MD5_SIZE);\n  MD5Final(digest, &ctx);\n  stream_put (op->s, digest, OSPF_AUTH_MD5_SIZE);\n  op->length = ntohs (ospfh->length) + OSPF_AUTH_MD5_SIZE;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn(\"ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u\",\n\t      (u_long)stream_get_endp(op->s), op->length);\n  return OSPF_AUTH_MD5_SIZE;\n}", "target": 0}
{"code": "static int tls1_check_sig_alg(SSL *s, X509 *x, int default_nid)\n{\n    int sig_nid, use_pc_sigalgs = 0;\n    size_t i;\n    const SIGALG_LOOKUP *sigalg;\n    size_t sigalgslen;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    if (SSL_IS_TLS13(s) && s->s3.tmp.peer_cert_sigalgs != NULL) {\n        sigalgslen = s->s3.tmp.peer_cert_sigalgslen;\n        use_pc_sigalgs = 1;\n    } else {\n        sigalgslen = s->shared_sigalgslen;\n    }\n    for (i = 0; i < sigalgslen; i++) {\n        sigalg = use_pc_sigalgs\n                 ? tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i])\n                 : s->shared_sigalgs[i];\n        if (sig_nid == sigalg->sigandhash)\n            return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "static int buffer_chain_size(void)\n{\n\tstruct bio_vec bv;\n\tint size;\n\tstruct req_iterator iter;\n\tchar *base;\n\tbase = bio_data(current_req->bio);\n\tsize = 0;\n\trq_for_each_segment(bv, current_req, iter) {\n\t\tif (page_address(bv.bv_page) + bv.bv_offset != base + size)\n\t\t\tbreak;\n\t\tsize += bv.bv_len;\n\t}\n\treturn size >> 9;\n}", "target": 0}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "  PutOperationParams() {}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeSourceMapUrl() {\n  BYN_TRACE(\"== writeSourceMapUrl\\n\");\n  auto start = startSection(BinaryConsts::Section::User);\n  writeInlineString(BinaryConsts::UserSections::SourceMapUrl);\n  writeInlineString(sourceMapUrl.c_str());\n  finishSection(start);\n}", "target": 0}
{"code": "LogFilePrep(const char *fname, const char *backup, const char *idstring)\n{\n    char *logFileName = NULL;\n    if (asprintf(&logFileName, fname, idstring) == -1)\n        FatalError(\"Cannot allocate space for the log file name\\n\");\n    if (backup && *backup) {\n        struct stat buf;\n        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {\n            char *suffix;\n            char *oldLog;\n            if ((asprintf(&suffix, backup, idstring) == -1) ||\n                (asprintf(&oldLog, \"%s%s\", logFileName, suffix) == -1)) {\n                FatalError(\"Cannot allocate space for the log file name\\n\");\n            }\n            free(suffix);\n            if (rename(logFileName, oldLog) == -1) {\n                FatalError(\"Cannot move old log file \\\"%s\\\" to \\\"%s\\\"\\n\",\n                           logFileName, oldLog);\n            }\n            free(oldLog);\n        }\n    }\n    else {\n        if (remove(logFileName) != 0 && errno != ENOENT) {\n            FatalError(\"Cannot remove old log file \\\"%s\\\": %s\\n\",\n                       logFileName, strerror(errno));\n        }\n    }\n    return logFileName;\n}", "target": 1}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "  String_Obj Parser::parse_url_function_string()\n  {\n    std::string prefix(\"\");\n    if (lex< uri_prefix >()) {\n      prefix = std::string(lexed);\n    }\n    lex < optional_spaces >();\n    String_Obj url_string = parse_url_function_argument();\n    std::string suffix(\"\");\n    if (lex< real_uri_suffix >()) {\n      suffix = std::string(lexed);\n    }\n    std::string uri(\"\");\n    if (url_string) {\n      uri = url_string->to_string({ NESTED, 5 });\n    }\n    if (String_Schema* schema = Cast<String_Schema>(url_string)) {\n      String_Schema_Obj res = SASS_MEMORY_NEW(String_Schema, pstate);\n      res->append(SASS_MEMORY_NEW(String_Constant, pstate, prefix));\n      res->append(schema);\n      res->append(SASS_MEMORY_NEW(String_Constant, pstate, suffix));\n      return res;\n    } else {\n      std::string res = prefix + uri + suffix;\n      return SASS_MEMORY_NEW(String_Constant, pstate, res);\n    }\n  }", "target": 0}
{"code": "static void containerKeysIntersectHelper(const req::ptr<c_Set>& st,\n                                         TypedValue* containers,\n                                         int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  bool isKey = isArrayType(containers[0].m_type);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, !isKey);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    isKey = isArrayType(containers[pos].m_type);\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      updateIntersectMapHelper(mp, c, pos, strTv, !isKey);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static gboolean udscs_server_accept_cb(GSocketService    *service,\n                                       GSocketConnection *socket_conn,\n                                       GObject           *source_object,\n                                       gpointer           user_data)\n{\n    struct udscs_server *server = user_data;\n    UdscsConnection *new_conn;\n    new_conn = g_object_new(UDSCS_TYPE_CONNECTION, NULL);\n    new_conn->debug = server->debug;\n    new_conn->read_callback = server->read_callback;\n    g_object_ref(socket_conn);\n    vdagent_connection_setup(VDAGENT_CONNECTION(new_conn),\n                             G_IO_STREAM(socket_conn),\n                             FALSE,\n                             sizeof(struct udscs_message_header),\n                             server->error_cb);\n    server->connections = g_list_prepend(server->connections, new_conn);\n    if (server->debug)\n        syslog(LOG_DEBUG, \"new client accepted: %p\", new_conn);\n    if (server->connect_callback)\n        server->connect_callback(new_conn);\n    return TRUE;\n}", "target": 1}
{"code": "uint8_t* sldns_str2wire_dname(const char* str, size_t* len)\n{\n\tuint8_t dname[LDNS_MAX_DOMAINLEN+1];\n\t*len = sizeof(dname);\n\tif(sldns_str2wire_dname_buf(str, dname, len) == 0) {\n\t\tuint8_t* r;\n\t\tif(*len > sizeof(dname)) return NULL;\n\t\tr = (uint8_t*)malloc(*len);\n\t\tif(r) return memcpy(r, dname, *len);\n\t}\n\t*len = 0;\n\treturn NULL;\n}", "target": 0}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tstruct minidump_directory entry;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tut64 rvadir = obj->hdr->stream_directory_rva;\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tut32 delta = i * sizeof (struct minidump_directory);\n\t\tint r = r_buf_read_at (obj->b, rvadir + delta, (ut8*) &entry, sizeof (struct minidump_directory));\n\t\tif (r) {\n\t\t\tr_bin_mdmp_init_directory_entry (obj, &entry);\n\t\t}\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "    int FixIso::run(const std::string& path)\n    {\n        try {\n            if (!Exiv2::fileExists(path, true)) {\n                std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n                return -1;\n            }\n            Timestamp ts;\n            if (Params::instance().preserve_)\n                ts.read(path);\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            Exiv2::ExifData& exifData = image->exifData();\n            if (exifData.empty()) {\n                std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n                return -3;\n            }\n            auto md = Exiv2::isoSpeed(exifData);\n            if (md != exifData.end()) {\n                if (strcmp(md->key().c_str(), \"Exif.Photo.ISOSpeedRatings\") == 0) {\n                    if (Params::instance().verbose_) {\n                        std::cout << _(\"Standard Exif ISO tag exists; not modified\\n\");\n                    }\n                    return 0;\n                }\n                std::ostringstream os;\n                md->write(os, &exifData);\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"Setting Exif ISO value to\") << \" \" << os.str() << \"\\n\";\n                }\n                exifData[\"Exif.Photo.ISOSpeedRatings\"] = os.str();\n            }\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n            return 0;\n        } catch (const Exiv2::AnyError& e) {\n            std::cerr << \"Exiv2 exception in fixiso action for file \" << path << \":\\n\" << e << \"\\n\";\n            return 1;\n        }\n    }", "target": 0}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_last_notice) \n{\n\tzval *pgsql_link = NULL;\n\tPGconn *pg_link;\n\tint id = -1;\n\tphp_pgsql_notice *notice;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &pgsql_link) == FAILURE) {\n\t\treturn;\n\t}\n\tif (pgsql_link == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif ((notice = zend_hash_index_find_ptr(&PGG(notices), (zend_ulong)Z_RES_HANDLE_P(pgsql_link))) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(notice->message, notice->len);\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "void FIFOSampleBuffer::setChannels(int numChannels)\n{\n    uint usedBytes;\n    assert(numChannels > 0);\n    usedBytes = channels * samplesInBuffer;\n    channels = (uint)numChannels;\n    samplesInBuffer = usedBytes / channels;\n}", "target": 1}
{"code": "static int proc_pid_limits(struct task_struct *task, char *buffer)\n{\n\tunsigned int i;\n\tint count = 0;\n\tunsigned long flags;\n\tchar *bufptr = buffer;\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\trcu_read_lock();\n\tif (!lock_task_sighand(task,&flags)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\trcu_read_unlock();\n\tcount += sprintf(&bufptr[count], \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tcount += sprintf(&bufptr[count], \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"%-20lu \",\n\t\t\t\t\t rlim[i].rlim_max);\n\t\tif (lnames[i].unit)\n\t\t\tcount += sprintf(&bufptr[count], \"%-10s\\n\",\n\t\t\t\t\t lnames[i].unit);\n\t\telse\n\t\t\tcount += sprintf(&bufptr[count], \"\\n\");\n\t}\n\treturn count;\n}", "target": 0}
{"code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}", "target": 1}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n        return TRUE;\n}", "target": 1}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "static void ahci_irq_lower(AHCIState *s, AHCIDevice *dev)\n{\n    DeviceState *dev_state = s->container;\n    PCIDevice *pci_dev = (PCIDevice *) object_dynamic_cast(OBJECT(dev_state),\n                                                           TYPE_PCI_DEVICE);\n    DPRINTF(0, \"lower irq\\n\");\n    if (!pci_dev || !msi_enabled(pci_dev)) {\n        qemu_irq_lower(s->irq);\n    }\n}", "target": 0}
{"code": "void RGWDeleteLC_ObjStore_S3::send_response()\n{\n  if (op_ret == 0)\n      op_ret = STATUS_NO_CONTENT;\n  if (op_ret) {   \n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n}", "target": 0}
{"code": "mrb_decode_insn(const mrb_code *pc)\n{\n  struct mrb_insn_data data = { 0 };\n  if (pc == 0) return data;\n  data.addr = pc;\n  mrb_code insn = READ_B();\n  uint16_t a = 0;\n  uint16_t b = 0;\n  uint16_t c = 0;\n  switch (insn) {\n#define FETCH_Z() \n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n  }\n  switch (insn) {\n  case OP_EXT1:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _1 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT2:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _2 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  case OP_EXT3:\n    insn = READ_B();\n    switch (insn) {\n#define OPCODE(i,x) case OP_ ## i: FETCH_ ## x ## _3 (); break;\n#include \"mruby/ops.h\"\n#undef OPCODE\n    }\n    break;\n  default:\n    break;\n  }\n  data.insn = insn;\n  data.a = a;\n  data.b = b;\n  data.c = c;\n  return data;\n}", "target": 0}
{"code": "static void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_CLAIMS);\n\tif (s_claims != NULL)\n\t\toidc_util_decode_json_object(r, s_claims, claims);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_REQUEST_STATE_KEY_IDTOKEN);\n\tif (s_id_token != NULL)\n\t\toidc_util_decode_json_object(r, s_id_token, id_token);\n}", "target": 0}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "ebt_basic_match(const struct ebt_entry *e, const struct sk_buff *skb,\n                const struct net_device *in, const struct net_device *out)\n{\n\tconst struct ethhdr *h = eth_hdr(skb);\n\tconst struct net_bridge_port *p;\n\t__be16 ethproto;\n\tint verdict, i;\n\tif (vlan_tx_tag_present(skb))\n\t\tethproto = htons(ETH_P_8021Q);\n\telse\n\t\tethproto = h->h_proto;\n\tif (e->bitmask & EBT_802_3) {\n\t\tif (FWINV2(ntohs(ethproto) >= 1536, EBT_IPROTO))\n\t\t\treturn 1;\n\t} else if (!(e->bitmask & EBT_NOPROTO) &&\n\t   FWINV2(e->ethproto != ethproto, EBT_IPROTO))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->in, in), EBT_IIN))\n\t\treturn 1;\n\tif (FWINV2(ebt_dev_check(e->out, out), EBT_IOUT))\n\t\treturn 1;\n\tif (in && (p = br_port_get_rcu(in)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_in, p->br->dev), EBT_ILOGICALIN))\n\t\treturn 1;\n\tif (out && (p = br_port_get_rcu(out)) != NULL &&\n\t    FWINV2(ebt_dev_check(e->logical_out, p->br->dev), EBT_ILOGICALOUT))\n\t\treturn 1;\n\tif (e->bitmask & EBT_SOURCEMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_source[i] ^ e->sourcemac[i]) &\n\t\t\t   e->sourcemsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_ISOURCE) )\n\t\t\treturn 1;\n\t}\n\tif (e->bitmask & EBT_DESTMAC) {\n\t\tverdict = 0;\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tverdict |= (h->h_dest[i] ^ e->destmac[i]) &\n\t\t\t   e->destmsk[i];\n\t\tif (FWINV2(verdict != 0, EBT_IDEST) )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}", "target": 1}
{"code": "int nft_validate_output_register(enum nft_registers reg)\n{\n\tif (reg < NFT_REG_VERDICT)\n\t\treturn -EINVAL;\n\tif (reg > NFT_REG_MAX)\n\t\treturn -ERANGE;\n\treturn 0;\n}", "target": 0}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\troot_tmp = gf_strdup(szPath);\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\tstrcat(szPath, \"gpac_cache\");\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}", "target": 0}
{"code": "static int wcd9335_slim_status(struct slim_device *sdev,\n\t\t\t       enum slim_device_status status)\n{\n\tstruct device *dev = &sdev->dev;\n\tstruct device_node *ifc_dev_np;\n\tstruct wcd9335_codec *wcd;\n\tint ret;\n\twcd = dev_get_drvdata(dev);\n\tifc_dev_np = of_parse_phandle(dev->of_node, \"slim-ifc-dev\", 0);\n\tif (!ifc_dev_np) {\n\t\tdev_err(dev, \"No Interface device found\\n\");\n\t\treturn -EINVAL;\n\t}\n\twcd->slim = sdev;\n\twcd->slim_ifc_dev = of_slim_get_device(sdev->ctrl, ifc_dev_np);\n\tof_node_put(ifc_dev_np);\n\tif (!wcd->slim_ifc_dev) {\n\t\tdev_err(dev, \"Unable to get SLIM Interface device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tslim_get_logical_addr(wcd->slim_ifc_dev);\n\twcd->regmap = regmap_init_slimbus(sdev, &wcd9335_regmap_config);\n\tif (IS_ERR(wcd->regmap)) {\n\t\tdev_err(dev, \"Failed to allocate slim register map\\n\");\n\t\treturn PTR_ERR(wcd->regmap);\n\t}\n\twcd->if_regmap = regmap_init_slimbus(wcd->slim_ifc_dev,\n\t\t\t\t\t\t  &wcd9335_ifc_regmap_config);\n\tif (IS_ERR(wcd->if_regmap)) {\n\t\tdev_err(dev, \"Failed to allocate ifc register map\\n\");\n\t\treturn PTR_ERR(wcd->if_regmap);\n\t}\n\tret = wcd9335_bring_up(wcd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to bringup WCD9335\\n\");\n\t\treturn ret;\n\t}\n\tret = wcd9335_irq_init(wcd);\n\tif (ret)\n\t\treturn ret;\n\twcd9335_probe(wcd);\n\treturn ret;\n}", "target": 0}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "parse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}", "target": 1}
{"code": "get_auth_param(struct auth_param *auth, char *name)\n{\n    struct auth_param *ap;\n    for (ap = auth; ap->name != NULL; ap++) {\n\tif (strcasecmp(name, ap->name) == 0)\n\t    return ap->val;\n    }\n    return NULL;\n}", "target": 0}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "void IndexedDBDatabase::RenameIndex(IndexedDBTransaction* transaction,\n                                    int64_t object_store_id,\n                                    int64_t index_id,\n                                    const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameIndex\", \"txn.id\", transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreIdAndIndexId(object_store_id, index_id))\n    return;\n  IndexedDBIndexMetadata& index_metadata =\n      metadata_.object_stores[object_store_id].indexes[index_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, new_name, &old_name,\n      &index_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming index.\");\n    return;\n  }\n  DCHECK_EQ(index_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameIndexAbortOperation, this,\n                     object_store_id, index_id, std::move(old_name)));\n}", "target": 0}
{"code": "send_userauth_info_request(Authctxt *authctxt)\n{\n\tKbdintAuthctxt *kbdintctxt;\n\tchar *name, *instr, **prompts;\n\tint i;\n\tu_int *echo_on;\n\tkbdintctxt = authctxt->kbdintctxt;\n\tif (kbdintctxt->device->query(kbdintctxt->ctxt,\n\t    &name, &instr, &kbdintctxt->nreq, &prompts, &echo_on))\n\t\treturn 0;\n\tpacket_start(SSH2_MSG_USERAUTH_INFO_REQUEST);\n\tpacket_put_cstring(name);\n\tpacket_put_cstring(instr);\n\tpacket_put_cstring(\"\");\t\t\n\tpacket_put_int(kbdintctxt->nreq);\n\tfor (i = 0; i < kbdintctxt->nreq; i++) {\n\t\tpacket_put_cstring(prompts[i]);\n\t\tpacket_put_char(echo_on[i]);\n\t}\n\tpacket_send();\n\tpacket_write_wait();\n\tfor (i = 0; i < kbdintctxt->nreq; i++)\n\t\txfree(prompts[i]);\n\txfree(prompts);\n\txfree(echo_on);\n\txfree(name);\n\txfree(instr);\n\treturn 1;\n}", "target": 0}
{"code": "static inline int bitDiff(int value1, int value2)\n{\n  int decBits = 0;\n  if (value2 < value1)\n    while (decBits <= 14 && (value2 << ++decBits) < value1)\n      ;\n  return decBits;\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n    if (session == NULL) {\n        goto error;\n    }\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n    return scp;\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}", "target": 1}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "std::unique_ptr<cql_server::response> cql_server::connection::make_ready(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    return std::make_unique<cql_server::response>(stream, cql_binary_opcode::READY, tr_state);\n}", "target": 0}
{"code": "static const char *req_handler_field(request_rec *r)\n{\n    return r->handler;\n}", "target": 0}
{"code": "read_nextline(void)\n{\nint len;\nuschar *p, *q;\nif (next_line != NULL)\n  {\n  uschar *yield = next_line;\n  next_line = NULL;\n  return yield;\n  }\nif (popto == 0)\n  {\n  pushstr *ps = pushed;\n  if (ps == NULL) error(12); else\n    {\n    popto = -1;\n    (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n    pushed = ps->next;\n    free(ps);\n    return inbuffer;\n    }\n  }\nif (popto > 0)\n  {\n  pushstr *ps = pushed;\n  if (ps->letter == popto) popto = -1;  \n  (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n  pushed = ps->next;\n  free(ps);\n  return inbuffer;\n  }\nif (from_type_ptr < 0) return NULL;\nfor (;;)\n  {\n  if (from_type[from_type_ptr] == FROM_MACRO)\n    {\n    if (macrocurrent->nextline == NULL)\n      {\n      macroexe *temp = macrocurrent;\n      macrocurrent = macrocurrent->prev;\n      macro_free(temp);\n      }\n    else\n      {\n      read_process_macroline(macrocurrent->nextline->string, inbuffer);\n      macrocurrent->nextline = macrocurrent->nextline->next;\n      break;\n      }\n    }\n  else\n    {\n    len = get_nextline(istack->file, inbuffer, INBUFFSIZE);\n    if (len < 0)\n      {\n      istackstr *prev = istack->prev;\n      fclose(istack->file);\n      free(istack);\n      istack = prev;\n      }\n    else\n      {\n      istack->linenumber++;\n      q = inbuffer;\n      for (;;)\n        {\n        p = q + len;\n        while (p > q && isspace(p[-1])) p--;\n        if (p - q < 3 || Ustrncmp(p - 3, \"&&&\", 3) != 0) break;\n        q = p - 3;\n        *q = 0;\n        if (istack == NULL) break;\n        len = get_nextline(istack->file, q, INBUFFSIZE - (q - inbuffer));\n        if (len < 0) break;\n        istack->linenumber++;\n        p = q;\n        while (*p == ' ' || *p == '\\t') { p++; len--; }\n        if (p > q) memmove(q, p, len + 1);\n        }\n      break;\n      }\n    }\n  if (--from_type_ptr < 0) return NULL;\n  }\nreturn inbuffer;\n}", "target": 1}
{"code": "time_to_df(int h, int min, int s)\n{\n    return h * HOUR_IN_SECONDS + min * MINUTE_IN_SECONDS + s;\n}", "target": 0}
{"code": "flatpak_run_extend_ld_path (FlatpakBwrap *bwrap,\n                            const char *prepend,\n                            const char *append)\n{\n  g_autoptr(GString) ld_library_path = g_string_new (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"));\n  if (prepend != NULL && *prepend != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_prepend (ld_library_path, \":\");\n      g_string_prepend (ld_library_path, prepend);\n    }\n  if (append != NULL && *append != '\\0')\n    {\n      if (ld_library_path->len > 0)\n        g_string_append (ld_library_path, \":\");\n      g_string_append (ld_library_path, append);\n    }\n  flatpak_bwrap_set_env (bwrap, \"LD_LIBRARY_PATH\", ld_library_path->str, TRUE);\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 1}
{"code": "void LibRaw::convert_to_rgb_loop(float out_cam[3][4]) {}", "target": 0}
{"code": "static int _gnutls_verify_crl2(gnutls_x509_crl_t crl,\n\t\t\t       const gnutls_x509_crt_t * trusted_cas,\n\t\t\t       int tcas_size, unsigned int flags,\n\t\t\t       unsigned int *output)\n{\n    gnutls_datum_t crl_signed_data = { NULL, 0 };\n    gnutls_datum_t crl_signature = { NULL, 0 };\n    gnutls_x509_crt_t issuer;\n    int ret, result;\n    if (output)\n\t*output = 0;\n    if (tcas_size >= 1)\n\tissuer = find_crl_issuer(crl, trusted_cas, tcas_size);\n    else {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (issuer == NULL) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_SIGNER_NOT_FOUND | GNUTLS_CERT_INVALID;\n\treturn 0;\n    }\n    if (!(flags & GNUTLS_VERIFY_DISABLE_CA_SIGN)) {\n\tif (gnutls_x509_crt_get_ca_status(issuer, NULL) != 1) {\n\t    gnutls_assert();\n\t    if (output)\n\t\t*output |= GNUTLS_CERT_SIGNER_NOT_CA | GNUTLS_CERT_INVALID;\n\t    return 0;\n\t}\n    }\n    result =\n\t_gnutls_x509_get_signed_data(crl->crl, \"tbsCertList\",\n\t\t\t\t     &crl_signed_data);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    result =\n\t_gnutls_x509_get_signature(crl->crl, \"signature\", &crl_signature);\n    if (result < 0) {\n\tgnutls_assert();\n\tgoto cleanup;\n    }\n    ret =\n\t_gnutls_x509_verify_signature(&crl_signed_data, &crl_signature,\n\t\t\t\t      issuer);\n    if (ret < 0) {\n\tgnutls_assert();\n    } else if (ret == 0) {\n\tgnutls_assert();\n\tif (output)\n\t    *output |= GNUTLS_CERT_INVALID;\n\tret = 0;\n    }\n    result = ret;\n  cleanup:\n    _gnutls_free_datum(&crl_signed_data);\n    _gnutls_free_datum(&crl_signature);\n    return result;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "int sc_compare_oid(const struct sc_object_id *oid1, const struct sc_object_id *oid2)\n{\n\tint i;\n\tif (oid1 == NULL || oid2 == NULL) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tfor (i = 0; i < SC_MAX_OBJECT_ID_OCTETS; i++)   {\n\t\tif (oid1->value[i] != oid2->value[i])\n\t\t\treturn 0;\n\t\tif (oid1->value[i] == -1)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "Value ExpressionRegex::nextMatch(RegexExecutionState* regexState) const {\n    int execResult = execute(regexState);\n    if (execResult < 0) {\n        return Value(BSONNULL);\n    }\n    StringData input = *(regexState->input);\n    auto verifyBounds = [&input, this](auto startPos, auto limitPos, auto isCapture) {\n        if (startPos == -1 || limitPos == -1) {\n            massert(31304,\n                    str::stream() << \"Unexpected error occurred while executing \" << _opName\n                                  << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                    isCapture && startPos == -1 && limitPos == -1);\n            return;\n        }\n        massert(31305,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos,\n                (startPos >= 0 && static_cast<size_t>(startPos) <= input.size()));\n        massert(31306,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". limitPos: \" << limitPos,\n                (limitPos >= 0 && static_cast<size_t>(limitPos) <= input.size()));\n        massert(31307,\n                str::stream() << \"Unexpected error occurred while executing \" << _opName\n                              << \". startPos: \" << startPos << \", limitPos: \" << limitPos,\n                startPos <= limitPos);\n    };\n    verifyBounds(regexState->capturesBuffer[0], regexState->capturesBuffer[1], false);\n    const int matchStartByteIndex = regexState->capturesBuffer[0];\n    StringData matchedStr =\n        input.substr(matchStartByteIndex, regexState->capturesBuffer[1] - matchStartByteIndex);\n    for (int byteIx = regexState->startBytePos; byteIx < matchStartByteIndex;\n         ++(regexState->startCodePointPos)) {\n        byteIx += getCodePointLength(input[byteIx]);\n    }\n    regexState->startBytePos = matchStartByteIndex;\n    std::vector<Value> captures;\n    captures.reserve(regexState->numCaptures);\n    for (int i = 0; i < regexState->numCaptures; ++i) {\n        const int start = regexState->capturesBuffer[2 * (i + 1)];\n        const int limit = regexState->capturesBuffer[2 * (i + 1) + 1];\n        verifyBounds(start, limit, true);\n        captures.push_back(start == -1 && limit == -1 ? Value(BSONNULL)\n                                                      : Value(input.substr(start, limit - start)));\n    }\n    MutableDocument match;\n    match.addField(\"match\", Value(matchedStr));\n    match.addField(\"idx\", Value(regexState->startCodePointPos));\n    match.addField(\"captures\", Value(captures));\n    return match.freezeToValue();\n}", "target": 0}
{"code": "unsigned FAST_FUNC udhcp_option_idx(const char *name)\n{\n\tint n = index_in_strings(dhcp_option_strings, name);\n\tif (n >= 0)\n\t\treturn n;\n\t{\n\t\tchar buf[sizeof(dhcp_option_strings)];\n\t\tchar *d = buf;\n\t\tconst char *s = dhcp_option_strings;\n\t\twhile (s < dhcp_option_strings + sizeof(dhcp_option_strings) - 2) {\n\t\t\t*d++ = (*s == '\\0' ? ' ' : *s);\n\t\t\ts++;\n\t\t}\n\t\t*d = '\\0';\n\t\tbb_error_msg_and_die(\"unknown option '%s', known options: %s\", name, buf);\n\t}\n}", "target": 0}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "static void blk_mq_queue_reinit(struct request_queue *q)\n{\n\tWARN_ON_ONCE(!atomic_read(&q->mq_freeze_depth));\n\tblk_mq_sysfs_unregister(q);\n\tblk_mq_update_queue_map(q->mq_map, q->nr_hw_queues);\n\tblk_mq_map_swqueue(q);\n\tblk_mq_sysfs_register(q);\n}", "target": 0}
{"code": "int udp_lib_setsockopt(struct sock *sk, int level, int optname,\n\t\t       char __user *optval, unsigned int optlen,\n\t\t       int (*push_pending_frames)(struct sock *))\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint val, valbool;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tvalbool = val ? 1 : 0;\n\tswitch (optname) {\n\tcase UDP_CORK:\n\t\tif (val != 0) {\n\t\t\tup->corkflag = 1;\n\t\t} else {\n\t\t\tup->corkflag = 0;\n\t\t\tlock_sock(sk);\n\t\t\tpush_pending_frames(sk);\n\t\t\trelease_sock(sk);\n\t\t}\n\t\tbreak;\n\tcase UDP_ENCAP:\n\t\tswitch (val) {\n\t\tcase 0:\n\t\tcase UDP_ENCAP_ESPINUDP:\n\t\tcase UDP_ENCAP_ESPINUDP_NON_IKE:\n\t\t\tup->encap_rcv = xfrm4_udp_encap_rcv;\n\t\tcase UDP_ENCAP_L2TPINUDP:\n\t\t\tup->encap_type = val;\n\t\t\tudp_encap_enable();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENOPROTOOPT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase UDP_NO_CHECK6_TX:\n\t\tup->no_check6_tx = valbool;\n\t\tbreak;\n\tcase UDP_NO_CHECK6_RX:\n\t\tup->no_check6_rx = valbool;\n\t\tbreak;\n\tcase UDPLITE_SEND_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcslen = val;\n\t\tup->pcflag |= UDPLITE_SEND_CC;\n\t\tbreak;\n\tcase UDPLITE_RECV_CSCOV:\n\t\tif (!is_udplite)         \n\t\t\treturn -ENOPROTOOPT;\n\t\tif (val != 0 && val < 8) \n\t\t\tval = 8;\n\t\telse if (val > USHRT_MAX)\n\t\t\tval = USHRT_MAX;\n\t\tup->pcrlen = val;\n\t\tup->pcflag |= UDPLITE_RECV_CC;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n{\n\tconst char *s;\n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}", "target": 1}
{"code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "NOEXPORT void tray_update(const int num) {\n    NOTIFYICONDATA nid;\n    static ICON_TYPE previous_icon=ICON_NONE;\n    ICON_TYPE current_icon;\n    LPTSTR tip;\n    if(!global_options.option.taskbar) { \n        tray_delete(); \n        return;\n    }\n    if(!tray_menu_handle) \n        tray_menu_handle=LoadMenu(ghInst, MAKEINTRESOURCE(IDM_TRAYMENU));\n    if(!tray_menu_handle) {\n        ioerror(\"LoadMenu\");\n        return;\n    }\n    if(cmdline.service)\n        EnableMenuItem(tray_menu_handle, IDM_EDIT_CONFIG, MF_GRAYED);\n    ZeroMemory(&nid, sizeof nid);\n    nid.cbSize=sizeof nid;\n    nid.uID=1; \n    nid.uFlags=NIF_MESSAGE|NIF_TIP;\n    nid.uCallbackMessage=WM_SYSTRAY; \n    nid.hWnd=hwnd; \n    if(num<0) {\n        tip=str_tprintf(TEXT(\"Server is down\"));\n        current_icon=ICON_ERROR;\n    } else if(num>0) {\n        tip=str_tprintf(TEXT(\"%d active session(s)\"), num);\n        current_icon=ICON_ACTIVE;\n    } else {\n        tip=str_tprintf(TEXT(\"Server is idle\"));\n        current_icon=ICON_IDLE;\n    }\n    _tcsncpy(nid.szTip, tip, 63);\n    nid.szTip[63]=TEXT('\\0');\n    str_free(tip);\n    nid.hIcon=global_options.icon[current_icon];\n    if(current_icon!=previous_icon) {\n        nid.uFlags|=NIF_ICON;\n        previous_icon=current_icon;\n    }\n    if(Shell_NotifyIcon(NIM_MODIFY, &nid)) \n        return; \n    nid.uFlags|=NIF_ICON;\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "build_cert_bag (unsigned char *buffer, size_t buflen, char *salt,\n                size_t *r_length)\n{\n  size_t len[9], needed;\n  unsigned char *p, *certbag;\n  size_t certbaglen;\n  needed = compute_tag_length (buflen);\n  needed += buflen;\n  needed += DIM (data_rc2iter2048);\n  needed += 2 + DIM (oid_data);\n  len[5] = needed;\n  needed += compute_tag_length ( needed);\n  needed += 3;\n  len[3] = needed;\n  needed += compute_tag_length (needed);\n  len[2] = needed;\n  needed += compute_tag_length (needed);\n  needed += 2 + DIM (oid_encryptedData);\n  len[0] = needed;\n  needed += compute_tag_length (needed);\n  p = certbag = gcry_malloc (needed);\n  if (!certbag)\n    {\n      log_error (\"error allocating buffer\\n\");\n      return NULL;\n    }\n  p = store_tag_length (p, TAG_SEQUENCE, len[0]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_encryptedData));\n  memcpy (p, oid_encryptedData, DIM (oid_encryptedData));\n  p += DIM (oid_encryptedData);\n  p = store_tag_length (p, 0xa0, len[2]);\n  p = store_tag_length (p, TAG_SEQUENCE, len[3]);\n  *p++ = TAG_INTEGER;\n  *p++ = 1;\n  *p++ = 0;\n  p = store_tag_length (p, TAG_SEQUENCE, len[5]);\n  p = store_tag_length (p, TAG_OBJECT_ID, DIM (oid_data));\n  memcpy (p, oid_data, DIM (oid_data));\n  p += DIM (oid_data);\n  memcpy (p, data_rc2iter2048, DIM (data_rc2iter2048));\n  memcpy (p + DATA_RC2ITER2048_SALT_OFF, salt, 8);\n  p += DIM (data_rc2iter2048);\n  p = store_tag_length (p, 0x80, buflen);\n  memcpy (p, buffer, buflen);\n  p += buflen;\n  certbaglen = p - certbag;\n  if (needed != certbaglen)\n    log_debug (\"length mismatch: %lu, %lu\\n\",\n               (unsigned long)needed, (unsigned long)certbaglen);\n  *r_length = certbaglen;\n  return certbag;\n}", "target": 0}
{"code": "writepid (const char* pidfile, pid_t pid)\n{\n\tFILE* f;\n\tif ((f = fopen(pidfile, \"w\")) ==  NULL ) {\n\t\tlog_err(\"cannot open pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t\treturn;\n\t}\n\tif(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {\n\t\tlog_err(\"cannot write to pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t}\n\tfclose(f);\n}", "target": 1}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& convolve(const CImg<t>& kernel, const bool boundary_conditions=true, const bool is_normalized=false) {\n      if (is_empty() || !kernel) return *this;\n      return get_convolve(kernel,boundary_conditions,is_normalized).move_to(*this);", "target": 0}
{"code": "static void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,\n                             struct fuse_file_info *fi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_intr_data d;\n    char *path;\n    int err = 0;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (f->conf.debug)\n        fprintf(stderr, \"RELEASE%s[%llu] flags: 0x%x\\n\",\n                fi->flush ? \"+FLUSH\" : \"\",\n                (unsigned long long) fi->fh, fi->flags);\n    if (fi->flush) {\n        err = fuse_flush_common(f, req, ino, path, fi);\n        if (err == -ENOSYS)\n            err = 0;\n    }\n    fuse_prepare_interrupt(f, req, &d);\n    fuse_do_release(f, ino, path, fi);\n    fuse_finish_interrupt(f, req, &d);\n    free(path);\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "static void io_init_new_worker(struct io_wqe *wqe, struct io_worker *worker,\n\t\t\t       struct task_struct *tsk)\n{\n\ttsk->pf_io_worker = worker;\n\tworker->task = tsk;\n\tset_cpus_allowed_ptr(tsk, wqe->cpu_mask);\n\ttsk->flags |= PF_NO_SETAFFINITY;\n\traw_spin_lock(&wqe->lock);\n\thlist_nulls_add_head_rcu(&worker->nulls_node, &wqe->free_list);\n\tlist_add_tail_rcu(&worker->all_list, &wqe->all_list);\n\tworker->flags |= IO_WORKER_F_FREE;\n\traw_spin_unlock(&wqe->lock);\n\twake_up_new_task(tsk);\n}", "target": 0}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static inline long put_compat_itimerval(struct compat_itimerval __user *o,\n\t\tstruct itimerval *i)\n{\n\treturn (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||\n\t\t(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |\n\t\t __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |\n\t\t __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |\n\t\t __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));\n}", "target": 0}
{"code": "png_crc_error(png_structp png_ptr)\n{\n   png_byte crc_bytes[4];\n   png_uint_32 crc;\n   int need_crc = 1;\n   if (png_ptr->chunk_name[0] & 0x20)                     \n   {\n      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n         need_crc = 0;\n   }\n   else                                                    \n   {\n      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)\n         need_crc = 0;\n   }\n   png_read_data(png_ptr, crc_bytes, 4);\n   if (need_crc)\n   {\n      crc = png_get_uint_32(crc_bytes);\n      return ((int)(crc != png_ptr->crc));\n   }\n   else\n      return (0);\n}", "target": 0}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "void OmniboxViewWin::RepaintDropHighlight(int position) {\n  if ((position != -1) && (position <= GetTextLength())) {\n    const POINT min_loc(PosFromChar(position));\n    const RECT highlight_bounds = {min_loc.x - 1, font_y_adjustment_,\n        min_loc.x + 2, font_.GetHeight() + font_y_adjustment_};\n    InvalidateRect(&highlight_bounds, false);\n  }\n}", "target": 0}
{"code": "static void maybe_add_creds(struct sk_buff *skb, const struct socket *sock,\n\t\t\t    const struct sock *other)\n{\n\tif (UNIXCB(skb).pid)\n\t\treturn;\n\tif (unix_passcred_enabled(sock, other)) {\n\t\tUNIXCB(skb).pid  = get_pid(task_tgid(current));\n\t\tcurrent_uid_gid(&UNIXCB(skb).uid, &UNIXCB(skb).gid);\n\t}\n}", "target": 0}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 1}
{"code": "static void vnc_client_cache_addr(VncState *client)\n{\n    Error *err = NULL;\n    client->info = g_malloc0(sizeof(*client->info));\n    vnc_init_basic_info_from_remote_addr(client->sioc,\n                                         qapi_VncClientInfo_base(client->info),\n                                         &err);\n    client->info->websocket = client->websocket;\n    if (err) {\n        qapi_free_VncClientInfo(client->info);\n        client->info = NULL;\n        error_free(err);\n    }\n}", "target": 0}
{"code": "ref_param_read_float_array(gs_param_list * plist, gs_param_name pkey,\n                           gs_param_float_array * pvalue)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    iparam_loc loc;\n    ref aref, elt;\n    int code = ref_param_read_array(iplist, pkey, &loc);\n    float *pfv;\n    uint size;\n    long i;\n    if (code != 0)\n        return code;\n    size = r_size(loc.pvalue);\n    pfv = (float *)gs_alloc_byte_array(plist->memory, size, sizeof(float),\n                                       \"ref_param_read_float_array\");\n    if (pfv == 0)\n        return_error(gs_error_VMerror);\n    aref = *loc.pvalue;\n    loc.pvalue = &elt;\n    for (i = 0; code >= 0 && i < size; i++) {\n        array_get(plist->memory, &aref, i, &elt);\n        code = float_param(&elt, pfv + i);\n    }\n    if (code < 0) {\n        gs_free_object(plist->memory, pfv, \"ref_read_float_array_param\");\n        return (*loc.presult = code);\n    }\n    pvalue->data = pfv;\n    pvalue->size = size;\n    pvalue->persistent = true;\n    return 0;\n}", "target": 0}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "PHP_MINIT_FUNCTION(spl_heap) \n{\n\tREGISTER_SPL_STD_CLASS_EX(SplHeap, spl_heap_object_new, spl_funcs_SplHeap);\n\tmemcpy(&spl_handler_SplHeap, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplHeap.clone_obj      = spl_heap_object_clone;\n\tspl_handler_SplHeap.count_elements = spl_heap_object_count_elements;\n\tspl_handler_SplHeap.get_debug_info = spl_heap_object_get_debug_info;\n\tREGISTER_SPL_IMPLEMENTS(SplHeap, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplHeap, Countable);\n\tspl_ce_SplHeap->get_iterator = spl_heap_get_iterator;\n\tREGISTER_SPL_SUB_CLASS_EX(SplMinHeap,           SplHeap,        spl_heap_object_new, spl_funcs_SplMinHeap);\n\tREGISTER_SPL_SUB_CLASS_EX(SplMaxHeap,           SplHeap,        spl_heap_object_new, spl_funcs_SplMaxHeap);\n\tspl_ce_SplMaxHeap->get_iterator = spl_heap_get_iterator;\n\tspl_ce_SplMinHeap->get_iterator = spl_heap_get_iterator;\n\tREGISTER_SPL_STD_CLASS_EX(SplPriorityQueue, spl_heap_object_new, spl_funcs_SplPriorityQueue);\n\tmemcpy(&spl_handler_SplPriorityQueue, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplPriorityQueue.clone_obj      = spl_heap_object_clone;\n\tspl_handler_SplPriorityQueue.count_elements = spl_heap_object_count_elements;\n\tspl_handler_SplPriorityQueue.get_debug_info = spl_pqueue_object_get_debug_info;\n\tREGISTER_SPL_IMPLEMENTS(SplPriorityQueue, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplPriorityQueue, Countable);\n\tspl_ce_SplPriorityQueue->get_iterator = spl_pqueue_get_iterator;\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_BOTH\",      SPL_PQUEUE_EXTR_BOTH);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_PRIORITY\",  SPL_PQUEUE_EXTR_PRIORITY);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplPriorityQueue, \"EXTR_DATA\",      SPL_PQUEUE_EXTR_DATA);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "libxlDomainDefNamespaceParse(xmlXPathContextPtr ctxt,\n                             void **data)\n{\n    libxlDomainXmlNsDef *nsdata = NULL;\n    g_autofree xmlNodePtr *nodes = NULL;\n    ssize_t nnodes;\n    size_t i;\n    int ret = -1;\n    if ((nnodes = virXPathNodeSet(\"./xen:commandline/xen:arg\", ctxt, &nodes)) < 0)\n        return -1;\n    if (nnodes == 0)\n        return 0;\n    nsdata = g_new0(libxlDomainXmlNsDef, 1);\n    nsdata->args = g_new0(char *, nnodes + 1);\n    for (i = 0; i < nnodes; i++) {\n        if (!(nsdata->args[nsdata->num_args++] = virXMLPropString(nodes[i], \"value\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No device model command-line argument specified\"));\n            goto cleanup;\n        }\n    }\n    *data = g_steal_pointer(&nsdata);\n    ret = 0;\n cleanup:\n    libxlDomainDefNamespaceFree(nsdata);\n    return ret;\n}", "target": 0}
{"code": "void LibRaw::process_Sony_0x0116(uchar *buf, ushort len, unsigned long long id)\n{\n  int i = 0;\n  if (((id == 0x101ULL) || \n       (id == 0x106ULL) || \n       (id == 0x10dULL) || \n       (id == 0x10eULL)    \n       ) &&\n      (len >= 2))\n    i = 1;\n  else if ((id >= 0x111ULL) && (len >= 3))\n    i = 2;\n  else\n    return;\n  imgdata.makernotes.common.BatteryTemperature = (float)(buf[i] - 32) / 1.8f;\n}", "target": 0}
{"code": "void vsock_remove_bound(struct vsock_sock *vsk)\n{\n\tspin_lock_bh(&vsock_table_lock);\n\t__vsock_remove_bound(vsk);\n\tspin_unlock_bh(&vsock_table_lock);\n}", "target": 0}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "postmatch_getter(void)\n{\n    return rb_reg_match_post(rb_backref_get());\n}", "target": 0}
{"code": "static ZIPARCHIVE_METHOD(addFromString)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *buffer, *name;\n\tint buffer_len, name_len;\n\tze_zip_object *ze_obj;\n\tstruct zip_source *zs;\n\tint pos = 0;\n\tint cur_idx;\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\",\n\t\t\t&name, &name_len, &buffer, &buffer_len) == FAILURE) {\n\t\treturn;\n\t}\n\tze_obj = (ze_zip_object*) zend_object_store_get_object(this TSRMLS_CC);\n\tif (ze_obj->buffers_cnt) {\n\t\tze_obj->buffers = (char **)erealloc(ze_obj->buffers, sizeof(char *) * (ze_obj->buffers_cnt+1));\n\t\tpos = ze_obj->buffers_cnt++;\n\t} else {\n\t\tze_obj->buffers = (char **)emalloc(sizeof(char *));\n\t\tze_obj->buffers_cnt++;\n\t\tpos = 0;\n\t}\n\tze_obj->buffers[pos] = (char *)emalloc(buffer_len + 1);\n\tmemcpy(ze_obj->buffers[pos], buffer, buffer_len + 1);\n\tzs = zip_source_buffer(intern, ze_obj->buffers[pos], buffer_len, 0);\n\tif (zs == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tcur_idx = zip_name_locate(intern, (const char *)name, 0);\n\tif (cur_idx >= 0) {\n\t\tif (zip_delete(intern, cur_idx) == -1) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (zip_add(intern, name, zs) != -1) {\n\t\tRETURN_TRUE;\n\t}\nfail:\n\tzip_source_free(zs);\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\tret = buf[1];\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 1}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }", "target": 1}
{"code": "static av_cold int shorten_decode_init(AVCodecContext *avctx)\n{\n    ShortenContext *s = avctx->priv_data;\n    s->avctx          = avctx;\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16P;\n    return 0;\n}", "target": 0}
{"code": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\tmm->address = address;\n\tmm->size = size;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\treturn (mm);\n}", "target": 1}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "static inline bool tok_white(const Token *x)\n{\n    return tok_type(x, TOK_WHITESPACE);\n}", "target": 0}
{"code": "TEST_F(LoaderTest, PbtxtFormat) {\n  SavedModelBundle bundle;\n  SessionOptions session_options;\n  RunOptions run_options;\n  const string export_dir =\n      io::JoinPath(testing::TensorFlowSrcRoot(), kTestDataPbTxt);\n  TF_ASSERT_OK(LoadSavedModel(session_options, run_options, export_dir,\n                              {kSavedModelTagServe}, &bundle));\n  CheckSavedModelBundle(export_dir, bundle);\n}", "target": 0}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "GfxShading::GfxShading(int typeA)\n{\n    type = typeA;\n    colorSpace = nullptr;\n}", "target": 0}
{"code": "void sock_init_data(struct socket *sock, struct sock *sk)\n{\n\tskb_queue_head_init(&sk->sk_receive_queue);\n\tskb_queue_head_init(&sk->sk_write_queue);\n\tskb_queue_head_init(&sk->sk_error_queue);\n#ifdef CONFIG_NET_DMA\n\tskb_queue_head_init(&sk->sk_async_wait_queue);\n#endif\n\tsk->sk_send_head\t=\tNULL;\n\tinit_timer(&sk->sk_timer);\n\tsk->sk_allocation\t=\tGFP_KERNEL;\n\tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n\tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n\tsk->sk_state\t\t=\tTCP_CLOSE;\n\tsk_set_socket(sk, sock);\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sock) {\n\t\tsk->sk_type\t=\tsock->type;\n\t\tsk->sk_wq\t=\tsock->wq;\n\t\tsock->sk\t=\tsk;\n\t} else\n\t\tsk->sk_wq\t=\tNULL;\n\tspin_lock_init(&sk->sk_dst_lock);\n\trwlock_init(&sk->sk_callback_lock);\n\tlockdep_set_class_and_name(&sk->sk_callback_lock,\n\t\t\taf_callback_keys + sk->sk_family,\n\t\t\taf_family_clock_key_strings[sk->sk_family]);\n\tsk->sk_state_change\t=\tsock_def_wakeup;\n\tsk->sk_data_ready\t=\tsock_def_readable;\n\tsk->sk_write_space\t=\tsock_def_write_space;\n\tsk->sk_error_report\t=\tsock_def_error_report;\n\tsk->sk_destruct\t\t=\tsock_def_destruct;\n\tsk->sk_sndmsg_page\t=\tNULL;\n\tsk->sk_sndmsg_off\t=\t0;\n\tsk->sk_peek_off\t\t=\t-1;\n\tsk->sk_peer_pid \t=\tNULL;\n\tsk->sk_peer_cred\t=\tNULL;\n\tsk->sk_write_pending\t=\t0;\n\tsk->sk_rcvlowat\t\t=\t1;\n\tsk->sk_rcvtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_sndtimeo\t\t=\tMAX_SCHEDULE_TIMEOUT;\n\tsk->sk_stamp = ktime_set(-1L, 0);\n\tsmp_wmb();\n\tatomic_set(&sk->sk_refcnt, 1);\n\tatomic_set(&sk->sk_drops, 0);\n}", "target": 0}
{"code": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tdst->transparent = src->transparent;\n\tif (src->sx < (crop->x + crop->width -1)) {\n\t\tcrop->width = src->sx - crop->x + 1;\n\t}\n\tif (src->sy < (crop->y + crop->height -1)) {\n\t\tcrop->height = src->sy - crop->y + 1;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t} else {\n\t\tint y = crop->y;\n\t\tif (src->trueColor) {\n\t\t\tunsigned int dst_y = 0;\n\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tint x;\n\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t}\n}", "target": 1}
{"code": "aura::Window::Windows Shell::GetAllRootWindows() {\n  CHECK(HasInstance());\n  return Shell::GetInstance()->window_tree_host_manager()->GetAllRootWindows();\n}", "target": 0}
{"code": "GF_Box *gf_isom_clone_config_box(GF_Box *box)\n{\n\tu8 *data=NULL;\n\tu32 size=0;\n\tGF_Err e;\n\tGF_Box *clone=NULL;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_size(box);\n\tif (!e)\n\t\te = gf_isom_box_write(box, bs);\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\tif (!e) {\n\t\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t\te = gf_isom_box_parse(&clone, bs);\n\t\tgf_bs_del(bs);\n\t}\n\tif (data)\n\t\tgf_free(data);\n\tif (e) {\n\t\tif (clone)\n\t\t\tgf_isom_box_del(clone);\n\t\tclone = NULL;\n\t}\n\treturn clone;\n}", "target": 0}
{"code": "static GF_Filter *locate_alias_sink(GF_Filter *filter, const char *url, const char *mime_type)\n{\n\tu32 i;\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tu32 j;\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_Filter *f;\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\tif (!pidi->filter) continue;\n\t\t\tif (pidi->filter->act_as_sink && pidi->filter->freg->use_alias\n\t\t\t\t&& pidi->filter->freg->use_alias(pidi->filter, url, mime_type)\n\t\t\t) {\n\t\t\t\treturn pidi->filter;\n\t\t\t}\n\t\t\tf = locate_alias_sink(pidi->filter, url, mime_type);\n\t\t\tif (f) return f;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "static char *red_stream_get_local_address(RedStream *stream)\n{\n    return addr_to_string(\"%s;%s\", &stream->priv->info->laddr_ext,\n                          stream->priv->info->llen_ext);\n}", "target": 0}
{"code": "getHostName() {\n\tlong hostNameMax = HOST_NAME_MAX;\n\tif (hostNameMax < 255) {\n\t\thostNameMax = 255;\n\t}\n\tstring buf(hostNameMax + 1, '\\0');\n\tif (gethostname(&buf[0], hostNameMax + 1) == 0) {\n\t\tbuf[hostNameMax] = '\\0';\n\t\treturn string(buf.c_str());\n\t} else {\n\t\tint e = errno;\n\t\tthrow SystemException(\"Unable to query the system's host name\", e);\n\t}\n}", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "    Loader::UniquePtr createLoaderXmpJpeg(PreviewId id, const Image &image, int parIdx)\n    {\n        return Loader::UniquePtr(new LoaderXmpJpeg(id, image, parIdx));\n    }", "target": 0}
{"code": "MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)\n{\n  unsigned char\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  return(data);\n}", "target": 1}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "static locale_t AcquireCLocale(void)\n{\n#if defined(MAGICKCORE_HAVE_NEWLOCALE)\n  if (c_locale == (locale_t) NULL)\n    c_locale=newlocale(LC_ALL_MASK,\"C\",(locale_t) 0);\n#elif defined(MAGICKCORE_WINDOWS_SUPPORT) && !defined(__MINGW32__)\n  if (c_locale == (locale_t) NULL)\n    c_locale=_create_locale(LC_ALL,\"C\");\n#endif\n  return(c_locale);\n}", "target": 0}
{"code": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "char *BN_bn2dec(const BIGNUM *a)\n{\n    int i = 0, num, ok = 0;\n    char *buf = NULL;\n    char *p;\n    BIGNUM *t = NULL;\n    BN_ULONG *bn_data = NULL, *lp;\n    i = BN_num_bits(a) * 3;\n    num = (i / 10 + i / 1000 + 1) + 1;\n    bn_data = OPENSSL_malloc((num / BN_DEC_NUM + 1) * sizeof(BN_ULONG));\n    buf = OPENSSL_malloc(num + 3);\n    if ((buf == NULL) || (bn_data == NULL)) {\n        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    if ((t = BN_dup(a)) == NULL)\n        goto err;\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\n    p = buf;\n    lp = bn_data;\n    if (BN_is_zero(t)) {\n        *(p++) = '0';\n        *(p++) = '\\0';\n    } else {\n        if (BN_is_negative(t))\n            *p++ = '-';\n        i = 0;\n        while (!BN_is_zero(t)) {\n            *lp = BN_div_word(t, BN_DEC_CONV);\n            lp++;\n        }\n        lp--;\n        BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\n        while (*p)\n            p++;\n        while (lp != bn_data) {\n            lp--;\n            BIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\n            while (*p)\n                p++;\n        }\n    }\n    ok = 1;\n err:\n    OPENSSL_free(bn_data);\n    BN_free(t);\n    if (ok)\n        return buf;\n    OPENSSL_free(buf);\n    return NULL;\n}", "target": 1}
{"code": "static ssize_t carrier_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\treturn netdev_store(dev, attr, buf, len, change_carrier);", "target": 0}
{"code": "static void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint queued;\n\tqueued = tty_insert_flip_string(&port->port, data, length);\n\tif (queued < length)\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t__func__, length - queued);\n\ttty_flip_buffer_push(&port->port);\n}", "target": 0}
{"code": "PHP_PGSQL_API int php_pgsql_delete(PGconn *pg_link, const char *table, zval *ids_array, zend_ulong opt, zend_string **sql) \n{\n\tzval ids_converted;\n\tsmart_str querystr = {0};\n\tint ret = FAILURE;\n\tassert(pg_link != NULL);\n\tassert(table != NULL);\n\tassert(Z_TYPE_P(ids_array) == IS_ARRAY);\n\tassert(!(opt & ~(PGSQL_CONV_FORCE_NULL|PGSQL_DML_EXEC|PGSQL_DML_STRING|PGSQL_DML_ESCAPE)));\n\tif (zend_hash_num_elements(Z_ARRVAL_P(ids_array)) == 0) {\n\t\treturn FAILURE;\n\t}\n\tZVAL_UNDEF(&ids_converted);\n\tif (!(opt & (PGSQL_DML_NO_CONV|PGSQL_DML_ESCAPE))) {\n\t\tarray_init(&ids_converted);\n\t\tif (php_pgsql_convert(pg_link, table, ids_array, &ids_converted, (opt & PGSQL_CONV_OPTS)) == FAILURE) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tids_array = &ids_converted;\n\t}\n\tsmart_str_appends(&querystr, \"DELETE FROM \");\n\tbuild_tablename(&querystr, pg_link, table);\n\tsmart_str_appends(&querystr, \" WHERE \");\n\tif (build_assignment_string(pg_link, &querystr, Z_ARRVAL_P(ids_array), 1, \" AND \", sizeof(\" AND \")-1, opt))\n\t\tgoto cleanup;\n\tsmart_str_appendc(&querystr, ';');\n\tsmart_str_0(&querystr);\n\tif ((opt & PGSQL_DML_EXEC) && do_exec(&querystr, PGRES_COMMAND_OK, pg_link, opt) == 0) {\n\t\tret = SUCCESS;\n\t} else if (opt & PGSQL_DML_STRING) {\n\t\tret = SUCCESS;\n\t}\ncleanup:\n\tzval_ptr_dtor(&ids_converted);\n\tif (ret == SUCCESS && (opt & PGSQL_DML_STRING)) {\n\t\t*sql = querystr.s;\n\t}\n\telse {\n\t\tsmart_str_free(&querystr);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 0}
{"code": "rndset(unsigned long v)\n{\n\tregister uint32_t h;\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tregister uint32_t t;\n#endif\n\tstruct {\n\t\tstruct timeval tv;\n\t\tvoid *sp;\n\t\tuint32_t qh;\n\t\tpid_t pp;\n\t\tshort r;\n\t} z;\n#ifdef DEBUG\n\tmemset(&z, 0, sizeof(z));\n#endif\n\th = lcg_state;\n\tBAFHFinish_reg(h);\n\tBAFHUpdateMem_reg(h, &v, sizeof(v));\n\tmksh_TIME(z.tv);\n\tz.sp = &lcg_state;\n\tz.pp = procpid;\n\tz.r = (short)rndget();\n#if defined(arc4random_pushb_fast) || defined(MKSH_A4PB)\n\tt = qh_state;\n\tBAFHFinish_reg(t);\n\tz.qh = (t & 0xFFFF8000) | rndget();\n\tlcg_state = (t << 15) | rndget();\n\tt = h;\n\tBAFHUpdateMem_reg(t, &lcg_state, sizeof(lcg_state));\n\tBAFHFinish_reg(t);\n\tlcg_state = t;\n#if defined(arc4random_pushb_fast)\n\tarc4random_pushb_fast(&lcg_state, sizeof(lcg_state));\n\tlcg_state = arc4random();\n#else\n\tlcg_state = arc4random_pushb(&lcg_state, sizeof(lcg_state));\n#endif\n\tBAFHUpdateMem_reg(h, &lcg_state, sizeof(lcg_state));\n#else\n\tz.qh = qh_state;\n#endif\n\tBAFHUpdateMem_reg(h, &z, sizeof(z));\n\tBAFHFinish_reg(h);\n\tlcg_state = h;\n}", "target": 0}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "static BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\nbit_index >>= SLJIT_WORD_SHIFT;\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\nif (*byte & mask)\n  return FALSE;\n*byte |= mask;\nreturn TRUE;\n}", "target": 0}
{"code": "void pdu_submit(V9fsPDU *pdu, P9MsgHeader *hdr)\n{\n    Coroutine *co;\n    CoroutineEntry *handler;\n    V9fsState *s = pdu->s;\n    pdu->size = le32_to_cpu(hdr->size_le);\n    pdu->id = hdr->id;\n    pdu->tag = le16_to_cpu(hdr->tag_le);\n    if (pdu->id >= ARRAY_SIZE(pdu_co_handlers) ||\n        (pdu_co_handlers[pdu->id] == NULL)) {\n        handler = v9fs_op_not_supp;\n    } else if (is_ro_export(&s->ctx) && !is_read_only_op(pdu)) {\n        handler = v9fs_fs_ro;\n    } else {\n        handler = pdu_co_handlers[pdu->id];\n    }\n    qemu_co_queue_init(&pdu->complete);\n    co = qemu_coroutine_create(handler, pdu);\n    qemu_coroutine_enter(co);\n}", "target": 0}
{"code": "static int transmit_skb(struct sk_buff *skb, struct caifsock *cf_sk,\n\t\t\tint noblock, long timeo)\n{\n\tstruct cfpkt *pkt;\n\tpkt = cfpkt_fromnative(CAIF_DIR_OUT, skb);\n\tmemset(skb->cb, 0, sizeof(struct caif_payload_info));\n\tcfpkt_set_prio(pkt, cf_sk->sk.sk_priority);\n\tif (cf_sk->layer.dn == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\treturn cf_sk->layer.dn->transmit(cf_sk->layer.dn, pkt);\n}", "target": 0}
{"code": "static ssize_t ifalias_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst struct net_device *netdev = to_net_dev(dev);\n\tchar tmp[IFALIASZ];\n\tssize_t ret = 0;\n\tret = dev_get_alias(netdev, tmp, sizeof(tmp));\n\tif (ret > 0)\n\t\tret = sprintf(buf, \"%s\\n\", tmp);\n\treturn ret;", "target": 0}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "static WERROR dcesrv_DnssrvComplexOperation(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx, struct DnssrvComplexOperation *r)\n{\n\tstruct dnsserver_state *dsstate;\n\tstruct dnsserver_zone *z;\n\tWERROR ret;\n\tZERO_STRUCTP(r->out.pdwTypeOut);\n\tZERO_STRUCTP(r->out.ppDataOut);\n\tif ((dsstate = dnsserver_connect(dce_call)) == NULL) {\n\t\treturn WERR_DNS_ERROR_DS_UNAVAILABLE;\n\t}\n\tif (r->in.pszZone == NULL) {\n\t\tret = dnsserver_complex_operate_server(dsstate, mem_ctx,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t} else {\n\t\tz = dnsserver_find_zone(dsstate->zones, r->in.pszZone);\n\t\tif (z == NULL) {\n\t\t\treturn WERR_DNS_ERROR_ZONE_DOES_NOT_EXIST;\n\t\t}\n\t\tret = dnsserver_complex_operate_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\t\tr->in.pszOperation,\n\t\t\t\t\t\t\tDNS_CLIENT_VERSION_W2K,\n\t\t\t\t\t\t\tr->in.dwTypeIn,\n\t\t\t\t\t\t\t&r->in.pDataIn,\n\t\t\t\t\t\t\tr->out.pdwTypeOut,\n\t\t\t\t\t\t\tr->out.ppDataOut);\n\t}\n\tif (W_ERROR_EQUAL(ret, WERR_CALL_NOT_IMPLEMENTED)) {\n\t\tNDR_PRINT_FUNCTION_DEBUG(DnssrvComplexOperation, NDR_IN, r);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static bool getFileSizeFromFindData(const WIN32_FIND_DATAW& findData, long long& size)\n{\n    ULARGE_INTEGER fileSize;\n    fileSize.HighPart = findData.nFileSizeHigh;\n    fileSize.LowPart = findData.nFileSizeLow;\n    if (fileSize.QuadPart > static_cast<ULONGLONG>(std::numeric_limits<long long>::max()))\n        return false;\n    size = fileSize.QuadPart;\n    return true;\n}", "target": 0}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "PHP_MINIT_FUNCTION(spl_observer)\n{\n\tREGISTER_SPL_INTERFACE(SplObserver);\n\tREGISTER_SPL_INTERFACE(SplSubject);\n\tREGISTER_SPL_STD_CLASS_EX(SplObjectStorage, spl_SplObjectStorage_new, spl_funcs_SplObjectStorage);\n\tmemcpy(&spl_handler_SplObjectStorage, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_handler_SplObjectStorage.get_debug_info  = spl_object_storage_debug_info;\n\tspl_handler_SplObjectStorage.compare_objects = spl_object_storage_compare_objects;\n\tspl_handler_SplObjectStorage.clone_obj       = spl_object_storage_clone;\n\tspl_handler_SplObjectStorage.get_gc          = spl_object_storage_get_gc;\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Countable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, ArrayAccess);\n\tREGISTER_SPL_STD_CLASS_EX(MultipleIterator, spl_SplObjectStorage_new, spl_funcs_MultipleIterator);\n\tREGISTER_SPL_ITERATOR(MultipleIterator);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ANY\",     MIT_NEED_ANY);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ALL\",     MIT_NEED_ALL);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_NUMERIC\", MIT_KEYS_NUMERIC);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_ASSOC\",   MIT_KEYS_ASSOC);\n\treturn SUCCESS;\n}", "target": 0}
{"code": "_parse_config_file(pam_handle_t *pamh, int ctrl, const char *file)\n{\n    int retval;\n    char buffer[BUF_SIZE];\n    FILE *conf;\n    VAR Var, *var=&Var;\n    D((\"Called.\"));\n    var->name=NULL; var->defval=NULL; var->override=NULL;\n    D((\"Config file name is: %s\", file));\n    if ((conf = fopen(file,\"r\")) == NULL) {\n      pam_syslog(pamh, LOG_ERR, \"Unable to open config file: %s: %m\", file);\n      return PAM_IGNORE;\n    }\n    while (( retval = _assemble_line(conf, buffer, BUF_SIZE)) > 0) {\n      D((\"Read line: %s\", buffer));\n      if ((retval = _parse_line(pamh, buffer, var)) == GOOD_LINE) {\n\tretval = _check_var(pamh, var);\n\tif (DEFINE_VAR == retval) {\n\t  retval = _define_var(pamh, ctrl, var);\n\t} else if (UNDEFINE_VAR == retval) {\n\t  retval = _undefine_var(pamh, ctrl, var);\n\t}\n      }\n      if (PAM_SUCCESS != retval && ILLEGAL_VAR != retval\n\t  && BAD_LINE != retval && PAM_BAD_ITEM != retval) break;\n      _clean_var(var);\n    }  \n    (void) fclose(conf);\n    _clean_var(var);        \n    D((\"Exit.\"));\n    return (retval != 0 ? PAM_ABORT : PAM_SUCCESS);\n}", "target": 0}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "static int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\terr = kvm_rdpmc(vcpu);\n\tkvm_complete_insn_gp(vcpu, err);\n\treturn 1;\n}", "target": 0}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": "static int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec *tp)\n{\n\treturn posix_cpu_clock_get(PROCESS_CLOCK, tp);\n}", "target": 0}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n \tif (stack->elements) {\n \t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n \t\t\t}\n \t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n     if (code == gs_error_undefinedresult) {\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "dodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\tif (xdh_sizeof + offset > size) {\n\t\treturn xdh_sizeof + offset;\n\t}\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val & DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}", "target": 0}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "SampleEncrypter::EncryptAudioSample(AP4_DataBuffer& sample, AP4_SampleDescription* sample_description)\n{\n    if (sample.GetDataSize() <= 16) {\n        return AP4_SUCCESS;\n    }\n    if (sample_description->GetFormat() == AP4_SAMPLE_FORMAT_EC_3) {\n        AP4_UI08*    data      = sample.UseData();\n        unsigned int data_size = sample.GetDataSize();\n        while (data_size > 4) {\n            unsigned int syncword = (data[0]<<8) | data[1];\n            if (syncword != 0x0b77) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            unsigned int frmsiz = 1+(((data[2]<<8)|(data[3]))&0x7FF);\n            unsigned int frame_size = 2*frmsiz;\n            if (data_size < frame_size) {\n                return AP4_ERROR_INVALID_FORMAT; \n            }\n            if (frame_size > 16) {\n                unsigned int encrypted_block_count = (frame_size-16)/16;\n                AP4_Size encrypted_size = encrypted_block_count*16;\n                m_StreamCipher->SetIV(m_IV);\n                m_StreamCipher->ProcessBuffer(data+16, encrypted_size, data+16, &encrypted_size);\n            }\n            data      += frame_size;\n            data_size -= frame_size;\n        }\n    } else {\n        unsigned int encrypted_block_count = (sample.GetDataSize()-16)/16;\n        AP4_Size encrypted_size = encrypted_block_count*16;\n        m_StreamCipher->SetIV(m_IV);\n        m_StreamCipher->ProcessBuffer(sample.UseData()+16, encrypted_size, sample.UseData()+16, &encrypted_size);\n    }\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "setup_remove_header(const uschar *hnames)\n{\nif (*hnames)\n  acl_removed_headers = acl_removed_headers\n    ? string_sprintf(\"%s : %s\", acl_removed_headers, hnames)\n    : string_copy(hnames);\n}", "target": 0}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 0}
{"code": "nfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     struct nfsd4_access *access)\n{\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleCreateStreamTextureCHROMIUM(\n    uint32 immediate_data_size,\n    const gles2::CreateStreamTextureCHROMIUM& c) {\n  if (!feature_info_->feature_flags().chromium_stream_texture) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glOpenStreamTextureCHROMIUM: \"\n               \"not supported.\");\n    return error::kNoError;\n  }\n  uint32 client_id = c.client_id;\n  typedef gles2::CreateStreamTextureCHROMIUM::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result)\n    return error::kOutOfBounds;\n  *result = GL_ZERO;\n  TextureManager::TextureInfo* info =\n      texture_manager()->GetTextureInfo(client_id);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"bad texture id.\");\n    return error::kNoError;\n  }\n  if (info->IsStreamTexture()) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"is already a stream texture.\");\n    return error::kNoError;\n  }\n  if (info->target() && info->target() != GL_TEXTURE_EXTERNAL_OES) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"is already bound to incompatible target.\");\n    return error::kNoError;\n  }\n  if (!stream_texture_manager_)\n    return error::kInvalidArguments;\n  GLuint object_id = stream_texture_manager_->CreateStreamTexture(\n      info->service_id(), client_id);\n  if (object_id) {\n    info->SetStreamTexture(true);\n  } else {\n    SetGLError(GL_OUT_OF_MEMORY,\n               \"glCreateStreamTextureCHROMIUM: \"\n               \"failed to create platform texture.\");\n  }\n  *result = object_id;\n  return error::kNoError;\n}", "target": 0}
{"code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tstruct jbg_dec_state decoder;\n\tint decodeStatus = 0;\n\tunsigned char* pImage = NULL;\n\t(void) size, (void) s;\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawdatasize);\n\t}\n\tjbg_dec_init(&decoder);\n#if defined(HAVE_JBG_NEWLEN)\n\tjbg_newlen(tif->tif_rawdata, (size_t)tif->tif_rawdatasize);\n#endif \n\tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawdata,\n\t\t\t\t  (size_t)tif->tif_rawdatasize, NULL);\n\tif (JBG_EOK != decodeStatus)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\n\t\t\t     decodeStatus,\n#if defined(JBG_EN)\n\t\t\t     jbg_strerror(decodeStatus, JBG_EN)\n#else\n\t\t\t     jbg_strerror(decodeStatus)\n#endif\n\t\t\t     );\n\t\tjbg_dec_free(&decoder);\n\t\treturn 0;\n\t}\n\tpImage = jbg_dec_getimage(&decoder, 0);\n\t_TIFFmemcpy(buffer, pImage, jbg_dec_getsize(&decoder));\n\tjbg_dec_free(&decoder);\n\treturn 1;\n}", "target": 1}
{"code": "timeout_response_cb (GtkDialog *dialog, int response_id, gpointer data)\n{\n        TimeoutDialog *timeout = data;\n        if (response_id == GTK_RESPONSE_DELETE_EVENT) {\n                timeout->response_id = GTK_RESPONSE_CANCEL;\n        } else\n                timeout->response_id = response_id;\n        gtk_main_quit ();\n}", "target": 0}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, BasicRequestDoubleHeadersTest) {\n  initializeFilter(request_config_yaml);\n  Http::TestRequestHeaderMapImpl incoming_headers{{\"X-VERSION\", \"foo\"}, {\"X-VERSION\", \"bar\"}};\n  std::map<std::string, std::string> expected = {{\"version\", \"foo,bar\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(\"envoy.lb\", MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(incoming_headers, false));\n  Http::MetadataMap metadata_map{{\"metadata\", \"metadata\"}};\n  EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->decodeMetadata(metadata_map));\n  Buffer::OwnedImpl data(\"data\");\n  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->decodeData(data, false));\n  Http::TestRequestTrailerMapImpl incoming_trailers;\n  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->decodeTrailers(incoming_trailers));\n  filter_->onDestroy();\n}", "target": 0}
{"code": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\tif (--header->nreg)\n\t\treturn;\n\tif (parent)\n\t\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}", "target": 1}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "  void addCopy(const LowerCaseString& key, absl::string_view value) override {\n    HeaderMapImpl::addCopy(key, value);\n  }", "target": 0}
{"code": "static struct xol_area *__create_xol_area(unsigned long vaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tuprobe_opcode_t insn = UPROBE_SWBP_INSN;\n\tstruct xol_area *area;\n\tarea = kmalloc(sizeof(*area), GFP_KERNEL);\n\tif (unlikely(!area))\n\t\tgoto out;\n\tarea->bitmap = kzalloc(BITS_TO_LONGS(UINSNS_PER_PAGE) * sizeof(long), GFP_KERNEL);\n\tif (!area->bitmap)\n\t\tgoto free_area;\n\tarea->xol_mapping.name = \"[uprobes]\";\n\tarea->xol_mapping.fault = NULL;\n\tarea->xol_mapping.pages = area->pages;\n\tarea->pages[0] = alloc_page(GFP_HIGHUSER);\n\tif (!area->pages[0])\n\t\tgoto free_bitmap;\n\tarea->pages[1] = NULL;\n\tarea->vaddr = vaddr;\n\tinit_waitqueue_head(&area->wq);\n\tset_bit(0, area->bitmap);\n\tatomic_set(&area->slot_count, 1);\n\tarch_uprobe_copy_ixol(area->pages[0], 0, &insn, UPROBE_SWBP_INSN_SIZE);\n\tif (!xol_add_vma(mm, area))\n\t\treturn area;\n\t__free_page(area->pages[0]);\n free_bitmap:\n\tkfree(area->bitmap);\n free_area:\n\tkfree(area);\n out:\n\treturn NULL;\n}", "target": 0}
{"code": "void AsfVideo::fileProperties() {\n  DataBuf FileIddBuf = io_->read(GUID);\n  xmpData()[\"Xmp.video.FileID\"] = GUIDTag(FileIddBuf.data()).to_string();\n  xmpData()[\"Xmp.video.FileLength\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.CreationDate\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.DataPackets\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.duration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.SendDuration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.Preroll\"] = readQWORDTag(io_);\n  io_->seek(io_->tell() + DWORD + DWORD + DWORD,\n            BasicIo::beg);  \n  xmpData()[\"Xmp.video.MaxBitRate\"] = readDWORDTag(io_);\n}  ", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": "    void ExifThumb::setJpegThumbnail(\n        const std::string& path,\n              URational    xres,\n              URational    yres,\n              uint16_t     unit\n    )\n    {\n        DataBuf thumb = readFile(path); \n        setJpegThumbnail(thumb.pData_, thumb.size_, xres, yres, unit);\n    }", "target": 0}
{"code": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n    if (*a == '-') {\n        neg = 1;\n        a++;\n    }\n    for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)\n        continue;\n    if (i > INT_MAX/4)\n        goto err;\n    num = i + neg;\n    if (bn == NULL)\n        return (num);\n    if (*bn == NULL) {\n        if ((ret = BN_new()) == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n    if (bn_expand(ret, i * 4) == NULL)\n        goto err;\n    j = i;                      \n    m = 0;\n    h = 0;\n    while (j > 0) {\n        m = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\n        l = 0;\n        for (;;) {\n            c = a[j - m];\n            if ((c >= '0') && (c <= '9'))\n                k = c - '0';\n            else if ((c >= 'a') && (c <= 'f'))\n                k = c - 'a' + 10;\n            else if ((c >= 'A') && (c <= 'F'))\n                k = c - 'A' + 10;\n            else\n                k = 0;          \n            l = (l << 4) | k;\n            if (--m <= 0) {\n                ret->d[h++] = l;\n                break;\n            }\n        }\n        j -= (BN_BYTES * 2);\n    }\n    ret->top = h;\n    bn_correct_top(ret);\n    ret->neg = neg;\n    *bn = ret;\n    bn_check_top(ret);\n    return (num);\n err:\n    if (*bn == NULL)\n        BN_free(ret);\n    return (0);\n}", "target": 0}
{"code": "void IndexedDBDatabase::DeleteObjectStoreAbortOperation(\n    IndexedDBObjectStoreMetadata object_store_metadata) {\n  IDB_TRACE(\"IndexedDBDatabase::DeleteObjectStoreAbortOperation\");\n  AddObjectStore(std::move(object_store_metadata),\n                 IndexedDBObjectStoreMetadata::kInvalidId);\n}", "target": 0}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}", "target": 0}
{"code": "  StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return stride_;\n    }\n    const TensorShape stride_shape = ctx->InputShape(2);\n    if (!TensorShapeUtils::IsVector(stride_shape)) {\n      return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                     stride_shape.DebugString());\n    }\n    if (stride_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> stride;\n    auto status = ctx->ConstantInputAsIntVector(2, &stride);\n    if (!status.ok()) {\n      return status;\n    }\n    return stride;\n  }", "target": 1}
{"code": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}", "target": 1}
{"code": "void OmniboxViewWin::OnLButtonDown(UINT keys, const CPoint& point) {\n  TrackMousePosition(kLeft, point);\n  if (gaining_focus_.get()) {\n    saved_selection_for_focus_change_.cpMin = -1;\n    DefWindowProc(WM_LBUTTONDOWN, keys, MAKELPARAM(point.x, point.y));\n    DefWindowProc(WM_LBUTTONUP, keys, MAKELPARAM(point.x, point.y));\n  }\n  const bool is_triple_click = tracking_double_click_ &&\n      views::NativeTextfieldWin::IsDoubleClick(double_click_point_, point,\n          GetCurrentMessage()->time - double_click_time_);\n  tracking_double_click_ = false;\n  if (!gaining_focus_.get() && !is_triple_click)\n    OnPossibleDrag(point);\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  OnBeforePossibleChange();\n  DefWindowProc(WM_LBUTTONDOWN, keys,\n                MAKELPARAM(ClipXCoordToVisibleText(point.x, is_triple_click),\n                           point.y));\n  OnAfterPossibleChange();\n  gaining_focus_.reset();\n}", "target": 0}
{"code": "void LibRaw::getOlympus_CameraType2()\n{\n  if (OlyID != 0x0ULL)\n    return;\n  int i = 0;\n  fread(imOly.CameraType2, 6, 1, ifp);\n  imOly.CameraType2[5] = 0;\n  while ((i < 6) && imOly.CameraType2[i])\n  {\n    OlyID = OlyID << 8 | imOly.CameraType2[i];\n    if (i < 5 && isspace(imOly.CameraType2[i + 1]))\n      imOly.CameraType2[i + 1] = '\\0';\n    i++;\n  }\n  unique_id = OlyID;\n  setOlympusBodyFeatures(OlyID);\n  return;\n}", "target": 0}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "static int unlock_full_stripe(struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t      bool locked)\n{\n\tstruct btrfs_block_group_cache *bg_cache;\n\tstruct btrfs_full_stripe_locks_tree *locks_root;\n\tstruct full_stripe_lock *fstripe_lock;\n\tu64 fstripe_start;\n\tbool freeit = false;\n\tint ret = 0;\n\tif (!locked)\n\t\treturn 0;\n\tbg_cache = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!bg_cache) {\n\t\tASSERT(0);\n\t\treturn -ENOENT;\n\t}\n\tif (!(bg_cache->flags & BTRFS_BLOCK_GROUP_RAID56_MASK))\n\t\tgoto out;\n\tlocks_root = &bg_cache->full_stripe_locks_root;\n\tfstripe_start = get_full_stripe_logical(bg_cache, bytenr);\n\tmutex_lock(&locks_root->lock);\n\tfstripe_lock = search_full_stripe_lock(locks_root, fstripe_start);\n\tif (!fstripe_lock) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t\tmutex_unlock(&locks_root->lock);\n\t\tgoto out;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\tWARN_ON(1);\n\t\tbtrfs_warn(fs_info, \"full stripe lock at %llu refcount underflow\",\n\t\t\tfstripe_lock->logical);\n\t} else {\n\t\tfstripe_lock->refs--;\n\t}\n\tif (fstripe_lock->refs == 0) {\n\t\trb_erase(&fstripe_lock->node, &locks_root->root);\n\t\tfreeit = true;\n\t}\n\tmutex_unlock(&locks_root->lock);\n\tmutex_unlock(&fstripe_lock->mutex);\n\tif (freeit)\n\t\tkfree(fstripe_lock);\nout:\n\tbtrfs_put_block_group(bg_cache);\n\treturn ret;\n}", "target": 0}
{"code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\tfclose (f);\n    }\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}", "target": 1}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "uint16_t read16(uint8_t* arr, int pos,  int swapBytes)\n{\n    uint8_t b1 = arr[pos];\n    uint8_t b2 = arr[pos+1];\n    return (swapBytes) ?  ((b2 << 8) | b1) : ((b1 << 8) | b2);\n}", "target": 0}
{"code": "static cfg_opt_t *cfg_dupopt_array(cfg_opt_t *opts)\n{\n\tint i;\n\tcfg_opt_t *dupopts;\n\tint n = cfg_numopts(opts);\n\tdupopts = calloc(n + 1, sizeof(cfg_opt_t));\n\tif (!dupopts)\n\t\treturn NULL;\n\tmemcpy(dupopts, opts, n * sizeof(cfg_opt_t));\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = NULL;\n\t\tdupopts[i].subopts = NULL;\n\t\tdupopts[i].def.parsed = NULL;\n\t\tdupopts[i].def.string = NULL;\n\t\tdupopts[i].comment = NULL;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tdupopts[i].name = strdup(opts[i].name);\n\t\tif (!dupopts[i].name)\n\t\t\tgoto err;\n\t\tif (opts[i].subopts) {\n\t\t\tdupopts[i].subopts = cfg_dupopt_array(opts[i].subopts);\n\t\t\tif (!dupopts[i].subopts)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.parsed) {\n\t\t\tdupopts[i].def.parsed = strdup(opts[i].def.parsed);\n\t\t\tif (!dupopts[i].def.parsed)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].def.string) {\n\t\t\tdupopts[i].def.string = strdup(opts[i].def.string);\n\t\t\tif (!dupopts[i].def.string)\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (opts[i].comment) {\n\t\t\tdupopts[i].comment = strdup(opts[i].comment);\n\t\t\tif (!dupopts[i].comment)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn dupopts;\nerr:\n\tcfg_free_opt_array(dupopts);\n\treturn NULL;\n}", "target": 0}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\trq_qos_exit(q);\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tblk_put_queue(q);\n}", "target": 1}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "void decompTest(tjhandle handle, unsigned char *jpegBuf,\n\tunsigned long jpegSize, int w, int h, int pf, char *basename, int subsamp,\n\tint flags)\n{\n\tint i, n=0;\n\ttjscalingfactor *sf=tjGetScalingFactors(&n);\n\tif(!sf || !n) _throwtj();\n\tfor(i=0; i<n; i++)\n\t{\n\t\tif(subsamp==TJSAMP_444 || subsamp==TJSAMP_GRAY ||\n\t\t\t(subsamp==TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==2 || sf[i].denom==1)) ||\n\t\t\t(subsamp!=TJSAMP_411 && sf[i].num==1 &&\n\t\t\t\t(sf[i].denom==4 || sf[i].denom==2 || sf[i].denom==1)))\n\t\t\t_decompTest(handle, jpegBuf, jpegSize, w, h, pf, basename, subsamp,\n\t\t\t\tflags, sf[i]);\n\t}\n\tbailout:\n\treturn;\n}", "target": 0}
{"code": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n    SAFE_FREE(cipher->aes_key);\n}", "target": 1}
{"code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\t*len = sizeof(*addr);\n\treturn 0;\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "static void RegionIter_destructor(JNIEnv* env, jobject, jlong pairHandle)\n{\n RgnIterPair* pair = reinterpret_cast<RgnIterPair*>(pairHandle);\n SkASSERT(pair);\n delete pair;\n}", "target": 0}
{"code": "static int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 1}
{"code": "void jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    strncpy(str, \"ID:\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n  } else if (lex->tk == LEX_STR) {\n    strncpy(str, \"String:'\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n    strncat(str, \"'\", len);\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}", "target": 1}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "ds_fgetstr (FILE *f, dynamic_string *s, char eos)\n{\n  int insize;\t\t\t\n  int strsize;\t\t\t\n  int next_ch;\n  insize = 0;\n  strsize = s->ds_length;\n  next_ch = getc (f);\n  while (next_ch != eos && next_ch != EOF)\n    {\n      if (insize >= strsize - 1)\n\t{\n\t  ds_resize (s, strsize * 2 + 2);\n\t  strsize = s->ds_length;\n\t}\n      s->ds_string[insize++] = next_ch;\n      next_ch = getc (f);\n    }\n  s->ds_string[insize++] = '\\0';\n  if (insize == 1 && next_ch == EOF)\n    return NULL;\n  else\n    return s->ds_string;\n}", "target": 1}
{"code": "status_t Parcel::write(const FlattenableHelperInterface& val)\n{\n status_t err;\n const size_t len = val.getFlattenedSize();\n const size_t fd_count = val.getFdCount();\n if ((len > INT32_MAX) || (fd_count > INT32_MAX)) {\n return BAD_VALUE;\n }\n    err = this->writeInt32(len);\n if (err) return err;\n    err = this->writeInt32(fd_count);\n if (err) return err;\n void* const buf = this->writeInplace(pad_size(len));\n if (buf == NULL)\n return BAD_VALUE;\n int* fds = NULL;\n if (fd_count) {\n        fds = new int[fd_count];\n }\n    err = val.flatten(buf, len, fds, fd_count);\n for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {\n        err = this->writeDupFileDescriptor( fds[i] );\n }\n if (fd_count) {\n delete [] fds;\n }\n return err;\n}", "target": 0}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}", "target": 1}
{"code": "static inline bool mpOk(const QString &mp)\n{\n    return !mp.isEmpty() && mp.startsWith(\"/home/\"); \n}", "target": 1}
{"code": "static char *str_dup_safe_fixed(const ut8 *b, const ut8 *str, ut64 len, const ut8 *end) {\n\tif (str >= b && str + len < end) {\n\t\tchar *result = calloc (1, len + 1);\n\t\tif (result) {\n\t\t\tr_str_ncpy (result, (const char *)str, len);\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "url_escape_1 (const char *s, unsigned char mask, bool allow_passthrough)\n{\n  const char *p1;\n  char *p2, *newstr;\n  int newlen;\n  int addition = 0;\n  for (p1 = s; *p1; p1++)\n    if (urlchr_test (*p1, mask))\n      addition += 2;            \n  if (!addition)\n    return allow_passthrough ? (char *)s : xstrdup (s);\n  newlen = (p1 - s) + addition;\n  newstr = xmalloc (newlen + 1);\n  p1 = s;\n  p2 = newstr;\n  while (*p1)\n    {\n      if (urlchr_test (*p1, mask))\n        {\n          unsigned char c = *p1++;\n          *p2++ = '%';\n          *p2++ = XNUM_TO_DIGIT (c >> 4);\n          *p2++ = XNUM_TO_DIGIT (c & 0xf);\n        }\n      else\n        *p2++ = *p1++;\n    }\n  assert (p2 - newstr == newlen);\n  *p2 = '\\0';\n  return newstr;\n}", "target": 0}
{"code": "static void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}", "target": 0}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 1}
{"code": "static int sg_proc_seq_show_debug(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tunsigned long iflags;\n\tif (it && (0 == it->index))\n\t\tseq_printf(s, \"max_active_device=%d  def_reserved_size=%d\\n\",\n\t\t\t   (int)it->max, sg_big_buff);\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tif (NULL == sdp)\n\t\tgoto skip;\n\tread_lock(&sdp->sfd_lock);\n\tif (!list_empty(&sdp->sfds)) {\n\t\tseq_printf(s, \" >>> device=%s \", sdp->disk->disk_name);\n\t\tif (atomic_read(&sdp->detaching))\n\t\t\tseq_puts(s, \"detaching pending close \");\n\t\telse if (sdp->device) {\n\t\t\tstruct scsi_device *scsidp = sdp->device;\n\t\t\tseq_printf(s, \"%d:%d:%d:%llu   em=%d\",\n\t\t\t\t   scsidp->host->host_no,\n\t\t\t\t   scsidp->channel, scsidp->id,\n\t\t\t\t   scsidp->lun,\n\t\t\t\t   scsidp->host->hostt->emulated);\n\t\t}\n\t\tseq_printf(s, \" sg_tablesize=%d excl=%d open_cnt=%d\\n\",\n\t\t\t   sdp->sg_tablesize, sdp->exclude, sdp->open_cnt);\n\t\tsg_proc_debug_helper(s, sdp);\n\t}\n\tread_unlock(&sdp->sfd_lock);\nskip:\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "MOCK_IMPL(const char *,\ndirvote_get_pending_consensus, (consensus_flavor_t flav))\n{\n  tor_assert(((int)flav) >= 0 && (int)flav < N_CONSENSUS_FLAVORS);\n  return pending_consensuses[flav].body;\n}", "target": 0}
{"code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "copy_opt_anc_info(OptAncInfo* to, OptAncInfo* from)\n{\n  *to = *from;\n}", "target": 0}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "LogData::LogData()\n    : routing_id(0),\n      type(0),\n      sent(0),\n      receive(0),\n      dispatch(0) {\n}", "target": 0}
{"code": "CellularNetwork::CellularNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  service_name_ = SafeString(service->name);\n  activation_state_ = service->activation_state;\n  network_technology_ = service->network_technology;\n  roaming_state_ = service->roaming_state;\n  restricted_pool_ = service->restricted_pool;\n  if (service->carrier_info) {\n    operator_name_ = SafeString(service->carrier_info->operator_name);\n    operator_code_ = SafeString(service->carrier_info->operator_code);\n    payment_url_ = SafeString(service->carrier_info->payment_url);\n  }\n  if (service->device_info) {\n    meid_ = SafeString(service->device_info->MEID);\n    imei_ = SafeString(service->device_info->IMEI);\n    imsi_ = SafeString(service->device_info->IMSI);\n    esn_ = SafeString(service->device_info->ESN);\n    mdn_ = SafeString(service->device_info->MDN);\n    min_ = SafeString(service->device_info->MIN);\n    model_id_ = SafeString(service->device_info->model_id);\n    manufacturer_ = SafeString(service->device_info->manufacturer);\n    firmware_revision_ = SafeString(service->device_info->firmware_revision);\n    hardware_revision_ = SafeString(service->device_info->hardware_revision);\n    last_update_ = SafeString(service->device_info->last_update);\n    prl_version_ = service->device_info->PRL_version;\n  }\n  type_ = TYPE_CELLULAR;\n}", "target": 0}
{"code": "fbStore_r5g6b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD16 *pixel = ((CARD16 *) bits) + x;\n    for (i = 0; i < width; ++i) {\n        CARD32 s = READ(values + i);\n        WRITE(pixel++, ((s >> 3) & 0x001f) |\n\t      ((s >> 5) & 0x07e0) |\n\t      ((s >> 8) & 0xf800));\n    }\n}", "target": 0}
{"code": "static void nvme_dsm_cb(void *opaque, int ret)\n{\n    NvmeDSMAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeCtrl *n = nvme_ctrl(req);\n    NvmeNamespace *ns = req->ns;\n    NvmeDsmRange *range;\n    uint64_t slba;\n    uint32_t nlb;\n    if (ret < 0) {\n        iocb->ret = ret;\n        goto done;\n    }\nnext:\n    if (iocb->idx == iocb->nr) {\n        goto done;\n    }\n    range = &iocb->range[iocb->idx++];\n    slba = le64_to_cpu(range->slba);\n    nlb = le32_to_cpu(range->nlb);\n    trace_pci_nvme_dsm_deallocate(slba, nlb);\n    if (nlb > n->dmrsl) {\n        trace_pci_nvme_dsm_single_range_limit_exceeded(nlb, n->dmrsl);\n        goto next;\n    }\n    if (nvme_check_bounds(ns, slba, nlb)) {\n        trace_pci_nvme_err_invalid_lba_range(slba, nlb,\n                                             ns->id_ns.nsze);\n        goto next;\n    }\n    iocb->aiocb = blk_aio_pdiscard(ns->blkconf.blk, nvme_l2b(ns, slba),\n                                   nvme_l2b(ns, nlb),\n                                   nvme_dsm_md_cb, iocb);\n    return;\ndone:\n    iocb->aiocb = NULL;\n    qemu_bh_schedule(iocb->bh);\n}", "target": 0}
{"code": "void undefer_input(__G)\n    __GDEF\n{\n    if (G.incnt > 0)\n        G.csize += G.incnt;\n    if (G.incnt_leftover > 0) {\n        G.incnt = G.incnt_leftover + (int)G.csize;\n        G.inptr = G.inptr_leftover - (int)G.csize;\n        G.incnt_leftover = 0;\n    } else if (G.incnt < 0)\n        G.incnt = 0;\n} ", "target": 1}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 0}
{"code": "    void CiffComponent::doPrint(std::ostream&      os,\n                                ByteOrder          byteOrder,\n                                const std::string& prefix) const\n    {\n        os << prefix\n           << _(\"tag\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << tagId()\n           << \", \" << _(\"dir\") << \" = 0x\" << std::setw(4) << std::setfill('0')\n           << std::hex << std::right << dir()\n           << \", \" << _(\"type\") << \" = \" << TypeInfo::typeName(typeId())\n           << \", \" << _(\"size\") << \" = \" << std::dec << size_\n           << \", \" << _(\"offset\") << \" = \" << offset_ << \"\\n\";\n        Value::UniquePtr value;\n        if (typeId() != directory) {\n            value = Value::create(typeId());\n            value->read(pData_, size_, byteOrder);\n            if (value->size() < 100) {\n                os << prefix << *value << \"\\n\";\n            }\n        }\n    } ", "target": 0}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "_gcry_ecc_eddsa_compute_h_d (unsigned char **r_digest,\n                             gcry_mpi_t d, mpi_ec_t ec)\n{\n  gpg_err_code_t rc;\n  unsigned char *rawmpi = NULL;\n  unsigned int rawmpilen;\n  unsigned char *digest;\n  gcry_buffer_t hvec[2];\n  int hashalgo, b;\n  *r_digest = NULL;\n  hashalgo = GCRY_MD_SHA512;\n  if (hashalgo != GCRY_MD_SHA512)\n    return GPG_ERR_DIGEST_ALGO;\n  b = (ec->nbits+7)/8;\n  if (b != 256/8)\n    return GPG_ERR_INTERNAL; \n  digest = xtrycalloc_secure (2, b);\n  if (!digest)\n    return gpg_err_code_from_syserror ();\n  memset (hvec, 0, sizeof hvec);\n  rawmpi = _gcry_mpi_get_buffer (d, 0, &rawmpilen, NULL);\n  if (!rawmpi)\n    {\n      xfree (digest);\n      return gpg_err_code_from_syserror ();\n    }\n  hvec[0].data = digest;\n  hvec[0].off = 0;\n  hvec[0].len = b > rawmpilen? b - rawmpilen : 0;\n  hvec[1].data = rawmpi;\n  hvec[1].off = 0;\n  hvec[1].len = rawmpilen;\n  rc = _gcry_md_hash_buffers (hashalgo, 0, digest, hvec, 2);\n  xfree (rawmpi);\n  if (rc)\n    {\n      xfree (digest);\n      return rc;\n    }\n  reverse_buffer (digest, 32);  \n  digest[0]   = (digest[0] & 0x7f) | 0x40;\n  digest[31] &= 0xf8;\n  *r_digest = digest;\n  return 0;\n}", "target": 0}
{"code": "void ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\tqsUsername = si->qsUsername;\n\tg.s.qsLastServer = si->qsName;\n\tQDialog::accept();\n}", "target": 0}
{"code": "static void ashtech_event_hook(struct gps_device_t *session, event_t event)\n{\n    if (session->context->readonly)\n\treturn;\n    if (event == event_wakeup)\n\t(void)nmea_send(session, \"$PASHQ,RID\");\n    if (event == event_identified) {\n\t(void)nmea_send(session, \"$PASHS,WAS,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,ALL,A,OFF\");\n#ifdef __future__\n\t(void)nmea_send(session, \"$PASHS,NME,POS,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,SAT,A,ON\");\n#else\n\t(void)nmea_send(session, \"$PASHS,NME,GGA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSA,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,GSV,A,ON\");\n\t(void)nmea_send(session, \"$PASHS,NME,RMC,A,ON\");\n#endif\n\t(void)nmea_send(session, \"$PASHS,NME,ZDA,A,ON\");\n    }\n}", "target": 0}
{"code": "static void InitPSDInfo(Image *image,Image *layer,PSDInfo *info)\n{\n  (void) memset(info,0,sizeof(*info));\n  info->version=1;\n  info->columns=layer->columns;\n  info->rows=layer->rows;\n  info->mode=10; \n  if (IsGrayImage(image,&image->exception) != MagickFalse)\n    info->channels=2U;\n  else\n    if (image->storage_class == PseudoClass)\n      {\n        info->mode=2;\n        info->channels=2U;\n      }\n    else\n      {\n        if (image->colorspace != CMYKColorspace)\n          info->channels=4U;\n        else\n          info->channels=5U;\n      }\n  if (image->matte == MagickFalse)\n    info->channels--;\n  info->min_channels=info->channels;\n  if (image->matte != MagickFalse)\n    info->min_channels--;\n}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, AveragePoolImageSize17) {\n  int image_size = 17;\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_AVERAGE_POOL_2D,\n      {TensorType_UINT8, {1, image_size, image_size, 1}, 0, 16},\n      image_size,\n      image_size,\n      {TensorType_UINT8, {}, 0, 16});\n  std::vector<float> input(image_size * image_size, 16.f);\n  m.SetInput(input);\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(), ::testing::ElementsAre(255));\n}", "target": 0}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "static const char *typeString(ut32 n, int *bits) {\n\t*bits = 32;\n\tif (n == 12) { \n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0100000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\tif (n == 0x0200000c) { \n\t\t*bits = 64;\n\t\treturn \"arm\";\n\t}\n\treturn \"x86\";\n}", "target": 0}
{"code": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}", "target": 1}
{"code": "decrypt(MPI output, MPI a, MPI b, ELG_secret_key *skey )\n{\n    MPI t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n    mpi_normalize (a);\n    mpi_normalize (b);\n    mpi_powm( t1, a, skey->x, skey->p );\n    mpi_invm( t1, t1, skey->p );\n    mpi_mulm( output, b, t1, skey->p );\n#if 0\n    if( DBG_CIPHER ) {\n\tlog_mpidump(\"elg decrypted x= \", skey->x);\n\tlog_mpidump(\"elg decrypted p= \", skey->p);\n\tlog_mpidump(\"elg decrypted a= \", a);\n\tlog_mpidump(\"elg decrypted b= \", b);\n\tlog_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n    mpi_free(t1);\n}", "target": 1}
{"code": "atoi_err(const char *nptr, int *val)\n{\n\tconst char *errstr = NULL;\n\tlong long num;\n\tif (nptr == NULL || *nptr == '\\0')\n\t\treturn \"missing\";\n\tnum = strtonum(nptr, 0, INT_MAX, &errstr);\n\tif (errstr == NULL)\n\t\t*val = (int)num;\n\treturn errstr;\n}", "target": 0}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tkeyring = ERR_PTR(-EINVAL);\n\tif (!name)\n\t\tgoto error;\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    type_data.link\n\t\t\t\t    ) {\n\t\t\tif (keyring->user->user_ns != current_user_ns())\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_inc(&keyring->usage);\n\t\t\tread_unlock(&keyring_name_lock);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tread_unlock(&keyring_name_lock);\n\tkeyring = ERR_PTR(-ENOKEY);\n error:\n\treturn keyring;\n} ", "target": 1}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "static int ptrace_signal(int signr, siginfo_t *info,\n\t\t\t struct pt_regs *regs, void *cookie)\n{\n\tif (!task_ptrace(current))\n\t\treturn signr;\n\tptrace_signal_deliver(regs, cookie);\n\tptrace_stop(signr, 0, info);\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\tcurrent->exit_code = 0;\n\tif (signr != info->si_signo) {\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = task_uid(current->parent);\n\t}\n\tif (sigismember(&current->blocked, signr)) {\n\t\tspecific_send_sig_info(signr, info, current);\n\t\tsignr = 0;\n\t}\n\treturn signr;\n}", "target": 0}
{"code": "MagickExport void DestroyImageProperties(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->properties != (void *) NULL)\n    image->properties=(void *) DestroySplayTree((SplayTreeInfo *)\n      image->properties);\n}", "target": 0}
{"code": "bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  try {\n    __u8 struct_v = 1;\n    ::decode(struct_v, iter);\n    ::decode(entity_name, iter);\n    ::decode(global_id, iter);\n  } catch (const buffer::error &err) {\n    ldout(cct, 0) << \"AuthNoneAuthorizeHandle::verify_authorizer() failed to decode\" << dendl;\n    return false;\n  }\n  caps_info.allow_all = true;\n  return true;\n}", "target": 1}
{"code": "dissect_header_lens_v1(tvbuff_t *tvb, int offset, proto_tree *tree, int encoding, int * const *hf_indexes)\n{\n    int param_count;\n    proto_item *ti;\n    proto_tree *len_tree;\n    for (param_count = 0; hf_indexes[param_count]; param_count++);\n    ti = proto_tree_add_item(tree, hf_se_param_lens, tvb, offset, param_count * SYSDIG_PARAM_SIZE, ENC_NA);\n    len_tree = proto_item_add_subtree(ti, ett_sysdig_parm_lens);\n    for (param_count = 0; hf_indexes[param_count]; param_count++) {\n        proto_tree_add_item(len_tree, hf_se_param_len, tvb, offset + (param_count * SYSDIG_PARAM_SIZE), SYSDIG_PARAM_SIZE, encoding);\n    }\n    proto_item_set_len(ti, param_count * SYSDIG_PARAM_SIZE);\n    return param_count * SYSDIG_PARAM_SIZE;\n}", "target": 0}
{"code": "static const char *findattr(STANZA *s, const char *key)\n{\n    int i = s->numpairs;\n    PAIR *pp = s->pairs;\n    for ( ; --i >= 0; pp++)\n        if (strcasecmp(pp->key, key) == 0)\n            return pp->value;\n    return NULL;\n}", "target": 0}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "KCleanup::selectionChanged( KFileInfo *selection )\n{\n    bool enabled = false;\n    _selection = selection;\n    if ( selection )\n    {\n\tenabled = worksFor( selection );\n\tif ( ! selection->isFinished() )\n\t{\n\t    switch ( _refreshPolicy )\n\t    {\n\t\tcase refreshThis:\n\t\tcase refreshParent:\n\t\tcase assumeDeleted:\n\t\t    enabled = false;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n    }\n    KAction::setEnabled( enabled );\n}", "target": 0}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "static int update_private_key(const u8 *key, size_t keysize)\n{\n\tint r, idx = 0;\n\tsc_path_t path;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tidx = keysize * (opt_key_num-1);\n\tr = sc_update_binary(card, idx, key, keysize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to write private key: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "static int mem_cgroup_charge_common(struct page *page, struct mm_struct *mm,\n\t\t\t\tgfp_t gfp_mask, enum charge_type ctype)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tunsigned int nr_pages = 1;\n\tstruct page_cgroup *pc;\n\tbool oom = true;\n\tint ret;\n\tif (PageTransHuge(page)) {\n\t\tnr_pages <<= compound_order(page);\n\t\tVM_BUG_ON(!PageTransHuge(page));\n\t\toom = false;\n\t}\n\tpc = lookup_page_cgroup(page);\n\tret = __mem_cgroup_try_charge(mm, gfp_mask, nr_pages, &memcg, oom);\n\tif (ret == -ENOMEM)\n\t\treturn ret;\n\t__mem_cgroup_commit_charge(memcg, page, nr_pages, pc, ctype);\n\treturn 0;\n}", "target": 0}
{"code": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\told = xchg(p, posix_acl_dup(acl));\n\tif (!is_uncached_acl(old))\n\t\tposix_acl_release(old);\n}", "target": 0}
{"code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}", "target": 1}
{"code": "static inline uint8_t ok_read_uint8(ok_jpg_decoder *decoder) {\n    if (decoder->input_buffer_start == decoder->input_buffer_end) {\n        size_t len = decoder->input.read(decoder->input_user_data, decoder->input_buffer,\n                                         sizeof(decoder->input_buffer));\n        decoder->input_buffer_start = decoder->input_buffer;\n        decoder->input_buffer_end = decoder->input_buffer + len;\n        if (len == 0) {\n            return 0;\n        }\n    }\n    return *decoder->input_buffer_start++;\n}", "target": 0}
{"code": "void TDStretch::setChannels(int numChannels)\n{\n    assert(numChannels > 0);\n    if (channels == numChannels) return;\n    channels = numChannels;\n    inputBuffer.setChannels(channels);\n    outputBuffer.setChannels(channels);\n    overlapLength=0;\n    setParameters(sampleRate);\n}", "target": 1}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void handle_swbp(struct pt_regs *regs)\n{\n\tstruct uprobe *uprobe;\n\tunsigned long bp_vaddr;\n\tint uninitialized_var(is_swbp);\n\tbp_vaddr = uprobe_get_swbp_addr(regs);\n\tif (bp_vaddr == get_trampoline_vaddr())\n\t\treturn handle_trampoline(regs);\n\tuprobe = find_active_uprobe(bp_vaddr, &is_swbp);\n\tif (!uprobe) {\n\t\tif (is_swbp > 0) {\n\t\t\tsend_sig(SIGTRAP, current, 0);\n\t\t} else {\n\t\t\tinstruction_pointer_set(regs, bp_vaddr);\n\t\t}\n\t\treturn;\n\t}\n\tinstruction_pointer_set(regs, bp_vaddr);\n\tsmp_rmb(); \n\tif (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))\n\t\tgoto out;\n\tif (!get_utask())\n\t\tgoto out;\n\tif (arch_uprobe_ignore(&uprobe->arch, regs))\n\t\tgoto out;\n\thandler_chain(uprobe, regs);\n\tif (arch_uprobe_skip_sstep(&uprobe->arch, regs))\n\t\tgoto out;\n\tif (!pre_ssout(uprobe, regs, bp_vaddr))\n\t\treturn;\nout:\n\tput_uprobe(uprobe);\n}", "target": 0}
{"code": "static void decode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n{\n    int x, y, p;\n    int16_t *sample[4][2];\n    int lbd    = s->avctx->bits_per_raw_sample <= 8;\n    int bits   = s->avctx->bits_per_raw_sample > 0 ? s->avctx->bits_per_raw_sample : 8;\n    int offset = 1 << bits;\n    for (x = 0; x < 4; x++) {\n        sample[x][0] = s->sample_buffer +  x * 2      * (w + 6) + 3;\n        sample[x][1] = s->sample_buffer + (x * 2 + 1) * (w + 6) + 3;\n    }\n    s->run_index = 0;\n    memset(s->sample_buffer, 0, 8 * (w + 6) * sizeof(*s->sample_buffer));\n    for (y = 0; y < h; y++) {\n        for (p = 0; p < 3 + s->transparency; p++) {\n            int16_t *temp = sample[p][0]; \n            sample[p][0] = sample[p][1];\n            sample[p][1] = temp;\n            sample[p][1][-1]= sample[p][0][0  ];\n            sample[p][0][ w]= sample[p][0][w-1];\n            if (lbd && s->slice_coding_mode == 0)\n                decode_line(s, w, sample[p], (p + 1)/2, 9);\n            else\n                decode_line(s, w, sample[p], (p + 1)/2, bits + (s->slice_coding_mode != 1));\n        }\n        for (x = 0; x < w; x++) {\n            int g = sample[0][1][x];\n            int b = sample[1][1][x];\n            int r = sample[2][1][x];\n            int a = sample[3][1][x];\n            if (s->slice_coding_mode != 1) {\n                b -= offset;\n                r -= offset;\n                g -= (b * s->slice_rct_by_coef + r * s->slice_rct_ry_coef) >> 2;\n                b += g;\n                r += g;\n            }\n            if (lbd)\n                *((uint32_t*)(src[0] + x*4 + stride[0]*y)) = b + (g<<8) + (r<<16) + (a<<24);\n            else {\n                *((uint16_t*)(src[0] + x*2 + stride[0]*y)) = b;\n                *((uint16_t*)(src[1] + x*2 + stride[1]*y)) = g;\n                *((uint16_t*)(src[2] + x*2 + stride[2]*y)) = r;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int idr_get_empty_slot(struct idr *idp, int starting_id,\n\t\t\t      struct idr_layer **pa)\n{\n\tstruct idr_layer *p, *new;\n\tint layers, v, id;\n\tunsigned long flags;\n\tid = starting_id;\nbuild_up:\n\tp = idp->top;\n\tlayers = idp->layers;\n\tif (unlikely(!p)) {\n\t\tif (!(p = get_from_free_list(idp)))\n\t\t\treturn -1;\n\t\tp->layer = 0;\n\t\tlayers = 1;\n\t}\n\twhile ((layers < (MAX_LEVEL - 1)) && (id >= (1 << (layers*IDR_BITS)))) {\n\t\tlayers++;\n\t\tif (!p->count) {\n\t\t\tp->layer++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(new = get_from_free_list(idp))) {\n\t\t\tspin_lock_irqsave(&idp->lock, flags);\n\t\t\tfor (new = p; p && p != idp->top; new = p) {\n\t\t\t\tp = p->ary[0];\n\t\t\t\tnew->ary[0] = NULL;\n\t\t\t\tnew->bitmap = new->count = 0;\n\t\t\t\t__move_to_free_list(idp, new);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&idp->lock, flags);\n\t\t\treturn -1;\n\t\t}\n\t\tnew->ary[0] = p;\n\t\tnew->count = 1;\n\t\tnew->layer = layers-1;\n\t\tif (p->bitmap == IDR_FULL)\n\t\t\t__set_bit(0, &new->bitmap);\n\t\tp = new;\n\t}\n\trcu_assign_pointer(idp->top, p);\n\tidp->layers = layers;\n\tv = sub_alloc(idp, &id, pa);\n\tif (v == IDR_NEED_TO_GROW)\n\t\tgoto build_up;\n\treturn(v);\n}", "target": 0}
{"code": "ciKlass* ciEnv::get_klass_by_index(const constantPoolHandle& cpool,\n                                   int index,\n                                   bool& is_accessible,\n                                   ciInstanceKlass* accessor) {\n  GUARDED_VM_ENTRY(return get_klass_by_index_impl(cpool, index, is_accessible, accessor);)\n}", "target": 0}
{"code": "static int MVGMacroCompare(const void *target,const void *source)\n{\n  const char\n    *p,\n    *q;\n  p=(const char *) target;\n  q=(const char *) source;\n  return(strcmp(p,q));\n}", "target": 0}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "void smp_send_pair_rsp(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  p_cb->local_i_key &= p_cb->peer_i_key;\n  p_cb->local_r_key &= p_cb->peer_r_key;\n if (smp_send_cmd(SMP_OPCODE_PAIRING_RSP, p_cb)) {\n if (p_cb->selected_association_model == SMP_MODEL_SEC_CONN_OOB)\n      smp_use_oob_private_key(p_cb, NULL);\n else\n      smp_decide_association_model(p_cb, NULL);\n }\n}", "target": 0}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "bool OmniboxViewWin::IsCommandIdChecked(int command_id) const {\n  return false;\n}", "target": 0}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n      free(p_cdtext_data);\n    }\n  }\n  return p_env->cdtext;\n}", "target": 1}
{"code": "int JOIN::init_join_caches()\n{\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(this, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab;\n       tab= next_linear_tab(this, tab, WITH_BUSH_ROOTS))\n  {\n    TABLE *table= tab->table;\n    if (table->file->keyread_enabled())\n    {\n      if (!(table->file->index_flags(table->file->keyread, 0, 1) & HA_CLUSTERED_INDEX))\n        table->mark_index_columns(table->file->keyread, table->read_set);\n    }\n    else if ((tab->read_first_record == join_read_first ||\n              tab->read_first_record == join_read_last) &&\n             !tab->filesort && table->covering_keys.is_set(tab->index) &&\n             !table->no_keyread)\n    {\n      table->prepare_for_keyread(tab->index, table->read_set);\n    }\n    if (tab->cache && tab->cache->init(select_options & SELECT_DESCRIBE))\n      revise_cache_usage(tab);\n    else\n      tab->remove_redundant_bnl_scan_conds();\n  }\n  return 0;\n}", "target": 0}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_disconnect_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_monitor_file *df = NULL, *_df;\n\tspin_lock(&shutdown_lock);\n\tlist_for_each_entry(_df, &shutdown_files, shutdown_list) {\n\t\tif (_df->file == file) {\n\t\t\tdf = _df;\n\t\t\tlist_del_init(&df->shutdown_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&shutdown_lock);\n\tif (likely(df)) {\n\t\tif ((file->f_flags & FASYNC) && df->disconnected_f_op->fasync)\n\t\t\tdf->disconnected_f_op->fasync(-1, file, 0);\n\t\treturn df->disconnected_f_op->release(inode, file);\n\t}\n\tpanic(\"%s(%p, %p) failed!\", __func__, inode, file);\n}", "target": 0}
{"code": "void usbredirparser_init(struct usbredirparser *parser_pub,\n    const char *version, uint32_t *caps, int caps_len, int flags)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    struct usb_redir_hello_header hello = { { 0 }, };\n    parser->flags = (flags & ~usbredirparser_fl_no_hello);\n    if (parser->callb.alloc_lock_func) {\n        parser->lock = parser->callb.alloc_lock_func();\n    }\n    snprintf(hello.version, sizeof(hello.version), \"%s\", version);\n    if (caps_len > USB_REDIR_CAPS_SIZE) {\n        caps_len = USB_REDIR_CAPS_SIZE;\n    }\n    memcpy(parser->our_caps, caps, caps_len * sizeof(uint32_t));\n    if (!(flags & usbredirparser_fl_usb_host))\n        usbredirparser_caps_set_cap(parser->our_caps,\n                                    usb_redir_cap_device_disconnect_ack);\n    usbredirparser_verify_caps(parser, parser->our_caps, \"our\");\n    if (!(flags & usbredirparser_fl_no_hello))\n        usbredirparser_queue(parser_pub, usb_redir_hello, 0, &hello,\n                             (uint8_t *)parser->our_caps,\n                             USB_REDIR_CAPS_SIZE * sizeof(uint32_t));\n}", "target": 0}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "bool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); \n  }\n  return true;\n}", "target": 1}
{"code": "prefix_code(uint8_t *data, size_t size)\n{\n\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n\treturn 0;\n}", "target": 0}
{"code": "int ldb_match_message(struct ldb_context *ldb,\n\t\t      const struct ldb_message *msg,\n\t\t      const struct ldb_parse_tree *tree,\n\t\t      enum ldb_scope scope, bool *matched)\n{\n\tunsigned int i;\n\tint ret;\n\t*matched = false;\n\tif (scope != LDB_SCOPE_BASE && ldb_dn_is_special(msg->dn)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tswitch (tree->operation) {\n\tcase LDB_OP_AND:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (!*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_OR:\n\t\tfor (i=0;i<tree->u.list.num_elements;i++) {\n\t\t\tret = ldb_match_message(ldb, msg, tree->u.list.elements[i], scope, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_NOT:\n\t\tret = ldb_match_message(ldb, msg, tree->u.isnot.child, scope, matched);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t*matched = ! *matched;\n\t\treturn LDB_SUCCESS;\n\tcase LDB_OP_EQUALITY:\n\t\treturn ldb_match_equality(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_SUBSTRING:\n\t\treturn ldb_match_substring(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_GREATER:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_GREATER, matched);\n\tcase LDB_OP_LESS:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_LESS, matched);\n\tcase LDB_OP_PRESENT:\n\t\treturn ldb_match_present(ldb, msg, tree, scope, matched);\n\tcase LDB_OP_APPROX:\n\t\treturn ldb_match_comparison(ldb, msg, tree, scope, LDB_OP_APPROX, matched);\n\tcase LDB_OP_EXTENDED:\n\t\treturn ldb_match_extended(ldb, msg, tree, scope, matched);\n\t}\n\treturn LDB_ERR_INAPPROPRIATE_MATCHING;\n}", "target": 0}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "u32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}", "target": 0}
{"code": "static void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}", "target": 1}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "    template<typename t, typename tc>\n    CImg<T>& draw_axis(const int x, const CImg<t>& values_y,\n                       const tc *const color, const float opacity=1,\n                       const unsigned int pattern=~0U, const unsigned int font_height=13,\n                       const bool allow_zero=true) {\n      if (is_empty()) return *this;\n      int siz = (int)values_y.size() - 1;\n      CImg<charT> txt(32);\n      CImg<T> label;\n      if (siz<=0) { \n        draw_line(x,0,x,_height - 1,color,opacity,pattern);\n        if (!siz) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)*values_y);\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            _yt = (height() - label.height())/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      } else { \n        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);\n        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);\n        cimg_foroff(values_y,y) {\n          cimg_snprintf(txt,txt._width,\"%g\",(double)values_y(y));\n          label.assign().draw_text(0,0,txt,color,(tc*)0,opacity,font_height);\n          const int\n            yi = (int)(y*(_height - 1)/siz),\n            _yt = yi - label.height()/2,\n            yt = _yt<0?0:_yt + label.height()>=height()?height() - 1-label.height():_yt,\n            _xt = x - 2 - label.width(),\n            xt = _xt>=0?_xt:x + 3;\n          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);\n          if (allow_zero || *txt!='0' || txt[1]!=0)\n            draw_text(xt,yt,txt,color,(tc*)0,opacity,font_height);\n        }\n      }\n      return *this;", "target": 0}
{"code": "managesieve_parser_read_string(struct managesieve_parser *parser,\n\t\t\t\t   const unsigned char *data, size_t data_size)\n{\n\tsize_t i;\n\tfor (i = parser->cur_pos; i < data_size; i++) {\n\t\tif (data[i] == '\"') {\n\t\t\tif ( !uni_utf8_data_is_valid(data+1, i-1) ) {\n\t\t\t\tparser->error = \"Invalid UTF-8 character in quoted-string.\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tmanagesieve_parser_save_arg(parser, data, i);\n\t\t\ti++; \n\t\t\tbreak;\n\t\t}\n\t\tif (data[i] == '\\\\') {\n\t\t\tif (i+1 == data_size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parser->str_first_escape < 0)\n\t\t\t\tparser->str_first_escape = i;\n\t\t\ti++;\n\t\t\tif ( !IS_QUOTED_SPECIAL(data[i]) ) {\n\t\t\t\tparser->error =\n\t\t\t\t\t\"Escaped quoted-string character is not a QUOTED-SPECIAL.\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ( (data[i] & 0x80) == 0 && !IS_SAFE_CHAR(data[i]) ) {\n\t\t\tparser->error = \"String contains invalid character.\";\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tparser->cur_pos = i;\n\treturn ( parser->cur_type == ARG_PARSE_NONE );\n}", "target": 1}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  SeenContainers seen;\n  return recursiveAddVarImpl(varName, varVariant, hasVarTag, seen);\n}", "target": 0}
{"code": "   Read the full structure of a message */\nPHP_FUNCTION(imap_fetchstructure)\n{\n\tzval *streamind;\n\tzend_long msgno, flags = 0;\n\tpils *imap_le_struct;\n\tBODY *body;\n\tint msgindex, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rl|l\", &streamind, &msgno, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags && ((flags & ~FT_UID) != 0)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"invalid value for the options parameter\");\n\t\tRETURN_FALSE;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (msgno < 1) {\n\t\tRETURN_FALSE;\n\t}\n\tobject_init(return_value);\n\tif ((argc == 3) && (flags & FT_UID)) {\n\t\tmsgindex = mail_msgno(imap_le_struct->imap_stream, msgno);\n\t} else {\n\t\tmsgindex = msgno;\n\t}\n\tPHP_IMAP_CHECK_MSGNO(msgindex);\n\tmail_fetchstructure_full(imap_le_struct->imap_stream, msgno, &body , (argc == 3 ? flags : NIL));\n\tif (!body) {\n\t\tphp_error_docref(NULL, E_WARNING, \"No body information available\");\n\t\tRETURN_FALSE;\n\t}\n\t_php_imap_add_body(return_value, body);", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "    size_t Iptcdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n    sigpipe_ignore(conn->data, &pipe_st);\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}", "target": 1}
{"code": "_XimEncodeStatusValue(\n    Xic\t\t\t ic,\n    XIMResourceList\t res,\n    XIMArg\t\t*p)\n{\n    if (res->xrm_name == XrmStringToQuark(XNStdColormap)) {\n\tXStandardColormap\t*colormap_ret = NULL;\n\tint\t\t\t count;\n\tif (!(XGetRGBColormaps(ic->core.im->core.display,\n\t\t\t\tic->core.focus_window, &colormap_ret,\n\t\t\t\t&count, (Atom)p->value)))\n\t    return False;\n\tXFree(colormap_ret);\n    } else if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tint\t\t  list_ret;\n\tXFontStruct\t**struct_list;\n\tchar\t\t**name_list;\n\tchar\t\t *tmp;\n\tint\t\t  len;\n\tregister int\t  i;\n\tif (!p->value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)p->value,\n\t\t\t\t\t\t &struct_list, &name_list);\n\tfor (i = 0, len = 0; i < list_ret; i++) {\n\t     len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif (!(tmp = Xmalloc(len+1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "resolveTable (const char *tableList, const char *base)\n{\n  return (*tableResolver) (tableList, base);\n}", "target": 0}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "static void unclear_tables(JOIN *join, table_map *cleared_tables)\n{\n  for (uint i= 0 ; i < join->table_count ; i++)\n  {\n    if ((*cleared_tables) & (((table_map) 1) << i))\n    {\n      TABLE *table= join->table[i];\n      if (table->s->null_bytes)\n        memcpy(table->null_flags, table->record[1], table->s->null_bytes);\n      unmark_as_null_row(table);\n    }\n  }\n}", "target": 0}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "static inline void GetMeanPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  double\n    sum;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sum);\n}", "target": 0}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isAttributeSupported(JSStringRef attribute)\n{\n    return false;\n}", "target": 0}
{"code": "static void sev_es_sync_from_ghcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tstruct ghcb *ghcb = svm->ghcb;\n\tu64 exit_code;\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs[VCPU_REGS_RAX] = ghcb_get_rax_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RBX] = ghcb_get_rbx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RCX] = ghcb_get_rcx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RDX] = ghcb_get_rdx_if_valid(ghcb);\n\tvcpu->arch.regs[VCPU_REGS_RSI] = ghcb_get_rsi_if_valid(ghcb);\n\tsvm->vmcb->save.cpl = ghcb_get_cpl_if_valid(ghcb);\n\tif (ghcb_xcr0_is_valid(ghcb)) {\n\t\tvcpu->arch.xcr0 = ghcb_get_xcr0(ghcb);\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t}\n\texit_code = ghcb_get_sw_exit_code(ghcb);\n\tcontrol->exit_code = lower_32_bits(exit_code);\n\tcontrol->exit_code_hi = upper_32_bits(exit_code);\n\tcontrol->exit_info_1 = ghcb_get_sw_exit_info_1(ghcb);\n\tcontrol->exit_info_2 = ghcb_get_sw_exit_info_2(ghcb);\n\tmemset(ghcb->save.valid_bitmap, 0, sizeof(ghcb->save.valid_bitmap));\n}", "target": 0}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "gen_k( gcry_mpi_t p, int small_k )\n{\n  gcry_mpi_t k = mpi_alloc_secure( 0 );\n  gcry_mpi_t temp = mpi_alloc( mpi_get_nlimbs(p) );\n  gcry_mpi_t p_1 = mpi_copy(p);\n  unsigned int orig_nbits = mpi_get_nbits(p);\n  unsigned int nbits, nbytes;\n  char *rndbuf = NULL;\n  if (small_k)\n    {\n      nbits = wiener_map( orig_nbits ) * 3 / 2;\n      if( nbits >= orig_nbits )\n        BUG();\n    }\n  else\n    nbits = orig_nbits;\n  nbytes = (nbits+7)/8;\n  if( DBG_CIPHER )\n    log_debug(\"choosing a random k\\n\");\n  mpi_sub_ui( p_1, p, 1);\n  for(;;)\n    {\n      if( !rndbuf || nbits < 32 )\n        {\n          xfree(rndbuf);\n          rndbuf = _gcry_random_bytes_secure( nbytes, GCRY_STRONG_RANDOM );\n        }\n      else\n        {\n          char *pp = _gcry_random_bytes_secure( 4, GCRY_STRONG_RANDOM );\n          memcpy( rndbuf, pp, 4 );\n          xfree(pp);\n\t}\n      _gcry_mpi_set_buffer( k, rndbuf, nbytes, 0 );\n      for(;;)\n        {\n          if( !(mpi_cmp( k, p_1 ) < 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('+');\n              break; \n            }\n          if( !(mpi_cmp_ui( k, 0 ) > 0) )  \n            {\n              if( DBG_CIPHER )\n                progress('-');\n              break; \n            }\n          if (mpi_gcd( temp, k, p_1 ))\n            goto found;  \n          mpi_add_ui( k, k, 1 );\n          if( DBG_CIPHER )\n            progress('.');\n\t}\n    }\n found:\n  xfree (rndbuf);\n  if( DBG_CIPHER )\n    progress('\\n');\n  mpi_free(p_1);\n  mpi_free(temp);\n  return k;\n}", "target": 0}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}", "target": 1}
{"code": "_gnutls_x509_encode_and_copy_PKI_params(ASN1_TYPE dst,\n\t\t\t\t\tconst char *dst_name,\n\t\t\t\t\tgnutls_pk_algorithm_t\n\t\t\t\t\tpk_algorithm,\n\t\t\t\t\tgnutls_pk_params_st * params)\n{\n\tconst char *pk;\n\tgnutls_datum_t der = { NULL, 0 };\n\tint result;\n\tchar name[128];\n\tpk = _gnutls_x509_pk_to_oid(pk_algorithm);\n\tif (pk == NULL) {\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_UNKNOWN_PK_ALGORITHM;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.algorithm\");\n\tresult = asn1_write_value(dst, name, pk, 1);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult =\n\t    _gnutls_x509_write_pubkey_params(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".algorithm.parameters\");\n\tresult = asn1_write_value(dst, name, der.data, der.size);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _gnutls_x509_write_pubkey(pk_algorithm, params, &der);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\t_asnstr_append_name(name, sizeof(name), dst_name,\n\t\t\t    \".subjectPublicKey\");\n\tresult = asn1_write_value(dst, name, der.data, der.size * 8);\n\t_gnutls_free_datum(&der);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "static inline struct kvm_mmu_page *page_header(hpa_t shadow_page)\n{\n\tstruct page *page = pfn_to_page(shadow_page >> PAGE_SHIFT);\n\treturn (struct kvm_mmu_page *)page_private(page);\n}", "target": 0}
{"code": "LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem& value) {\n  LIR_Opr result = new_register(type);\n  value.load_item();\n  __ move(value.result(), result);\n  assert(type == T_INT LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n  __ xadd(addr, result, result, LIR_OprFact::illegalOpr);\n  return result;\n}", "target": 0}
{"code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "target": 1}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "static void prio_changed_fair(struct rq *rq, struct task_struct *p,\n\t\t\t      int oldprio, int running)\n{\n\tif (running) {\n\t\tif (p->prio > oldprio)\n\t\t\tresched_task(rq->curr);\n\t} else\n\t\tcheck_preempt_curr(rq, p);\n}", "target": 0}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher %s has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "static int _assemble_line(FILE *f, char *buffer, int buf_len)\n{\n    char *p = buffer;\n    char *s, *os;\n    int used = 0;\n    D((\"called.\"));\n    for (;;) {\n\tif (used >= buf_len) {\n\t    D((\"_assemble_line: overflow\"));\n\t    return -1;\n\t}\n\tif (fgets(p, buf_len - used, f) == NULL) {\n\t    if (used) {\n\t\treturn -1;\n\t    } else {\n\t\treturn 0;\n\t    }\n\t}\n\ts = p + strspn(p, \" \\n\\t\");\n\tif (*s && (*s != '#')) {\n\t    os = s;\n\t    while (*s && *s != '#')\n\t\t ++s;\n\t    if (*s == '#') {\n\t\t *s = '\\0';\n\t\t used += strlen(os);\n\t\t break;                \n\t    }\n\t    s = os;\n\t    s += strlen(s);\n\t    while (s > os && ((*--s == ' ') || (*s == '\\t')\n\t\t\t      || (*s == '\\n')));\n\t    if (*s == '\\\\') {\n\t\t*s = '\\0';              \n\t\tused += strlen(os);\n\t\tp = s;                  \n\t    } else {\n\t\tused += strlen(os);\n\t\tbreak;                  \n\t    }\n\t} else {\n\t}\n    }\n    return used;\n}", "target": 0}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}", "target": 1}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "KCleanup::itemDir( const KFileInfo *item ) const\n{\n    QString dir = item->url();\n    if ( ! item->isDir() && ! item->isDotEntry() )\n    {\n\tdir.replace ( QRegExp ( \"/[^/]*$\" ), \"\" );\n    }\n    return dir;\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 1}
{"code": "void ogs_nas_5gs_mobile_identity_guti_to_nas_guti(\n        ogs_nas_5gs_mobile_identity_guti_t *mobile_identity_guti,\n        ogs_nas_5gs_guti_t *nas_guti)\n{\n    ogs_assert(mobile_identity_guti);\n    ogs_assert(nas_guti);\n    memset(nas_guti, 0, sizeof(*nas_guti));\n    memcpy(&nas_guti->nas_plmn_id,\n            &mobile_identity_guti->nas_plmn_id, OGS_PLMN_ID_LEN);\n    memcpy(&nas_guti->amf_id,\n            &mobile_identity_guti->amf_id, sizeof(ogs_amf_id_t));\n    nas_guti->m_tmsi = be32toh(mobile_identity_guti->m_tmsi);\n}", "target": 0}
{"code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n    appended_lines_mark(n, count);\n    msgmore((long)count);\n}", "target": 1}
{"code": "char *cgit_repourl(const char *reponame)\n{\n\tif (ctx.cfg.virtual_root)\n\t\treturn fmtalloc(\"%s%s/\", ctx.cfg.virtual_root, reponame);\n\telse\n\t\treturn fmtalloc(\"?r=%s\", reponame);\n}", "target": 0}
{"code": "static void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,\n\t\tstruct x86_exception *fault)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu32 exit_reason;\n\tif (fault->error_code & PFERR_RSVD_MASK)\n\t\texit_reason = EXIT_REASON_EPT_MISCONFIG;\n\telse\n\t\texit_reason = EXIT_REASON_EPT_VIOLATION;\n\tnested_vmx_vmexit(vcpu, exit_reason, 0, vcpu->arch.exit_qualification);\n\tvmcs12->guest_physical_address = fault->address;\n}", "target": 0}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "MagickPrivate size_t GetOptimalKernelWidth2D(const double radius,\n  const double sigma)\n{\n  double\n    alpha,\n    beta,\n    gamma,\n    normalize,\n    value;\n  size_t\n    width;\n  ssize_t\n    j,\n    u,\n    v;\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (radius > MagickEpsilon)\n    return((size_t) (2.0*ceil(radius)+1.0));\n  gamma=fabs(sigma);\n  if (gamma <= MagickEpsilon)\n    return(3UL);\n  alpha=PerceptibleReciprocal(2.0*gamma*gamma);\n  beta=(double) PerceptibleReciprocal((double) Magick2PI*gamma*gamma);\n  for (width=5; ; )\n  {\n    normalize=0.0;\n    j=(ssize_t) (width-1)/2;\n    for (v=(-j); v <= j; v++)\n      for (u=(-j); u <= j; u++)\n        normalize+=exp(-((double) (u*u+v*v))*alpha)*beta;\n    value=exp(-((double) (j*j))*alpha)*beta/normalize;\n    if ((value < QuantumScale) || (value < MagickEpsilon))\n      break;\n    width+=2;\n  }\n  return((size_t) (width-2));\n}", "target": 0}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "static inline void ConvertXYZToRGB(const double X,const double Y,const double Z,\n  double *red,double *green,double *blue)\n{\n  double\n    b,\n    g,\n    r;\n  assert(red != (double *) NULL);\n  assert(green != (double *) NULL);\n  assert(blue != (double *) NULL);\n  r=3.2404542*X-1.5371385*Y-0.4985314*Z;\n  g=(-0.9692660)*X+1.8760108*Y+0.0415560*Z;\n  b=0.0556434*X-0.2040259*Y+1.0572252*Z;\n  *red=EncodePixelGamma(QuantumRange*r);\n  *green=EncodePixelGamma(QuantumRange*g);\n  *blue=EncodePixelGamma(QuantumRange*b);\n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == 0xF2) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xD3;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xF3;\n      }\n    }\n    else if (code == 0xB5) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xCC;\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode = 0xEC;\n      }\n    }\n    else if (code == 0xC0 || code == 0xE0 || code == 0xB6)\n      ;\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_CP1253_TO_LOWER_CASE(code);\n    }\n    else if ((EncCP1253_CtypeTable[code] & BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 0xDC)\n\tcode = 0xA2;\n      else if (code >= 0xDD && code <= 0xDF)\n\tcode -= 0x25;\n      else if (code == 0xFC)\n\tcode = 0xBC;\n      else if (code == 0xFD || code == 0xFE)\n\tcode -= 0x3F;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "    void CiffHeader::print(std::ostream& os, const std::string& prefix) const\n    {\n        std::ios::fmtflags f( os.flags() );\n        os << prefix\n           << _(\"Header, offset\") << \" = 0x\" << std::setw(8) << std::setfill('0')\n           << std::hex << std::right << offset_ << \"\\n\";\n        if (pRootDir_) pRootDir_->print(os, byteOrder_, prefix);\n        os.flags(f);\n    } ", "target": 0}
{"code": "    ExifData::iterator ExifData::erase(ExifData::iterator pos)\n    {\n        return exifMetadata_.erase(pos);\n    }", "target": 0}
{"code": "static void io_async_task_func(struct callback_head *cb)\n{\n\tstruct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);\n\tstruct async_poll *apoll = req->apoll;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\ttrace_io_uring_task_run(req->ctx, req->opcode, req->user_data);\n\tif (io_poll_rewait(req, &apoll->poll)) {\n\t\tspin_unlock_irq(&ctx->completion_lock);\n\t\treturn;\n\t}\n\tif (hash_hashed(&req->hash_node))\n\t\thash_del(&req->hash_node);\n\tio_poll_remove_double(req, apoll->double_poll);\n\tspin_unlock_irq(&ctx->completion_lock);\n\tif (!READ_ONCE(apoll->poll.canceled))\n\t\t__io_req_task_submit(req);\n\telse\n\t\t__io_req_task_cancel(req, -ECANCELED);\n\tkfree(apoll->double_poll);\n\tkfree(apoll);\n}", "target": 1}
{"code": "static const char *set_limit_mem(cmd_parms *cmd, void *conf_,\n                                 const char *arg, const char * arg2)\n{\n    core_dir_config *conf = conf_;\n#if defined(RLIMIT_AS)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);\n#elif defined(RLIMIT_DATA)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);\n#elif defined(RLIMIT_VMEM)\n    ap_unixd_set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);\n#endif\n    return NULL;\n}", "target": 0}
{"code": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n  hb_ot_layout_t *layout = &face->ot_layout;\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "intrusive_ptr<Expression> Expression::parseObject(ExpressionContext* const expCtx,\n                                                  BSONObj obj,\n                                                  const VariablesParseState& vps) {\n    if (obj.isEmpty()) {\n        return ExpressionObject::create(expCtx, {});\n    }\n    if (obj.firstElementFieldName()[0] == '$') {\n        return parseExpression(expCtx, obj, vps);\n    }\n    return ExpressionObject::parse(expCtx, obj, vps);\n}", "target": 0}
{"code": "int sysctl_numa_balancing(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table t;\n\tint err;\n\tint state = static_branch_likely(&sched_numa_balancing);\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tt = *table;\n\tt.data = &state;\n\terr = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);\n\tif (err < 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}", "target": 0}
{"code": "gdk_pixbuf__bmp_image_begin_load(GdkPixbufModuleSizeFunc size_func,\n                                 GdkPixbufModulePreparedFunc prepared_func,\n\t\t\t\t GdkPixbufModuleUpdatedFunc updated_func,\n                                 gpointer user_data,\n                                 GError **error)\n{\n\tstruct bmp_progressive_state *context;\n\tcontext = g_new0(struct bmp_progressive_state, 1);\n\tcontext->size_func = size_func;\n\tcontext->prepared_func = prepared_func;\n\tcontext->updated_func = updated_func;\n\tcontext->user_data = user_data;\n\tcontext->read_state = READ_STATE_HEADERS;\n\tcontext->BufferSize = 26;\n\tcontext->BufferPadding = 0;\n\tcontext->buff = g_malloc(26);\n\tcontext->BufferDone = 0;\n\tcontext->Colormap = NULL;\n\tcontext->Lines = 0;\n\tcontext->Type = 0;\n\tmemset(&context->Header, 0, sizeof(struct headerpair));\n\tmemset(&context->compr, 0, sizeof(struct bmp_compression_state));\n\tcontext->pixbuf = NULL;\n\treturn (gpointer) context;\n}", "target": 0}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "assegment_free (struct assegment *seg)\n{\n  if (!seg)\n    return;\n  if (seg->as)\n    assegment_data_free (seg->as);\n  memset (seg, 0xfe, sizeof(struct assegment));\n  XFREE (MTYPE_AS_SEG, seg);\n  return;\n}", "target": 0}
{"code": "xmlParseElementEnd(xmlParserCtxtPtr ctxt) {\n    xmlParserNodeInfo node_info;\n    xmlNodePtr ret = ctxt->node;\n    if (ctxt->nameNr <= 0)\n        return;\n    if (ctxt->sax2) {\n        const xmlChar *prefix = ctxt->pushTab[ctxt->nameNr * 3 - 3];\n        const xmlChar *URI = ctxt->pushTab[ctxt->nameNr * 3 - 2];\n        int nsNr = (ptrdiff_t) ctxt->pushTab[ctxt->nameNr * 3 - 1];\n\txmlParseEndTag2(ctxt, prefix, URI, 0, nsNr, 0);\n\tnamePop(ctxt);\n    }\n#ifdef LIBXML_SAX1_ENABLED\n    else\n\txmlParseEndTag1(ctxt, 0);\n#endif \n    if ( ret != NULL && ctxt->record_info ) {\n       node_info.end_pos = ctxt->input->consumed +\n                          (CUR_PTR - ctxt->input->base);\n       node_info.end_line = ctxt->input->line;\n       node_info.node = ret;\n       xmlParserAddNodeInfo(ctxt, &node_info);\n    }\n}", "target": 0}
{"code": "METHODDEF(JDIMENSION)\nget_32bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  JSAMPARRAY image_ptr;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  if (source->use_inversion_array) {\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_EXT_BGRX ||\n      cinfo->in_color_space == JCS_EXT_BGRA) {\n    MEMCOPY(outptr, inptr, source->row_width);\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      JSAMPLE b = *inptr++, g = *inptr++, r = *inptr++;\n      rgb_to_cmyk(r, g, b, outptr, outptr + 1, outptr + 2, outptr + 3);\n      inptr++;                          \n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        outptr[aindex] = *inptr++;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        outptr[bindex] = *inptr++;      \n        outptr[gindex] = *inptr++;\n        outptr[rindex] = *inptr++;\n        inptr++;                        \n        outptr += ps;\n      }\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "bool IsIDNComponentInSingleScript(const char16* str, int str_len) {\n  UScriptCode first_script = USCRIPT_INVALID_CODE;\n  bool is_first = true;\n  int i = 0;\n  while (i < str_len) {\n    unsigned code_point;\n    U16_NEXT(str, i, str_len, code_point);\n    UErrorCode err = U_ZERO_ERROR;\n    UScriptCode cur_script = uscript_getScript(code_point, &err);\n    if (err != U_ZERO_ERROR)\n      return false;  \n    cur_script = NormalizeScript(cur_script);\n    if (is_first && cur_script != USCRIPT_COMMON) {\n      first_script = cur_script;\n      is_first = false;\n    } else {\n      if (cur_script != USCRIPT_COMMON && cur_script != first_script)\n        return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "dcchkstr(int size)\n{\n\twhile( (strsize+size) > strmaxsize ) {\n\t\tdcstr=realloc(dcstr,strmaxsize+DCSTRSIZE);\n\t\tstrmaxsize+=DCSTRSIZE;\n\t\tdcptr=dcstr+strsize;\n\t}\n}", "target": 0}
{"code": "static int compat_getdrvstat(int drive, bool poll,\n\t\t\t    struct compat_floppy_drive_struct __user *arg)\n{\n\tstruct compat_floppy_drive_struct v;\n\tmemset(&v, 0, sizeof(struct compat_floppy_drive_struct));\n\tmutex_lock(&floppy_mutex);\n\tif (poll) {\n\t\tif (lock_fdc(drive))\n\t\t\tgoto Eintr;\n\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\tgoto Eintr;\n\t\tprocess_fd_request();\n\t}\n\tv.spinup_date = UDRS->spinup_date;\n\tv.select_date = UDRS->select_date;\n\tv.first_read_date = UDRS->first_read_date;\n\tv.probed_format = UDRS->probed_format;\n\tv.track = UDRS->track;\n\tv.maxblock = UDRS->maxblock;\n\tv.maxtrack = UDRS->maxtrack;\n\tv.generation = UDRS->generation;\n\tv.keep_data = UDRS->keep_data;\n\tv.fd_ref = UDRS->fd_ref;\n\tv.fd_device = UDRS->fd_device;\n\tv.last_checked = UDRS->last_checked;\n\tv.dmabuf = (uintptr_t)UDRS->dmabuf;\n\tv.bufblocks = UDRS->bufblocks;\n\tmutex_unlock(&floppy_mutex);\n\tif (copy_from_user(arg, &v, sizeof(struct compat_floppy_drive_struct)))\n\t\treturn -EFAULT;\n\treturn 0;\nEintr:\n\tmutex_unlock(&floppy_mutex);\n\treturn -EINTR;\n}", "target": 0}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "static void imap_login_preinit(void)\n{\n\tlogin_set_roots = imap_login_setting_roots;\n}", "target": 0}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "static int vidioc_s_std(struct file *file, void *private_data, v4l2_std_id *_std)\n{\n\tv4l2_std_id req_std = 0, supported_std = 0;\n\tconst v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;\n\tif (_std) {\n\t\treq_std = *_std;\n\t\t*_std = all_std;\n\t}\n\tsupported_std = (all_std & req_std);\n\tif (no_std == supported_std)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "    std::string Iptcdatum::recordName() const\n    {\n        return key_.get() == 0 ? \"\" : key_->recordName();\n    }", "target": 0}
{"code": "static void ati_cursor_define(ATIVGAState *s)\n{\n    uint8_t data[1024];\n    uint8_t *src;\n    int i, j, idx = 0;\n    if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) {\n        return; \n    }\n    src = s->vga.vram_ptr + s->regs.cur_offset -\n          (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16;\n    for (i = 0; i < 64; i++) {\n        for (j = 0; j < 8; j++, idx++) {\n            data[idx] = src[i * 16 + j];\n            data[512 + idx] = src[i * 16 + j + 8];\n        }\n    }\n    if (!s->cursor) {\n        s->cursor = cursor_alloc(64, 64);\n    }\n    cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0,\n                    &data[512], 1, &data[0]);\n    dpy_cursor_define(s->vga.con, s->cursor);\n}", "target": 1}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "int rtnl_send_check(struct rtnl_handle *rth, const void *buf, int len)\n{\n\tstruct nlmsghdr *h;\n\tint status;\n\tchar resp[1024];\n\tstatus = send(rth->fd, buf, len, 0);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = recv(rth->fd, resp, sizeof(resp), MSG_DONTWAIT|MSG_PEEK);\n\tif (status < 0) {\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\tfor (h = (struct nlmsghdr *)resp; NLMSG_OK(h, status);\n\t     h = NLMSG_NEXT(h, status)) {\n\t\tif (h->nlmsg_type == NLMSG_ERROR) {\n\t\t\tstruct nlmsgerr *err = (struct nlmsgerr *)NLMSG_DATA(h);\n\t\t\tif (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr)))\n\t\t\t\tfprintf(stderr, \"ERROR truncated\\n\");\n\t\t\telse\n\t\t\t\terrno = -err->error;\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType DefineImageRegistry(const RegistryType type,\n  const char *option,ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n  register char\n    *p;\n  assert(option != (const char *) NULL);\n  (void) CopyMagickString(key,option,MagickPathExtent);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageRegistry(type,key,value,exception));\n}", "target": 0}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "static int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}", "target": 0}
{"code": "GF_Err fdpa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FDpacketBox *ptr = (GF_FDpacketBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->info.sender_current_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.expected_residual_time_present, 1);\n\tgf_bs_write_int(bs, ptr->info.session_close_bit, 1);\n\tgf_bs_write_int(bs, ptr->info.object_close_bit, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_u16(bs, ptr->info.transport_object_identifier);\n\tgf_bs_write_u16(bs, ptr->header_ext_count);\n\tfor (i=0; i<ptr->header_ext_count; i++) {\n\t\tgf_bs_write_u8(bs, ptr->headers[i].header_extension_type);\n\t\tif (ptr->headers[i].header_extension_type > 127) {\n\t\t\tgf_bs_write_data(bs, (const char *) ptr->headers[i].content, 3);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, ptr->headers[i].data_length ? (ptr->headers[i].data_length+2)/4 : 0);\n\t\t\tif (ptr->headers[i].data_length) {\n\t\t\t\tgf_bs_write_data(bs, ptr->headers[i].data, ptr->headers[i].data_length);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "  bool isReference() const { return type() == Type::Reference; }", "target": 0}
{"code": "void calc_group_buffer(TMP_TABLE_PARAM *param, ORDER *group)\n{\n  uint key_length=0, parts=0, null_parts=0;\n  for (; group ; group=group->next)\n  {\n    Item *group_item= *group->item;\n    Field *field= group_item->get_tmp_table_field();\n    if (field)\n    {\n      enum_field_types type;\n      if ((type= field->type()) == MYSQL_TYPE_BLOB)\n\tkey_length+=MAX_BLOB_WIDTH;\t\t\n      else if (type == MYSQL_TYPE_VARCHAR || type == MYSQL_TYPE_VAR_STRING)\n        key_length+= field->field_length + HA_KEY_BLOB_LENGTH;\n      else if (type == MYSQL_TYPE_BIT)\n      {\n        key_length+= 8;                         \n      }\n      else\n\tkey_length+= field->pack_length();\n    }\n    else\n    { \n      switch (group_item->cmp_type()) {\n      case REAL_RESULT:\n        key_length+= sizeof(double);\n        break;\n      case INT_RESULT:\n        key_length+= sizeof(longlong);\n        break;\n      case DECIMAL_RESULT:\n        key_length+= my_decimal_get_binary_size(group_item->max_length - \n                                                (group_item->decimals ? 1 : 0),\n                                                group_item->decimals);\n        break;\n      case TIME_RESULT:\n      {\n        key_length+= 8;\n        break;\n      }\n      case STRING_RESULT:\n      {\n        enum enum_field_types type= group_item->field_type();\n        if (type == MYSQL_TYPE_BLOB)\n          key_length+= MAX_BLOB_WIDTH;\t\t\n        else\n        {\n          key_length+= group_item->max_length + HA_KEY_BLOB_LENGTH;\n        }\n        break;\n      }\n      default:\n        DBUG_ASSERT(0);\n        my_error(ER_OUT_OF_RESOURCES, MYF(ME_FATAL));\n      }\n    }\n    parts++;\n    if (group_item->maybe_null)\n      null_parts++;\n  }\n  param->group_length= key_length + null_parts;\n  param->group_parts= parts;\n  param->group_null_parts= null_parts;\n}", "target": 0}
{"code": "PinholeVerification(struct upnphttp * h, char * int_ip, unsigned short int_port)\n{\n\tint n;\n\tchar senderAddr[INET6_ADDRSTRLEN]=\"\";\n\tstruct addrinfo hints, *ai, *p;\n\tstruct in6_addr result_ip;\n\tsyslog(LOG_INFO, \"Checking internal IP@ and port (Security policy purpose)\");\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\tif (inet_pton(AF_INET6, int_ip, &result_ip) <= 0)\n\t{\n\t\tn = getaddrinfo(int_ip, NULL, &hints, &ai);\n\t\tif(!n && ai->ai_family == AF_INET6)\n\t\t{\n\t\t\tfor(p = ai; p; p = p->ai_next)\n\t\t\t{\n\t\t\t\tinet_ntop(AF_INET6, (struct in6_addr *) p, int_ip, sizeof(struct in6_addr));\n\t\t\t\tresult_ip = *((struct in6_addr *) p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to convert hostname '%s' to ip address\", int_ip);\n\t\t\tSoapError(h, 402, \"Invalid Args\");\n\t\t\treturn -1;\n\t\t}\n        freeaddrinfo(p);\n\t}\n\tif(inet_ntop(AF_INET6, &(h->clientaddr_v6), senderAddr, INET6_ADDRSTRLEN) == NULL)\n\t{\n\t\tsyslog(LOG_ERR, \"inet_ntop: %m\");\n\t}\n#ifdef DEBUG\n\tprintf(\"\\tPinholeVerification:\\n\\t\\tCompare sender @: %s\\n\\t\\t  to intClient @: %s\\n\", senderAddr, int_ip);\n#endif\n\tif(strcmp(senderAddr, int_ip) != 0)\n\tif(h->clientaddr_v6.s6_addr != result_ip.s6_addr)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole for internal %s and is not authorized to do it\",\n\t\t       senderAddr, int_ip);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\tif (int_port < 1024)\n\t{\n\t\tsyslog(LOG_INFO, \"Client %s tried to access pinhole with port < 1024 and is not authorized to do it\",\n\t\t       senderAddr);\n\t\tSoapError(h, 606, \"Action not authorized\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "mld6_print(netdissect_options *ndo, const u_char *bp)\n{\n\tconst struct mld6_hdr *mp = (const struct mld6_hdr *)bp;\n\tconst u_char *ep;\n\tep = ndo->ndo_snapend;\n\tif ((const u_char *)mp + sizeof(*mp) > ep)\n\t\treturn;\n\tND_PRINT((ndo,\"max resp delay: %d \", EXTRACT_16BITS(&mp->mld6_maxdelay)));\n\tND_PRINT((ndo,\"addr: %s\", ip6addr_string(ndo, &mp->mld6_addr)));\n}", "target": 0}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tmm_init_uprobes_state(mm);\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "    int Erase::eraseComment(Exiv2::Image* image) const\n    {\n        if (Params::instance().verbose_ && image->comment().size() > 0) {\n            std::cout << _(\"Erasing JPEG comment from the file\") << std::endl;\n        }\n        image->clearComment();\n        return 0;\n    }", "target": 0}
{"code": "http_error_t::make_body (int n, const str &si, const str &aux)\n{\n  strbuf b;\n  str ldesc;\n  const str sdesc = http_status.get_desc (n, &ldesc);\n  b << \"<html>\\n\"\n    << \" <head>\\n\"\n    << \"  <title>\" << n << \" \" << sdesc << \"</title>\\n\"\n    << \" </head>\\n\"\n    << \" <body>\\n\"\n    << \" <h1>Error \" << n << \" \" << sdesc << \"</h1><br><br>\\n\"\n    ;\n  if (n == HTTP_NOT_FOUND && aux) {\n    b << \"The file <tt>\" << aux \n      << \"</tt> was not found on this server.<br><br>\\n\\n\";\n  }\n  b << \"  <hr>\\n\"\n    << \"  <i>\" << si << \"</i>\\n\"\n    << \" <br>\\n\"\n    << \" </body>\\n\"\n    << \"</html>\\n\"\n    ;\n  return b;\n}", "target": 1}
{"code": "static inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\t*entity     = table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DecrementInFlightEventCount() {\n  if (decrement_in_flight_event_count() <= 0) {\n    StopHangMonitorTimeout();\n  } else {\n    if (!is_hidden_)\n      RestartHangMonitorTimeout();\n  }\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "static void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}", "target": 0}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n  DrawInfo\n    *draw_info;\n  Image\n    *image;\n  MagickBooleanType\n    status;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 0}
{"code": "FileSystemOperation* FileSystemOperation::AsFileSystemOperation() {\n  return this;\n}", "target": 0}
{"code": "int sldns_str2wire_eui48_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tunsigned int a, b, c, d, e, f;\n\tint l;\n\tif(*len < 6)\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif (sscanf(str, \"%2x-%2x-%2x-%2x-%2x-%2x%n\",\n\t\t\t&a, &b, &c, &d, &e, &f, &l) != 6 ||\n\t\t\tl != (int)strlen(str))\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_EUI48;\n\trd[0] = a;\n\trd[1] = b;\n\trd[2] = c;\n\trd[3] = d;\n\trd[4] = e;\n\trd[5] = f;\n\t*len = 6;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "hyphenHashInsert (HyphenHashTab * hashTab, const CharsString * key, int val)\n{\n  int i, j;\n  HyphenHashEntry *e;\n  i = hyphenStringHash (key) % HYPHENHASHSIZE;\n  if (!(e = malloc (sizeof (HyphenHashEntry))))\n    outOfMemory ();\n  e->next = hashTab->entries[i];\n  e->key = malloc ((key->length + 1) * CHARSIZE);\n  if (!e->key)\n    outOfMemory ();\n  e->key->length = key->length;\n  for (j = 0; j < key->length; j++)\n    e->key->chars[j] = key->chars[j];\n  e->val = val;\n  hashTab->entries[i] = e;\n}", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "inline int32_t byteswap(int32_t value) { return _af_byteswap_int32(value); }", "target": 0}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "struct rad_packet_t *rad_packet_alloc(int code)\n{\n\tstruct rad_packet_t *pack;\n\tpack = mempool_alloc(packet_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"radius:packet: out of memory\\n\");\n\t\treturn NULL;\n\t}\n\tmemset(pack, 0, sizeof(*pack));\n\tpack->code = code;\n\tpack->len = 20;\n\tpack->id = 1;\n\tINIT_LIST_HEAD(&pack->attrs);\n\treturn pack;\n}", "target": 0}
{"code": "static ssize_t ext4_direct_IO_read(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct address_space *mapping = iocb->ki_filp->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\tinode_lock_shared(inode);\n\tret = filemap_write_and_wait_range(mapping, iocb->ki_pos,\n\t\t\t\t\t   iocb->ki_pos + count - 1);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t   iter, ext4_dio_get_block, NULL, NULL, 0);\nout_unlock:\n\tinode_unlock_shared(inode);\n\treturn ret;\n}", "target": 0}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "static inline vm_fault_t hugetlb_handle_userfault(struct vm_area_struct *vma,\n\t\t\t\t\t\t  struct address_space *mapping,\n\t\t\t\t\t\t  pgoff_t idx,\n\t\t\t\t\t\t  unsigned int flags,\n\t\t\t\t\t\t  unsigned long haddr,\n\t\t\t\t\t\t  unsigned long reason)\n{\n\tvm_fault_t ret;\n\tu32 hash;\n\tstruct vm_fault vmf = {\n\t\t.vma = vma,\n\t\t.address = haddr,\n\t\t.flags = flags,\n\t};\n\thash = hugetlb_fault_mutex_hash(mapping, idx);\n\tmutex_unlock(&hugetlb_fault_mutex_table[hash]);\n\ti_mmap_unlock_read(mapping);\n\tret = handle_userfault(&vmf, reason);\n\ti_mmap_lock_read(mapping);\n\tmutex_lock(&hugetlb_fault_mutex_table[hash]);\n\treturn ret;\n}", "target": 0}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "static char *get_pid_cgroup(pid_t pid, const char *contrl)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tchar *answer = NULL;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tconst char *h = find_mounted_controller(contrl);\n\tif (!h)\n\t\treturn NULL;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn NULL;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn NULL;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, h) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tdo {\n\t\t\tanswer = strdup(c2);\n\t\t} while (!answer);\n\t\tbreak;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 0}
{"code": "static long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}", "target": 0}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    bool timeout = false;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            timeout = true;\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (!timeout && s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 0}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "bool RenderMenuList::multiple()\n {\n     return toHTMLSelectElement(node())->multiple();\n }", "target": 1}
{"code": "AP_DECLARE(void) ap_set_content_length(request_rec *r, apr_off_t clength)\n{\n    r->clength = clength;\n    apr_table_setn(r->headers_out, \"Content-Length\",\n                   apr_off_t_toa(r->pool, clength));\n}", "target": 0}
{"code": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "chop(char *s)\n{\n\tchar *t = s;\n\twhile (*t) {\n\t\tif (*t == '\\n' || *t == '\\r') {\n\t\t\t*t = '\\0';\n\t\t\treturn s;\n\t\t}\n\t\tt++;\n\t}\n\treturn s;\n}", "target": 0}
{"code": "void LibRaw::nikon_coolscan_load_raw()\n{\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int bypp = tiff_bps <= 8 ? 1 : 2;\n  int bufsize = width * 3 * bypp;\n  unsigned char *buf = (unsigned char *)malloc(bufsize);\n  unsigned short *ubuf = (unsigned short *)buf;\n  if (tiff_bps <= 8)\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n  else\n    gamma_curve(1.0 / imgdata.params.coolscan_nef_gamma, 0., 1, 65535);\n  fseek(ifp, data_offset, SEEK_SET);\n  for (int row = 0; row < raw_height; row++)\n  {\n      if(tiff_bps <=8)\n        fread(buf, 1, bufsize, ifp);\n      else\n          read_shorts(ubuf,width*3);\n    unsigned short(*ip)[4] = (unsigned short(*)[4])image + row * width;\n    if (is_NikonTransfer == 2)\n    { \n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = ((float)curve[buf[col * 3]]) / 255.0f;\n        ip[col][1] = ((float)curve[buf[col * 3 + 1]]) / 255.0f;\n        ip[col][2] = ((float)curve[buf[col * 3 + 2]]) / 255.0f;\n        ip[col][3] = 0;\n      }\n    }\n    else if (tiff_bps <= 8)\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[buf[col * 3]];\n        ip[col][1] = curve[buf[col * 3 + 1]];\n        ip[col][2] = curve[buf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n    else\n    {\n      for (int col = 0; col < width; col++)\n      {\n        ip[col][0] = curve[ubuf[col * 3]];\n        ip[col][1] = curve[ubuf[col * 3 + 1]];\n        ip[col][2] = curve[ubuf[col * 3 + 2]];\n        ip[col][3] = 0;\n      }\n    }\n  }\n  free(buf);\n}", "target": 0}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "double Item_cache_str::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  int err_not_used;\n  char *end_not_used;\n  if (!has_value())\n    return 0.0;\n  if (value)\n    return my_strntod(value->charset(), (char*) value->ptr(),\n\t\t      value->length(), &end_not_used, &err_not_used);\n  return (double) 0;\n}", "target": 0}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "static int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %d; voff[%d] = %d\\n\", compno,\n\t\t  comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "static bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\tif (level == PT_PAGE_TABLE_LEVEL) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\treturn r || curr_pte != gw->ptes[level - 1];\n}", "target": 0}
{"code": "PHPAPI int php_execute_simple_script(zend_file_handle *primary_file, zval *ret)\n{\n\tchar *old_cwd;\n\tALLOCA_FLAG(use_heap)\n\tEG(exit_status) = 0;\n#define OLD_CWD_SIZE 4096\n\told_cwd = do_alloca(OLD_CWD_SIZE, use_heap);\n\told_cwd[0] = '\\0';\n\tzend_try {\n#ifdef PHP_WIN32\n\t\tif(primary_file->filename) {\n\t\t\tUpdateIniFromRegistry((char*)primary_file->filename);\n\t\t}\n#endif\n\t\tPG(during_request_startup) = 0;\n\t\tif (primary_file->filename && !(SG(options) & SAPI_OPTION_NO_CHDIR)) {\n\t\t\tphp_ignore_value(VCWD_GETCWD(old_cwd, OLD_CWD_SIZE-1));\n\t\t\tVCWD_CHDIR_FILE(primary_file->filename);\n\t\t}\n\t\tzend_execute_scripts(ZEND_REQUIRE, ret, 1, primary_file);\n\t} zend_end_try();\n\tif (old_cwd[0] != '\\0') {\n\t\tphp_ignore_value(VCWD_CHDIR(old_cwd));\n\t}\n\tfree_alloca(old_cwd, use_heap);\n\treturn EG(exit_status);\n}", "target": 0}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Cancel() { cancelled_ = true; }", "target": 0}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "proto_reg_handoff_sysdig_event(void)\n{\n    dissector_handle_t sysdig_event_handle;\n    sysdig_event_handle = create_dissector_handle(dissect_sysdig_event,\n            proto_sysdig_event);\n    dissector_add_uint(\"pcapng.block_type\", BLOCK_TYPE_SYSDIG_EVENT, sysdig_event_handle);\n    dissector_add_uint(\"pcapng.block_type\", BLOCK_TYPE_SYSDIG_EVENT_V2, sysdig_event_handle);\n    dissector_add_uint(\"pcapng.block_type\", BLOCK_TYPE_SYSDIG_EVENT_V2_LARGE, sysdig_event_handle);\n}", "target": 0}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tint len;\n\tint new_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + ppp->dev->hard_header_len;\n\tint compressor_skb_size = ppp->dev->mtu +\n\t\tppp->xcomp->comp_extra + PPP_HDRLEN;\n\tnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"PPP: no memory (comp pkt)\\n\");\n\t\treturn NULL;\n\t}\n\tif (ppp->dev->hard_header_len > PPP_HDRLEN)\n\t\tskb_reserve(new_skb,\n\t\t\t    ppp->dev->hard_header_len - PPP_HDRLEN);\n\tlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\n\t\t\t\t   new_skb->data, skb->len + 2,\n\t\t\t\t   compressor_skb_size);\n\tif (len > 0 && (ppp->flags & SC_CCP_UP)) {\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tskb_put(skb, len);\n\t\tskb_pull(skb, 2);\t\n\t} else if (len == 0) {\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = skb;\n\t} else {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_ERR \"ppp: compressor dropped pkt\\n\");\n\t\tkfree_skb(skb);\n\t\tkfree_skb(new_skb);\n\t\tnew_skb = NULL;\n\t}\n\treturn new_skb;\n}", "target": 0}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    SafeStringValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "    **/\n    bool operator==(const char *const expression) const {\n      return *this==(+*this)._fill(expression,true,true,0,0,\"operator==\",this);", "target": 0}
{"code": "write_os2_header (j_decompress_ptr cinfo, bmp_dest_ptr dest)\n{\n  char bmpfileheader[14];\n  char bmpcoreheader[12];\n  long headersize, bfSize;\n  int bits_per_pixel, cmap_entries;\n  if (cinfo->out_color_space == JCS_RGB ||\n      (cinfo->out_color_space >= JCS_EXT_RGB &&\n       cinfo->out_color_space <= JCS_EXT_ARGB)) {\n    if (cinfo->quantize_colors) {\n      bits_per_pixel = 8;\n      cmap_entries = 256;\n    } else {\n      bits_per_pixel = 24;\n      cmap_entries = 0;\n    }\n  } else if (cinfo->out_color_space == JCS_RGB565 ||\n             cinfo->out_color_space == JCS_CMYK) {\n    bits_per_pixel = 24;\n    cmap_entries   = 0;\n  } else {\n    bits_per_pixel = 8;\n    cmap_entries = 256;\n  }\n  headersize = 14 + 12 + cmap_entries * 3; \n  bfSize = headersize + (long) dest->row_width * (long) cinfo->output_height;\n  MEMZERO(bmpfileheader, sizeof(bmpfileheader));\n  MEMZERO(bmpcoreheader, sizeof(bmpcoreheader));\n  bmpfileheader[0] = 0x42;      \n  bmpfileheader[1] = 0x4D;\n  PUT_4B(bmpfileheader, 2, bfSize); \n  PUT_4B(bmpfileheader, 10, headersize); \n  PUT_2B(bmpcoreheader, 0, 12); \n  PUT_2B(bmpcoreheader, 4, cinfo->output_width); \n  PUT_2B(bmpcoreheader, 6, cinfo->output_height); \n  PUT_2B(bmpcoreheader, 8, 1);  \n  PUT_2B(bmpcoreheader, 10, bits_per_pixel); \n  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t) 14)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (JFWRITE(dest->pub.output_file, bmpcoreheader, 12) != (size_t) 12)\n    ERREXIT(cinfo, JERR_FILE_WRITE);\n  if (cmap_entries > 0)\n    write_colormap(cinfo, dest, cmap_entries, 3);\n}", "target": 0}
{"code": "int gnutls_x509_ext_import_subject_alt_names(const gnutls_datum_t * ext,\n\t\t\t\t\t  gnutls_subject_alt_names_t sans,\n\t\t\t\t\t  unsigned int flags)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result, ret;\n\tunsigned int i;\n\tgnutls_datum_t san, othername_oid;\n\tunsigned type;\n\tresult =\n\t    asn1_create_element(_gnutls_get_pkix(), \"PKIX1.GeneralNames\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\ti = 0;\n\tdo {\n\t\tsan.data = NULL;\n\t\tsan.size = 0;\n\t\tothername_oid.data = NULL;\n\t\tret = _gnutls_parse_general_name2(c2, \"\", i, &san, &type, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (type == GNUTLS_SAN_OTHERNAME) {\n\t\t\tret =\n\t\t\t    _gnutls_parse_general_name2(c2, \"\", i,\n\t\t\t\t\t\t\t&othername_oid,\n\t\t\t\t\t\t\tNULL, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t} else if (san.size == 0 || san.data == NULL) {\n\t\t\tret = gnutls_assert_val(GNUTLS_E_X509_UNKNOWN_SAN);\n\t\t\tbreak;\n\t\t}\n\t\tret = subject_alt_names_set(&sans->names, &sans->size,\n\t\t\t\t\t    type, &san,\n\t\t\t\t\t    (char *)othername_oid.data);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\ti++;\n\t} while (ret >= 0);\n\tsans->size = i;\n\tif (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n\t\tgnutls_free(san.data);\n\t\tgnutls_free(othername_oid.data);\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n{\n    os_ptr op = osp;\n     int code;\n     ref token;\n     pop(1);                     \n again:\n            gs_scanner_error_object(i_ctx_p, pstate, &i_ctx_p->error_object);\n            break;\n        case scan_BOS:\n            code = 0;\n        case 0:         \n            push(2);\n            ref_assign(op - 1, &token);\n            make_true(op);\n            break;\n        case scan_EOF:          \n            push(1);\n            make_false(op);\n            code = 0;\n            break;\n        case scan_Refill:       \n            code = gs_scan_handle_refill(i_ctx_p, pstate, save,\n                                      ztoken_continue);\n            switch (code) {\n                case 0: \n                    goto again;\n                case o_push_estack:\n                    return code;\n            }\n            break;              \n    }", "target": 1}
{"code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}", "target": 1}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n      if (len != data_size)\n\t{\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n      p = data + 2;\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\t  p += len;\n\t}\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\t  switch (type)\n\t    {\n\t    case 0:\t\t\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\t  p += len;\n\t}\n    }\n  return 0;\n}", "target": 1}
{"code": " bool PasswordAutofillAgent::TryToShowTouchToFill(\n     const WebFormControlElement& control_element) {\n   const WebInputElement* element = ToWebInputElement(&control_element);\n  if (!element || (!base::Contains(web_input_to_password_info_, *element) &&\n                   !base::Contains(password_to_username_, *element))) {\n     return false;\n   }\n   if (was_touch_to_fill_ui_shown_)\n    return false;\n  was_touch_to_fill_ui_shown_ = true;\n  GetPasswordManagerDriver()->ShowTouchToFill();\n  return true;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t TIFFReadCustomStream(unsigned char *data,const size_t count,\n  void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  size_t\n    total;\n  ssize_t\n    remaining;\n  if (count == 0)\n    return(0);\n  profile=(PhotoshopProfile *) user_data;\n  remaining=(MagickOffsetType) profile->length-profile->offset;\n  if (remaining <= 0)\n    return(-1);\n  total=MagickMin(count, (size_t) remaining);\n  (void) memcpy(data,profile->data->datum+profile->offset,total);\n  profile->offset+=total;\n  return(total);\n}", "target": 0}
{"code": "static inline int prb_curr_blk_in_use(struct kbdq_core *pkc,\n\t\t\t\t      struct block_desc *pbd)\n{\n\treturn TP_STATUS_USER & BLOCK_STATUS(pbd);\n}", "target": 0}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "  char *strndup(const char *str, size_t size)\n  {\n    char *copy;\n    size_t len = strlen(str);\n    if (len > size)\n      len = size;\n    copy = (char *)REDIRECT_MALLOC(len + 1);\n    if (copy == NULL) {\n      errno = ENOMEM;\n      return NULL;\n    }\n    BCOPY(str, copy, len);\n    copy[len] = '\\0';\n    return copy;\n  }", "target": 0}
{"code": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\tdentry->d_inode = inode;\n\tsmp_wmb();\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}", "target": 0}
{"code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }", "target": 1}
{"code": "cmsBool OpenOutput(const char* FileName)\n{\n\tOutFile = fopen(FileName, \"wb\");\n\tif (OutFile == NULL) {\n\t\tFatalError(\"Cannot create '%s'\", FileName);\n\t}\n\tCompressor.err                   = jpeg_std_error(&ErrorHandler.pub);\n\tErrorHandler.pub.error_exit      = my_error_exit;\n\tErrorHandler.pub.output_message  = my_error_exit;\n\tCompressor.input_components = Compressor.num_components = 4;\n\tjpeg_create_compress(&Compressor);\n\tjpeg_stdio_dest(&Compressor, OutFile);\n\treturn TRUE;\n}", "target": 0}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "left_is_superset(DTCollation *left, DTCollation *right)\n{\n  if (left->collation->state & MY_CS_UNICODE &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        (!(right->collation->state & MY_CS_UNICODE) ||\n         (left->collation->state & MY_CS_UNICODE_SUPPLEMENT &&\n          !(right->collation->state & MY_CS_UNICODE_SUPPLEMENT) &&\n          left->collation->mbmaxlen > right->collation->mbmaxlen &&\n          left->collation->mbminlen == right->collation->mbminlen)))))\n    return TRUE;\n  if (right->repertoire == MY_REPERTOIRE_ASCII &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        !(left->repertoire == MY_REPERTOIRE_ASCII))))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}", "target": 1}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "bool red_stream_write_all(RedStream *stream, const void *in_buf, size_t n)\n{\n    const uint8_t *buf = (uint8_t *)in_buf;\n    while (n) {\n        int now = red_stream_write(stream, buf, n);\n        if (now <= 0) {\n            if (now == -1 && (errno == EINTR || errno == EAGAIN)) {\n                continue;\n            }\n            return false;\n        }\n        n -= now;\n        buf += now;\n    }\n    return true;\n}", "target": 0}
{"code": "static int nfs4_find_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t      struct nfs_fsinfo *info)\n{\n\tint i, len, status = 0;\n\trpc_authflavor_t flav_array[NFS_MAX_SECFLAVORS];\n\tlen = rpcauth_list_flavors(flav_array, ARRAY_SIZE(flav_array));\n\tBUG_ON(len < 0);\n\tfor (i = 0; i < len; i++) {\n\t\tif (flav_array[i] == RPC_AUTH_UNIX)\n\t\t\tcontinue;\n\t\tstatus = nfs4_lookup_root_sec(server, fhandle, info, flav_array[i]);\n\t\tif (status == -NFS4ERR_WRONGSEC || status == -EACCES)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (status == -EACCES)\n\t\tstatus = -EPERM;\n\treturn status;\n}", "target": 0}
{"code": "test_gui_mouse_event(dict_T *args)\n{\n    int\t\tbutton;\n    int\t\trow;\n    int\t\tcol;\n    int\t\trepeated_click;\n    int_u\tmods;\n    int\t\tmove;\n    if (!dict_has_key(args, \"row\")\n\t    || !dict_has_key(args, \"col\"))\n\treturn FALSE;\n    move = (int)dict_get_bool(args, \"move\", FALSE);\n    if (!move && (!dict_has_key(args, \"button\")\n\t    || !dict_has_key(args, \"multiclick\")\n\t    || !dict_has_key(args, \"modifiers\")))\n\treturn FALSE;\n    row = (int)dict_get_number(args, \"row\");\n    col = (int)dict_get_number(args, \"col\");\n    if (move)\n    {\n\tif (dict_get_bool(args, \"cell\", FALSE))\n\t{\n\t    row = row * gui.char_height + gui.char_height / 2;\n\t    col = col * gui.char_width + gui.char_width / 2;\n\t}\n\tgui_mouse_moved(col, row);\n    }\n    else\n    {\n\tbutton = (int)dict_get_number(args, \"button\");\n\trepeated_click = (int)dict_get_number(args, \"multiclick\");\n\tmods = (int)dict_get_number(args, \"modifiers\");\n\tmouse_set_hor_scroll_step(6);\n\tmouse_set_vert_scroll_step(3);\n\tgui_send_mouse_event(button, TEXT_X(col - 1), TEXT_Y(row - 1),\n\t\t\t\t\t\t\trepeated_click, mods);\n    }\n    return TRUE;\n}", "target": 0}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "  explicit BoostedTreesMakeStatsSummaryOp(OpKernelConstruction* const context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"max_splits\", &max_splits_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_features\", &num_features_));\n  }", "target": 0}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source TSRMLS_DC)\n{\n\tvoid **old_p, *retval;\n\tif (zend_hash_index_find(&xlat_table, (ulong)source, (void **)&old_p) == SUCCESS) {\n\t\treturn *old_p;\n\t}\n\tretval = ZCG(mem);;\n\tZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n\tmemcpy(retval, source, size);\n\tif (free_source) {\n\t\tinterned_efree((char*)source);\n\t}\n\tzend_shared_alloc_register_xlat_entry(source, retval);\n\treturn retval;\n}", "target": 1}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n             methnum = ap_method_register(cmd->pool,\n                                          apr_pstrdup(cmd->pool, method));\n         }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 1}
{"code": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "START_TEST(test_tm_adopt_ispidowner)\n  {\n  fail_unless(TRUE == ispidowner(getpid()));\n  fail_unless(FALSE == ispidowner(1));\n  }", "target": 1}
{"code": "int http_skip_chunk_crlf(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *ptr;\n\tint bytes;\n\tbytes = 1;\n\tptr = buf->lr;\n\tif (*ptr == '\\r') {\n\t\tbytes++;\n\t\tptr++;\n\t\tif (ptr >= buf->data + buf->size)\n\t\t\tptr = buf->data;\n\t}\n\tif (bytes > buf->l - buf->send_max)\n\t\treturn 0;\n\tif (*ptr != '\\n') {\n\t\tmsg->err_pos = ptr - buf->data;\n\t\treturn -1;\n\t}\n\tptr++;\n\tif (ptr >= buf->data + buf->size)\n\t\tptr = buf->data;\n\tbuf->lr = ptr;\n\tmsg->sov = ptr - buf->data;\n\tmsg->som = msg->sov - bytes;\n\tmsg->msg_state = HTTP_MSG_CHUNK_SIZE;\n\treturn 1;\n}", "target": 0}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "void ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num = intf->intf_num, index;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\tcleanup_smi_msgs(intf);\n\tipmi_bmc_unregister(intf);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}", "target": 0}
{"code": "static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\treturn (ret != orig_pte);\n}", "target": 1}
{"code": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {\n\tut64 sz = 0;\n\tif (evp == NULL) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tif (evp->value) {\n\t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\t}\n\treturn sz;\n}", "target": 1}
{"code": "static ssize_t revision_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\treturn snprintf(buf, 20, \"%u\\n\", id.device_revision & 0x0F);\n}", "target": 0}
{"code": "    TiffComponent* TiffComponent::doAddPath(uint16_t  ,\n                                            TiffPath& ,\n                                            TiffComponent* const ,\n                                            TiffComponent::UniquePtr )\n    {\n        return this;\n    } ", "target": 0}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "z_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}", "target": 1}
{"code": "AcpiNsGetNodeUnlocked (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_GENERIC_STATE      ScopeInfo;\n    ACPI_STATUS             Status;\n    char                    *InternalPath;\n    ACPI_FUNCTION_TRACE_PTR (NsGetNodeUnlocked, ACPI_CAST_PTR (char, Pathname));\n    if (!Pathname)\n    {\n        *ReturnNode = PrefixNode;\n        if (!PrefixNode)\n        {\n            *ReturnNode = AcpiGbl_RootNode;\n        }\n        return_ACPI_STATUS (AE_OK);\n    }\n    if (ACPI_IS_ROOT_PREFIX (Pathname[0]) && (!Pathname[1]))\n    {\n        *ReturnNode = AcpiGbl_RootNode;\n        return_ACPI_STATUS (AE_OK);\n    }\n    Status = AcpiNsInternalizeName (Pathname, &InternalPath);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n    ScopeInfo.Scope.Node = PrefixNode;\n    Status = AcpiNsLookup (&ScopeInfo, InternalPath, ACPI_TYPE_ANY,\n        ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),\n        NULL, ReturnNode);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"%s, %s\\n\",\n            Pathname, AcpiFormatException (Status)));\n    }\n    ACPI_FREE (InternalPath);\n    return_ACPI_STATUS (Status);\n}", "target": 0}
{"code": "find_script_callback(char_u *fname, void *cookie)\n{\n    int sid;\n    int error = OK;\n    int *ret_sid = cookie;\n    sid = find_script_by_name(fname);\n    if (sid < 0)\n    {\n\tsid = get_new_scriptitem(&error);\n\tif (error == OK)\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(sid);\n\t    si->sn_name = vim_strsave(fname);\n\t    si->sn_state = SN_STATE_NOT_LOADED;\n\t}\n    }\n    *ret_sid = sid;\n}", "target": 0}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "static int dsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\n{\n    const unsigned char *p, *pm;\n    int pklen, pmlen;\n    int ptype;\n    void *pval;\n    ASN1_STRING *pstr;\n    X509_ALGOR *palg;\n    ASN1_INTEGER *public_key = NULL;\n    DSA *dsa = NULL;\n    if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\n        return 0;\n    X509_ALGOR_get0(NULL, &ptype, &pval, palg);\n    if (ptype == V_ASN1_SEQUENCE) {\n        pstr = pval;\n        pm = pstr->data;\n        pmlen = pstr->length;\n        if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen))) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n            goto err;\n        }\n    } else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {\n        if (!(dsa = DSA_new())) {\n            DSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    } else {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);\n        goto err;\n    }\n    if (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\n        goto err;\n    }\n    if (!(dsa->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\n        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);\n        goto err;\n    }\n    ASN1_INTEGER_free(public_key);\n    EVP_PKEY_assign_DSA(pkey, dsa);\n    return 1;\n err:\n    if (public_key)\n        ASN1_INTEGER_free(public_key);\n    if (dsa)\n        DSA_free(dsa);\n    return 0;\n}", "target": 0}
{"code": "int HeaderMapWrapper::luaPairs(lua_State* state) {\n  if (iterator_.get() != nullptr) {\n    luaL_error(state, \"cannot create a second iterator before completing the first\");\n  }\n  iterator_.reset(HeaderMapIterator::create(state, *this), true);\n  lua_pushcclosure(state, HeaderMapIterator::static_luaPairsIterator, 1);\n  return 1;\n}", "target": 0}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static noinline int audit_inode_permission(struct inode *inode,\n\t\t\t\t\t   u32 perms, u32 audited, u32 denied,\n\t\t\t\t\t   int result)\n{\n\tstruct common_audit_data ad;\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tint rc;\n\tad.type = LSM_AUDIT_DATA_INODE;\n\tad.u.inode = inode;\n\trc = slow_avc_audit(&selinux_state,\n\t\t\t    current_sid(), isec->sid, isec->sclass, perms,\n\t\t\t    audited, denied, result, &ad);\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}", "target": 0}
{"code": "ins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    \n    showmode();\n}", "target": 0}
{"code": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len, int seed)\n{\n    unsigned long value = (unsigned long) seed;\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}", "target": 1}
{"code": "static char *failover_find_primary_device_id(VirtIONet *n)\n{\n    Error *err = NULL;\n    FailoverId fid;\n    fid.n = n;\n    if (!qemu_opts_foreach(qemu_find_opts(\"device\"),\n                           failover_set_primary, &fid, &err)) {\n        return NULL;\n    }\n    return fid.id;\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "irc_server_get_name_without_port (const char *name)\n{\n    char *pos;\n    if (!name)\n        return NULL;\n    pos = strchr (name, '/');\n    if (pos && (pos != name))\n        return weechat_strndup (name, pos - name);\n    return strdup (name);\n}", "target": 0}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "jd_utc_to_local(int jd, int df, int of)\n{\n    df += of;\n    if (df < 0)\n\tjd -= 1;\n    else if (df >= DAY_IN_SECONDS)\n\tjd += 1;\n    return jd;\n}", "target": 0}
{"code": "PassRefPtr<Attr> Element::setAttributeNode(Attr* attrNode, ExceptionCode& ec)\n{\n    if (!attrNode) {\n        ec = TYPE_MISMATCH_ERR;\n        return 0;\n    }\n    RefPtr<Attr> oldAttrNode = attrIfExists(attrNode->qualifiedName());\n    if (oldAttrNode.get() == attrNode)\n        return attrNode; \n    if (attrNode->ownerElement()) {\n        ec = INUSE_ATTRIBUTE_ERR;\n        return 0;\n    }\n    synchronizeAllAttributes();\n    UniqueElementData* elementData = ensureUniqueElementData();\n    size_t index = elementData->getAttributeItemIndex(attrNode->qualifiedName());\n    if (index != notFound) {\n        if (oldAttrNode)\n            detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData->attributeItem(index)->value());\n        else\n            oldAttrNode = Attr::create(document(), attrNode->qualifiedName(), elementData->attributeItem(index)->value());\n    }\n     setAttributeInternal(index, attrNode->qualifiedName(), attrNode->value(), NotInSynchronizationOfLazyAttribute);\n     attrNode->attachToElement(this);\n     ensureAttrNodeListForElement(this)->append(attrNode);\n     return oldAttrNode.release();\n}", "target": 1}
{"code": "static int checksum_setup(struct net_device *dev, struct sk_buff *skb)\n{\n\tbool recalculate_partial_csum = false;\n\tif (skb->ip_summed != CHECKSUM_PARTIAL && skb_is_gso(skb)) {\n\t\tstruct netfront_info *np = netdev_priv(dev);\n\t\tatomic_inc(&np->rx_gso_checksum_fixup);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\trecalculate_partial_csum = true;\n\t}\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\treturn skb_checksum_setup(skb, recalculate_partial_csum);\n}", "target": 0}
{"code": "can_prompt_again(secuPWData *pwdata)\n{\n\tif (pwdata->orig_source == PW_PROMPT)\n\t\treturn true;\n\tif (pwdata->source == PW_DEVICE)\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "vhost_user_set_req_fd(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"Invalid file descriptor for slave channel (%d)\\n\",\n\t\t\t\tfd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->slave_req_fd >= 0)\n\t\tclose(dev->slave_req_fd);\n\tdev->slave_req_fd = fd;\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "LayoutUnit RenderBox::availableLogicalHeightUsing(const Length& h) const\n{\n    if (h.isFixed())\n        return computeContentBoxLogicalHeight(h.value());\n    if (isRenderView())\n        return isHorizontalWritingMode() ? toRenderView(this)->frameView()->visibleHeight() : toRenderView(this)->frameView()->visibleWidth();\n     if (isTableCell() && (h.isAuto() || h.isPercent()))\n         return overrideHeight() - borderAndPaddingLogicalWidth();\n    if (h.isPercent())\n       return computeContentBoxLogicalHeight(h.calcValue(containingBlock()->availableLogicalHeight()));\n    if (isRenderBlock() && isPositioned() && style()->height().isAuto() && !(style()->top().isAuto() || style()->bottom().isAuto())) {\n        RenderBlock* block = const_cast<RenderBlock*>(toRenderBlock(this));\n        LayoutUnit oldHeight = block->logicalHeight();\n        block->computeLogicalHeight();\n        LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentLogicalHeight());\n        block->setLogicalHeight(oldHeight);\n        return computeContentBoxLogicalHeight(newHeight);\n    }\n    return containingBlock()->availableLogicalHeight();\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "int spl_object_storage_contains(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) \n{\n\tint hash_len, found;\n\tchar *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);\n\tif (!hash) {\n\t\treturn 0;\n\t}\n\tfound = zend_hash_exists(&intern->storage, hash, hash_len);\n\tspl_object_storage_free_hash(intern, hash);\n\treturn found;\n} ", "target": 0}
{"code": "OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp)\n{\n    (void)p_tcp;\n    return 0;\n}", "target": 0}
{"code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n    (void) y;\n    while (h-- > 0) {\n\tfor (x = w; x-- > 0;)\n        {\n            *cp++ = BWmap[*pp][0] & (*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 1}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.cr2 = fault->address;\n\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n}", "target": 0}
{"code": "int lxc_safe_long(const char *numstr, long int *converted)\n{\n\tchar *err = NULL;\n\tsigned long int sli;\n\terrno = 0;\n\tsli = strtol(numstr, &err, 0);\n\tif (errno == ERANGE && (sli == LONG_MAX || sli == LONG_MIN))\n\t\treturn -ERANGE;\n\tif (errno != 0 && sli == 0)\n\t\treturn -EINVAL;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\t*converted = sli;\n\treturn 0;\n}", "target": 0}
{"code": "libxlDomainCreateChannelPTY(virDomainDef *def, libxl_ctx *ctx)\n{\n    libxl_device_channel *x_channels;\n    virDomainChrDef *chr;\n    size_t i;\n    int nchannels;\n    x_channels = libxl_device_channel_list(ctx, def->id, &nchannels);\n    if (!x_channels)\n        return;\n    for (i = 0; i < def->nchannels; i++) {\n        libxl_channelinfo channelinfo;\n        int ret;\n        chr = def->channels[i];\n        if (chr->source->type != VIR_DOMAIN_CHR_TYPE_PTY)\n            continue;\n        ret = libxl_device_channel_getinfo(ctx, def->id, &x_channels[i],\n                                           &channelinfo);\n        if (!ret && channelinfo.u.pty.path &&\n            *channelinfo.u.pty.path != '\\0') {\n                VIR_FREE(chr->source->data.file.path);\n                chr->source->data.file.path = g_strdup(channelinfo.u.pty.path);\n            }\n    }\n    for (i = 0; i < nchannels; i++)\n        libxl_device_channel_dispose(&x_channels[i]);\n}", "target": 0}
{"code": "rsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  int res;\n  mpz_t t, mb, xb, ri;\n  mpz_init (mb);\n  mpz_init (xb);\n  mpz_init (ri);\n  mpz_init (t);\n  rsa_blind (pub, random_ctx, random, mb, ri, m);\n  rsa_compute_root (key, xb, mb);\n  mpz_powm_sec(t, xb, pub->e, pub->n);\n  res = (mpz_cmp(mb, t) == 0);\n  if (res)\n    rsa_unblind (pub, x, ri, xb);\n  mpz_clear (mb);\n  mpz_clear (xb);\n  mpz_clear (ri);\n  mpz_clear (t);\n  return res;\n}", "target": 1}
{"code": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}", "target": 1}
{"code": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\tif (entry->fields.mask)\n\t\treturn -1;\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\treturn ret;\n}", "target": 1}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n    return match;\n}", "target": 1}
{"code": "static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}", "target": 1}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "struct file *do_file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\tconst char *name, const struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tstruct file *file;\n\tstruct filename filename = { .name = name };\n\tint flags = op->lookup_flags | LOOKUP_ROOT;\n\tnd.root.mnt = mnt;\n\tnd.root.dentry = dentry;\n\tif (dentry->d_inode->i_op->follow_link && op->intent & LOOKUP_OPEN)\n\t\treturn ERR_PTR(-ELOOP);\n\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(file == ERR_PTR(-ECHILD)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags);\n\tif (unlikely(file == ERR_PTR(-ESTALE)))\n\t\tfile = path_openat(-1, &filename, &nd, op, flags | LOOKUP_REVAL);\n\treturn file;\n}", "target": 0}
{"code": "mysql_create_db(MYSQL *mysql, const char *db)\n{\n  DBUG_ENTER(\"mysql_createdb\");\n  DBUG_PRINT(\"enter\",(\"db: %s\",db));\n  DBUG_RETURN(simple_command(mysql,COM_CREATE_DB,db, (ulong) strlen(db),0));\n}", "target": 0}
{"code": "void IndexedDBDatabase::ReportErrorWithDetails(Status status,\n                                               const char* message) {\n  DCHECK(!status.ok());\n  if (status.IsCorruption()) {\n    IndexedDBDatabaseError error(blink::kWebIDBDatabaseExceptionUnknownError,\n                                 message);\n    factory_->HandleBackingStoreCorruption(backing_store_->origin(), error);\n  } else {\n    factory_->HandleBackingStoreFailure(backing_store_->origin());\n  }\n}", "target": 0}
{"code": "ModuleExport void UnregisterJP2Image(void)\n{\n  (void) UnregisterMagickInfo(\"JPC\");\n  (void) UnregisterMagickInfo(\"JPT\");\n  (void) UnregisterMagickInfo(\"JPM\");\n  (void) UnregisterMagickInfo(\"JP2\");\n  (void) UnregisterMagickInfo(\"J2K\");\n}", "target": 0}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)\n{\n\tif (prev->on_rq)\n\t\tupdate_curr(cfs_rq);\n\tcheck_spread(cfs_rq, prev);\n\tif (prev->on_rq) {\n\t\tupdate_stats_wait_start(cfs_rq, prev);\n\t\t__enqueue_entity(cfs_rq, prev);\n\t}\n\tcfs_rq->curr = NULL;\n}", "target": 0}
{"code": "node_new_no_newline(Node** node, ScanEnv* env)\n{\n  Node* n;\n  n = node_new_anychar_with_fixed_option(ONIG_OPTION_NONE);\n  CHECK_NULL_RETURN_MEMERR(n);\n  *node = n;\n  return 0;\n}", "target": 0}
{"code": "static __init int vdso_do_find_sections(struct lib32_elfinfo *v32,\n\t\t\t\t\tstruct lib64_elfinfo *v64)\n{\n\tvoid *sect;\n\tv32->dynsym = find_section32(v32->hdr, \".dynsym\", &v32->dynsymsize);\n\tv32->dynstr = find_section32(v32->hdr, \".dynstr\", NULL);\n\tif (v32->dynsym == NULL || v32->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section32(v32->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO32: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv32->text = sect - vdso32_kbase;\n#ifdef CONFIG_PPC64\n\tv64->dynsym = find_section64(v64->hdr, \".dynsym\", &v64->dynsymsize);\n\tv64->dynstr = find_section64(v64->hdr, \".dynstr\", NULL);\n\tif (v64->dynsym == NULL || v64->dynstr == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: required symbol section not found\\n\");\n\t\treturn -1;\n\t}\n\tsect = find_section64(v64->hdr, \".text\", NULL);\n\tif (sect == NULL) {\n\t\tprintk(KERN_ERR \"vDSO64: the .text section was not found\\n\");\n\t\treturn -1;\n\t}\n\tv64->text = sect - vdso64_kbase;\n#endif \n\treturn 0;\n}", "target": 0}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "static void change_pageblock_range(struct page *pageblock_page,\n\t\t\t\t\tint start_order, int migratetype)\n{\n\tint nr_pageblocks = 1 << (start_order - pageblock_order);\n\twhile (nr_pageblocks--) {\n\t\tset_pageblock_migratetype(pageblock_page, migratetype);\n\t\tpageblock_page += pageblock_nr_pages;\n\t}\n}", "target": 0}
{"code": "\tFOR_EACH_MODULE_Type(CIRCNetwork* pNetwork) : CMuser(pNetwork ? pNetwork->GetUser()->GetModules() : CMtemp), CMnet(pNetwork ? pNetwork->GetModules() : CMtemp) {\n\t\twhere = AtGlobal;\n\t}", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n     Mutex::Autolock autoLock(mLock);\n     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n     header->nFilledLen = rangeLength;\n     header->nOffset = rangeOffset;\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}", "target": 1}
{"code": "struct vfsmount *lookup_mnt(struct path *path)\n{\n\tstruct mount *child_mnt;\n\tstruct vfsmount *m;\n\tunsigned seq;\n\trcu_read_lock();\n\tdo {\n\t\tseq = read_seqbegin(&mount_lock);\n\t\tchild_mnt = __lookup_mnt(path->mnt, path->dentry);\n\t\tm = child_mnt ? &child_mnt->mnt : NULL;\n\t} while (!legitimize_mnt(m, seq));\n\trcu_read_unlock();\n\treturn m;\n}", "target": 0}
{"code": "static int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    int ret;\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}", "target": 0}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
